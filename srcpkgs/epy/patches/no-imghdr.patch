--- a/pyproject.toml
+++ b/pyproject.toml
@@ -17,6 +17,7 @@ epy = "epy_reader.__main__:main"
 [tool.poetry.dependencies]
 python = "^3.8"
 windows-curses = { version = "*", markers = "platform_system == 'Windows'" }
+magic = { version = "*" }
 
 [tool.poetry.dev-dependencies]
 pynvim = "^0.4.3"
--- a/src/epy_reader/tools/KindleUnpack/mobi_cover.py
+++ b/src/epy_reader/tools/KindleUnpack/mobi_cover.py
@@ -8,7 +8,7 @@ from .compatibility_utils import unicode
 
 from .unipath import pathof
 import os
-import imghdr
+import magic
 
 import struct
 # note:  struct pack, unpack, unpack_from all require bytestring format
@@ -34,24 +34,14 @@ MAX_HEIGHT = 4096
 
 
 def get_image_type(imgname, imgdata=None):
-    imgtype = unicode_str(imghdr.what(pathof(imgname), imgdata))
-
-    # imghdr only checks for JFIF or Exif JPEG files. Apparently, there are some
-    # with only the magic JPEG bytes out there...
-    # ImageMagick handles those, so, do it too.
-    if imgtype is None:
-        if imgdata is None:
-            with open(pathof(imgname), 'rb') as f:
-                imgdata = f.read()
-        if imgdata[0:2] == b'\xFF\xD8':
-            # Get last non-null bytes
-            last = len(imgdata)
-            while (imgdata[last-1:last] == b'\x00'):
-                last-=1
-            # Be extra safe, check the trailing bytes, too.
-            if imgdata[last-2:last] == b'\xFF\xD9':
-                imgtype = "jpeg"
-    return imgtype
+    mime = None
+    if imgname:
+        mime = magic.from_file(pathof(imgname), mime=True)
+    if not mime and imgdata:
+        mime = magic.from_buffer(imgdata, mime=True)
+    if mime and mime.startswith('image/'):
+        return mime.removeprefix('image/')
+    return None
 
 
 def get_image_size(imgname, imgdata=None):
