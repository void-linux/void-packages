--- /dev/null
+++ kernel/nv-mm.h
@@ -0,0 +1,55 @@
+/*******************************************************************************
+    Copyright (c) 2016 NVIDIA Corporation
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to
+    deal in the Software without restriction, including without limitation the
+    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+    sell copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+        The above copyright notice and this permission notice shall be
+        included in all copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+
+*******************************************************************************/
+#ifndef __NV_MM_H__
+#define __NV_MM_H__
+
+/*  get_user_pages_remote() was added by:
+ *    2016 Feb 12: 1e9877902dc7e11d2be038371c6fbf2dfcd469d7
+ *
+ *  The very next commit (cde70140fed8429acf7a14e2e2cbd3e329036653)
+ *  deprecated the 8-argument version of get_user_pages for the
+ *  non-remote case (calling get_user_pages with current and current->mm).
+ *
+ *  The guidelines are: call NV_GET_USER_PAGES_REMOTE if you need the 8-argument
+ *  version that uses something other than current and current->mm. Use
+ *  NV_GET_USER_PAGES if you are refering to current and current->mm.
+ *
+*  Note that get_user_pages_remote() requires the caller to hold a reference on
+*  the task_struct (if non-NULL) and the mm_struct. This will always be true
+*  when using current and current->mm. If the kernel passes the driver a vma
+*  via driver callback, the kernel holds a reference on vma->vm_mm over that
+*  callback.
+ */
+
+#if defined(NV_GET_USER_PAGES_REMOTE_PRESENT)
+    #define NV_GET_USER_PAGES           get_user_pages
+    #define NV_GET_USER_PAGES_REMOTE    get_user_pages_remote
+#else
+    #define NV_GET_USER_PAGES(start, nr_pages, write, force, pages, vmas) \
+        get_user_pages(current, current->mm, start, nr_pages, write, force, pages, vmas)
+
+    #define NV_GET_USER_PAGES_REMOTE    get_user_pages
+#endif
+
+
+#endif // __NV_MM_H__
--- kernel/nv-mlock.c
+++ kernel/nv-mlock.c
@@ -13,6 +13,7 @@
 
 #include "os-interface.h"
 #include "nv-linux.h"
+#include "nv-mm.h"
 
 RM_STATUS NV_API_CALL nv_lock_user_pages(
     nv_state_t *nv,
@@ -49,7 +50,7 @@ RM_STATUS NV_API_CALL os_lock_user_pages(
     }
 
     down_read(&mm->mmap_sem);
-    ret = get_user_pages(current, mm, (unsigned long)address,
+    ret = NV_GET_USER_PAGES((unsigned long)address,
             page_count, write, force, user_pages, NULL);
     up_read(&mm->mmap_sem);
     pinned = ret;
@@ -62,7 +62,7 @@ RM_STATUS NV_API_CALL os_lock_user_pages(
     else if (pinned < page_count)
     {
         for (i = 0; i < pinned; i++)
-            page_cache_release(user_pages[i]);
+            put_page(user_pages[i]);
         os_free_mem(user_pages);
         return RM_ERR_INVALID_ADDRESS;
     }
@@ -81,7 +81,7 @@ RM_STATUS NV_API_CALL os_lock_user_pages(
             {
                 pci_unmap_page(dev, pte_array[j],
                         PAGE_SIZE, PCI_DMA_BIDIRECTIONAL);
-                page_cache_release(user_pages[j]);
+                put_page(user_pages[j]);
             }
             os_free_mem(user_pages);
             return RM_ERR_OPERATING_SYSTEM;
@@ -114,7 +114,7 @@ RM_STATUS NV_API_CALL os_unlock_user_pages(
                 PAGE_SIZE, PCI_DMA_BIDIRECTIONAL);
         if (write)
             set_page_dirty_lock(user_pages[i]);
-        page_cache_release(user_pages[i]);
+        put_page(user_pages[i]);
     }
 
     os_free_mem(user_pages);
diff --git kernel/conftest.sh.orig kernel/conftest.sh
index d01488b..308ea8a 100755
--- kernel/conftest.sh
+++ kernel/conftest.sh
@@ -1525,6 +1525,23 @@ compile_test() {
 
             compile_check_conftest "$CODE" "NV_NODE_END_PFN_PRESENT" "" "functions"
         ;;
+
+        get_user_pages_remote)
+            #
+            # Determine if the function get_user_pages_remote() is
+            # present.
+            #
+            # get_user_pages_remote() was added by:
+            #   2016 Feb 12: 1e9877902dc7e11d2be038371c6fbf2dfcd469d7
+            #
+            CODE="
+            #include <linux/mm.h>
+            int conftest_get_user_pages_remote(void) {
+                get_user_pages_remote();
+            }"
+
+            compile_check_conftest "$CODE" "NV_GET_USER_PAGES_REMOTE_PRESENT" "" "functions"
+        ;;
     esac
 }
 
--- kernel/Makefile.kbuild
+++ kernel/Makefile.kbuild
@@ -187,7 +187,8 @@ COMPILE_TESTS = \
 	drm_pci_set_busid \
 	write_cr4 \
 	for_each_online_node \
-	node_end_pfn
+	node_end_pfn \
+	get_user_pages_remote
 
 #
 # CFLAGS dependent on the type of builds (e.g. single/muliple module, debug)
