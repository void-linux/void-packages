diff --git src/gallium/auxiliary/draw/draw_llvm.c src/gallium/auxiliary/draw/draw_llvm.c
index 56c26f5..d477c40 100644
--- src/gallium/auxiliary/draw/draw_llvm.c
+++ src/gallium/auxiliary/draw/draw_llvm.c
@@ -96,7 +96,7 @@ draw_llvm_generate_elts(struct draw_llvm *llvm, struct draw_llvm_variant *var);
  * Create LLVM type for struct draw_jit_texture
  */
 static LLVMTypeRef
-create_jit_texture_type(struct gallivm_state *gallivm)
+create_jit_texture_type(struct gallivm_state *gallivm, const char *struct_name)
 {
    LLVMTargetDataRef target = gallivm->target;
    LLVMTypeRef texture_type;
@@ -120,13 +120,21 @@ create_jit_texture_type(struct gallivm_state *gallivm)
    elem_types[DRAW_JIT_TEXTURE_BORDER_COLOR] = 
       LLVMArrayType(LLVMFloatTypeInContext(gallivm->context), 4);
 
+#if HAVE_LLVM >= 0x0300
+   texture_type = LLVMStructCreateNamed(gallivm->context, struct_name);
+   LLVMStructSetBody(texture_type, elem_types,
+                     Elements(elem_types), 0);
+#else
    texture_type = LLVMStructTypeInContext(gallivm->context, elem_types,
                                           Elements(elem_types), 0);
 
+   LLVMAddTypeName(gallivm->module, struct_name, texture_type);
+
    /* Make sure the target's struct layout cache doesn't return
     * stale/invalid data.
     */
    LLVMInvalidateStructLayout(gallivm->target, texture_type);
+#endif
 
    LP_CHECK_MEMBER_OFFSET(struct draw_jit_texture, width,
                           target, texture_type,
@@ -176,7 +184,7 @@ create_jit_texture_type(struct gallivm_state *gallivm)
  */
 static LLVMTypeRef
 create_jit_context_type(struct gallivm_state *gallivm,
-                        LLVMTypeRef texture_type)
+                        LLVMTypeRef texture_type, const char *struct_name)
 {
    LLVMTargetDataRef target = gallivm->target;
    LLVMTypeRef float_type = LLVMFloatTypeInContext(gallivm->context);
@@ -189,11 +197,17 @@ create_jit_context_type(struct gallivm_state *gallivm,
    elem_types[3] = LLVMPointerType(float_type, 0); /* viewport */
    elem_types[4] = LLVMArrayType(texture_type,
                                  PIPE_MAX_VERTEX_SAMPLERS); /* textures */
-
+#if HAVE_LLVM >= 0x0300
+   context_type = LLVMStructCreateNamed(gallivm->context, struct_name);
+   LLVMStructSetBody(context_type, elem_types,
+                     Elements(elem_types), 0);
+#else
    context_type = LLVMStructTypeInContext(gallivm->context, elem_types,
                                           Elements(elem_types), 0);
+   LLVMAddTypeName(gallivm->module, struct_name, context_type);
 
    LLVMInvalidateStructLayout(gallivm->target, context_type);
+#endif
 
    LP_CHECK_MEMBER_OFFSET(struct draw_jit_context, vs_constants,
                           target, context_type, 0);
@@ -215,7 +229,7 @@ create_jit_context_type(struct gallivm_state *gallivm,
  * Create LLVM type for struct pipe_vertex_buffer
  */
 static LLVMTypeRef
-create_jit_vertex_buffer_type(struct gallivm_state *gallivm)
+create_jit_vertex_buffer_type(struct gallivm_state *gallivm, const char *struct_name)
 {
    LLVMTargetDataRef target = gallivm->target;
    LLVMTypeRef elem_types[3];
@@ -225,10 +239,17 @@ create_jit_vertex_buffer_type(struct gallivm_state *gallivm)
    elem_types[1] = LLVMInt32TypeInContext(gallivm->context);
    elem_types[2] = LLVMPointerType(LLVMInt8TypeInContext(gallivm->context), 0); /* vs_constants */
 
+#if HAVE_LLVM >= 0x0300
+   vb_type = LLVMStructCreateNamed(gallivm->context, struct_name);
+   LLVMStructSetBody(vb_type, elem_types,
+                     Elements(elem_types), 0);
+#else
    vb_type = LLVMStructTypeInContext(gallivm->context, elem_types,
                                      Elements(elem_types), 0);
+   LLVMAddTypeName(gallivm->module, struct_name, vb_type);
 
    LLVMInvalidateStructLayout(gallivm->target, vb_type);
+#endif
 
    LP_CHECK_MEMBER_OFFSET(struct pipe_vertex_buffer, stride,
                           target, vb_type, 0);
@@ -258,10 +279,17 @@ create_jit_vertex_header(struct gallivm_state *gallivm, int data_elems)
    elem_types[1]  = LLVMArrayType(LLVMFloatTypeInContext(gallivm->context), 4);
    elem_types[2]  = LLVMArrayType(elem_types[1], data_elems);
 
+#if HAVE_LLVM >= 0x0300
+   vertex_header = LLVMStructCreateNamed(gallivm->context, struct_name);
+   LLVMStructSetBody(vertex_header, elem_types,
+                     Elements(elem_types), 0);
+#else
    vertex_header = LLVMStructTypeInContext(gallivm->context, elem_types,
                                            Elements(elem_types), 0);
+   LLVMAddTypeName(gallivm->module, struct_name, vertex_header);
 
    LLVMInvalidateStructLayout(gallivm->target, vertex_header);
+#endif
 
    /* these are bit-fields and we can't take address of them
       LP_CHECK_MEMBER_OFFSET(struct vertex_header, clipmask,
@@ -284,8 +312,6 @@ create_jit_vertex_header(struct gallivm_state *gallivm, int data_elems)
                           target, vertex_header,
                           DRAW_JIT_VERTEX_DATA);
 
-   LLVMAddTypeName(gallivm->module, struct_name, vertex_header);
-
    return vertex_header;
 }
 
@@ -299,19 +325,15 @@ create_jit_types(struct draw_llvm *llvm)
    struct gallivm_state *gallivm = llvm->gallivm;
    LLVMTypeRef texture_type, context_type, buffer_type, vb_type;
 
-   texture_type = create_jit_texture_type(gallivm);
-   LLVMAddTypeName(gallivm->module, "texture", texture_type);
+   texture_type = create_jit_texture_type(gallivm, "texture");
 
-   context_type = create_jit_context_type(gallivm, texture_type);
-   LLVMAddTypeName(gallivm->module, "draw_jit_context", context_type);
+   context_type = create_jit_context_type(gallivm, texture_type, "draw_jit_context");
    llvm->context_ptr_type = LLVMPointerType(context_type, 0);
 
    buffer_type = LLVMPointerType(LLVMIntTypeInContext(gallivm->context, 8), 0);
-   LLVMAddTypeName(gallivm->module, "buffer", buffer_type);
    llvm->buffer_ptr_type = LLVMPointerType(buffer_type, 0);
 
-   vb_type = create_jit_vertex_buffer_type(gallivm);
-   LLVMAddTypeName(gallivm->module, "pipe_vertex_buffer", vb_type);
+   vb_type = create_jit_vertex_buffer_type(gallivm, "pipe_vertex_buffer");
    llvm->vb_ptr_type = LLVMPointerType(vb_type, 0);
 }
 
diff --git src/gallium/auxiliary/gallivm/lp_bld_debug.cpp src/gallium/auxiliary/gallivm/lp_bld_debug.cpp
index 8636cd6..f44749d 100644
--- src/gallium/auxiliary/gallivm/lp_bld_debug.cpp
+++ src/gallium/auxiliary/gallivm/lp_bld_debug.cpp
@@ -27,17 +27,23 @@
 
 #include <llvm-c/Core.h>
 #include <llvm/Target/TargetMachine.h>
-#include <llvm/Target/TargetRegistry.h>
-#include <llvm/Target/TargetSelect.h>
 #include <llvm/Target/TargetInstrInfo.h>
 #include <llvm/Support/raw_ostream.h>
 #include <llvm/Support/MemoryObject.h>
 
+#if HAVE_LLVM >= 0x0300
+#include <llvm/Support/TargetRegistry.h>
+#include <llvm/Support/TargetSelect.h>
+#else /* HAVE_LLVM < 0x0300 */
+#include <llvm/Target/TargetRegistry.h>
+#include <llvm/Target/TargetSelect.h>
+#endif /* HAVE_LLVM < 0x0300 */
+
 #if HAVE_LLVM >= 0x0209
 #include <llvm/Support/Host.h>
-#else
+#else /* HAVE_LLVM < 0x0209 */
 #include <llvm/System/Host.h>
-#endif
+#endif /* HAVE_LLVM < 0x0209 */
 
 #if HAVE_LLVM >= 0x0207
 #include <llvm/MC/MCDisassembler.h>
@@ -193,14 +199,23 @@ lp_disassemble(const void* func)
 
    InitializeAllDisassemblers();
 
+#if HAVE_LLVM >= 0x0300
+   OwningPtr<const MCAsmInfo> AsmInfo(T->createMCAsmInfo(Triple));
+#else
    OwningPtr<const MCAsmInfo> AsmInfo(T->createAsmInfo(Triple));
+#endif
 
    if (!AsmInfo) {
       debug_printf("error: no assembly info for target %s\n", Triple.c_str());
       return;
    }
 
+#if HAVE_LLVM >= 0x0300
+   const MCSubtargetInfo *STI = T->createMCSubtargetInfo(Triple, sys::getHostCPUName(), "");
+   OwningPtr<const MCDisassembler> DisAsm(T->createMCDisassembler(*STI));
+#else 
    OwningPtr<const MCDisassembler> DisAsm(T->createMCDisassembler());
+#endif 
    if (!DisAsm) {
       debug_printf("error: no disassembler for target %s\n", Triple.c_str());
       return;
@@ -213,7 +228,11 @@ lp_disassemble(const void* func)
 #else
    int AsmPrinterVariant = AsmInfo->getAssemblerDialect();
 #endif
-#if HAVE_LLVM >= 0x0208
+
+#if HAVE_LLVM >= 0x0300
+   OwningPtr<MCInstPrinter> Printer(
+         T->createMCInstPrinter(AsmPrinterVariant, *AsmInfo, *STI));
+#elif HAVE_LLVM >= 0x0208
    OwningPtr<MCInstPrinter> Printer(
          T->createMCInstPrinter(AsmPrinterVariant, *AsmInfo));
 #else
@@ -253,7 +272,11 @@ lp_disassemble(const void* func)
 
       if (!DisAsm->getInstruction(Inst, Size, memoryObject,
                                  pc,
-                                 nulls())) {
+#if HAVE_LLVM >= 0x0300
+				  nulls(), nulls())) {
+#else
+				  nulls())) {
+#endif
          debug_printf("invalid\n");
          pc += 1;
       }
@@ -276,7 +299,9 @@ lp_disassemble(const void* func)
        * Print the instruction.
        */
 
-#if HAVE_LLVM >= 0x208
+#if HAVE_LLVM >= 0x0300
+      Printer->printInst(&Inst, Out, "");
+#elif HAVE_LLVM >= 0x208
       Printer->printInst(&Inst, Out);
 #else
       Printer->printInst(&Inst);
@@ -289,7 +314,11 @@ lp_disassemble(const void* func)
 
       pc += Size;
 
+#if HAVE_LLVM >= 0x0300
+      const MCInstrDesc &TID = TII->get(Inst.getOpcode());
+#else
       const TargetInstrDesc &TID = TII->get(Inst.getOpcode());
+#endif
 
       /*
        * Keep track of forward jumps to a nearby address.
diff --git src/gallium/auxiliary/gallivm/lp_bld_type.c src/gallium/auxiliary/gallivm/lp_bld_type.c
index c5cf6d4..efd159f 100644
--- src/gallium/auxiliary/gallivm/lp_bld_type.c
+++ src/gallium/auxiliary/gallivm/lp_bld_type.c
@@ -325,16 +325,18 @@ lp_typekind_name(LLVMTypeKind t)
       return "LLVMArrayTypeKind";
    case LLVMPointerTypeKind:
       return "LLVMPointerTypeKind";
+#if HAVE_LLVM < 0x0300
    case LLVMOpaqueTypeKind:
       return "LLVMOpaqueTypeKind";
+#endif
    case LLVMVectorTypeKind:
       return "LLVMVectorTypeKind";
    case LLVMMetadataTypeKind:
       return "LLVMMetadataTypeKind";
-   /* Only in LLVM 2.7 and later???
+#if HAVE_LLVM == 0x0207
    case LLVMUnionTypeKind:
       return "LLVMUnionTypeKind";
-   */
+#endif
    default:
       return "unknown LLVMTypeKind";
    }
diff --git src/gallium/drivers/llvmpipe/lp_jit.c src/gallium/drivers/llvmpipe/lp_jit.c
index 268f0fa..ce92a80 100644
--- src/gallium/drivers/llvmpipe/lp_jit.c
+++ src/gallium/drivers/llvmpipe/lp_jit.c
@@ -68,10 +68,17 @@ lp_jit_create_types(struct llvmpipe_context *lp)
       elem_types[LP_JIT_TEXTURE_BORDER_COLOR] = 
          LLVMArrayType(LLVMFloatTypeInContext(lc), 4);
 
+#if HAVE_LLVM >= 0x0300
+   texture_type = LLVMStructCreateNamed(gallivm->context, "texture");
+   LLVMStructSetBody(texture_type, elem_types,
+                     Elements(elem_types), 0);
+#else
       texture_type = LLVMStructTypeInContext(lc, elem_types,
                                              Elements(elem_types), 0);
+      LLVMAddTypeName(gallivm->module, "texture", texture_type);
 
       LLVMInvalidateStructLayout(gallivm->target, texture_type);
+#endif
 
       LP_CHECK_MEMBER_OFFSET(struct lp_jit_texture, width,
                              gallivm->target, texture_type,
@@ -112,8 +119,6 @@ lp_jit_create_types(struct llvmpipe_context *lp)
 
       LP_CHECK_STRUCT_SIZE(struct lp_jit_texture,
                            gallivm->target, texture_type);
-
-      LLVMAddTypeName(gallivm->module, "texture", texture_type);
    }
 
    /* struct lp_jit_context */
@@ -129,11 +134,19 @@ lp_jit_create_types(struct llvmpipe_context *lp)
       elem_types[LP_JIT_CTX_TEXTURES] = LLVMArrayType(texture_type,
                                                       PIPE_MAX_SAMPLERS);
 
+#if HAVE_LLVM >= 0x0300
+   context_type = LLVMStructCreateNamed(gallivm->context, "context");
+   LLVMStructSetBody(context_type, elem_types,
+                     Elements(elem_types), 0);
+#else
       context_type = LLVMStructTypeInContext(lc, elem_types,
                                              Elements(elem_types), 0);
 
       LLVMInvalidateStructLayout(gallivm->target, context_type);
 
+      LLVMAddTypeName(gallivm->module, "context", context_type);
+#endif
+
       LP_CHECK_MEMBER_OFFSET(struct lp_jit_context, constants,
                              gallivm->target, context_type,
                              LP_JIT_CTX_CONSTANTS);
@@ -155,8 +168,6 @@ lp_jit_create_types(struct llvmpipe_context *lp)
       LP_CHECK_STRUCT_SIZE(struct lp_jit_context,
                            gallivm->target, context_type);
 
-      LLVMAddTypeName(gallivm->module, "context", context_type);
-
       lp->jit_context_ptr_type = LLVMPointerType(context_type, 0);
    }
 
diff --git src/gallium/drivers/nv50/nv50_context.c src/gallium/drivers/nv50/nv50_context.c
index ceb83f6..ac3e361 100644
--- src/gallium/drivers/nv50/nv50_context.c
+++ src/gallium/drivers/nv50/nv50_context.c
@@ -60,13 +60,13 @@ nv50_texture_barrier(struct pipe_context *pipe)
 void
 nv50_default_flush_notify(struct nouveau_channel *chan)
 {
-   struct nv50_context *nv50 = chan->user_private;
+   struct nv50_screen *screen = chan->user_private;
 
-   if (!nv50)
+   if (!screen)
       return;
 
-   nouveau_fence_update(&nv50->screen->base, TRUE);
-   nouveau_fence_next(&nv50->screen->base);
+   nouveau_fence_update(&screen->base, TRUE);
+   nouveau_fence_next(&screen->base);
 }
 
 static void
@@ -100,10 +100,8 @@ nv50_destroy(struct pipe_context *pipe)
 
    draw_destroy(nv50->draw);
 
-   if (nv50->screen->cur_ctx == nv50) {
-      nv50->screen->base.channel->user_private = NULL;
+   if (nv50->screen->cur_ctx == nv50)
       nv50->screen->cur_ctx = NULL;
-   }
 
    FREE(nv50);
 }
@@ -140,7 +138,6 @@ nv50_create(struct pipe_screen *pscreen, void *priv)
 
    if (!screen->cur_ctx)
       screen->cur_ctx = nv50;
-   screen->base.channel->user_private = nv50;
    screen->base.channel->flush_notify = nv50_default_flush_notify;
 
    nv50_init_query_functions(nv50);
diff --git src/gallium/drivers/nv50/nv50_screen.c src/gallium/drivers/nv50/nv50_screen.c
index 9606c99..f176a86 100644
--- src/gallium/drivers/nv50/nv50_screen.c
+++ src/gallium/drivers/nv50/nv50_screen.c
@@ -215,6 +215,8 @@ nv50_screen_destroy(struct pipe_screen *pscreen)
       nouveau_fence_wait(screen->base.fence.current);
       nouveau_fence_ref (NULL, &screen->base.fence.current);
    }
+   if (screen->base.channel)
+      screen->base.channel->user_private = NULL;
 
    nouveau_bo_ref(NULL, &screen->code);
    nouveau_bo_ref(NULL, &screen->tls_bo);
@@ -304,6 +306,7 @@ nv50_screen_create(struct pipe_winsys *ws, struct nouveau_device *dev)
       FAIL_SCREEN_INIT("nouveau_screen_init failed: %d\n", ret);
 
    chan = screen->base.channel;
+   chan->user_private = screen;
 
    pscreen->winsys = ws;
    pscreen->destroy = nv50_screen_destroy;
diff --git src/gallium/drivers/nv50/nv50_state_validate.c src/gallium/drivers/nv50/nv50_state_validate.c
index 11561f5..d29c1e9 100644
--- src/gallium/drivers/nv50/nv50_state_validate.c
+++ src/gallium/drivers/nv50/nv50_state_validate.c
@@ -282,8 +282,7 @@ nv50_switch_pipe_context(struct nv50_context *ctx_to)
    if (!ctx_to->zsa)
       ctx_to->dirty &= ~NV50_NEW_ZSA;
 
-   ctx_to->screen->base.channel->user_private = ctx_to->screen->cur_ctx =
-      ctx_to;
+   ctx_to->screen->cur_ctx = ctx_to;
 }
 
 static struct state_validate {
diff --git src/gallium/drivers/nv50/nv50_vbo.c src/gallium/drivers/nv50/nv50_vbo.c
index bb08941..f23008a 100644
--- src/gallium/drivers/nv50/nv50_vbo.c
+++ src/gallium/drivers/nv50/nv50_vbo.c
@@ -389,11 +389,11 @@ nv50_prim_gl(unsigned prim)
 static void
 nv50_draw_vbo_flush_notify(struct nouveau_channel *chan)
 {
-   struct nv50_context *nv50 = chan->user_private;
+   struct nv50_screen *screen = chan->user_private;
 
-   nouveau_fence_update(&nv50->screen->base, TRUE);
+   nouveau_fence_update(&screen->base, TRUE);
 
-   nv50_bufctx_emit_relocs(nv50);
+   nv50_bufctx_emit_relocs(screen->cur_ctx);
 }
 
 static void
@@ -650,7 +650,6 @@ nv50_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *info)
    nv50_state_validate(nv50);
 
    chan->flush_notify = nv50_draw_vbo_flush_notify;
-   chan->user_private = nv50;
 
    if (nv50->vbo_fifo) {
       nv50_push_vbo(nv50, info);
diff --git src/gallium/drivers/nvc0/nvc0_context.c src/gallium/drivers/nvc0/nvc0_context.c
index 2679b7f..983db23 100644
--- src/gallium/drivers/nvc0/nvc0_context.c
+++ src/gallium/drivers/nvc0/nvc0_context.c
@@ -89,10 +89,8 @@ nvc0_destroy(struct pipe_context *pipe)
 
    draw_destroy(nvc0->draw);
 
-   if (nvc0->screen->cur_ctx == nvc0) {
-      nvc0->screen->base.channel->user_private = NULL;
+   if (nvc0->screen->cur_ctx == nvc0)
       nvc0->screen->cur_ctx = NULL;
-   }
 
    FREE(nvc0);
 }
@@ -100,13 +98,13 @@ nvc0_destroy(struct pipe_context *pipe)
 void
 nvc0_default_flush_notify(struct nouveau_channel *chan)
 {
-   struct nvc0_context *nvc0 = chan->user_private;
+   struct nvc0_screen *screen = chan->user_private;
 
-   if (!nvc0)
+   if (!screen)
       return;
 
-   nouveau_fence_update(&nvc0->screen->base, TRUE);
-   nouveau_fence_next(&nvc0->screen->base);
+   nouveau_fence_update(&screen->base, TRUE);
+   nouveau_fence_next(&screen->base);
 }
 
 struct pipe_context *
@@ -141,7 +139,6 @@ nvc0_create(struct pipe_screen *pscreen, void *priv)
 
    if (!screen->cur_ctx)
       screen->cur_ctx = nvc0;
-   screen->base.channel->user_private = nvc0;
    screen->base.channel->flush_notify = nvc0_default_flush_notify;
 
    nvc0_init_query_functions(nvc0);
diff --git src/gallium/drivers/nvc0/nvc0_screen.c src/gallium/drivers/nvc0/nvc0_screen.c
index e87688e..43eb6ce 100644
--- src/gallium/drivers/nvc0/nvc0_screen.c
+++ src/gallium/drivers/nvc0/nvc0_screen.c
@@ -198,8 +198,12 @@ nvc0_screen_destroy(struct pipe_screen *pscreen)
 {
    struct nvc0_screen *screen = nvc0_screen(pscreen);
 
-   nouveau_fence_wait(screen->base.fence.current);
-   nouveau_fence_ref(NULL, &screen->base.fence.current);
+   if (screen->base.fence.current) {
+      nouveau_fence_wait(screen->base.fence.current);
+      nouveau_fence_ref(NULL, &screen->base.fence.current);
+   }
+   if (screen->base.channel)
+      screen->base.channel->user_private = NULL;
 
    nouveau_bo_ref(NULL, &screen->text);
    nouveau_bo_ref(NULL, &screen->tls);
@@ -362,6 +366,7 @@ nvc0_screen_create(struct pipe_winsys *ws, struct nouveau_device *dev)
       return NULL;
    }
    chan = screen->base.channel;
+   chan->user_private = screen;
 
    pscreen->winsys = ws;
    pscreen->destroy = nvc0_screen_destroy;
diff --git src/gallium/drivers/nvc0/nvc0_state_validate.c src/gallium/drivers/nvc0/nvc0_state_validate.c
index 9b2a281..f300f37 100644
--- src/gallium/drivers/nvc0/nvc0_state_validate.c
+++ src/gallium/drivers/nvc0/nvc0_state_validate.c
@@ -428,8 +428,7 @@ nvc0_switch_pipe_context(struct nvc0_context *ctx_to)
    if (!ctx_to->zsa)
       ctx_to->dirty &= ~NVC0_NEW_ZSA;
 
-   ctx_to->screen->base.channel->user_private = ctx_to->screen->cur_ctx =
-      ctx_to;
+   ctx_to->screen->cur_ctx = ctx_to;
 }
 
 static struct state_validate {
diff --git src/gallium/drivers/nvc0/nvc0_vbo.c src/gallium/drivers/nvc0/nvc0_vbo.c
index 4107910..8a5bf8d 100644
--- src/gallium/drivers/nvc0/nvc0_vbo.c
+++ src/gallium/drivers/nvc0/nvc0_vbo.c
@@ -367,11 +367,11 @@ nvc0_prim_gl(unsigned prim)
 static void
 nvc0_draw_vbo_flush_notify(struct nouveau_channel *chan)
 {
-   struct nvc0_context *nvc0 = chan->user_private;
+   struct nvc0_screen *screen = chan->user_private;
 
-   nouveau_fence_update(&nvc0->screen->base, TRUE);
+   nouveau_fence_update(&screen->base, TRUE);
 
-   nvc0_bufctx_emit_relocs(nvc0);
+   nvc0_bufctx_emit_relocs(screen->cur_ctx);
 }
 
 static void
@@ -587,7 +587,6 @@ nvc0_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *info)
    nvc0_state_validate(nvc0);
 
    chan->flush_notify = nvc0_draw_vbo_flush_notify;
-   chan->user_private = nvc0;
 
    if (nvc0->vbo_fifo) {
       nvc0_push_vbo(nvc0, info);
diff --git src/glsl/ast.h src/glsl/ast.h
index d1de227..532347d 100644
--- src/glsl/ast.h
+++ src/glsl/ast.h
@@ -372,7 +372,7 @@ struct ast_type_qualifier {
     * \note
     * This field is only valid if \c explicit_location is set.
     */
-   unsigned location;
+   int location;
 
    /**
     * Return true if and only if an interpolation qualifier is present.
diff --git src/glsl/ast_to_hir.cpp src/glsl/ast_to_hir.cpp
index 2289047..1650978 100644
--- src/glsl/ast_to_hir.cpp
+++ src/glsl/ast_to_hir.cpp
@@ -1140,7 +1140,7 @@ ast_expression::hir(exec_list *instructions,
 	 error_emitted = true;
       }
 
-      type = op[0]->type;
+      type = error_emitted ? glsl_type::error_type : op[0]->type;
       result = new(ctx) ir_expression(ir_unop_bit_not, type, op[0], NULL);
       break;
 
diff --git src/glsl/lower_vec_index_to_swizzle.cpp src/glsl/lower_vec_index_to_swizzle.cpp
index c7630c2..46fd6ac 100644
--- src/glsl/lower_vec_index_to_swizzle.cpp
+++ src/glsl/lower_vec_index_to_swizzle.cpp
@@ -33,6 +33,7 @@
 #include "ir_visitor.h"
 #include "ir_optimization.h"
 #include "glsl_types.h"
+#include "main/macros.h"
 
 /**
  * Visitor class for replacing expressions with ir_constant values.
@@ -76,8 +77,25 @@ ir_vec_index_to_swizzle_visitor::convert_vec_index_to_swizzle(ir_rvalue *ir)
 
    void *ctx = ralloc_parent(ir);
    this->progress = true;
-   return new(ctx) ir_swizzle(deref->array,
-			      ir_constant->value.i[0], 0, 0, 0, 1);
+
+   /* Page 40 of the GLSL 1.20 spec says:
+    *
+    *     "When indexing with non-constant expressions, behavior is undefined
+    *     if the index is negative, or greater than or equal to the size of
+    *     the vector."
+    *
+    * The quoted spec text mentions non-constant expressions, but this code
+    * operates on constants.  These constants are the result of non-constant
+    * expressions that have been optimized to constants.  The common case here
+    * is a loop counter from an unrolled loop that is used to index a vector.
+    *
+    * The ir_swizzle constructor gets angry if the index is negative or too
+    * large.  For simplicity sake, just clamp the index to [0, size-1].
+    */
+   const int i = MIN2(MAX2(ir_constant->value.i[0], 0),
+		      (deref->array->type->vector_elements - 1));
+
+   return new(ctx) ir_swizzle(deref->array, i, 0, 0, 0, 1);
 }
 
 ir_visitor_status
