Submitted By:            Matt Burgess <matthew_at_linuxfromscratch_dot_org>
Date:                    2009-07-22
Initial Package Version: 7.2
Upstream Status:         Already in upstream patch repo
Origin:                  Upstream
Description:             This patch contains upstream patch numbers 1 thru 239.

diff -Naur vim72.orig/Filelist vim72/Filelist
--- vim72.orig/Filelist	2008-07-06 19:02:23.000000000 +0100
+++ vim72/Filelist	2009-07-22 22:54:22.000000000 +0100
@@ -285,6 +285,7 @@
 		src/proto/os_win32.pro \
 		src/proto/os_mswin.pro \
 		src/testdir/Make_dos.mak \
+		src/testdir/Make_ming.mak \
 		src/testdir/dos.vim \
 		src/uninstal.c \
 		src/vim.def \
@@ -682,9 +683,7 @@
 		runtime/spell/??/main.aap \
 		runtime/spell/yi/README.txt \
 		runtime/spell/main.aap \
-		runtime/spell/cleanadd.vim \
 		runtime/spell/*.vim \
-		runtime/spell/fixdup \
 
 # generic language files, binary
 LANG_GEN_BIN = \
diff -Naur vim72.orig/runtime/doc/autocmd.txt vim72/runtime/doc/autocmd.txt
--- vim72.orig/runtime/doc/autocmd.txt	2008-08-09 15:22:59.000000000 +0100
+++ vim72/runtime/doc/autocmd.txt	2009-07-22 22:54:23.000000000 +0100
@@ -335,6 +335,8 @@
 				NOTE: When this autocommand is executed, the
 				current buffer "%" may be different from the
 				buffer being deleted "<afile>" and "<abuf>".
+				Don't change to another buffer, it will cause
+				problems.
 							*BufEnter*
 BufEnter			After entering a buffer.  Useful for setting
 				options for a file type.  Also executed when
@@ -397,6 +399,8 @@
 				NOTE: When this autocommand is executed, the
 				current buffer "%" may be different from the
 				buffer being unloaded "<afile>".
+				Don't change to another buffer, it will cause
+				problems.
 							*BufWinEnter*
 BufWinEnter			After a buffer is displayed in a window.  This
 				can be when the buffer is loaded (after
@@ -428,6 +432,8 @@
 				NOTE: When this autocommand is executed, the
 				current buffer "%" may be different from the
 				buffer being deleted "<afile>".
+				Don't change to another buffer, it will cause
+				problems.
 						*BufWrite* *BufWritePre*
 BufWrite or BufWritePre		Before writing the whole buffer to a file.
 							*BufWriteCmd*
@@ -748,8 +754,10 @@
 					'a'	abort, like hitting CTRL-C
 				When set to an empty string the user will be
 				asked, as if there was no SwapExists autocmd.
-				Note: Do not try to change the buffer, the
-				results are unpredictable.
+							*E812*
+				It is not allowed to change to another buffer,
+				change a buffer name or change directory
+				here.
 							*Syntax*
 Syntax				When the 'syntax' option has been set.  The
 				pattern is matched against the syntax name.
diff -Naur vim72.orig/runtime/doc/cmdline.txt vim72/runtime/doc/cmdline.txt
--- vim72.orig/runtime/doc/cmdline.txt	2008-08-09 15:22:59.000000000 +0100
+++ vim72/runtime/doc/cmdline.txt	2009-07-22 22:54:23.000000000 +0100
@@ -1,4 +1,4 @@
-*cmdline.txt*   For Vim version 7.2.  Last change: 2008 Jul 29
+*cmdline.txt*   For Vim version 7.2.  Last change: 2008 Sep 18
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -157,6 +157,11 @@
 				(doesn't work at the expression prompt; some
 				things such as changing the buffer or current
 				window are not allowed to avoid side effects)
+				When the result is a |List| the items are used
+				as lines.  They can have line breaks inside
+				too.
+				When the result is a Float it's automatically
+				converted to a String.
 		See |registers| about registers.  {not in Vi}
 		Implementation detail: When using the |expression| register
 		and invoking setcmdpos(), this sets the position before
@@ -436,13 +441,20 @@
 those files with an extension that is in the 'suffixes' option are ignored.
 The default is ".bak,~,.o,.h,.info,.swp,.obj", which means that files ending
 in ".bak", "~", ".o", ".h", ".info", ".swp" and ".obj" are sometimes ignored.
-It is impossible to ignore suffixes with two dots.  Examples:
+
+An empty entry, two consecutive commas, match a file name that does not
+contain a ".", thus has no suffix.  This is useful to ignore "prog" and prefer
+"prog.c".
+
+Examples:
 
   pattern:	files:				match:	~
    test*	test.c test.h test.o		test.c
    test*	test.h test.o			test.h and test.o
    test*	test.i test.h test.c		test.i and test.c
 
+It is impossible to ignore suffixes with two dots.
+
 If there is more than one matching file (after ignoring the ones matching
 the 'suffixes' option) the first file name is inserted.  You can see that
 there is only one match when you type 'wildchar' twice and the completed
@@ -730,19 +742,29 @@
 In Ex commands, at places where a file name can be used, the following
 characters have a special meaning.  These can also be used in the expression
 function expand() |expand()|.
-	%	is replaced with the current file name			*:_%*
-	#	is replaced with the alternate file name		*:_#*
+	%	Is replaced with the current file name.		  *:_%* *c_%*
+	#	Is replaced with the alternate file name.	  *:_#* *c_#*
 	#n	(where n is a number) is replaced with the file name of
-		buffer n.  "#0" is the same as "#"
-	##	is replaced with all names in the argument list		*:_##*
+		buffer n.  "#0" is the same as "#".
+	##	Is replaced with all names in the argument list	  *:_##* *c_##*
 		concatenated, separated by spaces.  Each space in a name
 		is preceded with a backslash.
-Note that these give the file name as it was typed.  If an absolute path is
-needed (when using the file name from a different directory), you need to add
-":p".  See |filename-modifiers|.
+	#<n	(where n is a number > 0) is replaced with old	  *:_#<* *c_#<*
+		file name n.  See |:oldfiles| or |v:oldfiles| to get the
+		number.							*E809*
+		{only when compiled with the +eval and +viminfo features}
+
+Note that these, except "#<n", give the file name as it was typed.  If an
+absolute path is needed (when using the file name from a different directory),
+you need to add ":p".  See |filename-modifiers|.
+
+The "#<n" item returns an absolute path, but it will start with "~/" for files
+below your home directory.
+
 Note that backslashes are inserted before spaces, so that the command will
 correctly interpret the file name.  But this doesn't happen for shell
-commands.  For those you probably have to use quotes: >
+commands.  For those you probably have to use quotes (this fails for files
+that contain a quote and wildcards): >
 	:!ls "%"
 	:r !spell "%"
 
diff -Naur vim72.orig/runtime/doc/eval.txt vim72/runtime/doc/eval.txt
--- vim72.orig/runtime/doc/eval.txt	2008-08-09 15:22:59.000000000 +0100
+++ vim72/runtime/doc/eval.txt	2009-07-22 22:54:21.000000000 +0100
@@ -1,4 +1,4 @@
-*eval.txt*	For Vim version 7.2.  Last change: 2008 Aug 09
+*eval.txt*	For Vim version 7.2.  Last change: 2008 Nov 27
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@@ -1484,6 +1484,17 @@
 		This is the screen column number, like with |virtcol()|.  The
 		value is zero when there was no mouse button click.
 
+					*v:oldfiles* *oldfiles-variable*
+v:oldfiles	List of file names that is loaded from the |viminfo| file on
+		startup.  These are the files that Vim remembers marks for.
+		The length of the List is limited by the ' argument of the
+		'viminfo' option (default is 100).
+		Also see |:oldfiles| and |c_#<|.
+		The List can be modified, but this has no effect on what is
+		stored in the |viminfo| file later.  If you use values other
+		than String this will cause trouble.
+		{only when compiled with the +viminfo feature}
+
 					*v:operator* *operator-variable*
 v:operator	The last operator given in Normal mode.  This is a single
 		character except for commands starting with <g> or <z>,
@@ -1695,7 +1706,7 @@
 exists( {expr})			Number	TRUE if {expr} exists
 extend({expr1}, {expr2} [, {expr3}])
 				List/Dict insert items of {expr2} into {expr1}
-expand( {expr})			String	expand special keywords in {expr}
+expand( {expr} [, {flag}])	String	expand special keywords in {expr}
 feedkeys( {string} [, {mode}])	Number	add key sequence to typeahead buffer
 filereadable( {file})		Number	TRUE if {file} is a readable file
 filewritable( {file})		Number	TRUE if {file} is a writable file
@@ -1747,8 +1758,9 @@
 getwinposx()			Number	X coord in pixels of GUI Vim window
 getwinposy()			Number	Y coord in pixels of GUI Vim window
 getwinvar( {nr}, {varname})	any	variable {varname} in window {nr}
-glob( {expr})			String	expand file wildcards in {expr}
-globpath( {path}, {expr})	String	do glob({expr}) for all dirs in {path}
+glob( {expr} [, {flag}])	String	expand file wildcards in {expr}
+globpath( {path}, {expr} [, {flag}])
+				String	do glob({expr}) for all dirs in {path}
 has( {feature})			Number	TRUE if feature {feature} supported
 has_key( {dict}, {key})		Number	TRUE if {dict} has entry {key}
 haslocaldir()			Number	TRUE if current window executed |:lcd|
@@ -2402,6 +2414,7 @@
 		When 'virtualedit' is used {off} specifies the offset in
 		screen columns from the start of the character.  E.g., a
 		position within a <Tab> or after the last character.
+		Returns 0 when the position could be set, -1 otherwise.
 
 
 deepcopy({expr}[, {noref}])				*deepcopy()* *E698*
@@ -3275,14 +3288,16 @@
 			:let list_is_on = getwinvar(2, '&list')
 			:echo "myvar = " . getwinvar(1, 'myvar')
 <
-							*glob()*
-glob({expr})	Expand the file wildcards in {expr}.  See |wildcards| for the
+glob({expr} [, {flag}])					*glob()*
+		Expand the file wildcards in {expr}.  See |wildcards| for the
 		use of special characters.
 		The result is a String.
 		When there are several matches, they are separated by <NL>
 		characters.
-		The 'wildignore' option applies: Names matching one of the
-		patterns in 'wildignore' will be skipped.
+		Unless the optional {flag} argument is given and is non-zero,
+		the 'suffixes' and 'wildignore' options apply: Names matching
+		one of the patterns in 'wildignore' will be skipped and
+		'suffixes' affect the ordering of matches.
 		If the expansion fails, the result is an empty string.
 		A name for a non-existing file is not included.
 
@@ -3296,20 +3311,22 @@
 		See |expand()| for expanding special Vim variables.  See
 		|system()| for getting the raw output of an external command.
 
-globpath({path}, {expr})				*globpath()*
+globpath({path}, {expr} [, {flag}])			*globpath()*
 		Perform glob() on all directories in {path} and concatenate
 		the results.  Example: >
 			:echo globpath(&rtp, "syntax/c.vim")
 <		{path} is a comma-separated list of directory names.  Each
 		directory name is prepended to {expr} and expanded like with
-		glob().  A path separator is inserted when needed.
+		|glob()|.  A path separator is inserted when needed.
 		To add a comma inside a directory name escape it with a
 		backslash.  Note that on MS-Windows a directory may have a
 		trailing backslash, remove it if you put a comma after it.
 		If the expansion fails for one of the directories, there is no
 		error message.
-		The 'wildignore' option applies: Names matching one of the
-		patterns in 'wildignore' will be skipped.
+		Unless the optional {flag} argument is given and is non-zero,
+		the 'suffixes' and 'wildignore' options apply: Names matching
+		one of the patterns in 'wildignore' will be skipped and
+		'suffixes' affect the ordering of matches.
 
 		The "**" item can be used to search in a directory tree.
 		For example, to find all "README.txt" files in the directories
@@ -4500,6 +4517,7 @@
 		should also work to move files across file systems.  The
 		result is a Number, which is 0 if the file was renamed
 		successfully, and non-zero when the renaming failed.
+		NOTE: If {to} exists it is overwritten without warning.
 		This function is not available in the |sandbox|.
 
 repeat({expr}, {count})					*repeat()*
@@ -5332,10 +5350,12 @@
 		"fg"		foreground color (GUI: color name used to set
 				the color, cterm: color number as a string,
 				term: empty string)
-		"bg"		background color (like "fg")
+		"bg"		background color (as with "fg")
+		"sp"		special color (as with "fg") |highlight-guisp|
 		"fg#"		like "fg", but for the GUI and the GUI is
 				running the name in "#RRGGBB" form
 		"bg#"		like "fg#" for "bg"
+		"sp#"		like "fg#" for "sp"
 		"bold"		"1" if bold
 		"italic"	"1" if italic
 		"reverse"	"1" if reverse
@@ -5823,7 +5843,8 @@
 mouse_pterm		Compiled with support for qnx pterm mouse.
 mouse_sysmouse		Compiled with support for sysmouse (*BSD console mouse)
 mouse_xterm		Compiled with support for xterm mouse.
-multi_byte		Compiled with support for editing Korean et al.
+multi_byte		Compiled with support for 'encoding'
+multi_byte_encoding	'encoding' is set to a multi-byte encoding.
 multi_byte_ime		Compiled with support for IME input method.
 multi_lang		Compiled with support for multiple languages.
 mzscheme		Compiled with MzScheme interface |mzscheme|.
diff -Naur vim72.orig/runtime/doc/if_cscop.txt vim72/runtime/doc/if_cscop.txt
--- vim72.orig/runtime/doc/if_cscop.txt	2008-08-09 15:22:59.000000000 +0100
+++ vim72/runtime/doc/if_cscop.txt	2009-07-22 22:54:23.000000000 +0100
@@ -1,4 +1,4 @@
-*if_cscop.txt*  For Vim version 7.2.  Last change: 2005 Mar 29
+*if_cscop.txt*  For Vim version 7.2.  Last change: 2009 Mar 18
 
 
 		  VIM REFERENCE MANUAL    by Andy Kahn
@@ -131,11 +131,22 @@
 		7 or f: Find this file
 		8 or i: Find files #including this file
 
+	For all types, except 4 and 6, leading white space for {name} is
+	removed.  For 4 and 6 there is exactly one space between {querytype}
+	and {name}.  Further white space is included in {name}.
+
 	EXAMPLES >
 	    :cscope find c vim_free
-	    :cscope find 3 vim_free
+	    :cscope find 3  vim_free
+<
+	    These two examples perform the same query: functions calling
+	    "vim_free". >
+
+	    :cscope find t initOnce
+	    :cscope find t  initOnce
 <
-	    These two examples perform the same query. >
+	    The first one searches for the text "initOnce", the second one for
+	    " initOnce". >
 
 	    :cscope find 0 DEFAULT_TERM
 <
@@ -344,13 +355,8 @@
 The DJGPP-built version from http://cscope.sourceforge.net is known to not
 work with Vim.
 
-There are a couple of hard-coded limitations:
-
-    1. The maximum number of cscope connections allowed is 8.  Do you
-    really need more?
-
-    2. Doing a |:tjump| when |:cstag| searches the tag files is not
-    configurable (e.g., you can't do a tselect instead).
+Hard-coded limitation: doing a |:tjump| when |:cstag| searches the tag files
+is not configurable (e.g., you can't do a tselect instead).
 
 ==============================================================================
 6. Suggested usage					*cscope-suggestions*
diff -Naur vim72.orig/runtime/doc/if_mzsch.txt vim72/runtime/doc/if_mzsch.txt
--- vim72.orig/runtime/doc/if_mzsch.txt	2008-08-09 15:22:59.000000000 +0100
+++ vim72/runtime/doc/if_mzsch.txt	2009-07-22 22:54:23.000000000 +0100
@@ -1,4 +1,4 @@
-*if_mzsch.txt*  For Vim version 7.2.  Last change: 2008 Jun 28
+*if_mzsch.txt*  For Vim version 7.2.  Last change: 2009 Jun 24
 
 
 		  VIM REFERENCE MANUAL    by Sergey Khorev
@@ -42,10 +42,6 @@
 
 							*:mzfile* *:mzf*
 :[range]mzf[ile] {file}	Execute the MzScheme script in {file}.  {not in Vi}
-			All statements are executed in the namespace of the
-			buffer that was current during :mzfile start.
-			If you want to access other namespaces, use
-			'parameterize'.
 
 All of these commands do essentially the same thing - they execute a piece of
 MzScheme code, with the "current range" set to the given line
@@ -54,8 +50,6 @@
 In the case of :mzscheme, the code to execute is in the command-line.
 In the case of :mzfile, the code to execute is the contents of the given file.
 
-Each buffer has its own MzScheme namespace. Global namespace is bound to
-the "global-namespace" value from the 'vimext' module.
 MzScheme interface defines exception exn:vim, derived from exn.
 It is raised for various Vim errors.
 
@@ -79,40 +73,8 @@
 e.g.: >
 	:mzscheme (require (prefix vim- vimext))
 <
-All the examples below assume this naming scheme.  Note that you need to do
-this again for every buffer.
+All the examples below assume this naming scheme. 
 
-The auto-instantiation can be achieved with autocommands, e.g. you can put
-something like this in your .vimrc (EOFs should not have indentation): >
-    function s:MzRequire()
-	if has("mzscheme")
-	    :mz << EOF
-	    (require (prefix vim- vimext))
-	    (let ((buf (vim-get-buff-by-name (vim-eval "expand(\"<afile>\")"))))
-	      (when (and buf (not (eq? buf (vim-curr-buff))))
-		(parameterize ((current-namespace (vim-get-buff-namespace buf)))
-		  (namespace-attach-module vim-global-namespace 'vimext)
-		  (namespace-require '(prefix vim vimext)))))
-    EOF
-	endif
-    endfunction
-
-    function s:MzStartup()
-	if has("mzscheme")
-	    au BufNew,BufNewFile,BufAdd,BufReadPre * :call s:MzRequire()
-	    :mz << EOF
-	    (current-library-collection-paths
-		(cons
-		    (build-path (find-system-path 'addon-dir) (version) "collects")
-		    (current-library-collection-paths)))
-    EOF
-	endif
-    endfunction
-
-    call s:MzStartup()
-<
-
-The global namespace just instantiated this module with the prefix "vimext:".
 							*mzscheme-sandbox*
 When executed in the |sandbox|, access to some filesystem and Vim interface
 procedures is restricted.
@@ -121,15 +83,20 @@
 2. Examples						*mzscheme-examples*
 >
 	:mzscheme (display "Hello")
+	:mz (display (string-append "Using MzScheme version " (version)))
+	:mzscheme (require (prefix vim- vimext)) ; for MzScheme < 4.x
+	:mzscheme (require (prefix-in vim- 'vimext)) ; MzScheme 4.x
 	:mzscheme (vim-set-buff-line 10 "This is line #10")
 <
 Inline script usage: >
 	function! <SID>SetFirstLine()
 	    :mz << EOF
 	    (display "!!!")
+	    (require (prefix vim- vimext))
+	    ; for newer versions (require (prefix-in vim- 'vimext))
 	    (vim-set-buff-line 1 "This is line #1")
 	    (vim-beep)
-	    EOF
+	EOF
 	endfunction
 
 	nmap <F9> :call <SID>SetFirstLine() <CR>
@@ -137,17 +104,33 @@
 File execution: >
 	:mzfile supascript.scm
 <
-Accessing the current buffer namespace from an MzScheme program running in
-another buffer within |:mzfile|-executed script : >
-	; Move to the window below
-	(vim-command "wincmd j")
-	; execute in the context of buffer, to which window belongs
-	; assume that buffer has 'textstring' defined
-	(parameterize ((current-namespace
-			(vim-get-buff-namespace (vim-curr-buff))))
-	 (eval '(vim-set-buff-line 1 textstring)))
-<
+Vim exception handling: >
+	:mz << EOF
+	(require (prefix vim- vimext))
+	; for newer versions (require (prefix-in vim- 'vimext))
+	(with-handlers
+	  ([exn:vim? (lambda (e) (display (exn-message e)))])
+	  (vim-eval "nonsense-string"))
+	EOF
+<
+Auto-instantiation of vimext module (can be placed in your |vimrc|): >
+    function! MzRequire()
+	:redir => l:mzversion
+	:mz (version)
+	:redir END
+	if strpart(l:mzversion, 1, 1) < "4"
+	    " MzScheme versions < 4.x:
+	    :mz (require (prefix vim- vimext))
+	else
+	    " newer versions:
+	    :mz (require (prefix-in vim- 'vimext))
+	endif
+    endfunction
 
+    if has("mzscheme")
+	silent call MzRequire()
+    endif
+<
 ==============================================================================
 3. Threads						*mzscheme-threads*
 
@@ -168,11 +151,11 @@
 Common
 ------
     (command {command-string})	    Perform the vim ":Ex" style command.
-    (eval {expr-string})	    Evaluate the vim expression to a string.
-				    A |List| is turned into a string by
-				    joining the items and inserting line
-				    breaks.
-				    NOTE clashes with MzScheme eval
+    (eval {expr-string})	    Evaluate the vim expression into
+				    respective MzScheme object: |Lists| are
+				    represented as Scheme lists,
+				    |Dictionaries| as hash tables.
+				    NOTE the name clashes with MzScheme eval
     (range-start)		    Start/End of the range passed with
     (range-end)			    the Scheme command.
     (beep)			    beep
@@ -186,7 +169,6 @@
 				    be set. The symbol 'global can be passed
 				    as {buffer-or-window}. Then |:setglobal|
 				    will be used.
-    global-namespace		    The MzScheme main namespace.
 
 Buffers							 *mzscheme-buffer*
 -------
@@ -228,7 +210,6 @@
 					if there is no such buffer.
     (get-buff-by-num {buffernum})   Get a buffer by its number (return #f if
 				    there is no buffer with this number).
-    (get-buff-namespace [buffer])   Get buffer namespace.
 
 Windows							    *mzscheme-window*
 ------
@@ -250,7 +231,7 @@
     (set-cursor (line . col) [window])  Set cursor position.
 
 ==============================================================================
-5. Dynamic loading					*mzscheme-dynamic*
+5. Dynamic loading				    *mzscheme-dynamic* *E815*
 
 On MS-Windows the MzScheme libraries can be loaded dynamically. The |:version|
 output then includes |+mzscheme/dyn|.
diff -Naur vim72.orig/runtime/doc/netbeans.txt vim72/runtime/doc/netbeans.txt
--- vim72.orig/runtime/doc/netbeans.txt	2008-08-09 15:22:59.000000000 +0100
+++ vim72/runtime/doc/netbeans.txt	2009-07-22 22:54:19.000000000 +0100
@@ -1,4 +1,4 @@
-*netbeans.txt*  For Vim version 7.2.  Last change: 2008 Jun 28
+*netbeans.txt*  For Vim version 7.2.  Last change: 2009 Jan 06
 
 
 		  VIM REFERENCE MANUAL    by Gordon Prieur et al.
@@ -722,8 +722,10 @@
 		of the cursor.
 		New in version 2.1.
 
-killed		A file was closed by the user.  Only for files that have been
-		assigned a number by the IDE.
+killed		A file was deleted or wiped out by the user and the buffer
+		annotations have been removed.  The bufID number for this
+		buffer has become invalid.  Only for files that have been
+		assigned a bufID number by the IDE.
 
 newDotAndMark off off
 		Reports the position of the cursor being at "off" bytes into
diff -Naur vim72.orig/runtime/doc/options.txt vim72/runtime/doc/options.txt
--- vim72.orig/runtime/doc/options.txt	2008-08-09 15:22:59.000000000 +0100
+++ vim72/runtime/doc/options.txt	2009-07-22 22:54:23.000000000 +0100
@@ -1,4 +1,4 @@
-*options.txt*	For Vim version 7.2.  Last change: 2008 Aug 06
+*options.txt*	For Vim version 7.2.  Last change: 2008 Nov 25
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@@ -1443,6 +1443,14 @@
 	autoselectml	Like "autoselect", but for the modeless selection
 			only.  Compare to the 'A' flag in 'guioptions'.
 
+	html		When the clipboard contains HTML, use this when
+			pasting.  When putting text on the clipboard, mark it
+			as HTML.  This works to copy rendered HTML from
+			Firefox, paste it as raw HTML in Vim, select the HTML
+			in Vim and paste it in a rich edit box in Firefox.
+			Only supported for GTK version 2 and later.
+			Only available with the |+multi_byte| feature.
+
 	exclude:{pattern}
 			Defines a pattern that is matched against the name of
 			the terminal 'term'.  If there is a match, no
@@ -4175,9 +4183,6 @@
 	be able to execute Normal mode commands.
 	This is the opposite of the 'keymap' option, where characters are
 	mapped in Insert mode.
-	This only works for 8-bit characters.  The value of 'langmap' may be
-	specified with multi-byte characters (e.g., UTF-8), but only the lower
-	8 bits of each character will be used.
 
 	Example (for Greek, in UTF-8):				*greek*  >
 	    :set langmap=Î‘A,Î’B,Î¨C,Î”D,Î•E,Î¦F,Î“G,Î—H,Î™I,ÎžJ,ÎšK,Î›L,ÎœM,ÎN,ÎŸO,Î P,QQ,Î¡R,Î£S,Î¤T,Î˜U,Î©V,WW,Î§X,Î¥Y,Î–Z,Î±a,Î²b,Ïˆc,Î´d,Îµe,Ï†f,Î³g,Î·h,Î¹i,Î¾j,Îºk,Î»l,Î¼m,Î½n,Î¿o,Ï€p,qq,Ïr,Ïƒs,Ï„t,Î¸u,Ï‰v,Ï‚w,Ï‡x,Ï…y,Î¶z
@@ -7472,7 +7477,9 @@
 			{not available when compiled without the |+wildignore|
 			feature}
 	A list of file patterns.  A file that matches with one of these
-	patterns is ignored when completing file or directory names.
+	patterns is ignored when completing file or directory names, and
+	influences the result of |expand()|, |glob()| and |globpath()| unless
+	a flag is passed to disable this.
 	The pattern is used like with |:autocmd|, see |autocmd-patterns|.
 	Also see 'suffixes'.
 	Example: >
diff -Naur vim72.orig/runtime/doc/os_vms.txt vim72/runtime/doc/os_vms.txt
--- vim72.orig/runtime/doc/os_vms.txt	2008-08-09 15:23:00.000000000 +0100
+++ vim72/runtime/doc/os_vms.txt	2009-07-22 22:54:16.000000000 +0100
@@ -1,4 +1,4 @@
-*os_vms.txt*    For Vim version 7.2.  Last change: 2006 Nov 18
+*os_vms.txt*    For Vim version 7.2.  Last change: 2008 Aug 19
 
 
 		  VIM REFERENCE MANUAL
@@ -312,7 +312,7 @@
 
 8. Useful notes						*vms-notes*
 
-8.1 backspace/delete
+8.1 Backspace/delete
 8.2 Filters
 8.3 VMS file version numbers
 8.4 Directory conversion
@@ -326,8 +326,10 @@
 8.12 diff-mode
 8.13 Allow '$' in C keywords
 8.14 VIMTUTOR for beginners
+8.15 Slow start in console mode issue 
+8.16 Common VIM directory - different architectures 
 
-8.1 backspace/delete
+8.1 Backspace/delete
 
 There are backspace/delete key inconsistencies with VMS.
 :fixdel doesn't do the trick, but the solution is: >
@@ -663,12 +665,130 @@
 
 (Thomas.R.Wyant III, Vim 6.1)
 
+8.14 Slow start in console mode issue
+
+As GUI/GTK Vim works equally well in console mode, many administartors
+deploy those executables system wide.
+Unfortunately, on a remote slow connections GUI/GTK executables behave rather
+slow when user wants to run Vim just in the console mode - because of X environment detection timeout.
+
+Luckily, there is a simple solution for that. Administrators need to deploy
+both GUI/GTK build and just console build executables, like below: >
+
+    |- vim72
+    |----- doc
+    |----- syntax        
+       vimrc    (system rc files)
+       gvimrc
+       gvim.exe (the remaned GUI or GTK built vim.exe)      
+       vim.exe  (the console only executable) 
+
+Define system symbols like below in for ex in LOGIN.COM or SYLOGIN.COM: >
+
+	$ define/nolog VIM RF10:[UTIL.VIM72] ! where you VIM directory is
+	$ vi*m  :== mcr VIM:VIM.EXE
+	$ gvi*m :== mcr VIM:GVIM.EXE
+	$ ! or you can try to spawn with
+	$ gv*im :== spawn/nowait/input=NLA0 mcr VIM:GVIM.EXE -g -GEOMETRY 80x40
+
+
+Like this, users that do not have X environment and want to use Vim just in 
+console mode can avoid performance problems.
+
+(Zoltan Arpadffy, Vim 7.2)
+
+8.15 Common VIM directory - different architectures
+
+In a cluster that contains nodes with different architectures like below:
+
+$show cluster
+View of Cluster from system ID 11655  node: TOR                                                                     18-AUG-2008 11:58:31
++---------------------------------+
+¦        SYSTEMS        ¦ MEMBERS ¦
++-----------------------+---------¦
+¦  NODE  ¦   SOFTWARE   ¦  STATUS ¦
++--------+--------------+---------¦
+¦ TOR    ¦ VMS V7.3-2   ¦ MEMBER  ¦
+¦ TITAN2 ¦ VMS V8.3     ¦ MEMBER  ¦
+¦ ODIN   ¦ VMS V7.3-2   ¦ MEMBER  ¦
++---------------------------------+
+
+It is convinient to have a common VIM directory but execute different
+executables. 
+There are more solutions for this problem:
+
+solution 1. all executables in the same directory with different names
+This is easily done with the following script that can be added
+to the login.com or sylogin.com: >
+
+	$ if f$getsyi("NODE_HWTYPE") .eqs. "VAX"
+	$ then
+	$       say "VAX platform"
+	$       vi*m:== mcr vim:VIM.EXE_VAX
+	$ endif
+	$ if f$getsyi("NODE_HWTYPE") .eqs. "ALPH"
+	$ then
+	$       say "ALPHA platform"
+	$       vi*m :== mcr vim:VIM.EXE_AXP
+	$ endif
+	$ if f$getsyi("ARCH_NAME") .eqs. "IA64"
+	$ then
+	$      say "IA64 platform"
+	$      vi*m :== mcr vim:VIM.EXE_IA64
+	$ endif
+
+solution 2. different directories: >
+
+	$ if f$getsyi("NODE_HWTYPE") .eqs. "VAX"
+	$ then
+	$       say "VAX platform"
+	$       define/nolog VIM RF10:[UTIL.VAX_EXE] ! VAX executables
+	$ endif
+	$ if f$getsyi("NODE_HWTYPE") .eqs. "ALPH"
+	$ then
+	$       say "ALPHA platform"
+	$       define/nolog VIM RF10:[UTIL.AXP_EXE] ! AXP executables
+	$ endif
+	$ if f$getsyi("ARCH_NAME") .eqs. "IA64"
+	$ then
+	$      say "IA64 platform"
+	$      define/nolog VIM RF10:[UTIL.IA64_EXE] ! IA64 executables
+	$ endif
+        $! VIMRUNTIME must be defined in order to find runtime files
+	$ define/nolog VIMRUNTIME RF10:[UTIL.VIM72]
+
+A good examle for this approach is the [GNU]gnu_tools.com script from GNU_TOOLS.ZIP
+package downloadable from http://www.polarhome.com/vim/
+
+(Zoltan Arpadffy, Vim 7.2)
+
 ==============================================================================
 
 9. VMS related changes					*vms-changes*
 
-Version 7
+Recent changes
+- The following plugins are included into VMS runtime: 
+  genutils 2.4, multiselect 2.2, multvals 3.1, selectbuf 4.3,
+  bufexplorer 7.1.7, taglist 4.5
+- minor changes in vimrc (just in VMS runtime) 
+- make_vms.mms - HUGE model is the default
+- [TESTDIR]make_vms.mms include as many tests possible
+- modify test30 and test54 for VMS
+- enable FLOAT feature in VMS port
+- os_vms.txt updated  
+
+Version 7.2 (2008 Aug 9)
+- VCF files write corrected
+- CTAGS 5.7 included
+- corrected make_vms.mms (on VAX gave syntax error) 
+
+Version 7.1 (2007 Jun 15)
+- create TAGS file from menu 
+
+Version 7 (2006 May 8)
 - Improved low level char input (affects just console mode)
+- Fixed plugin bug
+- CTAGS 5.6 included
 
 Version 6.4 (2005 Oct 15)
 - GTKLIB and Vim build on IA64
@@ -806,6 +926,7 @@
 
 OpenVMS documentation and executables are maintained by:
 Zoltan Arpadffy <arpadffy@polarhome.com>
+OpenVMS Vim page: http://www.polarhome.com/vim/
 
 This document uses parts and remarks from earlier authors and contributors
 of OS_VMS.TXT:
diff -Naur vim72.orig/runtime/doc/spell.txt vim72/runtime/doc/spell.txt
--- vim72.orig/runtime/doc/spell.txt	2008-08-09 15:23:00.000000000 +0100
+++ vim72/runtime/doc/spell.txt	2009-07-22 22:54:18.000000000 +0100
@@ -1,4 +1,4 @@
-*spell.txt*	For Vim version 7.2.  Last change: 2008 Jun 21
+*spell.txt*	For Vim version 7.2.  Last change: 2008 Nov 30
 
 
 		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@@ -831,8 +831,11 @@
 
 	# comment line ~
 
-With some items it's also possible to put a comment after it, but this isn't
-supported in general.
+Items with a fixed number of arguments can be followed by a comment.  But only
+if none of the arguments can contain white space.  The comment must start with
+a "#" character.  Example:
+
+	KEEPCASE =  # fix case for words with this flag ~
 
 
 ENCODING							*spell-SET*
@@ -965,6 +968,9 @@
 
 Note: When using utf-8 only characters up to 65000 may be used for flags.
 
+Note: even when using "num" or "long" the number of flags available to
+compounding and prefixes is limited to about 250.
+
 
 AFFIXES
 					    *spell-PFX* *spell-SFX*
@@ -1178,6 +1184,9 @@
 The flag also applies to the word with affixes, thus this can be used to mark
 a whole bunch of related words as bad.
 
+							*spell-FORBIDDENWORD*
+FORBIDDENWORD can be used just like BAD.  For compatibility with Hunspell.
+
 							*spell-NEEDAFFIX*
 The NEEDAFFIX flag is used to require that a word is used with an affix.  The
 word itself is not a good word (unless there is an empty affix).  Example:
@@ -1268,6 +1277,10 @@
 
 	NEEDCOMPOUND & ~
 
+							*spell-ONLYINCOMPOUND*
+The ONLYINCOMPOUND does exactly the same as NEEDCOMPOUND.  Supported for
+compatiblity with Hunspell.
+
 							*spell-COMPOUNDMIN*
 The minimal character length of a word used for compounding is specified with
 COMPOUNDMIN.  Example:
@@ -1328,6 +1341,20 @@
 rules.  Can also be used for an affix to count the affix as a compounding
 word.
 
+						*spell-CHECKCOMPOUNDPATTERN*
+CHECKCOMPOUNDPATTERN is used to define patterns that, when matching at the
+position where two words are compounded together forbids the compound.
+For example:
+	CHECKCOMPOUNDPATTERN o e ~
+
+This forbids compounding if the first word ends in "o" and the second word
+starts with "e".
+
+The arguments must be plain text, no patterns are actually supported, despite
+the item name.  Case is always ignored.
+
+The Hunspell feature to use three arguments and flags is not supported.
+
 							*spell-SYLLABLE*
 The SYLLABLE item defines characters or character sequences that are used to
 count the number of syllables in a word.  Example:
@@ -1496,6 +1523,10 @@
 ACCENT		(Hunspell)				*spell-ACCENT*
 		Use MAP instead. |spell-MAP|
 
+BREAK		(Hunspell)				*spell-BREAK*
+		Define break points.  Unclear how it works exactly.
+		Not supported.
+
 CHECKCOMPOUNDCASE  (Hunspell)			*spell-CHECKCOMPOUNDCASE*
 		Disallow uppercase letters at compound word boundaries.
 		Not supported.
@@ -1512,9 +1543,6 @@
 		Forbid three identical characters when compounding.  Not
 		supported.
 
-CHECKCOMPOUNDPATTERN  (Hunspell)		*spell-CHECKCOMPOUNDPATTERN*
-		Forbid compounding when patterns match.  Not supported.
-
 COMPLEXPREFIXES  (Hunspell)				*spell-COMPLEXPREFIXES*
 		Enables using two prefixes.  Not supported.
 
@@ -1536,13 +1564,18 @@
 COMPOUNDMIDDLE	(Hunspell)				*spell-COMPOUNDMIDDLE*
 		Use COMPOUNDRULE instead. |spell-COMPOUNDRULE|
 
+COMPOUNDRULES	(Hunspell)				*spell-COMPOUNDRULES*
+		Number of COMPOUNDRULE lines following.  Ignored, but the
+		argument must be a number.
+
 COMPOUNDSYLLABLE  (Hunspell)			*spell-COMPOUNDSYLLABLE*
 		Use SYLLABLE and COMPOUNDSYLMAX instead. |spell-SYLLABLE|
 		|spell-COMPOUNDSYLMAX|
 
-FORBIDDENWORD	(Hunspell)				*spell-FORBIDDENWORD*
-		Use BAD instead. |spell-BAD|
-
+KEY		(Hunspell)				*spell-KEY*
+		Define characters that are close together on the keyboard.
+		Used to give better suggestions.  Not supported.
+		
 LANG		(Hunspell)				*spell-LANG*
 		This specifies language-specific behavior.  This actually
 		moves part of the language knowledge into the program,
@@ -1553,10 +1586,7 @@
 		Only needed for morphological analysis.
 
 MAXNGRAMSUGS	(Hunspell)				*spell-MAXNGRAMSUGS*
-		Not supported.
-
-ONLYINCOMPOUND	(Hunspell)				*spell-ONLYINCOMPOUND*
-		Use NEEDCOMPOUND instead. |spell-NEEDCOMPOUND|
+		Set number of n-gram suggestions.  Not supported.
 
 PSEUDOROOT	(Hunspell)				*spell-PSEUDOROOT*
 		Use NEEDAFFIX instead. |spell-NEEDAFFIX|
diff -Naur vim72.orig/runtime/doc/starting.txt vim72/runtime/doc/starting.txt
--- vim72.orig/runtime/doc/starting.txt	2008-08-09 15:23:00.000000000 +0100
+++ vim72/runtime/doc/starting.txt	2009-07-22 22:54:17.000000000 +0100
@@ -1,4 +1,4 @@
-*starting.txt*  For Vim version 7.2.  Last change: 2008 Jun 21
+*starting.txt*  For Vim version 7.2.  Last change: 2008 Nov 09
 
 
 		  VIM REFERENCE MANUAL    by Bram Moolenaar
@@ -1337,8 +1337,9 @@
 							*viminfo-read*
 When Vim is started and the 'viminfo' option is non-empty, the contents of
 the viminfo file are read and the info can be used in the appropriate places.
-The marks are not read in at startup (but file marks are).  See
-|initialization| for how to set the 'viminfo' option upon startup.
+The |v:oldfiles| variable is filled.  The marks are not read in at startup
+(but file marks are).  See |initialization| for how to set the 'viminfo'
+option upon startup.
 
 							*viminfo-write*
 When Vim exits and 'viminfo' is non-empty, the info is stored in the viminfo
@@ -1372,6 +1373,8 @@
 that start with any string given with the "r" flag in 'viminfo'.  This can be
 used to avoid saving marks for files on removable media (for MS-DOS you would
 use "ra:,rb:", for Amiga "rdf0:,rdf1:,rdf2:").
+The |v:oldfiles| variable is filled with the file names that the viminfo file
+has marks for.
 
 							*viminfo-file-marks*
 Uppercase marks ('A to 'Z) are stored when writing the viminfo file.  The
@@ -1463,8 +1466,8 @@
 						   *:rv* *:rviminfo* *E195*
 :rv[iminfo][!] [file]	Read from viminfo file [file] (default: see above).
 			If [!] is given, then any information that is
-			already set (registers, marks, etc.) will be
-			overwritten.  {not in Vi}
+			already set (registers, marks, |v:oldfiles|, etc.)
+			will be overwritten   {not in Vi}
 
 					*:wv* *:wviminfo* *E137* *E138* *E574*
 :wv[iminfo][!] [file]	Write to viminfo file [file] (default: see above).
@@ -1479,4 +1482,20 @@
 			the .viminfo file.
 			{not in Vi}
 
+						*:ol* *:oldfiles*
+:ol[dfiles]		List the files that have marks stored in the viminfo
+			file.  This list is read on startup and only changes
+			afterwards with ":rviminfo!".  Also see |v:oldfiles|.
+			The number can be used with |c_#<|.
+			{not in Vi, only when compiled with the +eval feature}
+
+:bro[wse] ol[dfiles][!]
+			List file names as with |:oldfiles|, and then prompt
+			for a number.  When the number is valid that file from
+			the list is edited.
+			If you get the |press-enter| prompt you can press "q"
+			and still get the prompt to enter a file number.
+			Use ! to abondon a modified buffer. |abandon|
+			{not when compiled with tiny or small features}
+
  vim:tw=78:ts=8:ft=help:norl:
diff -Naur vim72.orig/runtime/doc/usr_21.txt vim72/runtime/doc/usr_21.txt
--- vim72.orig/runtime/doc/usr_21.txt	2008-08-09 15:23:01.000000000 +0100
+++ vim72/runtime/doc/usr_21.txt	2009-07-22 22:54:17.000000000 +0100
@@ -1,4 +1,4 @@
-*usr_21.txt*	For Vim version 7.2.  Last change: 2007 May 01
+*usr_21.txt*	For Vim version 7.2.  Last change: 2008 Nov 09
 
 		     VIM USER MANUAL - by Bram Moolenaar
 
@@ -153,7 +153,7 @@
 to be lost.  Each item can be remembered only once.
 
 
-GETTING BACK TO WHERE YOU WERE
+GETTING BACK TO WHERE YOU STOPPED VIM
 
 You are halfway editing a file and it's time to leave for holidays.  You exit
 Vim and go enjoy yourselves, forgetting all about your work.  After a couple
@@ -168,6 +168,48 @@
    The |:marks| command is useful to find out where '0 to '9 will take you.
 
 
+GETTING BACK TO SOME FILE
+
+If you want to go back to a file that you edited recently, but not when
+exiting Vim, there is a slightly more complicated way.  You can see a list of
+files by typing the command: >
+
+	:oldfiles
+<	1: ~/.viminfo ~
+	2: ~/text/resume.txt ~
+	3: /tmp/draft ~
+
+Now you would like to edit the second file, which is in the list preceded by
+"2:".  You type: >
+
+	:e #<2
+
+Instead of ":e" you can use any command that has a file name argument, the
+"#<2" item works in the same place as "%" (current file name) and "#"
+(alternate file name).  So you can also split the window to edit the third
+file: >
+
+	:split #<3
+
+That #<123 thing is a bit complicated when you just want to edit a file.
+Fortunately there is a simpler way: >
+
+	:browse oldfiles
+<	1: ~/.viminfo ~
+	2: ~/text/resume.txt ~
+	3: /tmp/draft ~
+	-- More --
+
+You get the same list of files as with |:oldfiles|.  If you want to edit
+"resume.txt" first press "q" to stop the listing.  You will get a prompt:
+
+	Type number and <Enter> (empty cancels): ~
+
+Type "2" and press <Enter> to edit the second file.
+
+More info at |:oldfiles|, |v:oldfiles| and |c_#<|.
+
+
 MOVE INFO FROM ONE VIM TO ANOTHER
 
 You can use the ":wviminfo" and ":rviminfo" commands to save and restore the
diff -Naur vim72.orig/runtime/doc/various.txt vim72/runtime/doc/various.txt
--- vim72.orig/runtime/doc/various.txt	2008-08-09 15:23:01.000000000 +0100
+++ vim72/runtime/doc/various.txt	2009-07-22 22:54:23.000000000 +0100
@@ -508,6 +508,17 @@
 			messages though.  Use ":silent" in the command itself
 			to avoid that: ":silent menu .... :silent command".
 
+						*:uns* *:unsilent*
+:uns[ilent] {command}	Execute {command} not silently.  Only makes a
+			difference when |:silent| was used to get to this
+			command.
+			Use this for giving a message even when |:silent| was
+			used.  In this example |:silent| is used to avoid the
+			message about reading the file and |:unsilent| to be
+			able to list the first line of each file. >
+    		:silent argdo unsilent echo expand('%') . ": " . getline(1)
+<
+
 						*:verb* *:verbose*
 :[count]verb[ose] {command}
 			Execute {command} with 'verbose' set to [count].  If
diff -Naur vim72.orig/runtime/scripts.vim vim72/runtime/scripts.vim
--- vim72.orig/runtime/scripts.vim	2008-08-08 23:27:21.000000000 +0100
+++ vim72/runtime/scripts.vim	2009-07-22 22:54:16.000000000 +0100
@@ -234,6 +234,10 @@
   elseif s:line1 =~ '\<DTD\s\+XHTML\s'
     set ft=xhtml
 
+    " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
+  elseif s:line1 =~? '\<DOCTYPE\s\+html\>'
+    set ft=html
+
     " PDF
   elseif s:line1 =~ '^%PDF-'
     set ft=pdf
diff -Naur vim72.orig/src/auto/configure vim72/src/auto/configure
--- vim72.orig/src/auto/configure	2008-07-24 13:40:36.000000000 +0100
+++ vim72/src/auto/configure	2009-07-22 22:54:24.000000000 +0100
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.62.
+# Generated by GNU Autoconf 2.63.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@@ -635,138 +635,140 @@
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL
-PATH_SEPARATOR
-PACKAGE_NAME
-PACKAGE_TARNAME
-PACKAGE_VERSION
-PACKAGE_STRING
-PACKAGE_BUGREPORT
-exec_prefix
-prefix
-program_transform_name
-bindir
-sbindir
-libexecdir
-datarootdir
-datadir
-sysconfdir
-sharedstatedir
-localstatedir
-includedir
-oldincludedir
-docdir
-infodir
-htmldir
-dvidir
-pdfdir
-psdir
-libdir
-localedir
-mandir
-DEFS
-ECHO_C
-ECHO_N
-ECHO_T
-LIBS
-build_alias
-host_alias
-target_alias
-SET_MAKE
-CC
-CFLAGS
-LDFLAGS
-CPPFLAGS
-ac_ct_CC
-EXEEXT
-OBJEXT
-CPP
-GREP
-EGREP
-AWK
-STRIP
-CPP_MM
-OS_EXTRA_SRC
-OS_EXTRA_OBJ
-VIMNAME
-EXNAME
-VIEWNAME
-line_break
-dovimdiff
-dogvimdiff
-compiledby
-vi_cv_path_mzscheme
-MZSCHEME_SRC
-MZSCHEME_OBJ
-MZSCHEME_PRO
-MZSCHEME_LIBS
-MZSCHEME_CFLAGS
-vi_cv_path_perl
-vi_cv_perllib
-shrpenv
-PERL_SRC
-PERL_OBJ
-PERL_PRO
-PERL_CFLAGS
-PERL_LIBS
-vi_cv_path_python
-PYTHON_CONFDIR
-PYTHON_LIBS
-PYTHON_GETPATH_CFLAGS
-PYTHON_CFLAGS
-PYTHON_SRC
-PYTHON_OBJ
-vi_cv_path_tcl
-TCL_SRC
-TCL_OBJ
-TCL_PRO
-TCL_CFLAGS
-TCL_LIBS
-vi_cv_path_ruby
-RUBY_SRC
-RUBY_OBJ
-RUBY_PRO
-RUBY_CFLAGS
-RUBY_LIBS
-WORKSHOP_SRC
-WORKSHOP_OBJ
-NETBEANS_SRC
-NETBEANS_OBJ
-SNIFF_SRC
-SNIFF_OBJ
-xmkmfpath
-XMKMF
-X_CFLAGS
-X_PRE_LIBS
-X_LIBS
-X_EXTRA_LIBS
-X_LIB
-GTK_CONFIG
-GTK12_CONFIG
-PKG_CONFIG
-GTK_CFLAGS
-GTK_LIBS
-GTK_LIBNAME
-GNOME_LIBS
-GNOME_LIBDIR
-GNOME_INCLUDEDIR
-GNOME_CONFIG
-MOTIF_LIBNAME
-NARROW_PROTO
-GUI_INC_LOC
-GUI_LIB_LOC
-GUITYPE
-GUI_X_LIBS
-HANGULIN_SRC
-HANGULIN_OBJ
-TAGPRG
-INSTALL_LANGS
-INSTALL_TOOL_LANGS
-MSGFMT
-MAKEMO
-DEPEND_CFLAGS_FILTER
+ac_subst_vars='LTLIBOBJS
 LIBOBJS
-LTLIBOBJS'
+DEPEND_CFLAGS_FILTER
+MAKEMO
+MSGFMT
+INSTALL_TOOL_LANGS
+INSTALL_LANGS
+TAGPRG
+HANGULIN_OBJ
+HANGULIN_SRC
+GUI_X_LIBS
+GUITYPE
+GUI_LIB_LOC
+GUI_INC_LOC
+NARROW_PROTO
+MOTIF_LIBNAME
+GNOME_CONFIG
+GNOME_INCLUDEDIR
+GNOME_LIBDIR
+GNOME_LIBS
+GTK_LIBNAME
+GTK_LIBS
+GTK_CFLAGS
+PKG_CONFIG
+GTK12_CONFIG
+GTK_CONFIG
+X_LIB
+X_EXTRA_LIBS
+X_LIBS
+X_PRE_LIBS
+X_CFLAGS
+XMKMF
+xmkmfpath
+SNIFF_OBJ
+SNIFF_SRC
+NETBEANS_OBJ
+NETBEANS_SRC
+WORKSHOP_OBJ
+WORKSHOP_SRC
+RUBY_LIBS
+RUBY_CFLAGS
+RUBY_PRO
+RUBY_OBJ
+RUBY_SRC
+vi_cv_path_ruby
+TCL_LIBS
+TCL_CFLAGS
+TCL_PRO
+TCL_OBJ
+TCL_SRC
+vi_cv_path_tcl
+PYTHON_OBJ
+PYTHON_SRC
+PYTHON_CFLAGS
+PYTHON_GETPATH_CFLAGS
+PYTHON_LIBS
+PYTHON_CONFDIR
+vi_cv_path_python
+PERL_LIBS
+PERL_CFLAGS
+PERL_PRO
+PERL_OBJ
+PERL_SRC
+shrpenv
+vi_cv_perllib
+vi_cv_path_perl
+MZSCHEME_MZC
+MZSCHEME_EXTRA
+MZSCHEME_CFLAGS
+MZSCHEME_LIBS
+MZSCHEME_PRO
+MZSCHEME_OBJ
+MZSCHEME_SRC
+vi_cv_path_mzscheme
+compiledby
+dogvimdiff
+dovimdiff
+line_break
+VIEWNAME
+EXNAME
+VIMNAME
+OS_EXTRA_OBJ
+OS_EXTRA_SRC
+CPP_MM
+STRIP
+AWK
+EGREP
+GREP
+CPP
+OBJEXT
+EXEEXT
+ac_ct_CC
+CPPFLAGS
+LDFLAGS
+CFLAGS
+CC
+SET_MAKE
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
@@ -1253,9 +1255,9 @@
 if test -n "$ac_unrecognized_opts"; then
   case $enable_option_checking in
     no) ;;
-    fatal) { $as_echo "$as_me: error: Unrecognized options: $ac_unrecognized_opts" >&2
+    fatal) { $as_echo "$as_me: error: unrecognized options: $ac_unrecognized_opts" >&2
    { (exit 1); exit 1; }; } ;;
-    *)     $as_echo "$as_me: WARNING: Unrecognized options: $ac_unrecognized_opts" >&2 ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
   esac
 fi
 
@@ -1308,7 +1310,7 @@
 ac_pwd=`pwd` && test -n "$ac_pwd" &&
 ac_ls_di=`ls -di .` &&
 ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  { $as_echo "$as_me: error: Working directory cannot be determined" >&2
+  { $as_echo "$as_me: error: working directory cannot be determined" >&2
    { (exit 1); exit 1; }; }
 test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
   { $as_echo "$as_me: error: pwd does not report name of working directory" >&2
@@ -1587,7 +1589,7 @@
 if $ac_init_version; then
   cat <<\_ACEOF
 configure
-generated by GNU Autoconf 2.62
+generated by GNU Autoconf 2.63
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@@ -1601,7 +1603,7 @@
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by $as_me, which was
-generated by GNU Autoconf 2.62.  Invocation command line was
+generated by GNU Autoconf 2.63.  Invocation command line was
 
   $ $0 $@
 
@@ -1724,8 +1726,8 @@
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
-$as_echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
+      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
@@ -1928,6 +1930,8 @@
   fi
 done
 if $ac_cache_corrupted; then
+  { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
   { $as_echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
 $as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
   { { $as_echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
@@ -2084,12 +2088,8 @@
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-$as_echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
@@ -2288,12 +2288,8 @@
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-$as_echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
+{ $as_echo "$as_me:$LINENO: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
@@ -2303,11 +2299,13 @@
 fi
 
 
-test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+test -z "$CC" && { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: no acceptable C compiler found in \$PATH
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 
 # Provide some information about the compiler.
 $as_echo "$as_me:$LINENO: checking for C compiler version" >&5
@@ -2437,11 +2435,13 @@
   $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { $as_echo "$as_me:$LINENO: error: C compiler cannot create executables
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: C compiler cannot create executables
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
+   { (exit 77); exit 77; }; }; }
 fi
 
 ac_exeext=$ac_cv_exeext
@@ -2469,13 +2469,15 @@
     if test "$cross_compiling" = maybe; then
 	cross_compiling=yes
     else
-	{ { $as_echo "$as_me:$LINENO: error: cannot run C compiled programs.
+	{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
     fi
   fi
 fi
@@ -2518,11 +2520,13 @@
   esac
 done
 else
-  { { $as_echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 rm -f conftest$ac_cv_exeext
@@ -2576,11 +2580,13 @@
   $as_echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { $as_echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: cannot compute suffix of object files: cannot compile
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
@@ -3148,11 +3154,13 @@
 if $ac_preproc_ok; then
   :
 else
-  { { $as_echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+  { { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { $as_echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
 See \`config.log' for more details." >&5
 $as_echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 ac_ext=c
@@ -4016,8 +4024,9 @@
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -4154,7 +4163,7 @@
 $as_echo "$ac_cv_header_Carbon_Carbon_h" >&6; }
 
 fi
-if test $ac_cv_header_Carbon_Carbon_h = yes; then
+if test "x$ac_cv_header_Carbon_Carbon_h" = x""yes; then
   CARBON=yes
 fi
 
@@ -4484,7 +4493,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_selinux_is_selinux_enabled" >&5
 $as_echo "$ac_cv_lib_selinux_is_selinux_enabled" >&6; }
-if test $ac_cv_lib_selinux_is_selinux_enabled = yes; then
+if test "x$ac_cv_lib_selinux_is_selinux_enabled" = x""yes; then
   LIBS="$LIBS -lselinux"
 	   cat >>confdefs.h <<\_ACEOF
 #define HAVE_SELINUX 1
@@ -4634,8 +4643,8 @@
 $as_echo "\"$PLTHOME\"" >&6; }
 	vi_cv_path_mzscheme_pfx="$PLTHOME"
     else
-	{ $as_echo "$as_me:$LINENO: result: \"not set\"" >&5
-$as_echo "\"not set\"" >&6; }
+	{ $as_echo "$as_me:$LINENO: result: not set" >&5
+$as_echo "not set" >&6; }
 		# Extract the first word of "mzscheme", so it can be a program name with args.
 set dummy mzscheme; ac_word=$2
 { $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
@@ -4690,16 +4699,16 @@
 if test "${vi_cv_path_mzscheme_pfx+set}" = set; then
   $as_echo_n "(cached) " >&6
 else
-   vi_cv_path_mzscheme_pfx=`
-	    ${vi_cv_path_mzscheme} -evm \
-	    "(display (simplify-path		\
+  	    	    echo "(display (simplify-path		\
 	       (build-path (call-with-values	\
 		(lambda () (split-path (find-system-path (quote exec-file)))) \
-		(lambda (base name must-be-dir?) base)) (quote up))))"`
+		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
+	    	     vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
+		sed -e 's+/$++'`
 fi
 { $as_echo "$as_me:$LINENO: result: $vi_cv_path_mzscheme_pfx" >&5
 $as_echo "$vi_cv_path_mzscheme_pfx" >&6; }
-	    	    vi_cv_path_mzscheme_pfx=`echo "$vi_cv_path_mzscheme_pfx" | sed 's+/$++'`
+	    rm -f mzdirs.scm
 	fi
     fi
   fi
@@ -4709,21 +4718,32 @@
     { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include" >&5
 $as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include... " >&6; }
     if test -f $vi_cv_path_mzscheme_pfx/include/scheme.h; then
-      { $as_echo "$as_me:$LINENO: result: \"yes\"" >&5
-$as_echo "\"yes\"" >&6; }
+      SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
+      { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
     else
-      { $as_echo "$as_me:$LINENO: result: \"no\"" >&5
-$as_echo "\"no\"" >&6; }
-      { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/plt/include" >&5
-$as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/plt/include... " >&6; }
+      { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+      { $as_echo "$as_me:$LINENO: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt" >&5
+$as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt... " >&6; }
       if test -f $vi_cv_path_mzscheme_pfx/include/plt/scheme.h; then
-	{ $as_echo "$as_me:$LINENO: result: \"yes\"" >&5
-$as_echo "\"yes\"" >&6; }
-	SCHEME_INC=/plt
+	{ $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
       else
-	{ $as_echo "$as_me:$LINENO: result: \"no\"" >&5
-$as_echo "\"no\"" >&6; }
-	vi_cv_path_mzscheme_pfx=
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	{ $as_echo "$as_me:$LINENO: checking if scheme.h can be found in /usr/include/plt/" >&5
+$as_echo_n "checking if scheme.h can be found in /usr/include/plt/... " >&6; }
+	if test -f /usr/include/plt/scheme.h; then
+	  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+	  SCHEME_INC=/usr/include/plt
+	else
+	  { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+	  vi_cv_path_mzscheme_pfx=
+	fi
       fi
     fi
   fi
@@ -4731,21 +4751,34 @@
   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
     if test "x$MACOSX" = "xyes"; then
       MZSCHEME_LIBS="-framework PLT_MzScheme"
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"; then
+      MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"
+      MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
     else
-      MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
+            if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.so"; then
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme3m"
+	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+      else
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
+      fi
       if test "$GCC" = yes; then
-			MZSCHEME_LIBS="$MZSCHEME_LIBS -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
+			MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
       elif test "`(uname) 2>/dev/null`" = SunOS &&
 			       uname -r | grep '^5' >/dev/null; then
-	MZSCHEME_LIBS="$MZSCHEME_LIBS -R ${vi_cv_path_mzscheme_pfx}/lib"
+	MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${vi_cv_path_mzscheme_pfx}/lib"
       fi
     fi
     if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
       SCHEME_COLLECTS=lib/plt/
     fi
-    MZSCHEME_CFLAGS="-I${vi_cv_path_mzscheme_pfx}/include${SCHEME_INC}   \
+    if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
+            MZSCHEME_EXTRA="mzscheme_base.c"
+      MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
+      MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+    fi
+    MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
       -DMZSCHEME_COLLECTS='\"${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects\"'"
     MZSCHEME_SRC="if_mzsch.c"
     MZSCHEME_OBJ="objects/if_mzsch.o"
@@ -4760,6 +4793,8 @@
 
 
 
+
+
 fi
 
 
@@ -5745,7 +5780,10 @@
 	fi
 	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG["LDFLAGS"]'`
 	if test "X$rubyldflags" != "X"; then
-	  LDFLAGS="$rubyldflags $LDFLAGS"
+	  	  	  	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//'`
+	  if test "X$rubyldflags" != "X"; then
+	    LDFLAGS="$rubyldflags $LDFLAGS"
+	  fi
 	fi
 	RUBY_SRC="if_ruby.c"
 	RUBY_OBJ="objects/if_ruby.o"
@@ -5891,7 +5929,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_socket_socket" >&5
 $as_echo "$ac_cv_lib_socket_socket" >&6; }
-if test $ac_cv_lib_socket_socket = yes; then
+if test "x$ac_cv_lib_socket_socket" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBSOCKET 1
 _ACEOF
@@ -5966,7 +6004,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
 $as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
-if test $ac_cv_lib_nsl_gethostbyname = yes; then
+if test "x$ac_cv_lib_nsl_gethostbyname" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBNSL 1
 _ACEOF
@@ -6203,8 +6241,8 @@
   have_x=disabled
 else
   case $x_includes,$x_libraries in #(
-    *\'*) { { $as_echo "$as_me:$LINENO: error: Cannot use X directory names containing '" >&5
-$as_echo "$as_me: error: Cannot use X directory names containing '" >&2;}
+    *\'*) { { $as_echo "$as_me:$LINENO: error: cannot use X directory names containing '" >&5
+$as_echo "$as_me: error: cannot use X directory names containing '" >&2;}
    { (exit 1); exit 1; }; };; #(
     *,NONE | NONE,*) if test "${ac_cv_have_x+set}" = set; then
   $as_echo_n "(cached) " >&6
@@ -6242,7 +6280,7 @@
 	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
     esac
     case $ac_im_usrlibdir in
-	/usr/lib | /lib) ;;
+	/usr/lib | /usr/lib64 | /lib | /lib64) ;;
 	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
     esac
   fi
@@ -6682,7 +6720,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dnet_dnet_ntoa" >&5
 $as_echo "$ac_cv_lib_dnet_dnet_ntoa" >&6; }
-if test $ac_cv_lib_dnet_dnet_ntoa = yes; then
+if test "x$ac_cv_lib_dnet_dnet_ntoa" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet"
 fi
 
@@ -6752,7 +6790,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dnet_stub_dnet_ntoa" >&5
 $as_echo "$ac_cv_lib_dnet_stub_dnet_ntoa" >&6; }
-if test $ac_cv_lib_dnet_stub_dnet_ntoa = yes; then
+if test "x$ac_cv_lib_dnet_stub_dnet_ntoa" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet_stub"
 fi
 
@@ -6924,7 +6962,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
 $as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
-if test $ac_cv_lib_nsl_gethostbyname = yes; then
+if test "x$ac_cv_lib_nsl_gethostbyname" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lnsl"
 fi
 
@@ -6994,7 +7032,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_bsd_gethostbyname" >&5
 $as_echo "$ac_cv_lib_bsd_gethostbyname" >&6; }
-if test $ac_cv_lib_bsd_gethostbyname = yes; then
+if test "x$ac_cv_lib_bsd_gethostbyname" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lbsd"
 fi
 
@@ -7160,7 +7198,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_socket_connect" >&5
 $as_echo "$ac_cv_lib_socket_connect" >&6; }
-if test $ac_cv_lib_socket_connect = yes; then
+if test "x$ac_cv_lib_socket_connect" = x""yes; then
   X_EXTRA_LIBS="-lsocket $X_EXTRA_LIBS"
 fi
 
@@ -7319,7 +7357,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_posix_remove" >&5
 $as_echo "$ac_cv_lib_posix_remove" >&6; }
-if test $ac_cv_lib_posix_remove = yes; then
+if test "x$ac_cv_lib_posix_remove" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lposix"
 fi
 
@@ -7478,7 +7516,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ipc_shmat" >&5
 $as_echo "$ac_cv_lib_ipc_shmat" >&6; }
-if test $ac_cv_lib_ipc_shmat = yes; then
+if test "x$ac_cv_lib_ipc_shmat" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lipc"
 fi
 
@@ -7559,7 +7597,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ICE_IceConnectionNumber" >&5
 $as_echo "$ac_cv_lib_ICE_IceConnectionNumber" >&6; }
-if test $ac_cv_lib_ICE_IceConnectionNumber = yes; then
+if test "x$ac_cv_lib_ICE_IceConnectionNumber" = x""yes; then
   X_PRE_LIBS="$X_PRE_LIBS -lSM -lICE"
 fi
 
@@ -7727,7 +7765,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&5
 $as_echo "$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" >&6; }
-if test $ac_cv_lib_Xdmcp__XdmcpAuthDoIt = yes; then
+if test "x$ac_cv_lib_Xdmcp__XdmcpAuthDoIt" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lXdmcp"
 fi
 
@@ -7797,7 +7835,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_ICE_IceOpenConnection" >&5
 $as_echo "$ac_cv_lib_ICE_IceOpenConnection" >&6; }
-if test $ac_cv_lib_ICE_IceOpenConnection = yes; then
+if test "x$ac_cv_lib_ICE_IceOpenConnection" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE"
 fi
 
@@ -7868,7 +7906,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&5
 $as_echo "$ac_cv_lib_Xpm_XpmCreatePixmapFromData" >&6; }
-if test $ac_cv_lib_Xpm_XpmCreatePixmapFromData = yes; then
+if test "x$ac_cv_lib_Xpm_XpmCreatePixmapFromData" = x""yes; then
   X_PRE_LIBS="$X_PRE_LIBS -lXpm"
 fi
 
@@ -7970,6 +8008,82 @@
 
     LDFLAGS="$ac_save_LDFLAGS"
 
+    { $as_echo "$as_me:$LINENO: checking size of wchar_t is 2 bytes" >&5
+$as_echo_n "checking size of wchar_t is 2 bytes... " >&6; }
+    if test "${ac_cv_small_wchar_t+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  if test "$cross_compiling" = yes; then
+  { { $as_echo "$as_me:$LINENO: error: failed to compile test program" >&5
+$as_echo "$as_me: error: failed to compile test program" >&2;}
+   { (exit 1); exit 1; }; }
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <X11/Xlib.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+		main()
+		{
+		  if (sizeof(wchar_t) <= 2)
+		    exit(1);
+		  exit(0);
+		}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_small_wchar_t="no"
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_small_wchar_t="yes"
+fi
+rm -rf conftest.dSYM
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+
+fi
+
+    { $as_echo "$as_me:$LINENO: result: $ac_cv_small_wchar_t" >&5
+$as_echo "$ac_cv_small_wchar_t" >&6; }
+    if test "x$ac_cv_small_wchar_t" = "xyes" ; then
+      cat >>confdefs.h <<\_ACEOF
+#define SMALL_WCHAR_T 1
+_ACEOF
+
+    fi
+
   fi
 fi
 
@@ -9251,7 +9365,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xext_XShapeQueryExtension" >&5
 $as_echo "$ac_cv_lib_Xext_XShapeQueryExtension" >&6; }
-if test $ac_cv_lib_Xext_XShapeQueryExtension = yes; then
+if test "x$ac_cv_lib_Xext_XShapeQueryExtension" = x""yes; then
   GUI_X_LIBS="-lXext"
 fi
 
@@ -9320,7 +9434,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_w_wslen" >&5
 $as_echo "$ac_cv_lib_w_wslen" >&6; }
-if test $ac_cv_lib_w_wslen = yes; then
+if test "x$ac_cv_lib_w_wslen" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lw"
 fi
 
@@ -9389,7 +9503,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlsym" >&5
 $as_echo "$ac_cv_lib_dl_dlsym" >&6; }
-if test $ac_cv_lib_dl_dlsym = yes; then
+if test "x$ac_cv_lib_dl_dlsym" = x""yes; then
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldl"
 fi
 
@@ -9458,7 +9572,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&5
 $as_echo "$ac_cv_lib_Xmu_XmuCreateStippledPixmap" >&6; }
-if test $ac_cv_lib_Xmu_XmuCreateStippledPixmap = yes; then
+if test "x$ac_cv_lib_Xmu_XmuCreateStippledPixmap" = x""yes; then
   GUI_X_LIBS="-lXmu $GUI_X_LIBS"
 fi
 
@@ -9528,7 +9642,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_Xp_XpEndJob" >&5
 $as_echo "$ac_cv_lib_Xp_XpEndJob" >&6; }
-if test $ac_cv_lib_Xp_XpEndJob = yes; then
+if test "x$ac_cv_lib_Xp_XpEndJob" = x""yes; then
   GUI_X_LIBS="-lXp $GUI_X_LIBS"
 fi
 
@@ -9699,8 +9813,9 @@
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -9852,8 +9967,9 @@
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -10098,8 +10214,9 @@
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -10362,6 +10479,56 @@
 
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
+{ $as_echo "$as_me:$LINENO: checking whether __attribute__((unused)) is allowed" >&5
+$as_echo_n "checking whether __attribute__((unused)) is allowed... " >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdio.h>
+int
+main ()
+{
+int x __attribute__((unused));
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }; cat >>confdefs.h <<\_ACEOF
+#define HAVE_ATTRIBUTE_UNUSED 1
+_ACEOF
+
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	{ $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
 if test "${ac_cv_header_elf_h+set}" = set; then
   { $as_echo "$as_me:$LINENO: checking for elf.h" >&5
 $as_echo_n "checking for elf.h... " >&6; }
@@ -10489,7 +10656,7 @@
 $as_echo "$ac_cv_header_elf_h" >&6; }
 
 fi
-if test $ac_cv_header_elf_h = yes; then
+if test "x$ac_cv_header_elf_h" = x""yes; then
   HAS_ELF=1
 fi
 
@@ -10555,7 +10722,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_elf_main" >&5
 $as_echo "$ac_cv_lib_elf_main" >&6; }
-if test $ac_cv_lib_elf_main = yes; then
+if test "x$ac_cv_lib_elf_main" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBELF 1
 _ACEOF
@@ -10629,8 +10796,9 @@
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
 _ACEOF
@@ -10916,7 +11084,6 @@
 
 
 
-
 for ac_header in stdarg.h stdlib.h string.h sys/select.h sys/utsname.h \
 	termcap.h fcntl.h sgtty.h sys/ioctl.h sys/time.h sys/types.h termio.h \
 	iconv.h langinfo.h math.h unistd.h stropts.h errno.h \
@@ -10924,7 +11091,7 @@
 	sys/stream.h termios.h libc.h sys/statfs.h \
 	poll.h sys/poll.h pwd.h utime.h sys/param.h libintl.h \
 	libgen.h util/debug.h util/msg18n.h frame.h \
-	sys/acl.h sys/access.h sys/sysctl.h sys/sysinfo.h wchar.h wctype.h
+	sys/acl.h sys/access.h sys/sysinfo.h wchar.h wctype.h
 do
 as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
@@ -11058,8 +11225,9 @@
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -11122,8 +11290,74 @@
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+for ac_header in sys/sysctl.h
+do
+as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+{ $as_echo "$as_me:$LINENO: checking for $ac_header" >&5
+$as_echo_n "checking for $ac_header... " >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#if defined HAVE_SYS_PARAM_H
+#  include <sys/param.h>
+#endif
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  eval "$as_ac_Header=yes"
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	eval "$as_ac_Header=no"
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+ac_res=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -11322,8 +11556,9 @@
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -11565,6 +11800,67 @@
 
 fi
 
+{ $as_echo "$as_me:$LINENO: checking for working volatile" >&5
+$as_echo_n "checking for working volatile... " >&6; }
+if test "${ac_cv_c_volatile+set}" = set; then
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+volatile int x;
+int * volatile y = (int *) 0;
+return !x && !y;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:$LINENO: $ac_try_echo\""
+$as_echo "$ac_try_echo") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_c_volatile=yes
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_c_volatile=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:$LINENO: result: $ac_cv_c_volatile" >&5
+$as_echo "$ac_cv_c_volatile" >&6; }
+if test $ac_cv_c_volatile = no; then
+
+cat >>confdefs.h <<\_ACEOF
+#define volatile /**/
+_ACEOF
+
+fi
+
 { $as_echo "$as_me:$LINENO: checking for mode_t" >&5
 $as_echo_n "checking for mode_t... " >&6; }
 if test "${ac_cv_type_mode_t+set}" = set; then
@@ -11659,7 +11955,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_mode_t" >&5
 $as_echo "$ac_cv_type_mode_t" >&6; }
-if test $ac_cv_type_mode_t = yes; then
+if test "x$ac_cv_type_mode_t" = x""yes; then
   :
 else
 
@@ -11763,7 +12059,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
 $as_echo "$ac_cv_type_off_t" >&6; }
-if test $ac_cv_type_off_t = yes; then
+if test "x$ac_cv_type_off_t" = x""yes; then
   :
 else
 
@@ -11867,7 +12163,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_pid_t" >&5
 $as_echo "$ac_cv_type_pid_t" >&6; }
-if test $ac_cv_type_pid_t = yes; then
+if test "x$ac_cv_type_pid_t" = x""yes; then
   :
 else
 
@@ -11971,7 +12267,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
 $as_echo "$ac_cv_type_size_t" >&6; }
-if test $ac_cv_type_size_t = yes; then
+if test "x$ac_cv_type_size_t" = x""yes; then
   :
 else
 
@@ -12175,7 +12471,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_ino_t" >&5
 $as_echo "$ac_cv_type_ino_t" >&6; }
-if test $ac_cv_type_ino_t = yes; then
+if test "x$ac_cv_type_ino_t" = x""yes; then
   :
 else
 
@@ -12279,7 +12575,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_type_dev_t" >&5
 $as_echo "$ac_cv_type_dev_t" >&6; }
-if test $ac_cv_type_dev_t = yes; then
+if test "x$ac_cv_type_dev_t" = x""yes; then
   :
 else
 
@@ -12569,8 +12865,9 @@
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_Lib'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Lib'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_LIB${libname}" | $as_tr_cpp` 1
 _ACEOF
@@ -13818,8 +14115,9 @@
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -14202,7 +14500,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_m_strtod" >&5
 $as_echo "$ac_cv_lib_m_strtod" >&6; }
-if test $ac_cv_lib_m_strtod = yes; then
+if test "x$ac_cv_lib_m_strtod" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBM 1
 _ACEOF
@@ -14362,7 +14660,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_posix1e_acl_get_file" >&5
 $as_echo "$ac_cv_lib_posix1e_acl_get_file" >&6; }
-if test $ac_cv_lib_posix1e_acl_get_file = yes; then
+if test "x$ac_cv_lib_posix1e_acl_get_file" = x""yes; then
   LIBS="$LIBS -lposix1e"
 else
   { $as_echo "$as_me:$LINENO: checking for acl_get_file in -lacl" >&5
@@ -14430,7 +14728,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_acl_acl_get_file" >&5
 $as_echo "$ac_cv_lib_acl_acl_get_file" >&6; }
-if test $ac_cv_lib_acl_acl_get_file = yes; then
+if test "x$ac_cv_lib_acl_acl_get_file" = x""yes; then
   LIBS="$LIBS -lacl"
 		  { $as_echo "$as_me:$LINENO: checking for fgetxattr in -lattr" >&5
 $as_echo_n "checking for fgetxattr in -lattr... " >&6; }
@@ -14497,7 +14795,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_attr_fgetxattr" >&5
 $as_echo "$ac_cv_lib_attr_fgetxattr" >&6; }
-if test $ac_cv_lib_attr_fgetxattr = yes; then
+if test "x$ac_cv_lib_attr_fgetxattr" = x""yes; then
   LIBS="$LIBS -lattr"
 fi
 
@@ -15226,7 +15524,6 @@
 
 
 
-
 bcopy_test_prog='
 #include "confdefs.h"
 #ifdef HAVE_STRING_H
@@ -15458,7 +15755,7 @@
 if test "$enable_multibyte" = "yes"; then
   cflags_save=$CFLAGS
   ldflags_save=$LDFLAGS
-  if test -n "$x_includes" ; then
+  if test "x$x_includes" != "xNONE" ; then
     CFLAGS="$CFLAGS -I$x_includes"
     LDFLAGS="$X_LIBS $LDFLAGS -lX11"
     { $as_echo "$as_me:$LINENO: checking whether X_LOCALE needed" >&5
@@ -15635,7 +15932,7 @@
 fi
 { $as_echo "$as_me:$LINENO: result: $ac_cv_lib_xpg4__xpg4_setrunelocale" >&5
 $as_echo "$ac_cv_lib_xpg4__xpg4_setrunelocale" >&6; }
-if test $ac_cv_lib_xpg4__xpg4_setrunelocale = yes; then
+if test "x$ac_cv_lib_xpg4__xpg4_setrunelocale" = x""yes; then
   LIBS="$LIBS -lxpg4"
 fi
 
@@ -15646,6 +15943,7 @@
 if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&5 2>&1; then
   TAGPRG="ctags -I INIT+ --fields=+S"
 else
+  TAGPRG="ctags"
   (eval etags	   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="etags"
   (eval etags -c   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="etags -c"
   (eval ctags	   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="ctags"
@@ -15933,8 +16231,9 @@
 		 $as_echo "$as_val"'`
 	       { $as_echo "$as_me:$LINENO: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-if test `eval 'as_val=${'$as_ac_var'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_var'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -16134,7 +16433,7 @@
 $as_echo "$ac_cv_header_dlfcn_h" >&6; }
 
 fi
-if test $ac_cv_header_dlfcn_h = yes; then
+if test "x$ac_cv_header_dlfcn_h" = x""yes; then
   DLL=dlfcn.h
 else
   if test "${ac_cv_header_dl_h+set}" = set; then
@@ -16264,7 +16563,7 @@
 $as_echo "$ac_cv_header_dl_h" >&6; }
 
 fi
-if test $ac_cv_header_dl_h = yes; then
+if test "x$ac_cv_header_dl_h" = x""yes; then
   DLL=dl.h
 fi
 
@@ -16783,8 +17082,9 @@
 $as_echo "$ac_res" >&6; }
 
 fi
-if test `eval 'as_val=${'$as_ac_Header'}
-		 $as_echo "$as_val"'` = yes; then
+as_val=`eval 'as_val=${'$as_ac_Header'}
+		 $as_echo "$as_val"'`
+   if test "x$as_val" = x""yes; then
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -16819,21 +17119,29 @@
   LDFLAGS="$LDFLAGS -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
 fi
 
-{ $as_echo "$as_me:$LINENO: checking for GCC 3 or later" >&5
-$as_echo_n "checking for GCC 3 or later... " >&6; }
 DEPEND_CFLAGS_FILTER=
 if test "$GCC" = yes; then
+  { $as_echo "$as_me:$LINENO: checking for GCC 3 or later" >&5
+$as_echo_n "checking for GCC 3 or later... " >&6; }
   gccmajor=`echo "$gccversion" | sed -e 's/^\([1-9]\)\..*$/\1/g'`
   if test "$gccmajor" -gt "2"; then
     DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
-  fi
-fi
-if test "$DEPEND_CFLAGS_FILTER" = ""; then
-  { $as_echo "$as_me:$LINENO: result: no" >&5
+    { $as_echo "$as_me:$LINENO: result: yes" >&5
+$as_echo "yes" >&6; }
+  else
+    { $as_echo "$as_me:$LINENO: result: no" >&5
 $as_echo "no" >&6; }
-else
-  { $as_echo "$as_me:$LINENO: result: yes" >&5
+  fi
+      { $as_echo "$as_me:$LINENO: checking whether we need -D_FORTIFY_SOURCE=1" >&5
+$as_echo_n "checking whether we need -D_FORTIFY_SOURCE=1... " >&6; }
+  if test "$gccmajor" -gt "3"; then
+    CFLAGS="$CFLAGS -D_FORTIFY_SOURCE=1"
+    { $as_echo "$as_me:$LINENO: result: yes" >&5
 $as_echo "yes" >&6; }
+  else
+    { $as_echo "$as_me:$LINENO: result: no" >&5
+$as_echo "no" >&6; }
+  fi
 fi
 
 
@@ -16866,8 +17174,8 @@
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
-$as_echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
+      *_cv_*) { $as_echo "$as_me:$LINENO: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
@@ -17259,7 +17567,7 @@
 # values after options handling.
 ac_log="
 This file was extended by $as_me, which was
-generated by GNU Autoconf 2.62.  Invocation command line was
+generated by GNU Autoconf 2.63.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -17272,6 +17580,15 @@
 
 _ACEOF
 
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+case $ac_config_headers in *"
+"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+esac
+
+
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 # Files that config.status was made for.
 config_files="$ac_config_files"
@@ -17284,16 +17601,17 @@
 \`$as_me' instantiates files from templates according to the
 current configuration.
 
-Usage: $0 [OPTIONS] [FILE]...
+Usage: $0 [OPTION]... [FILE]...
 
   -h, --help       print this help, then exit
   -V, --version    print version number and configuration settings, then exit
-  -q, --quiet      do not print progress messages
+  -q, --quiet, --silent
+                   do not print progress messages
   -d, --debug      don't remove temporary files
       --recheck    update $as_me by reconfiguring in the same conditions
-  --file=FILE[:TEMPLATE]
+      --file=FILE[:TEMPLATE]
                    instantiate the configuration file FILE
-  --header=FILE[:TEMPLATE]
+      --header=FILE[:TEMPLATE]
                    instantiate the configuration header FILE
 
 Configuration files:
@@ -17308,7 +17626,7 @@
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
 config.status
-configured by $0, generated by GNU Autoconf 2.62,
+configured by $0, generated by GNU Autoconf 2.63,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2008 Free Software Foundation, Inc.
@@ -17505,7 +17823,8 @@
 $as_echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
    { (exit 1); exit 1; }; }
 
-  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X` = $ac_delim_num; then
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
     break
   elif $ac_last_try; then
     { { $as_echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
@@ -17710,9 +18029,9 @@
   }
   split(mac1, mac2, "(") #)
   macro = mac2[1]
+  prefix = substr(line, 1, index(line, defundef) - 1)
   if (D_is_set[macro]) {
     # Preserve the white space surrounding the "#".
-    prefix = substr(line, 1, index(line, defundef) - 1)
     print prefix "define", macro P[macro] D[macro]
     next
   } else {
@@ -17720,7 +18039,7 @@
     # in the case of _POSIX_SOURCE, which is predefined and required
     # on some systems where configure will not decide to define it.
     if (defundef == "undef") {
-      print "/*", line, "*/"
+      print "/*", prefix defundef, macro, "*/"
       next
     }
   }
@@ -17744,8 +18063,8 @@
   esac
   case $ac_mode$ac_tag in
   :[FHL]*:*);;
-  :L* | :C*:*) { { $as_echo "$as_me:$LINENO: error: Invalid tag $ac_tag." >&5
-$as_echo "$as_me: error: Invalid tag $ac_tag." >&2;}
+  :L* | :C*:*) { { $as_echo "$as_me:$LINENO: error: invalid tag $ac_tag" >&5
+$as_echo "$as_me: error: invalid tag $ac_tag" >&2;}
    { (exit 1); exit 1; }; };;
   :[FH]-) ac_tag=-:-;;
   :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
@@ -18063,8 +18382,8 @@
   $ac_cs_success || { (exit 1); exit 1; }
 fi
 if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
-  { $as_echo "$as_me:$LINENO: WARNING: Unrecognized options: $ac_unrecognized_opts" >&5
-$as_echo "$as_me: WARNING: Unrecognized options: $ac_unrecognized_opts" >&2;}
+  { $as_echo "$as_me:$LINENO: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
 fi
 
 
diff -Naur vim72.orig/src/buffer.c vim72/src/buffer.c
--- vim72.orig/src/buffer.c	2008-08-06 12:00:48.000000000 +0100
+++ vim72/src/buffer.c	2009-07-22 22:54:22.000000000 +0100
@@ -33,7 +33,7 @@
 static char_u	*fname_match __ARGS((regprog_T *prog, char_u *name));
 #endif
 static void	buflist_setfpos __ARGS((buf_T *buf, win_T *win, linenr_T lnum, colnr_T col, int copy_options));
-static wininfo_T *find_wininfo __ARGS((buf_T *buf));
+static wininfo_T *find_wininfo __ARGS((buf_T *buf, int skip_diff_buffer));
 #ifdef UNIX
 static buf_T	*buflist_findname_stat __ARGS((char_u *ffname, struct stat *st));
 static int	otherfile_buf __ARGS((buf_T *buf, char_u *ffname, struct stat *stp));
@@ -44,6 +44,7 @@
 #ifdef FEAT_TITLE
 static int	ti_change __ARGS((char_u *str, char_u **last));
 #endif
+static int	append_arg_number __ARGS((win_T *wp, char_u *buf, int buflen, int add_file));
 static void	free_buffer __ARGS((buf_T *));
 static void	free_buffer_stuff __ARGS((buf_T *buf, int free_options));
 static void	clear_wininfo __ARGS((buf_T *buf));
@@ -437,10 +438,6 @@
 	return;
 #endif
 
-#ifdef FEAT_NETBEANS_INTG
-    if (usingNetbeans)
-	netbeans_file_closed(buf);
-#endif
     /* Change directories when the 'acd' option is set. */
     DO_AUTOCHDIR
 
@@ -515,12 +512,11 @@
  * buf_freeall() - free all things allocated for a buffer that are related to
  * the file.
  */
-/*ARGSUSED*/
     void
 buf_freeall(buf, del_buf, wipe_buf)
     buf_T	*buf;
-    int		del_buf;	/* buffer is going to be deleted */
-    int		wipe_buf;	/* buffer is going to be wiped out */
+    int		del_buf UNUSED;	    /* buffer is going to be deleted */
+    int		wipe_buf UNUSED;    /* buffer is going to be wiped out */
 {
 #ifdef FEAT_AUTOCMD
     int		is_curbuf = (buf == curbuf);
@@ -639,6 +635,10 @@
 #ifdef FEAT_SIGNS
     buf_delete_signs(buf);		/* delete any signs */
 #endif
+#ifdef FEAT_NETBEANS_INTG
+    if (usingNetbeans)
+        netbeans_file_killed(buf);
+#endif
 #ifdef FEAT_LOCALMAP
     map_clear_int(buf, MAP_ALL_MODES, TRUE, FALSE);  /* clear local mappings */
     map_clear_int(buf, MAP_ALL_MODES, TRUE, TRUE);   /* clear local abbrevs */
@@ -647,6 +647,9 @@
     vim_free(buf->b_start_fenc);
     buf->b_start_fenc = NULL;
 #endif
+#ifdef FEAT_SPELL
+    ga_clear(&buf->b_langp);
+#endif
 }
 
 /*
@@ -812,9 +815,6 @@
     int		bnr;		/* buffer number */
     char_u	*p;
 
-#ifdef FEAT_NETBEANS_INTG
-    netbeansCloseFile = 1;
-#endif
     if (addr_count == 0)
     {
 	(void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);
@@ -909,9 +909,6 @@
 	}
     }
 
-#ifdef FEAT_NETBEANS_INTG
-    netbeansCloseFile = 0;
-#endif
 
     return errormsg;
 }
@@ -1090,7 +1087,7 @@
 #endif
 	    setpcmark();
 	    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,
-						  forceit ? ECMD_FORCEIT : 0);
+					  forceit ? ECMD_FORCEIT : 0, curwin);
 
 	    /*
 	     * do_ecmd() may create a new buffer, then we have to delete
@@ -1237,7 +1234,7 @@
 	 * "buf" if one exists */
 	if ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))
 	    return OK;
-	/* If 'switchbuf' contians "usetab": jump to first window in any tab
+	/* If 'switchbuf' contains "usetab": jump to first window in any tab
 	 * page containing "buf" if one exists */
 	if ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))
 	    return OK;
@@ -1313,7 +1310,7 @@
     setpcmark();
     if (!cmdmod.keepalt)
 	curwin->w_alt_fnum = curbuf->b_fnum; /* remember alternate file */
-    buflist_altfpos();			 /* remember curpos */
+    buflist_altfpos(curwin);			 /* remember curpos */
 
 #ifdef FEAT_VISUAL
     /* Don't restart Select mode after switching to another buffer. */
@@ -1351,11 +1348,12 @@
 	}
     }
 #ifdef FEAT_AUTOCMD
+    /* An autocommand may have deleted "buf", already entered it (e.g., when
+     * it did ":bunload") or aborted the script processing! */
 # ifdef FEAT_EVAL
-    /* An autocommand may have deleted buf or aborted the script processing! */
-    if (buf_valid(buf) && !aborting())
+    if (buf_valid(buf) && buf != curbuf && !aborting())
 # else
-    if (buf_valid(buf))	    /* an autocommand may have deleted buf! */
+    if (buf_valid(buf) && buf != curbuf)
 # endif
 #endif
 	enter_buffer(buf);
@@ -1397,6 +1395,9 @@
     curwin->w_cursor.coladd = 0;
 #endif
     curwin->w_set_curswant = TRUE;
+#ifdef FEAT_AUTOCMD
+    curwin->w_topline_was_set = FALSE;
+#endif
 
     /* Make sure the buffer is loaded. */
     if (curbuf->b_ml.ml_mfp == NULL)	/* need to load the file */
@@ -1436,7 +1437,8 @@
     maketitle();
 #endif
 #ifdef FEAT_AUTOCMD
-    if (curwin->w_topline == 1)		/* when autocmds didn't change it */
+	/* when autocmds didn't change it */
+    if (curwin->w_topline == 1 && !curwin->w_topline_was_set)
 #endif
 	scroll_cursor_halfway(FALSE);	/* redisplay at correct position */
 
@@ -1451,13 +1453,13 @@
 
 #ifdef FEAT_KEYMAP
     if (curbuf->b_kmap_state & KEYMAP_INIT)
-	keymap_init();
+	(void)keymap_init();
 #endif
 #ifdef FEAT_SPELL
     /* May need to set the spell language.  Can only do this after the buffer
      * has been properly setup. */
     if (!curbuf->b_help && curwin->w_p_spell && *curbuf->b_p_spl != NUL)
-	did_set_spelllang(curbuf);
+	(void)did_set_spelllang(curbuf);
 #endif
 
     redraw_later(NOT_VALID);
@@ -1675,9 +1677,10 @@
     buf->b_fname = buf->b_sfname;
 #ifdef UNIX
     if (st.st_dev == (dev_T)-1)
-	buf->b_dev = -1;
+	buf->b_dev_valid = FALSE;
     else
     {
+	buf->b_dev_valid = TRUE;
 	buf->b_dev = st.st_dev;
 	buf->b_ino = st.st_ino;
     }
@@ -2022,13 +2025,12 @@
  * Return fnum of the found buffer.
  * Return < 0 for error.
  */
-/*ARGSUSED*/
     int
 buflist_findpat(pattern, pattern_end, unlisted, diffmode)
     char_u	*pattern;
     char_u	*pattern_end;	/* pointer to first char after pattern */
     int		unlisted;	/* find unlisted buffers */
-    int		diffmode;	/* find diff-mode buffers only */
+    int		diffmode UNUSED; /* find diff-mode buffers only */
 {
     buf_T	*buf;
     regprog_T	*prog;
@@ -2400,22 +2402,69 @@
     return;
 }
 
+#ifdef FEAT_DIFF
+static int wininfo_other_tab_diff __ARGS((wininfo_T *wip));
+
+/*
+ * Return TRUE when "wip" has 'diff' set and the diff is only for another tab
+ * page.  That's because a diff is local to a tab page.
+ */
+    static int
+wininfo_other_tab_diff(wip)
+    wininfo_T	*wip;
+{
+    win_T	*wp;
+
+    if (wip->wi_opt.wo_diff)
+    {
+	for (wp = firstwin; wp != NULL; wp = wp->w_next)
+	    /* return FALSE when it's a window in the current tab page, thus
+	     * the buffer was in diff mode here */
+	    if (wip->wi_win == wp)
+		return FALSE;
+	return TRUE;
+    }
+    return FALSE;
+}
+#endif
+
 /*
  * Find info for the current window in buffer "buf".
  * If not found, return the info for the most recently used window.
+ * When "skip_diff_buffer" is TRUE avoid windows with 'diff' set that is in
+ * another tab page.
  * Returns NULL when there isn't any info.
  */
     static wininfo_T *
-find_wininfo(buf)
+find_wininfo(buf, skip_diff_buffer)
     buf_T	*buf;
+    int		skip_diff_buffer UNUSED;
 {
     wininfo_T	*wip;
 
     for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)
-	if (wip->wi_win == curwin)
+	if (wip->wi_win == curwin
+#ifdef FEAT_DIFF
+		&& (!skip_diff_buffer || !wininfo_other_tab_diff(wip))
+#endif
+	   )
 	    break;
-    if (wip == NULL)	/* if no fpos for curwin, use the first in the list */
-	wip = buf->b_wininfo;
+
+    /* If no wininfo for curwin, use the first in the list (that doesn't have
+     * 'diff' set and is in another tab page). */
+    if (wip == NULL)
+    {
+#ifdef FEAT_DIFF
+	if (skip_diff_buffer)
+	{
+	    for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)
+		if (!wininfo_other_tab_diff(wip))
+		    break;
+	}
+	else
+#endif
+	    wip = buf->b_wininfo;
+    }
     return wip;
 }
 
@@ -2436,7 +2485,7 @@
     clearFolding(curwin);
 #endif
 
-    wip = find_wininfo(buf);
+    wip = find_wininfo(buf, TRUE);
     if (wip != NULL && wip->wi_optset)
     {
 	copy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);
@@ -2466,9 +2515,9 @@
     buf_T	*buf;
 {
     wininfo_T	*wip;
-    static pos_T no_position = {1, 0};
+    static pos_T no_position = INIT_POS_T(1, 0, 0);
 
-    wip = find_wininfo(buf);
+    wip = find_wininfo(buf, FALSE);
     if (wip != NULL)
 	return &(wip->wi_fpos);
     else
@@ -2489,7 +2538,6 @@
 /*
  * List all know file names (for :files and :buffers command).
  */
-/*ARGSUSED*/
     void
 buflist_list(eap)
     exarg_T	*eap;
@@ -2527,8 +2575,8 @@
 	{
 	    IObuff[len++] = ' ';
 	} while (--i > 0 && len < IOSIZE - 18);
-	vim_snprintf((char *)IObuff + len, IOSIZE - len, _("line %ld"),
-		buf == curbuf ? curwin->w_cursor.lnum
+	vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),
+		_("line %ld"), buf == curbuf ? curwin->w_cursor.lnum
 					       : (long)buflist_findlnum(buf));
 	msg_outtrans(IObuff);
 	out_flush();	    /* output one line at a time */
@@ -2642,9 +2690,10 @@
     buf->b_fname = buf->b_sfname;
 #ifdef UNIX
     if (st.st_dev == (dev_T)-1)
-	buf->b_dev = -1;
+	buf->b_dev_valid = FALSE;
     else
     {
+	buf->b_dev_valid = TRUE;
 	buf->b_dev = st.st_dev;
 	buf->b_ino = st.st_ino;
     }
@@ -2789,14 +2838,14 @@
 #endif
 
 /*
- * Set alternate cursor position for current window.
+ * Set alternate cursor position for the current buffer and window "win".
  * Also save the local window option values.
  */
     void
-buflist_altfpos()
+buflist_altfpos(win)
+    win_T *win;
 {
-    buflist_setfpos(curbuf, curwin, curwin->w_cursor.lnum,
-						  curwin->w_cursor.col, TRUE);
+    buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);
 }
 
 /*
@@ -2838,7 +2887,7 @@
 	/* If no struct stat given, get it now */
 	if (stp == NULL)
 	{
-	    if (buf->b_dev < 0 || mch_stat((char *)ffname, &st) < 0)
+	    if (!buf->b_dev_valid || mch_stat((char *)ffname, &st) < 0)
 		st.st_dev = (dev_T)-1;
 	    stp = &st;
 	}
@@ -2875,11 +2924,12 @@
 
     if (buf->b_fname != NULL && mch_stat((char *)buf->b_fname, &st) >= 0)
     {
+	buf->b_dev_valid = TRUE;
 	buf->b_dev = st.st_dev;
 	buf->b_ino = st.st_ino;
     }
     else
-	buf->b_dev = -1;
+	buf->b_dev_valid = FALSE;
 }
 
 /*
@@ -2890,7 +2940,7 @@
     buf_T	*buf;
     struct stat *stp;
 {
-    return (buf->b_dev >= 0
+    return (buf->b_dev_valid
 	    && stp->st_dev == buf->b_dev
 	    && stp->st_ino == buf->b_ino);
 }
@@ -2917,7 +2967,7 @@
 
     if (fullname > 1)	    /* 2 CTRL-G: include buffer number */
     {
-	sprintf((char *)buffer, "buf %d: ", curbuf->b_fnum);
+	vim_snprintf((char *)buffer, IOSIZE, "buf %d: ", curbuf->b_fnum);
 	p = buffer + STRLEN(buffer);
     }
     else
@@ -2991,11 +3041,12 @@
 		(long)curbuf->b_ml.ml_line_count,
 		n);
 	validate_virtcol();
-	col_print(buffer + STRLEN(buffer),
+	len = STRLEN(buffer);
+	col_print(buffer + len, IOSIZE - len,
 		   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);
     }
 
-    (void)append_arg_number(curwin, buffer, !shortmess(SHM_FILE), IOSIZE);
+    (void)append_arg_number(curwin, buffer, IOSIZE, !shortmess(SHM_FILE));
 
     if (dont_truncate)
     {
@@ -3023,15 +3074,16 @@
 }
 
     void
-col_print(buf, col, vcol)
+col_print(buf, buflen, col, vcol)
     char_u  *buf;
+    size_t  buflen;
     int	    col;
     int	    vcol;
 {
     if (col == vcol)
-	sprintf((char *)buf, "%d", col);
+	vim_snprintf((char *)buf, buflen, "%d", col);
     else
-	sprintf((char *)buf, "%d-%d", col, vcol);
+	vim_snprintf((char *)buf, buflen, "%d-%d", col, vcol);
 }
 
 #if defined(FEAT_TITLE) || defined(PROTO)
@@ -3144,18 +3196,18 @@
 		if (p == buf + off)
 		    /* must be a help buffer */
 		    vim_strncpy(buf + off, (char_u *)_("help"),
-							    IOSIZE - off - 1);
+						  (size_t)(IOSIZE - off - 1));
 		else
 		    *p = NUL;
 
 		/* translate unprintable chars */
 		p = transstr(buf + off);
-		vim_strncpy(buf + off, p, IOSIZE - off - 1);
+		vim_strncpy(buf + off, p, (size_t)(IOSIZE - off - 1));
 		vim_free(p);
 		STRCAT(buf, ")");
 	    }
 
-	    append_arg_number(curwin, buf, FALSE, IOSIZE);
+	    append_arg_number(curwin, buf, IOSIZE, FALSE);
 
 #if defined(FEAT_CLIENTSERVER)
 	    if (serverName != NULL)
@@ -3292,14 +3344,13 @@
  * If maxwidth is not zero, the string will be filled at any middle marker
  * or truncated if too long, fillchar is used for all whitespace.
  */
-/*ARGSUSED*/
     int
 build_stl_str_hl(wp, out, outlen, fmt, use_sandbox, fillchar, maxwidth, hltab, tabtab)
     win_T	*wp;
     char_u	*out;		/* buffer to write into != NameBuff */
     size_t	outlen;		/* length of out[] */
     char_u	*fmt;
-    int		use_sandbox;	/* "fmt" was set insecurely, use sandbox */
+    int		use_sandbox UNUSED; /* "fmt" was set insecurely, use sandbox */
     int		fillchar;
     int		maxwidth;
     struct stl_hlrec *hltab;	/* return: HL attributes (can be NULL) */
@@ -3470,7 +3521,7 @@
 		    n = (long)(p - t) - item[groupitem[groupdepth]].maxwid + 1;
 
 		*t = '<';
-		mch_memmove(t + 1, t + n, p - (t + n));
+		mch_memmove(t + 1, t + n, (size_t)(p - (t + n)));
 		p = p - n + 1;
 #ifdef FEAT_MBYTE
 		/* Fill up space left over by half a double-wide char. */
@@ -3500,7 +3551,7 @@
 		else
 		{
 		    /* fill by inserting characters */
-		    mch_memmove(t + n - l, t, p - t);
+		    mch_memmove(t + n - l, t, (size_t)(p - t));
 		    l = n - l;
 		    if (p + l >= out + outlen)
 			l = (long)((out + outlen) - p - 1);
@@ -3636,7 +3687,7 @@
 	    p = t;
 
 #ifdef FEAT_EVAL
-	    sprintf((char *)tmp, "%d", curbuf->b_fnum);
+	    vim_snprintf((char *)tmp, sizeof(tmp), "%d", curbuf->b_fnum);
 	    set_internal_string_var((char_u *)"actual_curbuf", tmp);
 
 	    o_curbuf = curbuf;
@@ -3703,13 +3754,13 @@
 
 	case STL_ALTPERCENT:
 	    str = tmp;
-	    get_rel_pos(wp, str);
+	    get_rel_pos(wp, str, TMPLEN);
 	    break;
 
 	case STL_ARGLISTSTAT:
 	    fillable = FALSE;
 	    tmp[0] = 0;
-	    if (append_arg_number(wp, tmp, FALSE, (int)sizeof(tmp)))
+	    if (append_arg_number(wp, tmp, (int)sizeof(tmp), FALSE))
 		str = tmp;
 	    break;
 
@@ -3744,7 +3795,7 @@
 	case STL_BYTEVAL_X:
 	    base = 'X';
 	case STL_BYTEVAL:
-	    if (wp->w_cursor.col > STRLEN(linecont))
+	    if (wp->w_cursor.col > (colnr_T)STRLEN(linecont))
 		num = 0;
 	    else
 	    {
@@ -3917,7 +3968,7 @@
 	    if (zeropad)
 		*t++ = '0';
 	    *t++ = '*';
-	    *t++ = nbase == 16 ? base : (nbase == 8 ? 'o' : 'd');
+	    *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');
 	    *t = 0;
 
 	    for (n = num, l = 1; n >= nbase; n /= nbase)
@@ -3963,7 +4014,7 @@
     width = vim_strsize(out);
     if (maxwidth > 0 && width > maxwidth)
     {
-	/* Result is too long, must trunctate somewhere. */
+	/* Result is too long, must truncate somewhere. */
 	l = 0;
 	if (itemcnt == 0)
 	    s = out;
@@ -4110,13 +4161,14 @@
 #if defined(FEAT_STL_OPT) || defined(FEAT_CMDL_INFO) \
 	    || defined(FEAT_GUI_TABLINE) || defined(PROTO)
 /*
- * Get relative cursor position in window into "str[]", in the form 99%, using
- * "Top", "Bot" or "All" when appropriate.
+ * Get relative cursor position in window into "buf[buflen]", in the form 99%,
+ * using "Top", "Bot" or "All" when appropriate.
  */
     void
-get_rel_pos(wp, str)
+get_rel_pos(wp, buf, buflen)
     win_T	*wp;
-    char_u	*str;
+    char_u	*buf;
+    int		buflen;
 {
     long	above; /* number of lines above window */
     long	below; /* number of lines below window */
@@ -4127,34 +4179,35 @@
 #endif
     below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;
     if (below <= 0)
-	STRCPY(str, above == 0 ? _("All") : _("Bot"));
+	vim_strncpy(buf, (char_u *)(above == 0 ? _("All") : _("Bot")),
+							(size_t)(buflen - 1));
     else if (above <= 0)
-	STRCPY(str, _("Top"));
+	vim_strncpy(buf, (char_u *)_("Top"), (size_t)(buflen - 1));
     else
-	sprintf((char *)str, "%2d%%", above > 1000000L
+	vim_snprintf((char *)buf, (size_t)buflen, "%2d%%", above > 1000000L
 				    ? (int)(above / ((above + below) / 100L))
 				    : (int)(above * 100L / (above + below)));
 }
 #endif
 
 /*
- * Append (file 2 of 8) to 'buf', if editing more than one file.
+ * Append (file 2 of 8) to "buf[buflen]", if editing more than one file.
  * Return TRUE if it was appended.
  */
-    int
-append_arg_number(wp, buf, add_file, maxlen)
+    static int
+append_arg_number(wp, buf, buflen, add_file)
     win_T	*wp;
     char_u	*buf;
+    int		buflen;
     int		add_file;	/* Add "file" before the arg number */
-    int		maxlen;		/* maximum nr of chars in buf or zero*/
 {
     char_u	*p;
 
     if (ARGCOUNT <= 1)		/* nothing to do */
 	return FALSE;
 
-    p = buf + STRLEN(buf);		/* go to the end of the buffer */
-    if (maxlen && p - buf + 35 >= maxlen) /* getting too long */
+    p = buf + STRLEN(buf);	/* go to the end of the buffer */
+    if (p - buf + 35 >= buflen)	/* getting too long */
 	return FALSE;
     *p++ = ' ';
     *p++ = '(';
@@ -4163,7 +4216,8 @@
 	STRCPY(p, "file ");
 	p += 5;
     }
-    sprintf((char *)p, wp->w_arg_idx_invalid ? "(%d) of %d)"
+    vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),
+		wp->w_arg_idx_invalid ? "(%d) of %d)"
 				  : "%d of %d)", wp->w_arg_idx + 1, ARGCOUNT);
     return TRUE;
 }
@@ -4219,10 +4273,9 @@
  * Make "ffname" a full file name, set "sfname" to "ffname" if not NULL.
  * "ffname" becomes a pointer to allocated memory (or NULL).
  */
-/*ARGSUSED*/
     void
 fname_expand(buf, ffname, sfname)
-    buf_T	*buf;
+    buf_T	*buf UNUSED;
     char_u	**ffname;
     char_u	**sfname;
 {
@@ -4488,7 +4541,7 @@
 		      ECMD_ONE,
 		      ((P_HID(curwin->w_buffer)
 			   || bufIsChanged(curwin->w_buffer)) ? ECMD_HIDE : 0)
-							       + ECMD_OLDBUF);
+						       + ECMD_OLDBUF, curwin);
 #ifdef FEAT_AUTOCMD
 	    if (use_firstwin)
 		++autocmd_no_leave;
@@ -4946,7 +4999,7 @@
 	if (tab != NULL)
 	{
 	    *tab++ = '\0';
-	    col = atoi((char *)tab);
+	    col = (colnr_T)atoi((char *)tab);
 	    tab = vim_strrchr(xline, '\t');
 	    if (tab != NULL)
 	    {
@@ -4984,6 +5037,7 @@
 #endif
     char_u	*line;
     int		max_buffers;
+    size_t	len;
 
     if (find_viminfo_parameter('%') == NULL)
 	return;
@@ -4992,7 +5046,8 @@
     max_buffers = get_viminfo_parameter('%');
 
     /* Allocate room for the file name, lnum and col. */
-    line = alloc(MAXPATHL + 40);
+#define LINE_BUF_LEN (MAXPATHL + 40)
+    line = alloc(LINE_BUF_LEN);
     if (line == NULL)
 	return;
 
@@ -5018,7 +5073,8 @@
 	    break;
 	putc('%', fp);
 	home_replace(NULL, buf->b_ffname, line, MAXPATHL, TRUE);
-	sprintf((char *)line + STRLEN(line), "\t%ld\t%d",
+	len = STRLEN(line);
+	vim_snprintf((char *)line + len, len - LINE_BUF_LEN, "\t%ld\t%d",
 			(long)buf->b_last_cursor.lnum,
 			buf->b_last_cursor.col);
 	viminfo_writestring(fp, line);
@@ -5048,7 +5104,8 @@
 	 */
 	FOR_ALL_TAB_WINDOWS(tp, win)
 	    if (win->w_buffer == buf)
-		break;
+		goto win_found;
+win_found:
 	if (win != NULL && win->w_llist_ref != NULL)
 	    return _("[Location List]");
 	else
@@ -5062,7 +5119,7 @@
     {
 	if (buf->b_sfname != NULL)
 	    return (char *)buf->b_sfname;
-	return "[Scratch]";
+	return _("[Scratch]");
     }
 #endif
     if (buf->b_fname == NULL)
@@ -5175,7 +5232,7 @@
     return;
 }
 
-    int
+    linenr_T
 buf_change_sign_type(buf, markId, typenr)
     buf_T	*buf;		/* buffer to store sign in */
     int		markId;		/* sign ID */
@@ -5192,10 +5249,10 @@
 	}
     }
 
-    return 0;
+    return (linenr_T)0;
 }
 
-    int_u
+    int
 buf_getsigntype(buf, lnum, type)
     buf_T	*buf;
     linenr_T	lnum;
@@ -5514,11 +5571,10 @@
  * this buffer.  Call this to wipe out a temp buffer that does not contain any
  * marks.
  */
-/*ARGSUSED*/
     void
 wipe_buffer(buf, aucmd)
     buf_T	*buf;
-    int		aucmd;	    /* When TRUE trigger autocommands. */
+    int		aucmd UNUSED;	    /* When TRUE trigger autocommands. */
 {
     if (buf->b_fnum == top_file_num - 1)
 	--top_file_num;
diff -Naur vim72.orig/src/charset.c vim72/src/charset.c
--- vim72.orig/src/charset.c	2008-07-24 15:59:44.000000000 +0100
+++ vim72/src/charset.c	2009-07-22 22:54:21.000000000 +0100
@@ -17,7 +17,7 @@
 static int win_nolbr_chartabsize __ARGS((win_T *wp, char_u *s, colnr_T col, int *headp));
 #endif
 
-static int nr2hex __ARGS((int c));
+static unsigned nr2hex __ARGS((unsigned c));
 
 static int    chartab_initialized = FALSE;
 
@@ -664,7 +664,7 @@
     }
 #endif
     buf[++i] = nr2hex((unsigned)c >> 4);
-    buf[++i] = nr2hex(c);
+    buf[++i] = nr2hex((unsigned)c);
     buf[++i] = '>';
     buf[++i] = NUL;
 }
@@ -674,9 +674,9 @@
  * Lower case letters are used to avoid the confusion of <F1> being 0xf1 or
  * function key 1.
  */
-    static int
+    static unsigned
 nr2hex(c)
-    int		c;
+    unsigned	c;
 {
     if ((c & 0xf) <= 9)
 	return (c & 0xf) + '0';
@@ -884,7 +884,7 @@
     if (c >= 0x100)
     {
 	if (enc_dbcs != 0)
-	    return dbcs_class((unsigned)c >> 8, c & 0xff) >= 2;
+	    return dbcs_class((unsigned)c >> 8, (unsigned)(c & 0xff)) >= 2;
 	if (enc_utf8)
 	    return utf_class(c) >= 2;
     }
@@ -1026,13 +1026,12 @@
  * string at start of line.  Warning: *headp is only set if it's a non-zero
  * value, init to 0 before calling.
  */
-/*ARGSUSED*/
     int
 win_lbr_chartabsize(wp, s, col, headp)
     win_T	*wp;
     char_u	*s;
     colnr_T	col;
-    int		*headp;
+    int		*headp UNUSED;
 {
 #ifdef FEAT_LINEBREAK
     int		c;
@@ -1090,7 +1089,7 @@
 	 */
 	numberextra = win_col_off(wp);
 	col2 = col;
-	colmax = W_WIDTH(wp) - numberextra;
+	colmax = (colnr_T)(W_WIDTH(wp) - numberextra);
 	if (col >= colmax)
 	{
 	    n = colmax + win_col_off2(wp);
@@ -1201,17 +1200,17 @@
     win_T	*wp;
     colnr_T	vcol;
 {
-    colnr_T	width1;		/* width of first line (after line number) */
-    colnr_T	width2;		/* width of further lines */
+    int		width1;		/* width of first line (after line number) */
+    int		width2;		/* width of further lines */
 
 #ifdef FEAT_VERTSPLIT
     if (wp->w_width == 0)	/* there is no border */
 	return FALSE;
 #endif
     width1 = W_WIDTH(wp) - win_col_off(wp);
-    if (vcol < width1 - 1)
+    if ((int)vcol < width1 - 1)
 	return FALSE;
-    if (vcol == width1 - 1)
+    if ((int)vcol == width1 - 1)
 	return TRUE;
     width2 = width1 + win_col_off2(wp);
     return ((vcol - width1) % width2 == width2 - 1);
@@ -1396,13 +1395,13 @@
 # ifdef FEAT_MBYTE
 	/* Cannot put the cursor on part of a wide character. */
 	ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);
-	if (pos->col < STRLEN(ptr))
+	if (pos->col < (colnr_T)STRLEN(ptr))
 	{
 	    int c = (*mb_ptr2char)(ptr + pos->col);
 
 	    if (c != TAB && vim_isprintc(c))
 	    {
-		endadd = char2cells(c) - 1;
+		endadd = (colnr_T)(char2cells(c) - 1);
 		if (coladd > endadd)	/* past end of line */
 		    endadd = 0;
 		else
diff -Naur vim72.orig/src/config.h.in vim72/src/config.h.in
--- vim72.orig/src/config.h.in	2008-06-21 16:01:41.000000000 +0100
+++ vim72/src/config.h.in	2009-07-22 22:54:22.000000000 +0100
@@ -30,12 +30,18 @@
 /* Define when __DATE__ " " __TIME__ can be used */
 #undef HAVE_DATE_TIME
 
+/* Define when __attribute__((unused)) can be used */
+#undef HAVE_ATTRIBUTE_UNUSED
+
 /* defined always when using configure */
 #undef UNIX
 
 /* Defined to the size of an int */
 #undef SIZEOF_INT
 
+/* Define when wchar_t is only 2 bytes. */
+#undef SMALL_WCHAR_T
+
 /*
  * If we cannot trust one of the following from the libraries, we use our
  * own safe but probably slower vim_memmove().
@@ -50,6 +56,9 @@
 /* Define to empty if the keyword does not work.  */
 #undef const
 
+/* Define to empty if the keyword does not work.  */
+#undef volatile
+
 /* Define to `int' if <sys/types.h> doesn't define.  */
 #undef mode_t
 
diff -Naur vim72.orig/src/config.mk.in vim72/src/config.mk.in
--- vim72.orig/src/config.mk.in	2008-06-21 16:56:41.000000000 +0100
+++ vim72/src/config.mk.in	2009-07-22 22:54:22.000000000 +0100
@@ -41,6 +41,8 @@
 MZSCHEME_OBJ	= @MZSCHEME_OBJ@
 MZSCHEME_CFLAGS	= @MZSCHEME_CFLAGS@
 MZSCHEME_PRO	= @MZSCHEME_PRO@
+MZSCHEME_EXTRA  = @MZSCHEME_EXTRA@
+MZSCHEME_MZC	= @MZSCHEME_MZC@
 
 PERL		= @vi_cv_path_perl@
 PERLLIB		= @vi_cv_perllib@
diff -Naur vim72.orig/src/configure.in vim72/src/configure.in
--- vim72.orig/src/configure.in	2008-07-24 13:40:26.000000000 +0100
+++ vim72/src/configure.in	2009-07-22 22:54:24.000000000 +0100
@@ -414,7 +414,7 @@
 	AC_MSG_RESULT("$PLTHOME")
 	vi_cv_path_mzscheme_pfx="$PLTHOME"
     else
-	AC_MSG_RESULT("not set")
+	AC_MSG_RESULT(not set)
 	dnl -- try to find MzScheme executable
 	AC_PATH_PROG(vi_cv_path_mzscheme, mzscheme)
 
@@ -430,14 +430,16 @@
 	if test "X$vi_cv_path_mzscheme" != "X"; then
 	    dnl -- find where MzScheme thinks it was installed
 	    AC_CACHE_CHECK(MzScheme install prefix,vi_cv_path_mzscheme_pfx,
-	    [ vi_cv_path_mzscheme_pfx=`
-	    ${vi_cv_path_mzscheme} -evm \
-	    "(display (simplify-path		\
+	    dnl different versions of MzScheme differ in command line processing
+	    dnl use universal approach
+	    echo "(display (simplify-path		\
 	       (build-path (call-with-values	\
 		(lambda () (split-path (find-system-path (quote exec-file)))) \
-		(lambda (base name must-be-dir?) base)) (quote up))))"` ])
-	    dnl Remove a trailing slash.
-	    vi_cv_path_mzscheme_pfx=`echo "$vi_cv_path_mzscheme_pfx" | sed 's+/$++'`
+		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
+	    dnl Remove a trailing slash
+	    [ vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
+		sed -e 's+/$++'` ])
+	    rm -f mzdirs.scm
 	fi
     fi
   fi
@@ -446,16 +448,24 @@
   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
     AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include)
     if test -f $vi_cv_path_mzscheme_pfx/include/scheme.h; then
-      AC_MSG_RESULT("yes")
+      SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
+      AC_MSG_RESULT(yes)
     else
-      AC_MSG_RESULT("no")
-      AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/plt/include)
+      AC_MSG_RESULT(no)
+      AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt)
       if test -f $vi_cv_path_mzscheme_pfx/include/plt/scheme.h; then
-	AC_MSG_RESULT("yes")
-	SCHEME_INC=/plt
+	AC_MSG_RESULT(yes)
+	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
       else
-	AC_MSG_RESULT("no")
-	vi_cv_path_mzscheme_pfx=
+	AC_MSG_RESULT(no)
+	AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)
+	if test -f /usr/include/plt/scheme.h; then
+	  AC_MSG_RESULT(yes)
+	  SCHEME_INC=/usr/include/plt
+	else
+	  AC_MSG_RESULT(no)
+	  vi_cv_path_mzscheme_pfx=
+	fi
       fi
     fi
   fi
@@ -463,23 +473,38 @@
   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
     if test "x$MACOSX" = "xyes"; then
       MZSCHEME_LIBS="-framework PLT_MzScheme"
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"; then
+      MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"
+      MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
     else
-      MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
+      dnl Using shared objects
+      if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.so"; then
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme3m"
+	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+      else
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
+      fi
       if test "$GCC" = yes; then
 	dnl Make Vim remember the path to the library.  For when it's not in
 	dnl $LD_LIBRARY_PATH.
-	MZSCHEME_LIBS="$MZSCHEME_LIBS -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
+	MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${vi_cv_path_mzscheme_pfx}/lib"
       elif test "`(uname) 2>/dev/null`" = SunOS &&
 			       uname -r | grep '^5' >/dev/null; then
-	MZSCHEME_LIBS="$MZSCHEME_LIBS -R ${vi_cv_path_mzscheme_pfx}/lib"
+	MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${vi_cv_path_mzscheme_pfx}/lib"
       fi
     fi
     if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
       SCHEME_COLLECTS=lib/plt/
     fi
-    MZSCHEME_CFLAGS="-I${vi_cv_path_mzscheme_pfx}/include${SCHEME_INC}   \
+    if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
+      dnl need to generate bytecode for MzScheme base
+      MZSCHEME_EXTRA="mzscheme_base.c"
+      MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
+      MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+    fi
+    MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
       -DMZSCHEME_COLLECTS='\"${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects\"'"
     MZSCHEME_SRC="if_mzsch.c"
     MZSCHEME_OBJ="objects/if_mzsch.o"
@@ -491,6 +516,8 @@
   AC_SUBST(MZSCHEME_PRO)
   AC_SUBST(MZSCHEME_LIBS)
   AC_SUBST(MZSCHEME_CFLAGS)
+  AC_SUBST(MZSCHEME_EXTRA)
+  AC_SUBST(MZSCHEME_MZC)
 fi
 
 
@@ -957,7 +984,13 @@
 	fi
 	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e 'print Config::CONFIG[["LDFLAGS"]]'`
 	if test "X$rubyldflags" != "X"; then
-	  LDFLAGS="$rubyldflags $LDFLAGS"
+	  dnl Ruby on Mac OS X 10.5 adds "-arch" flags but these should only
+	  dnl be included if requested by passing --with-mac-arch to
+	  dnl configure, so strip these flags first (if present)
+	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//'`
+	  if test "X$rubyldflags" != "X"; then
+	    LDFLAGS="$rubyldflags $LDFLAGS"
+	  fi
 	fi
 	RUBY_SRC="if_ruby.c"
 	RUBY_OBJ="objects/if_ruby.o"
@@ -1193,6 +1226,28 @@
 
     LDFLAGS="$ac_save_LDFLAGS"
 
+    AC_MSG_CHECKING(size of wchar_t is 2 bytes)
+    AC_CACHE_VAL(ac_cv_small_wchar_t,
+	[AC_TRY_RUN([
+#include <X11/Xlib.h>
+#if STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#endif
+		main()
+		{
+		  if (sizeof(wchar_t) <= 2)
+		    exit(1);
+		  exit(0);
+		}],
+		ac_cv_small_wchar_t="no",
+		ac_cv_small_wchar_t="yes",
+		AC_MSG_ERROR(failed to compile test program))])
+    AC_MSG_RESULT($ac_cv_small_wchar_t)
+    if test "x$ac_cv_small_wchar_t" = "xyes" ; then
+      AC_DEFINE(SMALL_WCHAR_T)
+    fi
+
   fi
 fi
 
@@ -2067,6 +2122,11 @@
 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_DATE_TIME),
 	AC_MSG_RESULT(no))
 
+AC_MSG_CHECKING(whether __attribute__((unused)) is allowed)
+AC_TRY_COMPILE([#include <stdio.h>], [int x __attribute__((unused));],
+	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ATTRIBUTE_UNUSED),
+	AC_MSG_RESULT(no))
+
 dnl Checks for header files.
 AC_CHECK_HEADER(elf.h, HAS_ELF=1)
 dnl AC_CHECK_HEADER(dwarf.h, SVR4=1)
@@ -2095,7 +2155,7 @@
 	sys/stream.h termios.h libc.h sys/statfs.h \
 	poll.h sys/poll.h pwd.h utime.h sys/param.h libintl.h \
 	libgen.h util/debug.h util/msg18n.h frame.h \
-	sys/acl.h sys/access.h sys/sysctl.h sys/sysinfo.h wchar.h wctype.h)
+	sys/acl.h sys/access.h sys/sysinfo.h wchar.h wctype.h)
 
 dnl sys/ptem.h depends on sys/stream.h on Solaris
 AC_CHECK_HEADERS(sys/ptem.h, [], [],
@@ -2103,6 +2163,12 @@
 #  include <sys/stream.h>
 #endif])
 
+dnl sys/sysctl.h depends on sys/param.h on OpenBSD
+AC_CHECK_HEADERS(sys/sysctl.h, [], [],
+[#if defined HAVE_SYS_PARAM_H
+#  include <sys/param.h>
+#endif])
+
 
 dnl pthread_np.h may exist but can only be used after including pthread.h
 AC_MSG_CHECKING([for pthread_np.h])
@@ -2148,6 +2214,7 @@
 dnl Checks for typedefs, structures, and compiler characteristics.
 AC_PROG_GCC_TRADITIONAL
 AC_C_CONST
+AC_C_VOLATILE
 AC_TYPE_MODE_T
 AC_TYPE_OFF_T
 AC_TYPE_PID_T
@@ -2869,7 +2936,6 @@
 AC_MSG_RESULT($ac_cv_sizeof_int)
 AC_DEFINE_UNQUOTED(SIZEOF_INT, $ac_cv_sizeof_int)
 
-
 dnl Check for memmove() before bcopy(), makes memmove() be used when both are
 dnl present, fixes problem with incompatibility between Solaris 2.4 and 2.5.
 
@@ -2951,7 +3017,7 @@
 if test "$enable_multibyte" = "yes"; then
   cflags_save=$CFLAGS
   ldflags_save=$LDFLAGS
-  if test -n "$x_includes" ; then
+  if test "x$x_includes" != "xNONE" ; then
     CFLAGS="$CFLAGS -I$x_includes"
     LDFLAGS="$X_LIBS $LDFLAGS -lX11"
     AC_MSG_CHECKING(whether X_LOCALE needed)
@@ -2967,7 +3033,7 @@
 dnl Link with xpg4, it is said to make Korean locale working
 AC_CHECK_LIB(xpg4, _xpg4_setrunelocale, [LIBS="$LIBS -lxpg4"],,)
 
-dnl Check how we can run ctags
+dnl Check how we can run ctags.  Default to "ctags" when nothing works.
 dnl --version for Exuberant ctags (preferred)
 dnl       Add --fields=+S to get function signatures for omni completion.
 dnl -t for typedefs (many ctags have this)
@@ -2979,6 +3045,7 @@
 if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
   TAGPRG="ctags -I INIT+ --fields=+S"
 else
+  TAGPRG="ctags"
   (eval etags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags"
   (eval etags -c   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags -c"
   (eval ctags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags"
@@ -3152,18 +3219,25 @@
 dnl But only when making dependencies, cproto and lint don't take "-isystem".
 dnl Mac gcc returns "powerpc-apple-darwin8-gcc-4.0.1 (GCC)...", need to allow
 dnl the number before the version number.
-AC_MSG_CHECKING(for GCC 3 or later)
 DEPEND_CFLAGS_FILTER=
 if test "$GCC" = yes; then
+  AC_MSG_CHECKING(for GCC 3 or later)
   gccmajor=`echo "$gccversion" | sed -e 's/^\([[1-9]]\)\..*$/\1/g'`
   if test "$gccmajor" -gt "2"; then
     DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
+    AC_MSG_RESULT(yes)
+  else
+    AC_MSG_RESULT(no)
+  fi
+  dnl -D_FORTIFY_SOURCE=2 crashes Vim on strcpy(buf, "000") when buf is
+  dnl declared as char x[1] but actually longer.  Introduced in gcc 4.0.
+  AC_MSG_CHECKING(whether we need -D_FORTIFY_SOURCE=1)
+  if test "$gccmajor" -gt "3"; then
+    CFLAGS="$CFLAGS -D_FORTIFY_SOURCE=1"
+    AC_MSG_RESULT(yes)
+  else
+    AC_MSG_RESULT(no)
   fi
-fi
-if test "$DEPEND_CFLAGS_FILTER" = ""; then
-  AC_MSG_RESULT(no)
-else
-  AC_MSG_RESULT(yes)
 fi
 AC_SUBST(DEPEND_CFLAGS_FILTER)
 
diff -Naur vim72.orig/src/diff.c vim72/src/diff.c
--- vim72.orig/src/diff.c	2008-03-05 11:16:56.000000000 +0000
+++ vim72/src/diff.c	2009-07-22 22:54:24.000000000 +0100
@@ -8,7 +8,7 @@
  */
 
 /*
- * diff.c: code for diff'ing two or three buffers.
+ * diff.c: code for diff'ing two, three or four buffers.
  */
 
 #include "vim.h"
@@ -73,6 +73,8 @@
 	{
 	    tp->tp_diffbuf[i] = NULL;
 	    tp->tp_diff_invalid = TRUE;
+	    if (tp == curtab)
+		diff_redraw(TRUE);
 	}
     }
 }
@@ -102,6 +104,7 @@
 	    {
 		curtab->tp_diffbuf[i] = NULL;
 		curtab->tp_diff_invalid = TRUE;
+		diff_redraw(TRUE);
 	    }
 	}
     }
@@ -113,7 +116,7 @@
  * Add a buffer to make diffs for.
  * Call this when a new buffer is being edited in the current window where
  * 'diff' is set.
- * Marks the current buffer as being part of the diff and requireing updating.
+ * Marks the current buffer as being part of the diff and requiring updating.
  * This must be done before any autocmd, because a command may use info
  * about the screen contents.
  */
@@ -131,6 +134,7 @@
 	{
 	    curtab->tp_diffbuf[i] = buf;
 	    curtab->tp_diff_invalid = TRUE;
+	    diff_redraw(TRUE);
 	    return;
 	}
 
@@ -648,10 +652,9 @@
  * The buffers are written to a file, also for unmodified buffers (the file
  * could have been produced by autocommands, e.g. the netrw plugin).
  */
-/*ARGSUSED*/
     void
 ex_diffupdate(eap)
-    exarg_T	*eap;	    /* can be NULL, it's not used */
+    exarg_T	*eap UNUSED;	    /* can be NULL */
 {
     buf_T	*buf;
     int		idx_orig;
@@ -661,6 +664,7 @@
     char_u	*tmp_diff;
     FILE	*fd;
     int		ok;
+    int		io_error = FALSE;
 
     /* Delete all diffblocks. */
     diff_clear(curtab);
@@ -697,18 +701,26 @@
     {
 	ok = FALSE;
 	fd = mch_fopen((char *)tmp_orig, "w");
-	if (fd != NULL)
+	if (fd == NULL)
+	    io_error = TRUE;
+	else
 	{
-	    fwrite("line1\n", (size_t)6, (size_t)1, fd);
+	    if (fwrite("line1\n", (size_t)6, (size_t)1, fd) != 1)
+		io_error = TRUE;
 	    fclose(fd);
 	    fd = mch_fopen((char *)tmp_new, "w");
-	    if (fd != NULL)
+	    if (fd == NULL)
+		io_error = TRUE;
+	    else
 	    {
-		fwrite("line2\n", (size_t)6, (size_t)1, fd);
+		if (fwrite("line2\n", (size_t)6, (size_t)1, fd) != 1)
+		    io_error = TRUE;
 		fclose(fd);
 		diff_file(tmp_orig, tmp_new, tmp_diff);
 		fd = mch_fopen((char *)tmp_diff, "r");
-		if (fd != NULL)
+		if (fd == NULL)
+		    io_error = TRUE;
+		else
 		{
 		    char_u	linebuf[LBUFLEN];
 
@@ -761,6 +773,8 @@
     }
     if (!ok)
     {
+	if (io_error)
+	    EMSG(_("E810: Cannot read or write temp files"));
 	EMSG(_("E97: Cannot create diffs"));
 	diff_a_works = MAYBE;
 #if defined(MSWIN) || defined(MSDOS)
@@ -812,6 +826,7 @@
     char_u	*tmp_diff;
 {
     char_u	*cmd;
+    size_t	len;
 
 #ifdef FEAT_EVAL
     if (*p_dex != NUL)
@@ -820,8 +835,9 @@
     else
 #endif
     {
-	cmd = alloc((unsigned)(STRLEN(tmp_orig) + STRLEN(tmp_new)
-				+ STRLEN(tmp_diff) + STRLEN(p_srr) + 27));
+	len = STRLEN(tmp_orig) + STRLEN(tmp_new)
+				      + STRLEN(tmp_diff) + STRLEN(p_srr) + 27;
+	cmd = alloc((unsigned)len);
 	if (cmd != NULL)
 	{
 	    /* We don't want $DIFF_OPTIONS to get in the way. */
@@ -831,7 +847,7 @@
 	    /* Build the diff command and execute it.  Always use -a, binary
 	     * differences are of no use.  Ignore errors, diff returns
 	     * non-zero when differences have been found. */
-	    sprintf((char *)cmd, "diff %s%s%s%s%s %s",
+	    vim_snprintf((char *)cmd, len, "diff %s%s%s%s%s %s",
 		    diff_a_works == FALSE ? "" : "-a ",
 #if defined(MSWIN) || defined(MSDOS)
 		    diff_bin_works == TRUE ? "--binary " : "",
@@ -841,7 +857,7 @@
 		    (diff_flags & DIFF_IWHITE) ? "-b " : "",
 		    (diff_flags & DIFF_ICASE) ? "-i " : "",
 		    tmp_orig, tmp_new);
-	    append_redir(cmd, p_srr, tmp_diff);
+	    append_redir(cmd, (int)len, p_srr, tmp_diff);
 #ifdef FEAT_AUTOCMD
 	    block_autocmds();	/* Avoid ShellCmdPost stuff */
 #endif
@@ -866,6 +882,7 @@
     char_u	*tmp_orig;	/* name of original temp file */
     char_u	*tmp_new;	/* name of patched temp file */
     char_u	*buf = NULL;
+    size_t	buflen;
     win_T	*old_curwin = curwin;
     char_u	*newname = NULL;	/* name of patched file buffer */
 #ifdef UNIX
@@ -876,6 +893,7 @@
     char_u	*browseFile = NULL;
     int		browse_flag = cmdmod.browse;
 #endif
+    struct stat st;
 
 #ifdef FEAT_BROWSE
     if (cmdmod.browse)
@@ -905,16 +923,17 @@
     /* Get the absolute path of the patchfile, changing directory below. */
     fullname = FullName_save(eap->arg, FALSE);
 #endif
-    buf = alloc((unsigned)(STRLEN(tmp_orig) + (
+    buflen = STRLEN(tmp_orig) + (
 # ifdef UNIX
 		    fullname != NULL ? STRLEN(fullname) :
 # endif
-		    STRLEN(eap->arg)) + STRLEN(tmp_new) + 16));
+		    STRLEN(eap->arg)) + STRLEN(tmp_new) + 16;
+    buf = alloc((unsigned)buflen);
     if (buf == NULL)
 	goto theend;
 
 #ifdef UNIX
-    /* Temporaraly chdir to /tmp, to avoid patching files in the current
+    /* Temporarily chdir to /tmp, to avoid patching files in the current
      * directory when the patch file contains more than one patch.  When we
      * have our own temp dir use that instead, it will be cleaned up when we
      * exit (any .rej files created).  Don't change directory if we can't
@@ -925,10 +944,10 @@
     {
 # ifdef TEMPDIRNAMES
 	if (vim_tempdir != NULL)
-	    mch_chdir((char *)vim_tempdir);
+	    ignored = mch_chdir((char *)vim_tempdir);
 	else
 # endif
-	    mch_chdir("/tmp");
+	    ignored = mch_chdir("/tmp");
 	shorten_fnames(TRUE);
     }
 #endif
@@ -946,7 +965,8 @@
     {
 	/* Build the patch command and execute it.  Ignore errors.  Switch to
 	 * cooked mode to allow the user to respond to prompts. */
-	sprintf((char *)buf, "patch -o %s %s < \"%s\"", tmp_new, tmp_orig,
+	vim_snprintf((char *)buf, buflen, "patch -o %s %s < \"%s\"",
+		tmp_new, tmp_orig,
 # ifdef UNIX
 		fullname != NULL ? fullname :
 # endif
@@ -980,44 +1000,51 @@
     STRCAT(buf, ".rej");
     mch_remove(buf);
 
-    if (curbuf->b_fname != NULL)
+    /* Only continue if the output file was created. */
+    if (mch_stat((char *)tmp_new, &st) < 0 || st.st_size == 0)
+	EMSG(_("E816: Cannot read patch output"));
+    else
     {
-	newname = vim_strnsave(curbuf->b_fname,
+	if (curbuf->b_fname != NULL)
+	{
+	    newname = vim_strnsave(curbuf->b_fname,
 					  (int)(STRLEN(curbuf->b_fname) + 4));
-	if (newname != NULL)
-	    STRCAT(newname, ".new");
-    }
+	    if (newname != NULL)
+		STRCAT(newname, ".new");
+	}
 
 #ifdef FEAT_GUI
-    need_mouse_correct = TRUE;
+	need_mouse_correct = TRUE;
 #endif
-    /* don't use a new tab page, each tab page has its own diffs */
-    cmdmod.tab = 0;
+	/* don't use a new tab page, each tab page has its own diffs */
+	cmdmod.tab = 0;
 
-    if (win_split(0, (diff_flags & DIFF_VERTICAL) ? WSP_VERT : 0) != FAIL)
-    {
-	/* Pretend it was a ":split fname" command */
-	eap->cmdidx = CMD_split;
-	eap->arg = tmp_new;
-	do_exedit(eap, old_curwin);
-
-	if (curwin != old_curwin)		/* split must have worked */
+	if (win_split(0, (diff_flags & DIFF_VERTICAL) ? WSP_VERT : 0) != FAIL)
 	{
-	    /* Set 'diff', 'scrollbind' on and 'wrap' off. */
-	    diff_win_options(curwin, TRUE);
-	    diff_win_options(old_curwin, TRUE);
+	    /* Pretend it was a ":split fname" command */
+	    eap->cmdidx = CMD_split;
+	    eap->arg = tmp_new;
+	    do_exedit(eap, old_curwin);
 
-	    if (newname != NULL)
+	    /* check that split worked and editing tmp_new */
+	    if (curwin != old_curwin && win_valid(old_curwin))
 	    {
-		/* do a ":file filename.new" on the patched buffer */
-		eap->arg = newname;
-		ex_file(eap);
+		/* Set 'diff', 'scrollbind' on and 'wrap' off. */
+		diff_win_options(curwin, TRUE);
+		diff_win_options(old_curwin, TRUE);
+
+		if (newname != NULL)
+		{
+		    /* do a ":file filename.new" on the patched buffer */
+		    eap->arg = newname;
+		    ex_file(eap);
 
 #ifdef FEAT_AUTOCMD
-		/* Do filetype detection with the new name. */
-		if (au_has_group((char_u *)"filetypedetect"))
-		    do_cmdline_cmd((char_u *)":doau filetypedetect BufRead");
+		    /* Do filetype detection with the new name. */
+		    if (au_has_group((char_u *)"filetypedetect"))
+			do_cmdline_cmd((char_u *)":doau filetypedetect BufRead");
 #endif
+		}
 	    }
 	}
     }
@@ -1074,10 +1101,9 @@
 /*
  * Set options to show difs for the current window.
  */
-/*ARGSUSED*/
     void
 ex_diffthis(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     /* Set 'diff', 'scrollbind' on and 'wrap' off. */
     diff_win_options(curwin, TRUE);
@@ -1138,7 +1164,7 @@
 
     for (wp = firstwin; wp != NULL; wp = wp->w_next)
     {
-	if (wp == curwin || eap->forceit)
+	if (wp == curwin || (eap->forceit && wp->w_p_diff))
 	{
 	    /* Set 'diff', 'scrollbind' off and 'wrap' on. */
 	    wp->w_p_diff = FALSE;
@@ -2114,6 +2140,8 @@
 	    EMSG2(_("E102: Can't find buffer \"%s\""), eap->arg);
 	    return;
 	}
+	if (buf == curbuf)
+	    return;		/* nothing to do */
 	idx_other = diff_buf_idx(buf);
 	if (idx_other == DB_COUNT)
 	{
diff -Naur vim72.orig/src/digraph.c vim72/src/digraph.c
--- vim72.orig/src/digraph.c	2008-06-23 22:12:51.000000000 +0100
+++ vim72/src/digraph.c	2009-07-22 22:54:21.000000000 +0100
@@ -32,7 +32,7 @@
 static void printdigraph __ARGS((digr_T *));
 
 /* digraphs added by the user */
-static garray_T	user_digraphs = {0, 0, sizeof(digr_T), 10, NULL};
+static garray_T	user_digraphs = {0, 0, (int)sizeof(digr_T), 10, NULL};
 
 /*
  * Note: Characters marked with XX are not included literally, because some
@@ -2371,10 +2371,10 @@
 	}
 	else
 #endif
-	    *p++ = dp->result;
+	    *p++ = (char_u)dp->result;
 	if (char2cells(dp->result) == 1)
 	    *p++ = ' ';
-	sprintf((char *)p, " %3d", dp->result);
+	vim_snprintf((char *)p, sizeof(buf) - (p - buf), " %3d", dp->result);
 	msg_outtrans(buf);
     }
 }
@@ -2395,7 +2395,10 @@
 static void keymap_unload __ARGS((void));
 
 /*
- * Set up key mapping tables for the 'keymap' option
+ * Set up key mapping tables for the 'keymap' option.
+ * Returns NULL if OK, an error message for failure.  This only needs to be
+ * used when setting the option, not later when the value has already been
+ * checked.
  */
     char_u *
 keymap_init()
@@ -2412,25 +2415,29 @@
     else
     {
 	char_u	*buf;
+	size_t  buflen;
 
 	/* Source the keymap file.  It will contain a ":loadkeymap" command
 	 * which will call ex_loadkeymap() below. */
-	buf = alloc((unsigned)(STRLEN(curbuf->b_p_keymap)
+	buflen = STRLEN(curbuf->b_p_keymap)
 # ifdef FEAT_MBYTE
-						       + STRLEN(p_enc)
+					   + STRLEN(p_enc)
 # endif
-						       + 14));
+						       + 14;
+	buf = alloc((unsigned)buflen);
 	if (buf == NULL)
 	    return e_outofmem;
 
 # ifdef FEAT_MBYTE
 	/* try finding "keymap/'keymap'_'encoding'.vim"  in 'runtimepath' */
-	sprintf((char *)buf, "keymap/%s_%s.vim", curbuf->b_p_keymap, p_enc);
+	vim_snprintf((char *)buf, buflen, "keymap/%s_%s.vim",
+						   curbuf->b_p_keymap, p_enc);
 	if (source_runtime(buf, FALSE) == FAIL)
 # endif
 	{
 	    /* try finding "keymap/'keymap'.vim" in 'runtimepath'  */
-	    sprintf((char *)buf, "keymap/%s.vim", curbuf->b_p_keymap);
+	    vim_snprintf((char *)buf, buflen, "keymap/%s.vim",
+							  curbuf->b_p_keymap);
 	    if (source_runtime(buf, FALSE) == FAIL)
 	    {
 		vim_free(buf);
diff -Naur vim72.orig/src/edit.c vim72/src/edit.c
--- vim72.orig/src/edit.c	2008-08-06 13:51:17.000000000 +0100
+++ vim72/src/edit.c	2009-07-22 22:54:23.000000000 +0100
@@ -57,7 +57,7 @@
     N_(" Keyword Local completion (^N^P)"),
 };
 
-static char_u e_hitend[] = N_("Hit end of paragraph");
+static char e_hitend[] = N_("Hit end of paragraph");
 
 /*
  * Structure used to store one match for insert completion.
@@ -114,6 +114,10 @@
  * FALSE the word to be completed must be located. */
 static int	  compl_started = FALSE;
 
+/* Set when doing something for completion that may call edit() recursively,
+ * which is not allowed. */
+static int	  compl_busy = FALSE;
+
 static int	  compl_matches = 0;
 static char_u	  *compl_pattern = NULL;
 static int	  compl_direction = FORWARD;
@@ -147,6 +151,7 @@
 static int  ins_compl_bs __ARGS((void));
 static void ins_compl_new_leader __ARGS((void));
 static void ins_compl_addleader __ARGS((int c));
+static int ins_compl_len __ARGS((void));
 static void ins_compl_restart __ARGS((void));
 static void ins_compl_set_original_text __ARGS((char_u *str));
 static void ins_compl_addfrommatch __ARGS((void));
@@ -164,7 +169,7 @@
 static int  ins_compl_key2count __ARGS((int c));
 static int  ins_compl_use_match __ARGS((int c));
 static int  ins_complete __ARGS((int c));
-static int  quote_meta __ARGS((char_u *dest, char_u *str, int len));
+static unsigned  quote_meta __ARGS((char_u *dest, char_u *str, int len));
 #endif /* FEAT_INS_EXPAND */
 
 #define BACKSPACE_CHAR		    1
@@ -197,7 +202,8 @@
 static void mb_replace_pop_ins __ARGS((int cc));
 #endif
 static void replace_flush __ARGS((void));
-static void replace_do_bs __ARGS((void));
+static void replace_do_bs __ARGS((int limit_col));
+static int del_char_after_col __ARGS((int limit_col));
 #ifdef FEAT_CINDENT
 static int cindent_on __ARGS((void));
 #endif
@@ -304,7 +310,7 @@
     int		c = 0;
     char_u	*ptr;
     int		lastc;
-    colnr_T	mincol;
+    int		mincol;
     static linenr_T o_lnum = 0;
     int		i;
     int		did_backspace = TRUE;	    /* previous char was backspace */
@@ -344,7 +350,7 @@
 
 #ifdef FEAT_INS_EXPAND
     /* Don't allow recursive insert mode when busy with completion. */
-    if (compl_started || pum_visible())
+    if (compl_started || compl_busy || pum_visible())
     {
 	EMSG(_(e_secure));
 	return FALSE;
@@ -385,7 +391,7 @@
 	if (startln)
 	    Insstart.col = 0;
     }
-    Insstart_textlen = linetabsize(ml_get_curline());
+    Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());
     Insstart_blank_vcol = MAXCOL;
     if (!did_ai)
 	ai_col = 0;
@@ -651,7 +657,7 @@
 	    mincol = curwin->w_wcol;
 	    validate_cursor_col();
 
-	    if ((int)curwin->w_wcol < (int)mincol - curbuf->b_p_ts
+	    if ((int)curwin->w_wcol < mincol - curbuf->b_p_ts
 		    && curwin->w_wrow == W_WINROW(curwin)
 						 + curwin->w_height - 1 - p_so
 		    && (curwin->w_cursor.lnum != curwin->w_topline
@@ -751,7 +757,7 @@
 		 * there is nothing to add, CTRL-L works like CTRL-P then. */
 		if (c == Ctrl_L
 			&& (ctrl_x_mode != CTRL_X_WHOLE_LINE
-			    || STRLEN(compl_shown_match->cp_str)
+			    || (int)STRLEN(compl_shown_match->cp_str)
 					  > curwin->w_cursor.col - compl_col))
 		{
 		    ins_compl_addfrommatch();
@@ -1338,8 +1344,10 @@
 		goto normalchar;
 
 docomplete:
+	    compl_busy = TRUE;
 	    if (ins_complete(c) == FAIL)
 		compl_cont_status = 0;
+	    compl_busy = FALSE;
 	    break;
 #endif /* FEAT_INS_EXPAND */
 
@@ -1441,10 +1449,9 @@
  * Only redraw when there are no characters available.  This speeds up
  * inserting sequences of characters (e.g., for CTRL-R).
  */
-/*ARGSUSED*/
     static void
 ins_redraw(ready)
-    int		ready;	    /* not busy with something */
+    int		ready UNUSED;	    /* not busy with something */
 {
     if (!char_avail())
     {
@@ -1771,7 +1778,7 @@
 	 * Compute the screen column where the cursor should be.
 	 */
 	vcol = get_indent() - vcol;
-	curwin->w_virtcol = (vcol < 0) ? 0 : vcol;
+	curwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);
 
 	/*
 	 * Advance the cursor until we reach the right screen column.
@@ -1798,9 +1805,9 @@
 	 */
 	if (vcol != (int)curwin->w_virtcol)
 	{
-	    curwin->w_cursor.col = new_cursor_col;
+	    curwin->w_cursor.col = (colnr_T)new_cursor_col;
 	    i = (int)curwin->w_virtcol - vcol;
-	    ptr = alloc(i + 1);
+	    ptr = alloc((unsigned)(i + 1));
 	    if (ptr != NULL)
 	    {
 		new_cursor_col += i;
@@ -1824,7 +1831,7 @@
     if (new_cursor_col <= 0)
 	curwin->w_cursor.col = 0;
     else
-	curwin->w_cursor.col = new_cursor_col;
+	curwin->w_cursor.col = (colnr_T)new_cursor_col;
     curwin->w_set_curswant = TRUE;
     changed_cline_bef_curs();
 
@@ -1933,6 +1940,8 @@
 /*
  * Backspace the cursor until the given column.  Handles REPLACE and VREPLACE
  * modes correctly.  May also be used when not in insert mode at all.
+ * Will attempt not to go before "col" even when there is a composing
+ * character.
  */
     void
 backspace_until_column(col)
@@ -1942,13 +1951,49 @@
     {
 	curwin->w_cursor.col--;
 	if (State & REPLACE_FLAG)
-	    replace_do_bs();
-	else
-	    (void)del_char(FALSE);
+	    replace_do_bs(col);
+	else if (!del_char_after_col(col))
+	    break;
     }
 }
 #endif
 
+/*
+ * Like del_char(), but make sure not to go before column "limit_col".
+ * Only matters when there are composing characters.
+ * Return TRUE when something was deleted.
+ */
+   static int
+del_char_after_col(limit_col)
+    int limit_col UNUSED;
+{
+#ifdef FEAT_MBYTE
+    if (enc_utf8 && limit_col >= 0)
+    {
+	colnr_T ecol = curwin->w_cursor.col + 1;
+
+	/* Make sure the cursor is at the start of a character, but
+	 * skip forward again when going too far back because of a
+	 * composing character. */
+	mb_adjust_cursor();
+	while (curwin->w_cursor.col < (colnr_T)limit_col)
+	{
+	    int l = utf_ptr2len(ml_get_cursor());
+
+	    if (l == 0)  /* end of line */
+		break;
+	    curwin->w_cursor.col += l;
+	}
+	if (*ml_get_cursor() == NUL || curwin->w_cursor.col == ecol)
+	    return FALSE;
+	del_bytes((long)((int)ecol - curwin->w_cursor.col), FALSE, TRUE);
+    }
+    else
+#endif
+	(void)del_char(FALSE);
+    return TRUE;
+}
+
 #if defined(FEAT_INS_EXPAND) || defined(PROTO)
 /*
  * CTRL-X pressed in Insert mode.
@@ -2160,7 +2205,7 @@
 	    actual_compl_length = compl_length;
 
 	/* Allocate wide character array for the completion and fill it. */
-	wca = (int *)alloc(actual_len * sizeof(int));
+	wca = (int *)alloc((unsigned)(actual_len * sizeof(int)));
 	if (wca != NULL)
 	{
 	    p = str;
@@ -2418,7 +2463,7 @@
 	{
 	    had_match = (curwin->w_cursor.col > compl_col);
 	    ins_compl_delete();
-	    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+	    ins_bytes(compl_leader + ins_compl_len());
 	    ins_redraw(FALSE);
 
 	    /* When the match isn't there (to avoid matching itself) remove it
@@ -2470,7 +2515,7 @@
 	    *p = NUL;
 	    had_match = (curwin->w_cursor.col > compl_col);
 	    ins_compl_delete();
-	    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+	    ins_bytes(compl_leader + ins_compl_len());
 	    ins_redraw(FALSE);
 
 	    /* When the match isn't there (to avoid matching itself) remove it
@@ -2539,7 +2584,7 @@
  */
     void
 set_completion(startcol, list)
-    int	    startcol;
+    colnr_T startcol;
     list_T  *list;
 {
     /* If already doing completions stop it. */
@@ -2550,10 +2595,10 @@
     if (stop_arrow() == FAIL)
 	return;
 
-    if (startcol > (int)curwin->w_cursor.col)
+    if (startcol > curwin->w_cursor.col)
 	startcol = curwin->w_cursor.col;
     compl_col = startcol;
-    compl_length = curwin->w_cursor.col - startcol;
+    compl_length = (int)curwin->w_cursor.col - (int)startcol;
     /* compl_pattern doesn't need to be set */
     compl_orig_text = vim_strnsave(ml_get_curline() + compl_col, compl_length);
     if (compl_orig_text == NULL || ins_compl_add(compl_orig_text,
@@ -2819,7 +2864,6 @@
     regmatch_T	regmatch;
     char_u	**files;
     int		count;
-    int		i;
     int		save_p_scs;
     int		dir = compl_direction;
 
@@ -2851,17 +2895,18 @@
     if (ctrl_x_mode == CTRL_X_WHOLE_LINE)
     {
 	char_u *pat_esc = vim_strsave_escaped(pat, (char_u *)"\\");
+	size_t len;
 
 	if (pat_esc == NULL)
 	    goto theend;
-	i = (int)STRLEN(pat_esc) + 10;
-	ptr = alloc(i);
+	len = STRLEN(pat_esc) + 10;
+	ptr = alloc((unsigned)len);
 	if (ptr == NULL)
 	{
 	    vim_free(pat_esc);
 	    goto theend;
 	}
-	vim_snprintf((char *)ptr, i, "^\\s*\\zs\\V%s", pat_esc);
+	vim_snprintf((char *)ptr, len, "^\\s*\\zs\\V%s", pat_esc);
 	regmatch.regprog = vim_regcomp(ptr, RE_MAGIC);
 	vim_free(pat_esc);
 	vim_free(ptr);
@@ -2952,7 +2997,7 @@
 	{
 	    vim_snprintf((char *)IObuff, IOSIZE,
 			      _("Scanning dictionary: %s"), (char *)files[i]);
-	    msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
+	    (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
 	}
 
 	if (fp != NULL)
@@ -3133,6 +3178,7 @@
 	vim_free(match);
     } while (compl_curr_match != NULL && compl_curr_match != compl_first_match);
     compl_first_match = compl_curr_match = NULL;
+    compl_shown_match = NULL;
 }
 
     static void
@@ -3209,7 +3255,7 @@
 {
     ins_compl_del_pum();
     ins_compl_delete();
-    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+    ins_bytes(compl_leader + ins_compl_len());
     compl_used_match = FALSE;
 
     if (compl_started)
@@ -3264,6 +3310,20 @@
 }
 
 /*
+ * Return the length of the completion, from the completion start column to
+ * the cursor column.  Making sure it never goes below zero.
+ */
+    static int
+ins_compl_len()
+{
+    int off = (int)curwin->w_cursor.col - (int)compl_col;
+
+    if (off < 0)
+	return 0;
+    return off;
+}
+
+/*
  * Append one character to the match leader.  May reduce the number of
  * matches.
  */
@@ -3292,7 +3352,7 @@
 
     vim_free(compl_leader);
     compl_leader = vim_strnsave(ml_get_curline() + compl_col,
-					    curwin->w_cursor.col - compl_col);
+				     (int)(curwin->w_cursor.col - compl_col));
     if (compl_leader != NULL)
 	ins_compl_new_leader();
 }
@@ -3340,7 +3400,7 @@
 ins_compl_addfrommatch()
 {
     char_u	*p;
-    int		len = curwin->w_cursor.col - compl_col;
+    int		len = (int)curwin->w_cursor.col - (int)compl_col;
     int		c;
     compl_T	*cp;
 
@@ -3621,10 +3681,9 @@
 	    {
 		ins_compl_delete();
 		if (compl_leader != NULL)
-		    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+		    ins_bytes(compl_leader + ins_compl_len());
 		else if (compl_first_match != NULL)
-		    ins_bytes(compl_orig_text
-					  + curwin->w_cursor.col - compl_col);
+		    ins_bytes(compl_orig_text + ins_compl_len());
 		retval = TRUE;
 	    }
 
@@ -3907,7 +3966,7 @@
 			    : ins_buf->b_sfname == NULL
 				? (char *)ins_buf->b_fname
 				: (char *)ins_buf->b_sfname);
-		msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
+		(void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
 	    }
 	    else if (*e_cpt == NUL)
 		break;
@@ -3936,8 +3995,8 @@
 		else if (*e_cpt == ']' || *e_cpt == 't')
 		{
 		    type = CTRL_X_TAGS;
-		    sprintf((char*)IObuff, _("Scanning tags."));
-		    msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
+		    vim_snprintf((char *)IObuff, IOSIZE, _("Scanning tags."));
+		    (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
 		}
 		else
 		    type = -1;
@@ -4035,7 +4094,7 @@
 	case CTRL_X_SPELL:
 #ifdef FEAT_SPELL
 	    num_matches = expand_spelling(first_match_pos.lnum,
-				 first_match_pos.col, compl_pattern, &matches);
+						     compl_pattern, &matches);
 	    if (num_matches > 0)
 		ins_compl_add_matches(num_matches, matches, p_ic);
 #endif
@@ -4187,7 +4246,7 @@
 	}
 
 	/* check if compl_curr_match has changed, (e.g. other type of
-	 * expansion added somenthing) */
+	 * expansion added something) */
 	if (type != 0 && compl_curr_match != old_match)
 	    found_new_match = OK;
 
@@ -4256,7 +4315,7 @@
     static void
 ins_compl_insert()
 {
-    ins_bytes(compl_shown_match->cp_str + curwin->w_cursor.col - compl_col);
+    ins_bytes(compl_shown_match->cp_str + ins_compl_len());
     if (compl_shown_match->cp_flags & ORIGINAL_TEXT)
 	compl_used_match = FALSE;
     else
@@ -4425,7 +4484,7 @@
 	if (!compl_get_longest || compl_used_match)
 	    ins_compl_insert();
 	else
-	    ins_bytes(compl_leader + curwin->w_cursor.col - compl_col);
+	    ins_bytes(compl_leader + ins_compl_len());
     }
     else
 	compl_used_match = FALSE;
@@ -4688,7 +4747,7 @@
 		}
 		compl_length = curwin->w_cursor.col - (int)compl_col;
 		/* IObuff is used to add a "word from the next line" would we
-		 * have enough space?  just being paranoic */
+		 * have enough space?  just being paranoid */
 #define	MIN_SPACE 75
 		if (compl_length > (IOSIZE - MIN_SPACE))
 		{
@@ -4745,10 +4804,9 @@
 	    {
 		char_u	    *prefix = (char_u *)"\\<";
 
-		/* we need 3 extra chars, 1 for the NUL and
-		 * 2 >= strlen(prefix)	-- Acevedo */
+		/* we need up to 2 extra chars for the prefix */
 		compl_pattern = alloc(quote_meta(NULL, line + compl_col,
-							   compl_length) + 3);
+							   compl_length) + 2);
 		if (compl_pattern == NULL)
 		    return FAIL;
 		if (!vim_iswordp(line + compl_col)
@@ -4823,7 +4881,7 @@
 		else
 		{
 		    compl_pattern = alloc(quote_meta(NULL, line + compl_col,
-							   compl_length) + 3);
+							   compl_length) + 2);
 		    if (compl_pattern == NULL)
 			return FAIL;
 		    STRCPY((char *)compl_pattern, "\\<");
@@ -4905,7 +4963,7 @@
 	    if (col < 0)
 		col = curs_col;
 	    compl_col = col;
-	    if ((colnr_T)compl_col > curs_col)
+	    if (compl_col > curs_col)
 		compl_col = curs_col;
 
 	    /* Setup variables for completion.  Need to obtain "line" again,
@@ -5178,15 +5236,15 @@
  * a backslash) the metachars, and dest would be NUL terminated.
  * Returns the length (needed) of dest
  */
-    static int
+    static unsigned
 quote_meta(dest, src, len)
     char_u	*dest;
     char_u	*src;
     int		len;
 {
-    int	m;
+    unsigned	m = (unsigned)len + 1;  /* one extra for the NUL */
 
-    for (m = len; --len >= 0; src++)
+    for ( ; --len >= 0; src++)
     {
 	switch (*src)
 	{
@@ -6015,7 +6073,7 @@
      * in 'formatoptions' and there is a single character before the cursor.
      * Otherwise the line would be broken and when typing another non-white
      * next they are not joined back together. */
-    wasatend = (pos.col == STRLEN(old));
+    wasatend = (pos.col == (colnr_T)STRLEN(old));
     if (*old != NUL && !trailblank && wasatend)
     {
 	dec_cursor();
@@ -6192,7 +6250,7 @@
      * three digits. */
     if (VIM_ISDIGIT(c))
     {
-	sprintf((char *)buf, "%03d", c);
+	vim_snprintf((char *)buf, sizeof(buf), "%03d", c);
 	AppendToRedobuff(buf);
     }
     else
@@ -6266,7 +6324,7 @@
 	    ins_need_undo = FALSE;
 	}
 	Insstart = curwin->w_cursor;	/* new insertion starts here */
-	Insstart_textlen = linetabsize(ml_get_curline());
+	Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());
 	ai_col = 0;
 #ifdef FEAT_VREPLACE
 	if (State & VREPLACE_FLAG)
@@ -6369,13 +6427,17 @@
 
 	/* If we just did an auto-indent, remove the white space from the end
 	 * of the line, and put the cursor back.
-	 * Do this when ESC was used or moving the cursor up/down. */
+	 * Do this when ESC was used or moving the cursor up/down.
+	 * Check for the old position still being valid, just in case the text
+	 * got changed unexpectedly. */
 	if (did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL
-			&& curwin->w_cursor.lnum != end_insert_pos->lnum)))
+			&& curwin->w_cursor.lnum != end_insert_pos->lnum))
+		&& end_insert_pos->lnum <= curbuf->b_ml.ml_line_count)
 	{
 	    pos_T	tpos = curwin->w_cursor;
 
 	    curwin->w_cursor = *end_insert_pos;
+	    check_cursor_col();  /* make sure it is not past the line */
 	    for (;;)
 	    {
 		if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)
@@ -6383,7 +6445,8 @@
 		cc = gchar_cursor();
 		if (!vim_iswhite(cc))
 		    break;
-		(void)del_char(TRUE);
+		if (del_char(TRUE) == FAIL)
+		    break;  /* should not happen */
 	    }
 	    if (curwin->w_cursor.lnum != tpos.lnum)
 		curwin->w_cursor = tpos;
@@ -6395,10 +6458,11 @@
 	     * deleted characters. */
 	    if (VIsual_active && VIsual.lnum == curwin->w_cursor.lnum)
 	    {
-		cc = (int)STRLEN(ml_get_curline());
-		if (VIsual.col > (colnr_T)cc)
+		int len = (int)STRLEN(ml_get_curline());
+
+		if (VIsual.col > len)
 		{
-		    VIsual.col = cc;
+		    VIsual.col = len;
 # ifdef FEAT_VIRTUALEDIT
 		    VIsual.coladd = 0;
 # endif
@@ -7123,9 +7187,12 @@
  * cc == 0: character was inserted, delete it
  * cc > 0: character was replaced, put cc (first byte of original char) back
  * and check for more characters to be put back
+ * When "limit_col" is >= 0, don't delete before this column.  Matters when
+ * using composing characters, use del_char_after_col() instead of del_char().
  */
     static void
-replace_do_bs()
+replace_do_bs(limit_col)
+    int		limit_col;
 {
     int		cc;
 #ifdef FEAT_VREPLACE
@@ -7153,7 +7220,7 @@
 #ifdef FEAT_MBYTE
 	if (has_mbyte)
 	{
-	    del_char(FALSE);
+	    (void)del_char_after_col(limit_col);
 # ifdef FEAT_VREPLACE
 	    if (State & VREPLACE_FLAG)
 		orig_len = (int)STRLEN(ml_get_cursor());
@@ -7203,7 +7270,7 @@
 	changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);
     }
     else if (cc == 0)
-	(void)del_char(FALSE);
+	(void)del_char_after_col(limit_col);
 }
 
 #ifdef FEAT_CINDENT
@@ -7646,9 +7713,7 @@
      */
     ++no_mapping;
     regname = plain_vgetc();
-#ifdef FEAT_LANGMAP
     LANGMAP_ADJUST(regname, TRUE);
-#endif
     if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P)
     {
 	/* Get a third key for literal register insertion */
@@ -7657,9 +7722,7 @@
 	add_to_showcmd_c(literally);
 #endif
 	regname = plain_vgetc();
-#ifdef FEAT_LANGMAP
 	LANGMAP_ADJUST(regname, TRUE);
-#endif
     }
     --no_mapping;
 
@@ -8150,7 +8213,7 @@
 /*
  * If the cursor is on an indent, ^T/^D insert/delete one
  * shiftwidth.	Otherwise ^T/^D behave like a "<<" or ">>".
- * Always round the indent to 'shiftwith', this is compatible
+ * Always round the indent to 'shiftwidth', this is compatible
  * with vi.  But vi only supports ^T and ^D after an
  * autoindent, we support it everywhere.
  */
@@ -8239,7 +8302,7 @@
 	 * Replace mode */
 	if (curwin->w_cursor.lnum != Insstart.lnum
 		|| curwin->w_cursor.col >= Insstart.col)
-	    replace_do_bs();
+	    replace_do_bs(-1);
     }
     else
 	(void)del_char(FALSE);
@@ -8258,6 +8321,7 @@
     linenr_T	lnum;
     int		cc;
     int		temp = 0;	    /* init for GCC */
+    colnr_T	save_col;
     colnr_T	mincol;
     int		did_backspace = FALSE;
     int		in_indent;
@@ -8415,13 +8479,13 @@
 		 */
 		while (cc > 0)
 		{
-		    temp = curwin->w_cursor.col;
+		    save_col = curwin->w_cursor.col;
 #ifdef FEAT_MBYTE
 		    mb_replace_pop_ins(cc);
 #else
 		    ins_char(cc);
 #endif
-		    curwin->w_cursor.col = temp;
+		    curwin->w_cursor.col = save_col;
 		    cc = replace_pop();
 		}
 		/* restore the characters that NL replaced */
@@ -8453,11 +8517,11 @@
 #endif
 			    )
 	{
-	    temp = curwin->w_cursor.col;
+	    save_col = curwin->w_cursor.col;
 	    beginline(BL_WHITE);
 	    if (curwin->w_cursor.col < (colnr_T)temp)
 		mincol = curwin->w_cursor.col;
-	    curwin->w_cursor.col = temp;
+	    curwin->w_cursor.col = save_col;
 	}
 
 	/*
@@ -8556,7 +8620,7 @@
 		break;
 	    }
 	    if (State & REPLACE_FLAG)
-		replace_do_bs();
+		replace_do_bs(-1);
 	    else
 	    {
 #ifdef FEAT_MBYTE
@@ -8931,7 +8995,10 @@
 	foldOpenCursor();
 #endif
     undisplay_dollar();
-    if (gchar_cursor() != NUL || virtual_active()
+    if (gchar_cursor() != NUL
+#ifdef FEAT_VIRTUALEDIT
+	    || virtual_active()
+#endif
 	    )
     {
 	start_arrow(&curwin->w_cursor);
diff -Naur vim72.orig/src/eval.c vim72/src/eval.c
--- vim72.orig/src/eval.c	2008-08-07 20:37:22.000000000 +0100
+++ vim72/src/eval.c	2009-07-22 22:54:22.000000000 +0100
@@ -32,6 +32,9 @@
 
 #define DICT_MAXNEST 100	/* maximum nesting of lists and dicts */
 
+#define DO_NOT_FREE_CNT 99999	/* refcount for dict or list that should not
+				   be freed. */
+
 /*
  * In a hashtab item "hi_key" points to "di_key" in a dictitem.
  * This avoids adding a pointer to the hashtab item.
@@ -126,8 +129,11 @@
 /*
  * When recursively copying lists and dicts we need to remember which ones we
  * have done to avoid endless recursiveness.  This unique ID is used for that.
+ * The last bit is used for previous_funccal, ignored when comparing.
  */
 static int current_copyID = 0;
+#define COPYID_INC 2
+#define COPYID_MASK (~0x1)
 
 /*
  * Array to hold the hashtab with variables local to each sourced script.
@@ -280,7 +286,7 @@
 #define VV_RO		2	/* read-only */
 #define VV_RO_SBX	4	/* read-only in the sandbox */
 
-#define VV_NAME(s, t)	s, {{t}}, {0}
+#define VV_NAME(s, t)	s, {{t, 0, {0}}, 0, {0}}, {0}
 
 static struct vimvar
 {
@@ -348,6 +354,7 @@
     {VV_NAME("mouse_col",	 VAR_NUMBER), 0},
     {VV_NAME("operator",	 VAR_STRING), VV_RO},
     {VV_NAME("searchforward",	 VAR_NUMBER), 0},
+    {VV_NAME("oldfiles",	 VAR_LIST), 0},
 };
 
 /* shorthand */
@@ -355,6 +362,7 @@
 #define vv_nr		vv_di.di_tv.vval.v_number
 #define vv_float	vv_di.di_tv.vval.v_float
 #define vv_str		vv_di.di_tv.vval.v_string
+#define vv_list		vv_di.di_tv.vval.v_list
 #define vv_tv		vv_di.di_tv
 
 /*
@@ -426,7 +434,6 @@
 static long list_idx_of_item __ARGS((list_T *l, listitem_T *item));
 static void list_append __ARGS((list_T *l, listitem_T *item));
 static int list_append_tv __ARGS((list_T *l, typval_T *tv));
-static int list_append_string __ARGS((list_T *l, char_u *str, int len));
 static int list_append_number __ARGS((list_T *l, varnumber_T n));
 static int list_insert_tv __ARGS((list_T *l, typval_T *tv, listitem_T *item));
 static int list_extend __ARGS((list_T	*l1, list_T *l2, listitem_T *bef));
@@ -435,6 +442,7 @@
 static void list_remove __ARGS((list_T *l, listitem_T *item, listitem_T *item2));
 static char_u *list2string __ARGS((typval_T *tv, int copyID));
 static int list_join __ARGS((garray_T *gap, list_T *l, char_u *sep, int echo, int copyID));
+static int free_unref_items __ARGS((int copyID));
 static void set_ref_in_ht __ARGS((hashtab_T *ht, int copyID));
 static void set_ref_in_list __ARGS((list_T *l, int copyID));
 static void set_ref_in_item __ARGS((typval_T *tv, int copyID));
@@ -788,6 +796,8 @@
 static void func_unref __ARGS((char_u *name));
 static void func_ref __ARGS((char_u *name));
 static void call_user_func __ARGS((ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv, linenr_T firstline, linenr_T lastline, dict_T *selfdict));
+static int can_free_funccal __ARGS((funccall_T *fc, int copyID)) ;
+static void free_funccal __ARGS((funccall_T *fc, int free_val));
 static void add_nr_var __ARGS((dict_T *dp, dictitem_T *v, char *name, varnumber_T nr));
 static win_T *find_win_by_nr __ARGS((typval_T *vp, tabpage_T *tp));
 static void getwinvar __ARGS((typval_T *argvars, typval_T *rettv, int off));
@@ -845,11 +855,17 @@
 	p = &vimvars[i];
 	if (p->vv_di.di_tv.v_type == VAR_STRING)
 	{
-	    vim_free(p->vv_di.di_tv.vval.v_string);
-	    p->vv_di.di_tv.vval.v_string = NULL;
+	    vim_free(p->vv_str);
+	    p->vv_str = NULL;
+	}
+	else if (p->vv_di.di_tv.v_type == VAR_LIST)
+	{
+	    list_unref(p->vv_list);
+	    p->vv_list = NULL;
 	}
     }
     hash_clear(&vimvarht);
+    hash_init(&vimvarht);  /* garbage_collect() will access it */
     hash_clear(&compat_hashtab);
 
     /* script-local variables */
@@ -916,6 +932,10 @@
 /* pointer to funccal for currently active function */
 funccall_T *current_funccal = NULL;
 
+/* pointer to list of previously used funccal, still around because some
+ * item in it is still being used. */
+funccall_T *previous_funccal = NULL;
+
 /*
  * Return TRUE when a function was ended by a ":return" command.
  */
@@ -1256,23 +1276,28 @@
 
 /*
  * Top level evaluation function, returning a string.
+ * When "convert" is TRUE convert a List into a sequence of lines and convert
+ * a Float to a String.
  * Return pointer to allocated memory, or NULL for failure.
  */
     char_u *
-eval_to_string(arg, nextcmd, dolist)
+eval_to_string(arg, nextcmd, convert)
     char_u	*arg;
     char_u	**nextcmd;
-    int		dolist;		/* turn List into sequence of lines */
+    int		convert;
 {
     typval_T	tv;
     char_u	*retval;
     garray_T	ga;
+#ifdef FEAT_FLOAT
+    char_u	numbuf[NUMBUFLEN];
+#endif
 
     if (eval0(arg, &tv, nextcmd, TRUE) == FAIL)
 	retval = NULL;
     else
     {
-	if (dolist && tv.v_type == VAR_LIST)
+	if (convert && tv.v_type == VAR_LIST)
 	{
 	    ga_init2(&ga, (int)sizeof(char), 80);
 	    if (tv.vval.v_list != NULL)
@@ -1280,6 +1305,13 @@
 	    ga_append(&ga, NUL);
 	    retval = (char_u *)ga.ga_data;
 	}
+#ifdef FEAT_FLOAT
+	else if (convert && tv.v_type == VAR_FLOAT)
+	{
+	    vim_snprintf((char *)numbuf, NUMBUFLEN, "%g", tv.vval.v_float);
+	    retval = vim_strsave(numbuf);
+	}
+#endif
 	else
 	    retval = vim_strsave(get_tv_string(&tv));
 	clear_tv(&tv);
@@ -3277,7 +3309,7 @@
 
     if (*startarg != '(')
     {
-	EMSG2(_("E107: Missing braces: %s"), eap->arg);
+	EMSG2(_("E107: Missing parentheses: %s"), eap->arg);
 	goto end;
     }
 
@@ -3657,8 +3689,8 @@
 }
 
 /*
- * Return TRUE if typeval "tv" is locked: Either tha value is locked itself or
- * it refers to a List or Dictionary that is locked.
+ * Return TRUE if typeval "tv" is locked: Either that value is locked itself
+ * or it refers to a List or Dictionary that is locked.
  */
     static int
 tv_islocked(tv)
@@ -3744,7 +3776,6 @@
  * Function given to ExpandGeneric() to obtain the list of user defined
  * (global/buffer/window/built-in) variable names.
  */
-/*ARGSUSED*/
     char_u *
 get_user_var_name(xp, idx)
     expand_T	*xp;
@@ -3902,7 +3933,7 @@
 
 /*
  * Handle top level expression:
- *	expr1 ? expr0 : expr0
+ *	expr2 ? expr1 : expr1
  *
  * "arg" must point to the first non-white of the expression.
  * "arg" is advanced to the next non-white after the recognized expression.
@@ -5835,7 +5866,7 @@
     return item1 == NULL && item2 == NULL;
 }
 
-#if defined(FEAT_PYTHON) || defined(PROTO)
+#if defined(FEAT_PYTHON) || defined(FEAT_MZSCHEME) || defined(PROTO)
 /*
  * Return the dictitem that an entry in a hashtable points to.
  */
@@ -6047,6 +6078,25 @@
 }
 
 /*
+ * Get list item "l[idx - 1]" as a string.  Returns NULL for failure.
+ */
+    char_u *
+list_find_str(l, idx)
+    list_T	*l;
+    long	idx;
+{
+    listitem_T	*li;
+
+    li = list_find(l, idx - 1);
+    if (li == NULL)
+    {
+	EMSGN(_(e_listidx), idx);
+	return NULL;
+    }
+    return get_tv_string(&li->li_tv);
+}
+
+/*
  * Locate "item" list "l" and return its index.
  * Returns -1 when "item" is not in the list.
  */
@@ -6137,7 +6187,7 @@
  * When "len" >= 0 use "str[len]".
  * Returns FAIL when out of memory.
  */
-    static int
+    int
 list_append_string(l, str, len)
     list_T	*l;
     char_u	*str;
@@ -6448,14 +6498,13 @@
     int
 garbage_collect()
 {
-    dict_T	*dd;
-    list_T	*ll;
-    int		copyID = ++current_copyID;
+    int		copyID;
     buf_T	*buf;
     win_T	*wp;
     int		i;
-    funccall_T	*fc;
-    int		did_free = FALSE;
+    funccall_T	*fc, **pfc;
+    int		did_free;
+    int		did_free_funccal = FALSE;
 #ifdef FEAT_WINDOWS
     tabpage_T	*tp;
 #endif
@@ -6465,10 +6514,25 @@
     may_garbage_collect = FALSE;
     garbage_collect_at_exit = FALSE;
 
+    /* We advance by two because we add one for items referenced through
+     * previous_funccal. */
+    current_copyID += COPYID_INC;
+    copyID = current_copyID;
+
     /*
      * 1. Go through all accessible variables and mark all lists and dicts
      *    with copyID.
      */
+
+    /* Don't free variables in the previous_funccal list unless they are only
+     * referenced through previous_funccal.  This must be first, because if
+     * the item is referenced elsewhere the funccal must not be freed. */
+    for (fc = previous_funccal; fc != NULL; fc = fc->caller)
+    {
+	set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1);
+	set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID + 1);
+    }
+
     /* script-local variables */
     for (i = 1; i <= ga_scripts.ga_len; ++i)
 	set_ref_in_ht(&SCRIPT_VARS(i), copyID);
@@ -6497,11 +6561,54 @@
 	set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID);
     }
 
+    /* v: vars */
+    set_ref_in_ht(&vimvarht, copyID);
+
+    /*
+     * 2. Free lists and dictionaries that are not referenced.
+     */
+    did_free = free_unref_items(copyID);
+
     /*
-     * 2. Go through the list of dicts and free items without the copyID.
+     * 3. Check if any funccal can be freed now.
+     */
+    for (pfc = &previous_funccal; *pfc != NULL; )
+    {
+	if (can_free_funccal(*pfc, copyID))
+	{
+	    fc = *pfc;
+	    *pfc = fc->caller;
+	    free_funccal(fc, TRUE);
+	    did_free = TRUE;
+	    did_free_funccal = TRUE;
+	}
+	else
+	    pfc = &(*pfc)->caller;
+    }
+    if (did_free_funccal)
+	/* When a funccal was freed some more items might be garbage
+	 * collected, so run again. */
+	(void)garbage_collect();
+
+    return did_free;
+}
+
+/*
+ * Free lists and dictionaries that are no longer referenced.
+ */
+    static int
+free_unref_items(copyID)
+    int copyID;
+{
+    dict_T	*dd;
+    list_T	*ll;
+    int		did_free = FALSE;
+
+    /*
+     * Go through the list of dicts and free items without the copyID.
      */
     for (dd = first_dict; dd != NULL; )
-	if (dd->dv_copyID != copyID)
+	if ((dd->dv_copyID & COPYID_MASK) != (copyID & COPYID_MASK))
 	{
 	    /* Free the Dictionary and ordinary items it contains, but don't
 	     * recurse into Lists and Dictionaries, they will be in the list
@@ -6516,12 +6623,13 @@
 	    dd = dd->dv_used_next;
 
     /*
-     * 3. Go through the list of lists and free items without the copyID.
-     *    But don't free a list that has a watcher (used in a for loop), these
-     *    are not referenced anywhere.
+     * Go through the list of lists and free items without the copyID.
+     * But don't free a list that has a watcher (used in a for loop), these
+     * are not referenced anywhere.
      */
     for (ll = first_list; ll != NULL; )
-	if (ll->lv_copyID != copyID && ll->lv_watch == NULL)
+	if ((ll->lv_copyID & COPYID_MASK) != (copyID & COPYID_MASK)
+						      && ll->lv_watch == NULL)
 	{
 	    /* Free the List and ordinary items it contains, but don't recurse
 	     * into Lists and Dictionaries, they will be in the list of dicts
@@ -6587,7 +6695,7 @@
     {
 	case VAR_DICT:
 	    dd = tv->vval.v_dict;
-	    if (dd->dv_copyID != copyID)
+	    if (dd != NULL && dd->dv_copyID != copyID)
 	    {
 		/* Didn't see this dict yet. */
 		dd->dv_copyID = copyID;
@@ -6597,7 +6705,7 @@
 
 	case VAR_LIST:
 	    ll = tv->vval.v_list;
-	    if (ll->lv_copyID != copyID)
+	    if (ll != NULL && ll->lv_copyID != copyID)
 	    {
 		/* Didn't see this list yet. */
 		ll->lv_copyID = copyID;
@@ -7525,8 +7633,8 @@
     {"getwinposx",	0, 0, f_getwinposx},
     {"getwinposy",	0, 0, f_getwinposy},
     {"getwinvar",	2, 2, f_getwinvar},
-    {"glob",		1, 1, f_glob},
-    {"globpath",	2, 2, f_globpath},
+    {"glob",		1, 2, f_glob},
+    {"globpath",	2, 3, f_globpath},
     {"has",		1, 1, f_has},
     {"has_key",		2, 2, f_has_key},
     {"haslocaldir",	0, 0, f_haslocaldir},
@@ -7723,7 +7831,6 @@
  * Function given to ExpandGeneric() to obtain the list of internal or
  * user defined variable or function names.
  */
-/*ARGSUSED*/
     char_u *
 get_expr_name(xp, idx)
     expand_T	*xp;
@@ -7856,9 +7963,9 @@
     else if (!aborting())
     {
 	if (argcount == MAX_FUNC_ARGS)
-	    emsg_funcname("E740: Too many arguments for function %s", name);
+	    emsg_funcname(N_("E740: Too many arguments for function %s"), name);
 	else
-	    emsg_funcname("E116: Invalid arguments for function %s", name);
+	    emsg_funcname(N_("E116: Invalid arguments for function %s"), name);
     }
 
     while (--argcount >= 0)
@@ -7956,7 +8063,8 @@
     /* execute the function if no errors detected and executing */
     if (evaluate && error == ERROR_NONE)
     {
-	rettv->v_type = VAR_NUMBER;	/* default is number rettv */
+	rettv->v_type = VAR_NUMBER;	/* default rettv is number zero */
+	rettv->vval.v_number = 0;
 	error = ERROR_UNKNOWN;
 
 	if (!builtin_function(fname))
@@ -8091,6 +8199,7 @@
 
 /*
  * Give an error message with a function name.  Handle <SNR> things.
+ * "ermsg" is to be passed without translation, use N_() instead of _().
  */
     static void
 emsg_funcname(ermsg, name)
@@ -8205,7 +8314,6 @@
 		return;
 	    li = l->lv_first;
 	}
-	rettv->vval.v_number = 0;	/* Default: Success */
 	for (;;)
 	{
 	    if (l == NULL)
@@ -8238,10 +8346,9 @@
 /*
  * "argc()" function
  */
-/* ARGSUSED */
     static void
 f_argc(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = ARGCOUNT;
@@ -8250,10 +8357,9 @@
 /*
  * "argidx()" function
  */
-/* ARGSUSED */
     static void
 f_argidx(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = curwin->w_arg_idx;
@@ -8331,10 +8437,9 @@
 /*
  * "browse(save, title, initdir, default)" function
  */
-/* ARGSUSED */
     static void
 f_browse(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_BROWSE
@@ -8366,10 +8471,9 @@
 /*
  * "browsedir(title, initdir)" function
  */
-/* ARGSUSED */
     static void
 f_browsedir(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_BROWSE
@@ -8594,10 +8698,9 @@
 /*
  * "byte2line(byte)" function
  */
-/*ARGSUSED*/
     static void
 f_byte2line(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifndef FEAT_BYTEOFF
@@ -8617,7 +8720,6 @@
 /*
  * "byteidx()" function
  */
-/*ARGSUSED*/
     static void
 f_byteidx(argvars, rettv)
     typval_T	*argvars;
@@ -8665,7 +8767,6 @@
     int		dummy;
     dict_T	*selfdict = NULL;
 
-    rettv->vval.v_number = 0;
     if (argvars[1].v_type != VAR_LIST)
     {
 	EMSG(_(e_listreq));
@@ -8737,10 +8838,9 @@
 /*
  * "changenr()" function
  */
-/*ARGSUSED*/
     static void
 f_changenr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = curbuf->b_u_seq_cur;
@@ -8790,11 +8890,10 @@
 /*
  * "clearmatches()" function
  */
-/*ARGSUSED*/
     static void
 f_clearmatches(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_SEARCH_EXTRA
     clear_matches(curwin);
@@ -8858,11 +8957,10 @@
 /*
  * "complete()" function
  */
-/*ARGSUSED*/
     static void
 f_complete(argvars, rettv)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
 {
     int	    startcol;
 
@@ -8893,7 +8991,6 @@
 /*
  * "complete_add()" function
  */
-/*ARGSUSED*/
     static void
 f_complete_add(argvars, rettv)
     typval_T	*argvars;
@@ -8905,10 +9002,9 @@
 /*
  * "complete_check()" function
  */
-/*ARGSUSED*/
     static void
 f_complete_check(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		saved = RedrawingDisabled;
@@ -8923,11 +9019,10 @@
 /*
  * "confirm(message, buttons[, default [, type]])" function
  */
-/*ARGSUSED*/
     static void
 f_confirm(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
     char_u	*message;
@@ -8973,13 +9068,9 @@
     if (buttons == NULL || *buttons == NUL)
 	buttons = (char_u *)_("&Ok");
 
-    if (error)
-	rettv->vval.v_number = 0;
-    else
+    if (!error)
 	rettv->vval.v_number = do_dialog(type, NULL, message, buttons,
 								   def, NULL);
-#else
-    rettv->vval.v_number = 0;
 #endif
 }
 
@@ -9096,11 +9187,10 @@
  *
  * Checks the existence of a cscope connection.
  */
-/*ARGSUSED*/
     static void
 f_cscope_connection(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_CSCOPE
     int		num = 0;
@@ -9118,17 +9208,15 @@
     }
 
     rettv->vval.v_number = cs_connection(num, dbpath, prepend);
-#else
-    rettv->vval.v_number = 0;
 #endif
 }
 
 /*
  * "cursor(lnum, col)" function
  *
- * Moves the cursor to the specified line and column
+ * Moves the cursor to the specified line and column.
+ * Returns 0 when the position could be set, -1 otherwise.
  */
-/*ARGSUSED*/
     static void
 f_cursor(argvars, rettv)
     typval_T	*argvars;
@@ -9139,6 +9227,7 @@
     long	coladd = 0;
 #endif
 
+    rettv->vval.v_number = -1;
     if (argvars[1].v_type == VAR_UNKNOWN)
     {
 	pos_T	    pos;
@@ -9183,6 +9272,7 @@
 #endif
 
     curwin->w_set_curswant = TRUE;
+    rettv->vval.v_number = 0;
 }
 
 /*
@@ -9200,7 +9290,10 @@
     if (noref < 0 || noref > 1)
 	EMSG(_(e_invarg));
     else
-	item_copy(&argvars[0], rettv, TRUE, noref == 0 ? ++current_copyID : 0);
+    {
+	current_copyID += COPYID_INC;
+	item_copy(&argvars[0], rettv, TRUE, noref == 0 ? current_copyID : 0);
+    }
 }
 
 /*
@@ -9220,27 +9313,23 @@
 /*
  * "did_filetype()" function
  */
-/*ARGSUSED*/
     static void
 f_did_filetype(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_AUTOCMD
     rettv->vval.v_number = did_filetype;
-#else
-    rettv->vval.v_number = 0;
 #endif
 }
 
 /*
  * "diff_filler()" function
  */
-/*ARGSUSED*/
     static void
 f_diff_filler(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_DIFF
     rettv->vval.v_number = diff_check_fill(curwin, get_tv_lnum(argvars));
@@ -9250,11 +9339,10 @@
 /*
  * "diff_hlID()" function
  */
-/*ARGSUSED*/
     static void
 f_diff_hlID(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_DIFF
     linenr_T		lnum = get_tv_lnum(argvars);
@@ -9367,7 +9455,6 @@
 /*
  * "eval()" function
  */
-/*ARGSUSED*/
     static void
 f_eval(argvars, rettv)
     typval_T	*argvars;
@@ -9391,10 +9478,9 @@
 /*
  * "eventhandler()" function
  */
-/*ARGSUSED*/
     static void
 f_eventhandler(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = vgetc_busy;
@@ -9518,7 +9604,7 @@
     else
     {
 	/* When the optional second argument is non-zero, don't remove matches
-	 * for 'suffixes' and 'wildignore' */
+	 * for 'wildignore' and don't put matches for 'suffixes' at the end. */
 	if (argvars[1].v_type != VAR_UNKNOWN
 				    && get_tv_number_chk(&argvars[1], &error))
 	    flags |= WILD_KEEP_ALL;
@@ -9542,7 +9628,6 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type == VAR_LIST && argvars[1].v_type == VAR_LIST)
     {
 	list_T		*l1, *l2;
@@ -9652,11 +9737,10 @@
 /*
  * "feedkeys()" function
  */
-/*ARGSUSED*/
     static void
 f_feedkeys(argvars, rettv)
     typval_T    *argvars;
-    typval_T    *rettv;
+    typval_T    *rettv UNUSED;
 {
     int		remap = TRUE;
     char_u	*keys, *flags;
@@ -9670,7 +9754,6 @@
     if (check_secure())
 	return;
 
-    rettv->vval.v_number = 0;
     keys = get_tv_string(&argvars[0]);
     if (*keys != NUL)
     {
@@ -9838,7 +9921,6 @@
     char_u	*ermsg = map ? (char_u *)"map()" : (char_u *)"filter()";
     int		save_did_emsg;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type == VAR_LIST)
     {
 	if ((l = argvars[0].vval.v_list) == NULL
@@ -10021,8 +10103,6 @@
 	else
 	    rettv->vval.v_number = (varnumber_T)f;
     }
-    else
-	rettv->vval.v_number = 0;
 }
 
 /*
@@ -10156,18 +10236,15 @@
     lnum = get_tv_lnum(argvars);
     if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)
 	rettv->vval.v_number = foldLevel(lnum);
-    else
 #endif
-	rettv->vval.v_number = 0;
 }
 
 /*
  * "foldtext()" function
  */
-/*ARGSUSED*/
     static void
 f_foldtext(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_FOLDING
@@ -10232,10 +10309,9 @@
 /*
  * "foldtextresult(lnum)" function
  */
-/*ARGSUSED*/
     static void
 f_foldtextresult(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_FOLDING
@@ -10268,13 +10344,11 @@
 /*
  * "foreground()" function
  */
-/*ARGSUSED*/
     static void
 f_foreground(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
-    rettv->vval.v_number = 0;
 #ifdef FEAT_GUI
     if (gui.in_use)
 	gui_mch_set_foreground();
@@ -10288,7 +10362,6 @@
 /*
  * "function()" function
  */
-/*ARGSUSED*/
     static void
 f_function(argvars, rettv)
     typval_T	*argvars;
@@ -10296,11 +10369,11 @@
 {
     char_u	*s;
 
-    rettv->vval.v_number = 0;
     s = get_tv_string(&argvars[0]);
     if (s == NULL || *s == NUL || VIM_ISDIGIT(*s))
 	EMSG2(_(e_invarg2), s);
-    else if (!function_exists(s))
+    /* Don't check an autoload name for existence here. */
+    else if (vim_strchr(s, AUTOLOAD_CHAR) == NULL && !function_exists(s))
 	EMSG2(_("E700: Unknown function: %s"), s);
     else
     {
@@ -10312,11 +10385,10 @@
 /*
  * "garbagecollect()" function
  */
-/*ARGSUSED*/
     static void
 f_garbagecollect(argvars, rettv)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
 {
     /* This is postponed until we are back at the toplevel, because we may be
      * using Lists and Dicts internally.  E.g.: ":echo [garbagecollect()]". */
@@ -10365,9 +10437,7 @@
 
     if (tv == NULL)
     {
-	if (argvars[2].v_type == VAR_UNKNOWN)
-	    rettv->vval.v_number = 0;
-	else
+	if (argvars[2].v_type != VAR_UNKNOWN)
 	    copy_tv(&argvars[2], rettv);
     }
     else
@@ -10392,13 +10462,8 @@
 {
     char_u	*p;
 
-    if (retlist)
-    {
-	if (rettv_list_alloc(rettv) == FAIL)
-	    return;
-    }
-    else
-	rettv->vval.v_number = 0;
+    if (retlist && rettv_list_alloc(rettv) == FAIL)
+	return;
 
     if (buf == NULL || buf->b_ml.ml_mfp == NULL || start < 0)
 	return;
@@ -10602,7 +10667,7 @@
 # ifdef FEAT_WINDOWS
 	    win_T	*wp;
 # endif
-	    int		n = 1;
+	    int		winnr = 1;
 
 	    if (row >= 0 && col >= 0)
 	    {
@@ -10612,9 +10677,9 @@
 		(void)mouse_comp_pos(win, &row, &col, &lnum);
 # ifdef FEAT_WINDOWS
 		for (wp = firstwin; wp != win; wp = wp->w_next)
-		    ++n;
+		    ++winnr;
 # endif
-		vimvars[VV_MOUSE_WIN].vv_nr = n;
+		vimvars[VV_MOUSE_WIN].vv_nr = winnr;
 		vimvars[VV_MOUSE_LNUM].vv_nr = lnum;
 		vimvars[VV_MOUSE_COL].vv_nr = col + 1;
 	    }
@@ -10626,10 +10691,9 @@
 /*
  * "getcharmod()" function
  */
-/*ARGSUSED*/
     static void
 f_getcharmod(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = mod_mask;
@@ -10638,10 +10702,9 @@
 /*
  * "getcmdline()" function
  */
-/*ARGSUSED*/
     static void
 f_getcmdline(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
@@ -10651,10 +10714,9 @@
 /*
  * "getcmdpos()" function
  */
-/*ARGSUSED*/
     static void
 f_getcmdpos(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = get_cmdline_pos() + 1;
@@ -10663,10 +10725,9 @@
 /*
  * "getcmdtype()" function
  */
-/*ARGSUSED*/
     static void
 f_getcmdtype(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
@@ -10681,10 +10742,9 @@
 /*
  * "getcwd()" function
  */
-/*ARGSUSED*/
     static void
 f_getcwd(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	cwd[MAXPATHL];
@@ -10705,10 +10765,9 @@
 /*
  * "getfontname()" function
  */
-/*ARGSUSED*/
     static void
 f_getfontname(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
@@ -10935,18 +10994,15 @@
 /*
  * "getmatches()" function
  */
-/*ARGSUSED*/
     static void
 f_getmatches(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_SEARCH_EXTRA
     dict_T	*dict;
     matchitem_T	*cur = curwin->w_match_head;
 
-    rettv->vval.v_number = 0;
-
     if (rettv_list_alloc(rettv) == OK)
     {
 	while (cur != NULL)
@@ -10968,10 +11024,9 @@
 /*
  * "getpid()" function
  */
-/*ARGSUSED*/
     static void
 f_getpid(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = mch_get_pid();
@@ -11015,17 +11070,15 @@
 /*
  * "getqflist()" and "getloclist()" functions
  */
-/*ARGSUSED*/
     static void
 f_getqflist(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_QUICKFIX
     win_T	*wp;
 #endif
 
-    rettv->vval.v_number = 0;
 #ifdef FEAT_QUICKFIX
     if (rettv_list_alloc(rettv) == OK)
     {
@@ -11135,10 +11188,9 @@
 /*
  * "getwinposx()" function
  */
-/*ARGSUSED*/
     static void
 f_getwinposx(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = -1;
@@ -11156,10 +11208,9 @@
 /*
  * "getwinposy()" function
  */
-/*ARGSUSED*/
     static void
 f_getwinposy(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = -1;
@@ -11284,13 +11335,25 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
+    int		flags = WILD_SILENT|WILD_USE_NL;
     expand_T	xpc;
+    int		error = FALSE;
 
-    ExpandInit(&xpc);
-    xpc.xp_context = EXPAND_FILES;
+    /* When the optional second argument is non-zero, don't remove matches
+    * for 'wildignore' and don't put matches for 'suffixes' at the end. */
+    if (argvars[1].v_type != VAR_UNKNOWN
+				&& get_tv_number_chk(&argvars[1], &error))
+	flags |= WILD_KEEP_ALL;
     rettv->v_type = VAR_STRING;
-    rettv->vval.v_string = ExpandOne(&xpc, get_tv_string(&argvars[0]),
-				     NULL, WILD_USE_NL|WILD_SILENT, WILD_ALL);
+    if (!error)
+    {
+	ExpandInit(&xpc);
+	xpc.xp_context = EXPAND_FILES;
+	rettv->vval.v_string = ExpandOne(&xpc, get_tv_string(&argvars[0]),
+						       NULL, flags, WILD_ALL);
+    }
+    else
+	rettv->vval.v_string = NULL;
 }
 
 /*
@@ -11301,14 +11364,22 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
+    int		flags = 0;
     char_u	buf1[NUMBUFLEN];
     char_u	*file = get_tv_string_buf_chk(&argvars[1], buf1);
+    int		error = FALSE;
 
+    /* When the optional second argument is non-zero, don't remove matches
+    * for 'wildignore' and don't put matches for 'suffixes' at the end. */
+    if (argvars[2].v_type != VAR_UNKNOWN
+				&& get_tv_number_chk(&argvars[2], &error))
+	flags |= WILD_KEEP_ALL;
     rettv->v_type = VAR_STRING;
-    if (file == NULL)
+    if (file == NULL || error)
 	rettv->vval.v_string = NULL;
     else
-	rettv->vval.v_string = globpath(get_tv_string(&argvars[0]), file);
+	rettv->vval.v_string = globpath(get_tv_string(&argvars[0]), file,
+								       flags);
 }
 
 /*
@@ -11782,6 +11853,10 @@
 	    n = has_patch(atoi((char *)name + 5));
 	else if (STRICMP(name, "vim_starting") == 0)
 	    n = (starting != 0);
+#ifdef FEAT_MBYTE
+	else if (STRICMP(name, "multi_byte_encoding") == 0)
+	    n = has_mbyte;
+#endif
 #if defined(FEAT_BEVAL) && defined(FEAT_GUI_W32)
 	else if (STRICMP(name, "balloon_multiline") == 0)
 	    n = multiline_balloon_available();
@@ -11847,7 +11922,6 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_DICT)
     {
 	EMSG(_(e_dictreq));
@@ -11863,10 +11937,9 @@
 /*
  * "haslocaldir()" function
  */
-/*ARGSUSED*/
     static void
 f_haslocaldir(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = (curwin->w_localdir != NULL);
@@ -11904,10 +11977,9 @@
 /*
  * "histadd()" function
  */
-/*ARGSUSED*/
     static void
 f_histadd(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_CMDHIST
@@ -11938,11 +12010,10 @@
 /*
  * "histdel()" function
  */
-/*ARGSUSED*/
     static void
 f_histdel(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_CMDHIST
     int		n;
@@ -11964,18 +12035,15 @@
 	n = del_history_entry(get_histtype(str),
 				      get_tv_string_buf(&argvars[1], buf));
     rettv->vval.v_number = n;
-#else
-    rettv->vval.v_number = 0;
 #endif
 }
 
 /*
  * "histget()" function
  */
-/*ARGSUSED*/
     static void
 f_histget(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_CMDHIST
@@ -12005,10 +12073,9 @@
 /*
  * "histnr()" function
  */
-/*ARGSUSED*/
     static void
 f_histnr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		i;
@@ -12050,10 +12117,9 @@
 /*
  * "hostname()" function
  */
-/*ARGSUSED*/
     static void
 f_hostname(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u hostname[256];
@@ -12066,10 +12132,9 @@
 /*
  * iconv() function
  */
-/*ARGSUSED*/
     static void
 f_iconv(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_MBYTE
@@ -12327,7 +12392,6 @@
     int		selected;
     int		mouse_used;
 
-    rettv->vval.v_number = 0;
 #ifdef NO_CONSOLE_INPUT
     /* While starting up, there is no place to enter text. */
     if (no_console_input())
@@ -12365,10 +12429,9 @@
 /*
  * "inputrestore()" function
  */
-/*ARGSUSED*/
     static void
 f_inputrestore(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     if (ga_userinput.ga_len > 0)
@@ -12376,7 +12439,7 @@
 	--ga_userinput.ga_len;
 	restore_typeahead((tasave_T *)(ga_userinput.ga_data)
 						       + ga_userinput.ga_len);
-	rettv->vval.v_number = 0; /* OK */
+	/* default return is zero == OK */
     }
     else if (p_verbose > 1)
     {
@@ -12388,10 +12451,9 @@
 /*
  * "inputsave()" function
  */
-/*ARGSUSED*/
     static void
 f_inputsave(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     /* Add an entry to the stack of typeahead storage. */
@@ -12400,7 +12462,7 @@
 	save_typeahead((tasave_T *)(ga_userinput.ga_data)
 						       + ga_userinput.ga_len);
 	++ga_userinput.ga_len;
-	rettv->vval.v_number = 0; /* OK */
+	/* default return is zero == OK */
     }
     else
 	rettv->vval.v_number = 1; /* Failed */
@@ -12434,7 +12496,6 @@
     list_T	*l;
     int		error = FALSE;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listarg), "insert()");
     else if ((l = argvars[0].vval.v_list) != NULL
@@ -12553,7 +12614,6 @@
     dict_T	*d;
     int		todo;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_DICT)
     {
 	EMSG(_(e_dictreq));
@@ -12641,7 +12701,6 @@
     garray_T	ga;
     char_u	*sep;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_LIST)
     {
 	EMSG(_(e_listreq));
@@ -12681,10 +12740,9 @@
 /*
  * "last_buffer_nr()" function.
  */
-/*ARGSUSED*/
     static void
 f_last_buffer_nr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		n = 0;
@@ -12739,9 +12797,7 @@
 #endif
 
     rettv->v_type = type;
-    if (type == VAR_NUMBER)
-	rettv->vval.v_number = 0;
-    else
+    if (type != VAR_NUMBER)
 	rettv->vval.v_string = NULL;
 
     if (check_restricted() || check_secure())
@@ -12813,10 +12869,9 @@
 /*
  * "line2byte(lnum)" function
  */
-/*ARGSUSED*/
     static void
 f_line2byte(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifndef FEAT_BYTEOFF
@@ -12862,10 +12917,9 @@
 /*
  * "localtime()" function
  */
-/*ARGSUSED*/
     static void
 f_localtime(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->vval.v_number = (varnumber_T)time(NULL);
@@ -13447,7 +13501,6 @@
 /*
  * "mode()" function
  */
-/*ARGSUSED*/
     static void
 f_mode(argvars, rettv)
     typval_T	*argvars;
@@ -13676,13 +13729,11 @@
 /*
  * "pumvisible()" function
  */
-/*ARGSUSED*/
     static void
 f_pumvisible(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
-    rettv->vval.v_number = 0;
 #ifdef FEAT_INS_EXPAND
     if (pum_visible())
 	rettv->vval.v_number = 1;
@@ -13716,7 +13767,6 @@
 	    stride = get_tv_number_chk(&argvars[2], &error);
     }
 
-    rettv->vval.v_number = 0;
     if (error)
 	return;		/* type error; errmsg already given */
     if (stride == 0)
@@ -14083,10 +14133,9 @@
 /*
  * "remote_expr()" function
  */
-/*ARGSUSED*/
     static void
 f_remote_expr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
@@ -14099,13 +14148,11 @@
 /*
  * "remote_foreground()" function
  */
-/*ARGSUSED*/
     static void
 f_remote_foreground(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
-    rettv->vval.v_number = 0;
 #ifdef FEAT_CLIENTSERVER
 # ifdef WIN32
     /* On Win32 it's done in this application. */
@@ -14126,10 +14173,9 @@
 #endif
 }
 
-/*ARGSUSED*/
     static void
 f_remote_peek(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_CLIENTSERVER
@@ -14161,7 +14207,6 @@
 	rettv->vval.v_number = (s != NULL);
     }
 # else
-    rettv->vval.v_number = 0;
     if (check_connection() == FAIL)
 	return;
 
@@ -14185,10 +14230,9 @@
 #endif
 }
 
-/*ARGSUSED*/
     static void
 f_remote_read(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	*r = NULL;
@@ -14220,10 +14264,9 @@
 /*
  * "remote_send()" function
  */
-/*ARGSUSED*/
     static void
 f_remote_send(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     rettv->v_type = VAR_STRING;
@@ -14250,7 +14293,6 @@
     dict_T	*d;
     dictitem_T	*di;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type == VAR_DICT)
     {
 	if (argvars[2].v_type != VAR_UNKNOWN)
@@ -14353,7 +14395,6 @@
 /*
  * "repeat()" function
  */
-/*ARGSUSED*/
     static void
 f_repeat(argvars, rettv)
     typval_T	*argvars;
@@ -14608,7 +14649,6 @@
     list_T	*l;
     listitem_T	*li, *ni;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listarg), "reverse()");
     else if ((l = argvars[0].vval.v_list) != NULL
@@ -14960,8 +15000,6 @@
     int		lnum = 0;
     int		col = 0;
 
-    rettv->vval.v_number = 0;
-
     if (rettv_list_alloc(rettv) == FAIL)
 	return;
 
@@ -15148,8 +15186,6 @@
     int		n;
     int		flags = 0;
 
-    rettv->vval.v_number = 0;
-
     if (rettv_list_alloc(rettv) == FAIL)
 	return;
 
@@ -15167,10 +15203,9 @@
 }
 
 
-/*ARGSUSED*/
     static void
 f_server2client(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_CLIENTSERVER
@@ -15199,10 +15234,9 @@
 #endif
 }
 
-/*ARGSUSED*/
     static void
 f_serverlist(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	*r = NULL;
@@ -15223,11 +15257,10 @@
 /*
  * "setbufvar()" function
  */
-/*ARGSUSED*/
     static void
 f_setbufvar(argvars, rettv)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
 {
     buf_T	*buf;
     aco_save_T	aco;
@@ -15235,8 +15268,6 @@
     typval_T	*varp;
     char_u	nbuf[NUMBUFLEN];
 
-    rettv->vval.v_number = 0;
-
     if (check_restricted() || check_secure())
 	return;
     (void)get_tv_number(&argvars[0]);	    /* issue errmsg if type error */
@@ -15316,7 +15347,7 @@
     else
 	line = get_tv_string_chk(&argvars[1]);
 
-    rettv->vval.v_number = 0;		/* OK */
+    /* default result is zero == OK */
     for (;;)
     {
 	if (l != NULL)
@@ -15364,12 +15395,11 @@
 /*
  * Used by "setqflist()" and "setloclist()" functions
  */
-/*ARGSUSED*/
     static void
 set_qf_ll_list(wp, list_arg, action_arg, rettv)
-    win_T	*wp;
-    typval_T	*list_arg;
-    typval_T	*action_arg;
+    win_T	*wp UNUSED;
+    typval_T	*list_arg UNUSED;
+    typval_T	*action_arg UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_QUICKFIX
@@ -15404,7 +15434,6 @@
 /*
  * "setloclist()" function
  */
-/*ARGSUSED*/
     static void
 f_setloclist(argvars, rettv)
     typval_T	*argvars;
@@ -15482,7 +15511,6 @@
 /*
  * "setpos()" function
  */
-/*ARGSUSED*/
     static void
 f_setpos(argvars, rettv)
     typval_T	*argvars;
@@ -15526,7 +15554,6 @@
 /*
  * "setqflist()" function
  */
-/*ARGSUSED*/
     static void
 f_setqflist(argvars, rettv)
     typval_T	*argvars;
@@ -15632,7 +15659,7 @@
     static void
 setwinvar(argvars, rettv, off)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
     int		off;
 {
     win_T	*win;
@@ -15645,8 +15672,6 @@
     char_u	nbuf[NUMBUFLEN];
     tabpage_T	*tp;
 
-    rettv->vval.v_number = 0;
-
     if (check_restricted() || check_secure())
 	return;
 
@@ -15838,10 +15863,9 @@
     if (res == FAIL)
 	res = ITEM_COMPARE_FAIL;
     else
-	/* return value has wrong type */
 	res = get_tv_number_chk(&rettv, &item_compare_func_err);
     if (item_compare_func_err)
-	res = ITEM_COMPARE_FAIL;
+	res = ITEM_COMPARE_FAIL;  /* return value has wrong type */
     clear_tv(&rettv);
     return res;
 }
@@ -15860,7 +15884,6 @@
     long	len;
     long	i;
 
-    rettv->vval.v_number = 0;
     if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listarg), "sort()");
     else
@@ -15952,10 +15975,9 @@
 /*
  * "spellbadword()" function
  */
-/* ARGSUSED */
     static void
 f_spellbadword(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	*word = (char_u *)"";
@@ -16007,10 +16029,9 @@
 /*
  * "spellsuggest()" function
  */
-/*ARGSUSED*/
     static void
 f_spellsuggest(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_SPELL
@@ -16493,10 +16514,9 @@
 /*
  * "synID(lnum, col, trans)" function
  */
-/*ARGSUSED*/
     static void
 f_synID(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		id = 0;
@@ -16521,10 +16541,9 @@
 /*
  * "synIDattr(id, what [, mode])" function
  */
-/*ARGSUSED*/
     static void
 f_synIDattr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	*p = NULL;
@@ -16590,8 +16609,11 @@
 		p = highlight_has_attr(id, HL_INVERSE, modec);
 		break;
 
-	case 's':					/* standout */
-		p = highlight_has_attr(id, HL_STANDOUT, modec);
+	case 's':
+		if (TOLOWER_ASC(what[1]) == 'p')	/* sp[#] */
+		    p = highlight_color(id, what, modec);
+		else					/* standout */
+		    p = highlight_has_attr(id, HL_STANDOUT, modec);
 		break;
 
 	case 'u':
@@ -16614,10 +16636,9 @@
 /*
  * "synIDtrans(id)" function
  */
-/*ARGSUSED*/
     static void
 f_synIDtrans(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		id;
@@ -16637,10 +16658,9 @@
 /*
  * "synstack(lnum, col)" function
  */
-/*ARGSUSED*/
     static void
 f_synstack(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_SYN_HL
@@ -16658,7 +16678,7 @@
     col = get_tv_number(&argvars[1]) - 1;	/* -1 on type error */
 
     if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count
-	    && col >= 0 && col < (long)STRLEN(ml_get(lnum))
+	    && col >= 0 && (col == 0 || col < (long)STRLEN(ml_get(lnum)))
 	    && rettv_list_alloc(rettv) != FAIL)
     {
 	(void)syn_get_id(curwin, lnum, (colnr_T)col, FALSE, NULL, TRUE);
@@ -16774,15 +16794,12 @@
 /*
  * "tabpagebuflist()" function
  */
-/* ARGSUSED */
     static void
 f_tabpagebuflist(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
-#ifndef FEAT_WINDOWS
-    rettv->vval.v_number = 0;
-#else
+#ifdef FEAT_WINDOWS
     tabpage_T	*tp;
     win_T	*wp = NULL;
 
@@ -16794,19 +16811,12 @@
 	if (tp != NULL)
 	    wp = (tp == curtab) ? firstwin : tp->tp_firstwin;
     }
-    if (wp == NULL)
-	rettv->vval.v_number = 0;
-    else
+    if (wp != NULL && rettv_list_alloc(rettv) != FAIL)
     {
-	if (rettv_list_alloc(rettv) == FAIL)
-	    rettv->vval.v_number = 0;
-	else
-	{
-	    for (; wp != NULL; wp = wp->w_next)
-		if (list_append_number(rettv->vval.v_list,
+	for (; wp != NULL; wp = wp->w_next)
+	    if (list_append_number(rettv->vval.v_list,
 						wp->w_buffer->b_fnum) == FAIL)
-		    break;
-	}
+		break;
     }
 #endif
 }
@@ -16815,10 +16825,9 @@
 /*
  * "tabpagenr()" function
  */
-/* ARGSUSED */
     static void
 f_tabpagenr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		nr = 1;
@@ -16900,10 +16909,9 @@
 /*
  * "tabpagewinnr()" function
  */
-/* ARGSUSED */
     static void
 f_tabpagewinnr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		nr = 1;
@@ -16923,10 +16931,9 @@
 /*
  * "tagfiles()" function
  */
-/*ARGSUSED*/
     static void
 f_tagfiles(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     char_u	fname[MAXPATHL + 1];
@@ -16934,10 +16941,7 @@
     int		first;
 
     if (rettv_list_alloc(rettv) == FAIL)
-    {
-	rettv->vval.v_number = 0;
 	return;
-    }
 
     for (first = TRUE; ; first = FALSE)
 	if (get_tagfname(&tn, first, fname) == FAIL
@@ -16969,10 +16973,9 @@
 /*
  * "tempname()" function
  */
-/*ARGSUSED*/
     static void
 f_tempname(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     static int	x = 'A';
@@ -17005,11 +17008,10 @@
 /*
  * "test(list)" function: Just checking the walls...
  */
-/*ARGSUSED*/
     static void
 f_test(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
     /* Used for unit testing.  Change the code below to your liking. */
 #if 0
@@ -17294,11 +17296,10 @@
 /*
  * "visualmode()" function
  */
-/*ARGSUSED*/
     static void
 f_visualmode(argvars, rettv)
-    typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*argvars UNUSED;
+    typval_T	*rettv UNUSED;
 {
 #ifdef FEAT_VISUAL
     char_u	str[2];
@@ -17311,8 +17312,6 @@
     /* A non-zero number or non-empty string argument: reset mode. */
     if (non_zero_arg(&argvars[0]))
 	curbuf->b_visual_mode_eval = NUL;
-#else
-    rettv->vval.v_number = 0; /* return anything, it won't work anyway */
 #endif
 }
 
@@ -17336,10 +17335,9 @@
 /*
  * "wincol()" function
  */
-/*ARGSUSED*/
     static void
 f_wincol(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     validate_cursor();
@@ -17366,10 +17364,9 @@
 /*
  * "winline()" function
  */
-/*ARGSUSED*/
     static void
 f_winline(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     validate_cursor();
@@ -17379,10 +17376,9 @@
 /*
  * "winnr()" function
  */
-/* ARGSUSED */
     static void
 f_winnr(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     int		nr = 1;
@@ -17396,10 +17392,9 @@
 /*
  * "winrestcmd()" function
  */
-/* ARGSUSED */
     static void
 f_winrestcmd(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
 #ifdef FEAT_WINDOWS
@@ -17431,11 +17426,10 @@
 /*
  * "winrestview()" function
  */
-/* ARGSUSED */
     static void
 f_winrestview(argvars, rettv)
     typval_T	*argvars;
-    typval_T	*rettv;
+    typval_T	*rettv UNUSED;
 {
     dict_T	*dict;
 
@@ -17477,10 +17471,9 @@
 /*
  * "winsaveview()" function
  */
-/* ARGSUSED */
     static void
 f_winsaveview(argvars, rettv)
-    typval_T	*argvars;
+    typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
     dict_T	*dict;
@@ -18097,14 +18090,28 @@
 }
 
 /*
- * Set v:count, v:count1 and v:prevcount.
+ * Get List v: variable value.  Caller must take care of reference count when
+ * needed.
+ */
+    list_T *
+get_vim_var_list(idx)
+    int		idx;
+{
+    return vimvars[idx].vv_list;
+}
+
+/*
+ * Set v:count to "count" and v:count1 to "count1".
+ * When "set_prevcount" is TRUE first set v:prevcount from v:count.
  */
     void
-set_vcount(count, count1)
+set_vcount(count, count1, set_prevcount)
     long	count;
     long	count1;
+    int		set_prevcount;
 {
-    vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;
+    if (set_prevcount)
+	vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;
     vimvars[VV_COUNT].vv_nr = count;
     vimvars[VV_COUNT1].vv_nr = count1;
 }
@@ -18132,6 +18139,20 @@
 }
 
 /*
+ * Set List v: variable to "val".
+ */
+    void
+set_vim_var_list(idx, val)
+    int		idx;
+    list_T	*val;
+{
+    list_unref(vimvars[idx].vv_list);
+    vimvars[idx].vv_list = val;
+    if (val != NULL)
+	++val->lv_refcount;
+}
+
+/*
  * Set v:register if needed.
  */
     void
@@ -18868,7 +18889,8 @@
     dictitem_T	*dict_var;
 {
     hash_init(&dict->dv_hashtab);
-    dict->dv_refcount = 99999;
+    dict->dv_refcount = DO_NOT_FREE_CNT;
+    dict->dv_copyID = 0;
     dict_var->di_tv.vval.v_dict = dict;
     dict_var->di_tv.v_type = VAR_DICT;
     dict_var->di_tv.v_lock = VAR_FIXED;
@@ -18951,7 +18973,8 @@
     char_u	*s;
     char_u	numbuf[NUMBUFLEN];
 
-    s = echo_string(&v->di_tv, &tofree, numbuf, ++current_copyID);
+    current_copyID += COPYID_INC;
+    s = echo_string(&v->di_tv, &tofree, numbuf, current_copyID);
     list_one_var_a(prefix, v->di_key, v->di_tv.v_type,
 					 s == NULL ? (char_u *)"" : s, first);
     vim_free(tofree);
@@ -19205,6 +19228,8 @@
  * Copy the values from typval_T "from" to typval_T "to".
  * When needed allocates string or increases reference count.
  * Does not make a copy of a list or dict but copies the reference!
+ * It is OK for "from" and "to" to point to the same item.  This is used to
+ * make a copy later.
  */
     static void
 copy_tv(from, to)
@@ -19384,7 +19409,8 @@
 	    }
 	    else if (eap->cmdidx == CMD_echo)
 		msg_puts_attr((char_u *)" ", echo_attr);
-	    p = echo_string(&rettv, &tofree, numbuf, ++current_copyID);
+	    current_copyID += COPYID_INC;
+	    p = echo_string(&rettv, &tofree, numbuf, current_copyID);
 	    if (p != NULL)
 		for ( ; *p != NUL && !got_int; ++p)
 		{
@@ -19660,6 +19686,7 @@
 			    list_func_head(fp, FALSE);
 		    }
 		}
+		vim_free(regmatch.regprog);
 	    }
 	}
 	if (*p == '/')
@@ -19748,7 +19775,7 @@
 		}
 	    }
 	    else
-		emsg_funcname("E123: Undefined function: %s", name);
+		emsg_funcname(N_("E123: Undefined function: %s"), name);
 	}
 	goto ret_free;
     }
@@ -19792,7 +19819,7 @@
 						      : eval_isnamec(arg[j])))
 		++j;
 	    if (arg[j] != NUL)
-		emsg_funcname(_(e_invarg2), arg);
+		emsg_funcname((char *)e_invarg2, arg);
 	}
     }
 
@@ -20064,7 +20091,7 @@
 	v = find_var(name, &ht);
 	if (v != NULL && v->di_tv.v_type == VAR_FUNC)
 	{
-	    emsg_funcname("E707: Function name conflicts with variable: %s",
+	    emsg_funcname(N_("E707: Function name conflicts with variable: %s"),
 									name);
 	    goto erret;
 	}
@@ -20079,7 +20106,7 @@
 	    }
 	    if (fp->uf_calls > 0)
 	    {
-		emsg_funcname("E127: Cannot redefine function %s: It is in use",
+		emsg_funcname(N_("E127: Cannot redefine function %s: It is in use"),
 									name);
 		goto erret;
 	    }
@@ -20590,6 +20617,9 @@
     int		st_len = 0;
 
     todo = (int)func_hashtab.ht_used;
+    if (todo == 0)
+	return;     /* nothing to dump */
+
     sorttab = (ufunc_T **)alloc((unsigned)(sizeof(ufunc_T) * todo));
 
     for (hi = func_hashtab.ht_array; todo > 0; ++hi)
@@ -20638,6 +20668,8 @@
 							      prof_self_cmp);
 	prof_sort_list(fd, sorttab, st_len, "SELF", TRUE);
     }
+
+    vim_free(sorttab);
 }
 
     static void
@@ -21012,7 +21044,7 @@
     char_u	*save_sourcing_name;
     linenr_T	save_sourcing_lnum;
     scid_T	save_current_SID;
-    funccall_T	fc;
+    funccall_T	*fc;
     int		save_did_emsg;
     static int	depth = 0;
     dictitem_T	*v;
@@ -21038,36 +21070,37 @@
 
     line_breakcheck();		/* check for CTRL-C hit */
 
-    fc.caller = current_funccal;
-    current_funccal = &fc;
-    fc.func = fp;
-    fc.rettv = rettv;
+    fc = (funccall_T *)alloc(sizeof(funccall_T));
+    fc->caller = current_funccal;
+    current_funccal = fc;
+    fc->func = fp;
+    fc->rettv = rettv;
     rettv->vval.v_number = 0;
-    fc.linenr = 0;
-    fc.returned = FALSE;
-    fc.level = ex_nesting_level;
+    fc->linenr = 0;
+    fc->returned = FALSE;
+    fc->level = ex_nesting_level;
     /* Check if this function has a breakpoint. */
-    fc.breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);
-    fc.dbg_tick = debug_tick;
+    fc->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);
+    fc->dbg_tick = debug_tick;
 
     /*
-     * Note about using fc.fixvar[]: This is an array of FIXVAR_CNT variables
+     * Note about using fc->fixvar[]: This is an array of FIXVAR_CNT variables
      * with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free
      * each argument variable and saves a lot of time.
      */
     /*
      * Init l: variables.
      */
-    init_var_dict(&fc.l_vars, &fc.l_vars_var);
+    init_var_dict(&fc->l_vars, &fc->l_vars_var);
     if (selfdict != NULL)
     {
 	/* Set l:self to "selfdict".  Use "name" to avoid a warning from
 	 * some compiler that checks the destination size. */
-	v = &fc.fixvar[fixvar_idx++].var;
+	v = &fc->fixvar[fixvar_idx++].var;
 	name = v->di_key;
 	STRCPY(name, "self");
 	v->di_flags = DI_FLAGS_RO + DI_FLAGS_FIX;
-	hash_add(&fc.l_vars.dv_hashtab, DI2HIKEY(v));
+	hash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));
 	v->di_tv.v_type = VAR_DICT;
 	v->di_tv.v_lock = 0;
 	v->di_tv.vval.v_dict = selfdict;
@@ -21079,28 +21112,31 @@
      * Set a:0 to "argcount".
      * Set a:000 to a list with room for the "..." arguments.
      */
-    init_var_dict(&fc.l_avars, &fc.l_avars_var);
-    add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "0",
+    init_var_dict(&fc->l_avars, &fc->l_avars_var);
+    add_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, "0",
 				(varnumber_T)(argcount - fp->uf_args.ga_len));
-    v = &fc.fixvar[fixvar_idx++].var;
-    STRCPY(v->di_key, "000");
+    /* Use "name" to avoid a warning from some compiler that checks the
+     * destination size. */
+    v = &fc->fixvar[fixvar_idx++].var;
+    name = v->di_key;
+    STRCPY(name, "000");
     v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
-    hash_add(&fc.l_avars.dv_hashtab, DI2HIKEY(v));
+    hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));
     v->di_tv.v_type = VAR_LIST;
     v->di_tv.v_lock = VAR_FIXED;
-    v->di_tv.vval.v_list = &fc.l_varlist;
-    vim_memset(&fc.l_varlist, 0, sizeof(list_T));
-    fc.l_varlist.lv_refcount = 99999;
-    fc.l_varlist.lv_lock = VAR_FIXED;
+    v->di_tv.vval.v_list = &fc->l_varlist;
+    vim_memset(&fc->l_varlist, 0, sizeof(list_T));
+    fc->l_varlist.lv_refcount = DO_NOT_FREE_CNT;
+    fc->l_varlist.lv_lock = VAR_FIXED;
 
     /*
      * Set a:firstline to "firstline" and a:lastline to "lastline".
      * Set a:name to named arguments.
      * Set a:N to the "..." arguments.
      */
-    add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "firstline",
+    add_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, "firstline",
 						      (varnumber_T)firstline);
-    add_nr_var(&fc.l_avars, &fc.fixvar[fixvar_idx++].var, "lastline",
+    add_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, "lastline",
 						       (varnumber_T)lastline);
     for (i = 0; i < argcount; ++i)
     {
@@ -21116,7 +21152,7 @@
 	}
 	if (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN)
 	{
-	    v = &fc.fixvar[fixvar_idx++].var;
+	    v = &fc->fixvar[fixvar_idx++].var;
 	    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
 	}
 	else
@@ -21128,7 +21164,7 @@
 	    v->di_flags = DI_FLAGS_RO;
 	}
 	STRCPY(v->di_key, name);
-	hash_add(&fc.l_avars.dv_hashtab, DI2HIKEY(v));
+	hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));
 
 	/* Note: the values are copied directly to avoid alloc/free.
 	 * "argvars" must have VAR_FIXED for v_lock. */
@@ -21137,9 +21173,9 @@
 
 	if (ai >= 0 && ai < MAX_FUNC_ARGS)
 	{
-	    list_append(&fc.l_varlist, &fc.l_listitems[ai]);
-	    fc.l_listitems[ai].li_tv = argvars[i];
-	    fc.l_listitems[ai].li_tv.v_lock = VAR_FIXED;
+	    list_append(&fc->l_varlist, &fc->l_listitems[ai]);
+	    fc->l_listitems[ai].li_tv = argvars[i];
+	    fc->l_listitems[ai].li_tv.v_lock = VAR_FIXED;
 	}
     }
 
@@ -21204,7 +21240,7 @@
 	if (!fp->uf_profiling && has_profiling(FALSE, fp->uf_name, NULL))
 	    func_do_profile(fp);
 	if (fp->uf_profiling
-		       || (fc.caller != NULL && &fc.caller->func->uf_profiling))
+		    || (fc->caller != NULL && fc->caller->func->uf_profiling))
 	{
 	    ++fp->uf_tm_count;
 	    profile_start(&call_start);
@@ -21220,7 +21256,7 @@
     did_emsg = FALSE;
 
     /* call do_cmdline() to execute the lines */
-    do_cmdline(NULL, get_func_line, (void *)&fc,
+    do_cmdline(NULL, get_func_line, (void *)fc,
 				     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);
 
     --RedrawingDisabled;
@@ -21235,16 +21271,16 @@
 
 #ifdef FEAT_PROFILE
     if (do_profiling == PROF_YES && (fp->uf_profiling
-		    || (fc.caller != NULL && &fc.caller->func->uf_profiling)))
+		    || (fc->caller != NULL && fc->caller->func->uf_profiling)))
     {
 	profile_end(&call_start);
 	profile_sub_wait(&wait_start, &call_start);
 	profile_add(&fp->uf_tm_total, &call_start);
 	profile_self(&fp->uf_tm_self, &call_start, &fp->uf_tm_children);
-	if (fc.caller != NULL && &fc.caller->func->uf_profiling)
+	if (fc->caller != NULL && fc->caller->func->uf_profiling)
 	{
-	    profile_add(&fc.caller->func->uf_tm_children, &call_start);
-	    profile_add(&fc.caller->func->uf_tml_children, &call_start);
+	    profile_add(&fc->caller->func->uf_tm_children, &call_start);
+	    profile_add(&fc->caller->func->uf_tml_children, &call_start);
 	}
     }
 #endif
@@ -21257,9 +21293,9 @@
 
 	if (aborting())
 	    smsg((char_u *)_("%s aborted"), sourcing_name);
-	else if (fc.rettv->v_type == VAR_NUMBER)
+	else if (fc->rettv->v_type == VAR_NUMBER)
 	    smsg((char_u *)_("%s returning #%ld"), sourcing_name,
-					       (long)fc.rettv->vval.v_number);
+					       (long)fc->rettv->vval.v_number);
 	else
 	{
 	    char_u	buf[MSG_BUF_LEN];
@@ -21270,7 +21306,7 @@
 	    /* The value may be very long.  Skip the middle part, so that we
 	     * have some idea how it starts and ends. smsg() would always
 	     * truncate it at the end. */
-	    s = tv2string(fc.rettv, &tofree, numbuf2, 0);
+	    s = tv2string(fc->rettv, &tofree, numbuf2, 0);
 	    if (s != NULL)
 	    {
 		trunc_string(s, buf, MSG_BUF_CLEN);
@@ -21306,14 +21342,84 @@
     }
 
     did_emsg |= save_did_emsg;
-    current_funccal = fc.caller;
+    current_funccal = fc->caller;
+    --depth;
 
-    /* The a: variables typevals were not allocated, only free the allocated
-     * variables. */
-    vars_clear_ext(&fc.l_avars.dv_hashtab, FALSE);
+    /* If the a:000 list and the l: and a: dicts are not referenced we can
+     * free the funccall_T and what's in it. */
+    if (fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT
+	    && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT
+	    && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)
+    {
+	free_funccal(fc, FALSE);
+    }
+    else
+    {
+	hashitem_T	*hi;
+	listitem_T	*li;
+	int		todo;
 
-    vars_clear(&fc.l_vars.dv_hashtab);		/* free all l: variables */
-    --depth;
+	/* "fc" is still in use.  This can happen when returning "a:000" or
+	 * assigning "l:" to a global variable.
+	 * Link "fc" in the list for garbage collection later. */
+	fc->caller = previous_funccal;
+	previous_funccal = fc;
+
+	/* Make a copy of the a: variables, since we didn't do that above. */
+	todo = (int)fc->l_avars.dv_hashtab.ht_used;
+	for (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)
+	{
+	    if (!HASHITEM_EMPTY(hi))
+	    {
+		--todo;
+		v = HI2DI(hi);
+		copy_tv(&v->di_tv, &v->di_tv);
+	    }
+	}
+
+	/* Make a copy of the a:000 items, since we didn't do that above. */
+	for (li = fc->l_varlist.lv_first; li != NULL; li = li->li_next)
+	    copy_tv(&li->li_tv, &li->li_tv);
+    }
+}
+
+/*
+ * Return TRUE if items in "fc" do not have "copyID".  That means they are not
+ * referenced from anywhere that is in use.
+ */
+    static int
+can_free_funccal(fc, copyID)
+    funccall_T	*fc;
+    int		copyID;
+{
+    return (fc->l_varlist.lv_copyID != copyID
+	    && fc->l_vars.dv_copyID != copyID
+	    && fc->l_avars.dv_copyID != copyID);
+}
+
+/*
+ * Free "fc" and what it contains.
+ */
+   static void
+free_funccal(fc, free_val)
+    funccall_T	*fc;
+    int		free_val;  /* a: vars were allocated */
+{
+    listitem_T	*li;
+
+    /* The a: variables typevals may not have been allocated, only free the
+     * allocated variables. */
+    vars_clear_ext(&fc->l_avars.dv_hashtab, free_val);
+
+    /* free all l: variables */
+    vars_clear(&fc->l_vars.dv_hashtab);
+
+    /* Free the a:000 variables if they were allocated. */
+    if (free_val)
+	for (li = fc->l_varlist.lv_first; li != NULL; li = li->li_next)
+	    clear_tv(&li->li_tv);
+
+    vim_free(fc);
 }
 
 /*
@@ -21512,12 +21618,11 @@
  * Called by do_cmdline() to get the next line.
  * Returns allocated string, or NULL for end of function.
  */
-/* ARGSUSED */
     char_u *
 get_func_line(c, cookie, indent)
-    int	    c;		    /* not used */
+    int	    c UNUSED;
     void    *cookie;
-    int	    indent;	    /* not used */
+    int	    indent UNUSED;
 {
     funccall_T	*fcp = (funccall_T *)cookie;
     ufunc_T	*fp = fcp->func;
@@ -21886,6 +21991,61 @@
     }
 }
 
+/*
+ * List v:oldfiles in a nice way.
+ */
+    void
+ex_oldfiles(eap)
+    exarg_T	*eap UNUSED;
+{
+    list_T	*l = vimvars[VV_OLDFILES].vv_list;
+    listitem_T	*li;
+    int		nr = 0;
+
+    if (l == NULL)
+	msg((char_u *)_("No old files"));
+    else
+    {
+	msg_start();
+	msg_scroll = TRUE;
+	for (li = l->lv_first; li != NULL && !got_int; li = li->li_next)
+	{
+	    msg_outnum((long)++nr);
+	    MSG_PUTS(": ");
+	    msg_outtrans(get_tv_string(&li->li_tv));
+	    msg_putchar('\n');
+	    out_flush();	    /* output one line at a time */
+	    ui_breakcheck();
+	}
+	/* Assume "got_int" was set to truncate the listing. */
+	got_int = FALSE;
+
+#ifdef FEAT_BROWSE_CMD
+	if (cmdmod.browse)
+	{
+	    quit_more = FALSE;
+	    nr = prompt_for_number(FALSE);
+	    msg_starthere();
+	    if (nr > 0)
+	    {
+		char_u *p = list_find_str(get_vim_var_list(VV_OLDFILES),
+								    (long)nr);
+
+		if (p != NULL)
+		{
+		    p = expand_env_save(p);
+		    eap->arg = p;
+		    eap->cmdidx = CMD_edit;
+		    cmdmod.browse = FALSE;
+		    do_exedit(eap, NULL);
+		    vim_free(p);
+		}
+	    }
+	}
+#endif
+    }
+}
+
 #endif /* FEAT_EVAL */
 
 
diff -Naur vim72.orig/src/ex_cmds2.c vim72/src/ex_cmds2.c
--- vim72.orig/src/ex_cmds2.c	2008-07-13 17:18:22.000000000 +0100
+++ vim72/src/ex_cmds2.c	2009-07-22 22:54:22.000000000 +0100
@@ -28,7 +28,8 @@
 {
     char_u	*sn_name;
 # ifdef UNIX
-    int		sn_dev;
+    int		sn_dev_valid;
+    dev_t	sn_dev;
     ino_t	sn_ino;
 # endif
 # ifdef FEAT_PROFILE
@@ -680,10 +681,9 @@
 /*
  * ":breaklist".
  */
-/*ARGSUSED*/
     void
 ex_breaklist(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     struct debuggy *bp;
     int		i;
@@ -1342,14 +1342,13 @@
 /*
  * return TRUE if buffer was changed and cannot be abandoned.
  */
-/*ARGSUSED*/
     int
 check_changed(buf, checkaw, mult_win, forceit, allbuf)
     buf_T	*buf;
     int		checkaw;	/* do autowrite if buffer was changed */
     int		mult_win;	/* check also when several wins for the buf */
     int		forceit;
-    int		allbuf;		/* may write all buffers */
+    int		allbuf UNUSED;	/* may write all buffers */
 {
     if (       !forceit
 	    && bufIsChanged(buf)
@@ -1759,12 +1758,11 @@
  *
  * Return FAIL for failure, OK otherwise.
  */
-/*ARGSUSED*/
     static int
 do_arglist(str, what, after)
     char_u	*str;
-    int		what;
-    int		after;		/* 0 means before first one */
+    int		what UNUSED;
+    int		after UNUSED;		/* 0 means before first one */
 {
     garray_T	new_ga;
     int		exp_count;
@@ -2132,8 +2130,8 @@
 	 * argument index. */
 	if (do_ecmd(0, alist_name(&ARGLIST[curwin->w_arg_idx]), NULL,
 		      eap, ECMD_LAST,
-		      (P_HID(curwin->w_buffer) ? ECMD_HIDE : 0) +
-				   (eap->forceit ? ECMD_FORCEIT : 0)) == FAIL)
+		      (P_HID(curwin->w_buffer) ? ECMD_HIDE : 0)
+			 + (eap->forceit ? ECMD_FORCEIT : 0), curwin) == FAIL)
 	    curwin->w_arg_idx = old_arg_idx;
 	/* like Vi: set the mark where the cursor is in the file. */
 	else if (eap->cmdidx != CMD_argdo)
@@ -2549,11 +2547,10 @@
 
 static void source_callback __ARGS((char_u *fname, void *cookie));
 
-/*ARGSUSED*/
     static void
 source_callback(fname, cookie)
     char_u	*fname;
-    void	*cookie;
+    void	*cookie UNUSED;
 {
     (void)do_source(fname, FALSE, DOSO_NONE);
 }
@@ -2680,10 +2677,9 @@
 /*
  * ":options"
  */
-/*ARGSUSED*/
     void
 ex_options(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     cmd_source((char_u *)SYS_OPTWIN_FILE, NULL);
 }
@@ -2842,6 +2838,7 @@
     linenr_T		    save_sourcing_lnum;
     char_u		    *p;
     char_u		    *fname_exp;
+    char_u		    *firstline = NULL;
     int			    retval = FAIL;
 #ifdef FEAT_EVAL
     scid_T		    save_current_SID;
@@ -2992,23 +2989,6 @@
 
     cookie.level = ex_nesting_level;
 #endif
-#ifdef FEAT_MBYTE
-    cookie.conv.vc_type = CONV_NONE;		/* no conversion */
-
-    /* Try reading the first few bytes to check for a UTF-8 BOM. */
-    {
-	char_u	    buf[3];
-
-	if (fread((char *)buf, sizeof(char_u), (size_t)3, cookie.fp)
-								  == (size_t)3
-		&& buf[0] == 0xef && buf[1] == 0xbb && buf[2] == 0xbf)
-	    /* Found BOM, setup conversion and skip over it. */
-	    convert_setup(&cookie.conv, (char_u *)"utf-8", p_enc);
-	else
-	    /* No BOM found, rewind. */
-	    fseek(cookie.fp, 0L, SEEK_SET);
-    }
-#endif
 
     /*
      * Keep the sourcing name/lnum, for recursive calls.
@@ -3018,6 +2998,27 @@
     save_sourcing_lnum = sourcing_lnum;
     sourcing_lnum = 0;
 
+#ifdef FEAT_MBYTE
+    cookie.conv.vc_type = CONV_NONE;		/* no conversion */
+
+    /* Read the first line so we can check for a UTF-8 BOM. */
+    firstline = getsourceline(0, (void *)&cookie, 0);
+    if (firstline != NULL && STRLEN(firstline) >= 3 && firstline[0] == 0xef
+			      && firstline[1] == 0xbb && firstline[2] == 0xbf)
+    {
+	/* Found BOM; setup conversion, skip over BOM and recode the line. */
+	convert_setup(&cookie.conv, (char_u *)"utf-8", p_enc);
+	p = string_convert(&cookie.conv, firstline + 3, NULL);
+	if (p == NULL)
+	    p = vim_strsave(firstline + 3);
+	if (p != NULL)
+	{
+	    vim_free(firstline);
+	    firstline = p;
+	}
+    }
+#endif
+
 #ifdef STARTUPTIME
     time_push(&tv_rel, &tv_start);
 #endif
@@ -3049,7 +3050,7 @@
 		    /* Compare dev/ino when possible, it catches symbolic
 		     * links.  Also compare file names, the inode may change
 		     * when the file was edited. */
-		    ((stat_ok && si->sn_dev != -1)
+		    ((stat_ok && si->sn_dev_valid)
 			&& (si->sn_dev == st.st_dev
 			    && si->sn_ino == st.st_ino)) ||
 # endif
@@ -3076,11 +3077,12 @@
 # ifdef UNIX
 	if (stat_ok)
 	{
+	    si->sn_dev_valid = TRUE;
 	    si->sn_dev = st.st_dev;
 	    si->sn_ino = st.st_ino;
 	}
 	else
-	    si->sn_dev = -1;
+	    si->sn_dev_valid = FALSE;
 # endif
 
 	/* Allocate the local script variables to use for this script. */
@@ -3111,9 +3113,8 @@
     /*
      * Call do_cmdline, which will call getsourceline() to get the lines.
      */
-    do_cmdline(NULL, getsourceline, (void *)&cookie,
+    do_cmdline(firstline, getsourceline, (void *)&cookie,
 				     DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_REPEAT);
-
     retval = OK;
 
 #ifdef FEAT_PROFILE
@@ -3145,8 +3146,8 @@
 	verbose_leave();
     }
 #ifdef STARTUPTIME
-    vim_snprintf(IObuff, IOSIZE, "sourcing %s", fname);
-    time_msg(IObuff, &tv_start);
+    vim_snprintf((char *)IObuff, IOSIZE, "sourcing %s", fname);
+    time_msg((char *)IObuff, &tv_start);
     time_pop(&tv_rel);
 #endif
 
@@ -3171,6 +3172,7 @@
 #endif
     fclose(cookie.fp);
     vim_free(cookie.nextline);
+    vim_free(firstline);
 #ifdef FEAT_MBYTE
     convert_setup(&cookie.conv, NULL, NULL);
 #endif
@@ -3185,10 +3187,9 @@
 /*
  * ":scriptnames"
  */
-/*ARGSUSED*/
     void
 ex_scriptnames(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     int i;
 
@@ -3312,12 +3313,11 @@
  * Return a pointer to the line in allocated memory.
  * Return NULL for end-of-file or some error.
  */
-/* ARGSUSED */
     char_u *
 getsourceline(c, cookie, indent)
-    int		c;		/* not used */
+    int		c UNUSED;
     void	*cookie;
-    int		indent;		/* not used */
+    int		indent UNUSED;
 {
     struct source_cookie *sp = (struct source_cookie *)cookie;
     char_u		*line;
@@ -3368,7 +3368,7 @@
 	    p = skipwhite(sp->nextline);
 	    if (*p != '\\')
 		break;
-	    s = alloc((int)(STRLEN(line) + STRLEN(p)));
+	    s = alloc((unsigned)(STRLEN(line) + STRLEN(p)));
 	    if (s == NULL)	/* out of memory */
 		break;
 	    STRCPY(s, line);
@@ -3644,10 +3644,9 @@
  * ":scriptencoding": Set encoding conversion for a sourced script.
  * Without the multi-byte feature it's simply ignored.
  */
-/*ARGSUSED*/
     void
 ex_scriptencoding(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #ifdef FEAT_MBYTE
     struct source_cookie	*sp;
@@ -4096,10 +4095,9 @@
  * Function given to ExpandGeneric() to obtain the possible arguments of the
  * ":language" command.
  */
-/*ARGSUSED*/
     char_u *
 get_lang_arg(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx == 0)
diff -Naur vim72.orig/src/ex_cmds.c vim72/src/ex_cmds.c
--- vim72.orig/src/ex_cmds.c	2008-08-04 20:15:00.000000000 +0100
+++ vim72/src/ex_cmds.c	2009-07-22 22:54:23.000000000 +0100
@@ -24,7 +24,7 @@
 static void do_filter __ARGS((linenr_T line1, linenr_T line2, exarg_T *eap, char_u *cmd, int do_in, int do_out));
 #ifdef FEAT_VIMINFO
 static char_u *viminfo_filename __ARGS((char_u	*));
-static void do_viminfo __ARGS((FILE *fp_in, FILE *fp_out, int want_info, int want_marks, int force_read));
+static void do_viminfo __ARGS((FILE *fp_in, FILE *fp_out, int flags));
 static int viminfo_encoding __ARGS((vir_T *virp));
 static int read_viminfo_up_to_marks __ARGS((vir_T *virp, int forceit, int writing));
 #endif
@@ -43,12 +43,12 @@
 /*
  * ":ascii" and "ga".
  */
-/*ARGSUSED*/
     void
 do_ascii(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     int		c;
+    int		cval;
     char	buf1[20];
     char	buf2[20];
     char_u	buf3[7];
@@ -75,6 +75,10 @@
     {
 	if (c == NL)	    /* NUL is stored as NL */
 	    c = NUL;
+	if (c == CAR && get_fileformat(curbuf) == EOL_MAC)
+	    cval = NL;	    /* NL is stored as CR */
+	else
+	    cval = c;
 	if (vim_isprintc_strict(c) && (c < ' '
 #ifndef EBCDIC
 		    || c > '~'
@@ -82,19 +86,20 @@
 			       ))
 	{
 	    transchar_nonprint(buf3, c);
-	    sprintf(buf1, "  <%s>", (char *)buf3);
+	    vim_snprintf(buf1, sizeof(buf1), "  <%s>", (char *)buf3);
 	}
 	else
 	    buf1[0] = NUL;
 #ifndef EBCDIC
 	if (c >= 0x80)
-	    sprintf(buf2, "  <M-%s>", transchar(c & 0x7f));
+	    vim_snprintf(buf2, sizeof(buf2), "  <M-%s>",
+						 (char *)transchar(c & 0x7f));
 	else
 #endif
 	    buf2[0] = NUL;
 	vim_snprintf((char *)IObuff, IOSIZE,
 		_("<%s>%s%s  %d,  Hex %02x,  Octal %03o"),
-					   transchar(c), buf1, buf2, c, c, c);
+				  transchar(c), buf1, buf2, cval, cval, cval);
 #ifdef FEAT_MBYTE
 	if (enc_utf8)
 	    c = cc[ci++];
@@ -353,7 +358,7 @@
     linenr_T	lnum;
     long	maxlen = 0;
     sorti_T	*nrs;
-    size_t	count = eap->line2 - eap->line1 + 1;
+    size_t	count = (size_t)(eap->line2 - eap->line1 + 1);
     size_t	i;
     char_u	*p;
     char_u	*s;
@@ -952,7 +957,7 @@
 	    }
 	    len += (int)STRLEN(prevcmd);
 	}
-	if ((t = alloc(len)) == NULL)
+	if ((t = alloc((unsigned)len)) == NULL)
 	{
 	    vim_free(newcmd);
 	    return;
@@ -1543,7 +1548,7 @@
      * redirecting input and/or output.
      */
     if (itmp != NULL || otmp != NULL)
-	sprintf((char *)buf, "(%s)", (char *)cmd);
+	vim_snprintf((char *)buf, len, "(%s)", (char *)cmd);
     else
 	STRCPY(buf, cmd);
     if (itmp != NULL)
@@ -1592,37 +1597,41 @@
     }
 #endif
     if (otmp != NULL)
-	append_redir(buf, p_srr, otmp);
+	append_redir(buf, (int)len, p_srr, otmp);
 
     return buf;
 }
 
 /*
- * Append output redirection for file "fname" to the end of string buffer "buf"
+ * Append output redirection for file "fname" to the end of string buffer
+ * "buf[buflen]"
  * Works with the 'shellredir' and 'shellpipe' options.
  * The caller should make sure that there is enough room:
  *	STRLEN(opt) + STRLEN(fname) + 3
  */
     void
-append_redir(buf, opt, fname)
+append_redir(buf, buflen, opt, fname)
     char_u	*buf;
+    int		buflen;
     char_u	*opt;
     char_u	*fname;
 {
     char_u	*p;
+    char_u	*end;
 
-    buf += STRLEN(buf);
+    end = buf + STRLEN(buf);
     /* find "%s", skipping "%%" */
     for (p = opt; (p = vim_strchr(p, '%')) != NULL; ++p)
 	if (p[1] == 's')
 	    break;
     if (p != NULL)
     {
-	*buf = ' '; /* not really needed? Not with sh, ksh or bash */
-	sprintf((char *)buf + 1, (char *)opt, (char *)fname);
+	*end = ' '; /* not really needed? Not with sh, ksh or bash */
+	vim_snprintf((char *)end + 1, (size_t)(buflen - (end + 1 - buf)),
+						  (char *)opt, (char *)fname);
     }
     else
-	sprintf((char *)buf,
+	vim_snprintf((char *)end, (size_t)(buflen - (end - buf)),
 #ifdef FEAT_QUICKFIX
 # ifndef RISCOS
 		opt != p_sp ? " %s%s" :
@@ -1676,14 +1685,12 @@
 
 /*
  * read_viminfo() -- Read the viminfo file.  Registers etc. which are already
- * set are not over-written unless force is TRUE. -- webb
+ * set are not over-written unless "flags" includes VIF_FORCEIT. -- webb
  */
     int
-read_viminfo(file, want_info, want_marks, forceit)
-    char_u	*file;
-    int		want_info;
-    int		want_marks;
-    int		forceit;
+read_viminfo(file, flags)
+    char_u	*file;	    /* file name or NULL to use default name */
+    int		flags;	    /* VIF_WANT_INFO et al. */
 {
     FILE	*fp;
     char_u	*fname;
@@ -1691,7 +1698,7 @@
     if (no_viminfo())
 	return FAIL;
 
-    fname = viminfo_filename(file);	    /* may set to default if NULL */
+    fname = viminfo_filename(file);	/* get file name in allocated buffer */
     if (fname == NULL)
 	return FAIL;
     fp = mch_fopen((char *)fname, READBIN);
@@ -1701,8 +1708,9 @@
 	verbose_enter();
 	smsg((char_u *)_("Reading viminfo file \"%s\"%s%s%s"),
 		fname,
-		want_info ? _(" info") : "",
-		want_marks ? _(" marks") : "",
+		(flags & VIF_WANT_INFO) ? _(" info") : "",
+		(flags & VIF_WANT_MARKS) ? _(" marks") : "",
+		(flags & VIF_GET_OLDFILES) ? _(" oldfiles") : "",
 		fp == NULL ? _(" FAILED") : "");
 	verbose_leave();
     }
@@ -1712,10 +1720,9 @@
 	return FAIL;
 
     viminfo_errcnt = 0;
-    do_viminfo(fp, NULL, want_info, want_marks, forceit);
+    do_viminfo(fp, NULL, flags);
 
     fclose(fp);
-
     return OK;
 }
 
@@ -1786,7 +1793,7 @@
 	 * overwrite a user's viminfo file after a "su root", with a
 	 * viminfo file that the user can't read.
 	 */
-	st_old.st_dev = 0;
+	st_old.st_dev = (dev_t)0;
 	st_old.st_ino = 0;
 	st_old.st_mode = 0600;
 	if (mch_stat((char *)fname, &st_old) == 0
@@ -1943,7 +1950,7 @@
 	     * root.
 	     */
 	    if (fp_out != NULL)
-		(void)fchown(fileno(fp_out), st_old.st_uid, st_old.st_gid);
+		ignored = fchown(fileno(fp_out), st_old.st_uid, st_old.st_gid);
 #endif
 	}
     }
@@ -1968,7 +1975,7 @@
     }
 
     viminfo_errcnt = 0;
-    do_viminfo(fp_in, fp_out, !forceit, !forceit, FALSE);
+    do_viminfo(fp_in, fp_out, forceit ? 0 : (VIF_WANT_INFO | VIF_WANT_MARKS));
 
     fclose(fp_out);	    /* errors are ignored !? */
     if (fp_in != NULL)
@@ -2041,12 +2048,10 @@
  * do_viminfo() -- Should only be called from read_viminfo() & write_viminfo().
  */
     static void
-do_viminfo(fp_in, fp_out, want_info, want_marks, force_read)
+do_viminfo(fp_in, fp_out, flags)
     FILE	*fp_in;
     FILE	*fp_out;
-    int		want_info;
-    int		want_marks;
-    int		force_read;
+    int		flags;
 {
     int		count = 0;
     int		eof = FALSE;
@@ -2061,8 +2066,9 @@
 
     if (fp_in != NULL)
     {
-	if (want_info)
-	    eof = read_viminfo_up_to_marks(&vir, force_read, fp_out != NULL);
+	if (flags & VIF_WANT_INFO)
+	    eof = read_viminfo_up_to_marks(&vir,
+					 flags & VIF_FORCEIT, fp_out != NULL);
 	else
 	    /* Skip info, find start of marks */
 	    while (!(eof = viminfo_readline(&vir))
@@ -2092,8 +2098,9 @@
 	write_viminfo_bufferlist(fp_out);
 	count = write_viminfo_marks(fp_out);
     }
-    if (fp_in != NULL && want_marks)
-	copy_viminfo_marks(&vir, fp_out, count, eof);
+    if (fp_in != NULL
+	    && (flags & (VIF_WANT_MARKS | VIF_GET_OLDFILES | VIF_FORCEIT)))
+	copy_viminfo_marks(&vir, fp_out, count, eof, flags);
 
     vim_free(vir.vir_line);
 #ifdef FEAT_MBYTE
@@ -2248,12 +2255,11 @@
  *
  * Return the string in allocated memory (NULL when out of memory).
  */
-/*ARGSUSED*/
     char_u *
 viminfo_readstring(virp, off, convert)
     vir_T	*virp;
     int		off;		    /* offset for virp->vir_line */
-    int		convert;	    /* convert the string */
+    int		convert UNUSED;	    /* convert the string */
 {
     char_u	*retval;
     char_u	*s, *d;
@@ -2365,10 +2371,9 @@
  *   ^?		^H
  * not ^?	^?
  */
-/*ARGSUSED*/
     void
 do_fixdel(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     char_u  *p;
 
@@ -2387,7 +2392,8 @@
 
     if (curwin->w_p_nu || use_number)
     {
-	sprintf((char *)numbuf, "%*ld ", number_width(curwin), (long)lnum);
+	vim_snprintf((char *)numbuf, sizeof(numbuf),
+				   "%*ld ", number_width(curwin), (long)lnum);
 	msg_puts_attr(numbuf, hl_attr(HLF_N));	/* Highlight line nrs */
     }
     msg_prt_line(ml_get(lnum), list);
@@ -2414,8 +2420,8 @@
 	cursor_on();		/* msg_start() switches it off */
 	out_flush();
 	silent_mode = save_silent;
-	info_message = FALSE;
     }
+    info_message = FALSE;
 }
 
 /*
@@ -2704,7 +2710,12 @@
 	if (eap->cmdidx == CMD_saveas)
 	{
 	    if (retval == OK)
+	    {
 		curbuf->b_p_ro = FALSE;
+#ifdef FEAT_WINDOWS
+		redraw_tabline = TRUE;
+#endif
+	    }
 	    /* Change directories when the 'acd' option is set. */
 	    DO_AUTOCHDIR
 	}
@@ -2724,7 +2735,6 @@
  * May set eap->forceit if a dialog says it's OK to overwrite.
  * Return OK if it's OK, FAIL if it is not.
  */
-/*ARGSUSED*/
     static int
 check_overwrite(eap, buf, fname, ffname, other)
     exarg_T	*eap;
@@ -3054,7 +3064,8 @@
 	retval = 0;	/* it's in the same file */
     }
     else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,
-		(P_HID(curbuf) ? ECMD_HIDE : 0) + (forceit ? ECMD_FORCEIT : 0)) == OK)
+		(P_HID(curbuf) ? ECMD_HIDE : 0) + (forceit ? ECMD_FORCEIT : 0),
+		curwin) == OK)
 	retval = -1;	/* opened another file */
     else
 	retval = 1;	/* error encountered */
@@ -3087,17 +3098,21 @@
  *	 ECMD_OLDBUF: use existing buffer if it exists
  *	ECMD_FORCEIT: ! used for Ex command
  *	 ECMD_ADDBUF: don't edit, just add to buffer list
+ *   oldwin: Should be "curwin" when editing a new buffer in the current
+ *           window, NULL when splitting the window first.  When not NULL info
+ *           of the previous buffer for "oldwin" is stored.
  *
  * return FAIL for failure, OK otherwise
  */
     int
-do_ecmd(fnum, ffname, sfname, eap, newlnum, flags)
+do_ecmd(fnum, ffname, sfname, eap, newlnum, flags, oldwin)
     int		fnum;
     char_u	*ffname;
     char_u	*sfname;
     exarg_T	*eap;			/* can be NULL! */
     linenr_T	newlnum;
     int		flags;
+    win_T	*oldwin;
 {
     int		other_file;		/* TRUE if editing another file */
     int		oldbuf;			/* TRUE if using existing buffer */
@@ -3269,7 +3284,8 @@
 	{
 	    if (!cmdmod.keepalt)
 		curwin->w_alt_fnum = curbuf->b_fnum;
-	    buflist_altfpos();
+	    if (oldwin != NULL)
+		buflist_altfpos(oldwin);
 	}
 
 	if (fnum)
@@ -3373,7 +3389,7 @@
 
 		/* close the link to the current buffer */
 		u_sync(FALSE);
-		close_buffer(curwin, curbuf,
+		close_buffer(oldwin, curbuf,
 				      (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD);
 
 #ifdef FEAT_AUTOCMD
@@ -3701,7 +3717,7 @@
     /* If the window options were changed may need to set the spell language.
      * Can only do this after the buffer has been properly setup. */
     if (did_get_winopts && curwin->w_p_spell && *curbuf->b_p_spl != NUL)
-	did_set_spelllang(curbuf);
+	(void)did_set_spelllang(curbuf);
 #endif
 
     if (command == NULL)
@@ -3774,7 +3790,7 @@
 
 #ifdef FEAT_KEYMAP
     if (curbuf->b_kmap_state & KEYMAP_INIT)
-	keymap_init();
+	(void)keymap_init();
 #endif
 
     --RedrawingDisabled;
@@ -3997,6 +4013,9 @@
 	    break;
 	ml_delete(eap->line1, FALSE);
     }
+
+    /* make sure the cursor is not beyond the end of the file now */
+    check_cursor_lnum();
     deleted_lines_mark(eap->line1, (long)(eap->line2 - lnum));
 
     /* ":append" on the line above the deleted lines. */
@@ -4022,8 +4041,10 @@
 	bigness = curwin->w_height;
     else if (firstwin == lastwin)
 	bigness = curwin->w_p_scr * 2;
+#ifdef FEAT_WINDOWS
     else
 	bigness = curwin->w_height - 3;
+#endif
     if (bigness < 1)
 	bigness = 1;
 
@@ -4472,7 +4493,7 @@
 	    char_u	*p1;
 	    int		did_sub = FALSE;
 	    int		lastone;
-	    unsigned	len, needed_len;
+	    int		len, copy_len, needed_len;
 	    long	nmatch_tl = 0;	/* nr of lines matched below lnum */
 	    int		do_again;	/* do it again after joining lines */
 	    int		skip_match = FALSE;
@@ -4617,6 +4638,8 @@
 
 		if (do_ask)
 		{
+		    int typed = 0;
+
 		    /* change State to CONFIRM, so that the mouse works
 		     * properly */
 		    save_State = State;
@@ -4655,7 +4678,7 @@
 			    resp = getexmodeline('?', NULL, 0);
 			    if (resp != NULL)
 			    {
-				i = *resp;
+				typed = *resp;
 				vim_free(resp);
 			    }
 			}
@@ -4707,7 +4730,7 @@
 #endif
 			    ++no_mapping;	/* don't map this key */
 			    ++allow_keys;	/* allow special keys */
-			    i = plain_vgetc();
+			    typed = plain_vgetc();
 			    --allow_keys;
 			    --no_mapping;
 
@@ -4718,35 +4741,35 @@
 			}
 
 			need_wait_return = FALSE; /* no hit-return prompt */
-			if (i == 'q' || i == ESC || i == Ctrl_C
+			if (typed == 'q' || typed == ESC || typed == Ctrl_C
 #ifdef UNIX
-				|| i == intr_char
+				|| typed == intr_char
 #endif
 				)
 			{
 			    got_quit = TRUE;
 			    break;
 			}
-			if (i == 'n')
+			if (typed == 'n')
 			    break;
-			if (i == 'y')
+			if (typed == 'y')
 			    break;
-			if (i == 'l')
+			if (typed == 'l')
 			{
 			    /* last: replace and then stop */
 			    do_all = FALSE;
 			    line2 = lnum;
 			    break;
 			}
-			if (i == 'a')
+			if (typed == 'a')
 			{
 			    do_ask = FALSE;
 			    break;
 			}
 #ifdef FEAT_INS_EXPAND
-			if (i == Ctrl_E)
+			if (typed == Ctrl_E)
 			    scrollup_clamp();
-			else if (i == Ctrl_Y)
+			else if (typed == Ctrl_Y)
 			    scrolldown_clamp();
 #endif
 		    }
@@ -4757,7 +4780,7 @@
 		    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)
 			--no_u_sync;
 
-		    if (i == 'n')
+		    if (typed == 'n')
 		    {
 			/* For a multi-line match, put matchcol at the NUL at
 			 * the end of the line and set nmatch to one, so that
@@ -4808,9 +4831,9 @@
 		    p1 = ml_get(sub_firstlnum + nmatch - 1);
 		    nmatch_tl += nmatch - 1;
 		}
-		i = regmatch.startpos[0].col - copycol;
-		needed_len = i + ((unsigned)STRLEN(p1) - regmatch.endpos[0].col)
-								 + sublen + 1;
+		copy_len = regmatch.startpos[0].col - copycol;
+		needed_len = copy_len + ((unsigned)STRLEN(p1)
+				       - regmatch.endpos[0].col) + sublen + 1;
 		if (new_start == NULL)
 		{
 		    /*
@@ -4833,7 +4856,7 @@
 		     */
 		    len = (unsigned)STRLEN(new_start);
 		    needed_len += len;
-		    if (needed_len > new_start_len)
+		    if (needed_len > (int)new_start_len)
 		    {
 			new_start_len = needed_len + 50;
 			if ((p1 = alloc_check(new_start_len)) == NULL)
@@ -4851,8 +4874,8 @@
 		/*
 		 * copy the text up to the part that matched
 		 */
-		mch_memmove(new_end, sub_firstline + copycol, (size_t)i);
-		new_end += i;
+		mch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);
+		new_end += copy_len;
 
 		(void)vim_regsub_multi(&regmatch,
 				    sub_firstlnum - regmatch.startpos[0].lnum,
@@ -5059,6 +5082,7 @@
 
 	    if (did_sub)
 		++sub_nlines;
+	    vim_free(new_start);	/* for when substitute was cancelled */
 	    vim_free(sub_firstline);	/* free the copy of the original line */
 	    sub_firstline = NULL;
 	}
@@ -5610,7 +5634,13 @@
 	     */
 	    alt_fnum = curbuf->b_fnum;
 	    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_LASTL,
-						   ECMD_HIDE + ECMD_SET_HELP);
+			  ECMD_HIDE + ECMD_SET_HELP,
+#ifdef FEAT_WINDOWS
+			  NULL  /* buffer is still open, don't store info */
+#else
+			  curwin
+#endif
+		    );
 	    if (!cmdmod.keepalt)
 		curwin->w_alt_fnum = alt_fnum;
 	    empty_fnum = curbuf->b_fnum;
@@ -5769,7 +5799,7 @@
      * Recognize a few exceptions to the rule.	Some strings that contain '*'
      * with "star".  Otherwise '*' is recognized as a wildcard.
      */
-    for (i = sizeof(mtable) / sizeof(char *); --i >= 0; )
+    for (i = (int)(sizeof(mtable) / sizeof(char *)); --i >= 0; )
 	if (STRCMP(arg, mtable[i]) == 0)
 	{
 	    STRCPY(d, rtable[i]);
@@ -6093,10 +6123,9 @@
 /*
  * ":exusage"
  */
-/*ARGSUSED*/
     void
 ex_exusage(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     do_cmdline_cmd((char_u *)"help ex-cmd-index");
 }
@@ -6104,10 +6133,9 @@
 /*
  * ":viusage"
  */
-/*ARGSUSED*/
     void
 ex_viusage(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     do_cmdline_cmd((char_u *)"help normal-index");
 }
@@ -6519,22 +6547,11 @@
 static sign_T	*first_sign = NULL;
 static int	last_sign_typenr = MAX_TYPENR;	/* is decremented */
 
+static int sign_cmd_idx __ARGS((char_u *begin_cmd, char_u *end_cmd));
 static void sign_list_defined __ARGS((sign_T *sp));
+static void sign_undefine __ARGS((sign_T *sp, sign_T *sp_prev));
 
-/*
- * ":sign" command
- */
-    void
-ex_sign(eap)
-    exarg_T	*eap;
-{
-    char_u	*arg = eap->arg;
-    char_u	*p;
-    int		idx;
-    sign_T	*sp;
-    sign_T	*sp_prev;
-    buf_T	*buf;
-    static char	*cmds[] = {
+static char *cmds[] = {
 			"define",
 #define SIGNCMD_DEFINE	0
 			"undefine",
@@ -6547,22 +6564,51 @@
 #define SIGNCMD_UNPLACE	4
 			"jump",
 #define SIGNCMD_JUMP	5
+			NULL
 #define SIGNCMD_LAST	6
-    };
+};
+
+/*
+ * Find index of a ":sign" subcmd from its name.
+ * "*end_cmd" must be writable.
+ */
+    static int
+sign_cmd_idx(begin_cmd, end_cmd)
+    char_u	*begin_cmd;	/* begin of sign subcmd */
+    char_u	*end_cmd;	/* just after sign subcmd */
+{
+    int		idx;
+    char	save = *end_cmd;
+
+    *end_cmd = NUL;
+    for (idx = 0; ; ++idx)
+	if (cmds[idx] == NULL || STRCMP(begin_cmd, cmds[idx]) == 0)
+	    break;
+    *end_cmd = save;
+    return idx;
+}
+
+/*
+ * ":sign" command
+ */
+    void
+ex_sign(eap)
+    exarg_T	*eap;
+{
+    char_u	*arg = eap->arg;
+    char_u	*p;
+    int		idx;
+    sign_T	*sp;
+    sign_T	*sp_prev;
+    buf_T	*buf;
 
     /* Parse the subcommand. */
     p = skiptowhite(arg);
-    if (*p != NUL)
-	*p++ = NUL;
-    for (idx = 0; ; ++idx)
+    idx = sign_cmd_idx(arg, p);
+    if (idx == SIGNCMD_LAST)
     {
-	if (idx == SIGNCMD_LAST)
-	{
-	    EMSG2(_("E160: Unknown sign command: %s"), arg);
-	    return;
-	}
-	if (STRCMP(arg, cmds[idx]) == 0)
-	    break;
+	EMSG2(_("E160: Unknown sign command: %s"), arg);
+	return;
     }
     arg = skipwhite(p);
 
@@ -6728,24 +6774,8 @@
 		/* ":sign list {name}" */
 		sign_list_defined(sp);
 	    else
-	    {
 		/* ":sign undefine {name}" */
-		vim_free(sp->sn_name);
-		vim_free(sp->sn_icon);
-#ifdef FEAT_SIGN_ICONS
-		if (sp->sn_image != NULL)
-		{
-		    out_flush();
-		    gui_mch_destroy_sign(sp->sn_image);
-		}
-#endif
-		vim_free(sp->sn_text);
-		if (sp_prev == NULL)
-		    first_sign = sp->sn_next;
-		else
-		    sp_prev->sn_next = sp->sn_next;
-		vim_free(sp);
-	    }
+		sign_undefine(sp, sp_prev);
 	}
     }
     else
@@ -6994,6 +7024,31 @@
 }
 
 /*
+ * Undefine a sign and free its memory.
+ */
+    static void
+sign_undefine(sp, sp_prev)
+    sign_T	*sp;
+    sign_T	*sp_prev;
+{
+    vim_free(sp->sn_name);
+    vim_free(sp->sn_icon);
+#ifdef FEAT_SIGN_ICONS
+    if (sp->sn_image != NULL)
+    {
+	out_flush();
+	gui_mch_destroy_sign(sp->sn_image);
+    }
+#endif
+    vim_free(sp->sn_text);
+    if (sp_prev == NULL)
+	first_sign = sp->sn_next;
+    else
+	sp_prev->sn_next = sp->sn_next;
+    vim_free(sp);
+}
+
+/*
  * Get highlighting attribute for sign "typenr".
  * If "line" is TRUE: line highl, if FALSE: text highl.
  */
@@ -7067,6 +7122,197 @@
     return (char_u *)_("[Deleted]");
 }
 
+#if defined(EXITFREE) || defined(PROTO)
+/*
+ * Undefine/free all signs.
+ */
+    void
+free_signs()
+{
+    while (first_sign != NULL)
+	sign_undefine(first_sign, NULL);
+}
+#endif
+
+#if defined(FEAT_CMDL_COMPL) || defined(PROTO)
+static enum
+{
+    EXP_SUBCMD,		/* expand :sign sub-commands */
+    EXP_DEFINE,		/* expand :sign define {name} args */
+    EXP_PLACE,		/* expand :sign place {id} args */
+    EXP_UNPLACE,	/* expand :sign unplace" */
+    EXP_SIGN_NAMES	/* expand with name of placed signs */
+} expand_what;
+
+/*
+ * Function given to ExpandGeneric() to obtain the sign command
+ * expansion.
+ */
+    char_u *
+get_sign_name(xp, idx)
+    expand_T	*xp UNUSED;
+    int		idx;
+{
+    sign_T	*sp;
+    int		current_idx;
+
+    switch (expand_what)
+    {
+    case EXP_SUBCMD:
+	return (char_u *)cmds[idx];
+    case EXP_DEFINE:
+	{
+	    char *define_arg[] =
+	    {
+		"icon=", "linehl=", "text=", "texthl=", NULL
+	    };
+	    return (char_u *)define_arg[idx];
+	}
+    case EXP_PLACE:
+	{
+	    char *place_arg[] =
+	    {
+		"line=", "name=", "file=", "buffer=", NULL
+	    };
+	    return (char_u *)place_arg[idx];
+	}
+    case EXP_UNPLACE:
+	{
+	    char *unplace_arg[] = { "file=", "buffer=", NULL };
+	    return (char_u *)unplace_arg[idx];
+	}
+    case EXP_SIGN_NAMES:
+	/* Complete with name of signs already defined */
+	current_idx = 0;
+	for (sp = first_sign; sp != NULL; sp = sp->sn_next)
+	    if (current_idx++ == idx)
+		return sp->sn_name;
+	return NULL;
+    default:
+	return NULL;
+    }
+}
+
+/*
+ * Handle command line completion for :sign command.
+ */
+    void
+set_context_in_sign_cmd(xp, arg)
+    expand_T	*xp;
+    char_u	*arg;
+{
+    char_u	*p;
+    char_u	*end_subcmd;
+    char_u	*last;
+    int		cmd_idx;
+    char_u	*begin_subcmd_args;
+
+    /* Default: expand subcommands. */
+    xp->xp_context = EXPAND_SIGN;
+    expand_what = EXP_SUBCMD;
+    xp->xp_pattern = arg;
+
+    end_subcmd = skiptowhite(arg);
+    if (*end_subcmd == NUL)
+	/* expand subcmd name
+	 * :sign {subcmd}<CTRL-D>*/
+	return;
+
+    cmd_idx = sign_cmd_idx(arg, end_subcmd);
+
+    /* :sign {subcmd} {subcmd_args}
+     *                |
+     *                begin_subcmd_args */
+    begin_subcmd_args = skipwhite(end_subcmd);
+    p = skiptowhite(begin_subcmd_args);
+    if (*p == NUL)
+    {
+	/*
+	 * Expand first argument of subcmd when possible.
+	 * For ":jump {id}" and ":unplace {id}", we could
+	 * possibly expand the ids of all signs already placed.
+	 */
+	xp->xp_pattern = begin_subcmd_args;
+	switch (cmd_idx)
+	{
+	    case SIGNCMD_LIST:
+	    case SIGNCMD_UNDEFINE:
+		/* :sign list <CTRL-D>
+		 * :sign undefine <CTRL-D> */
+		expand_what = EXP_SIGN_NAMES;
+		break;
+	    default:
+		xp->xp_context = EXPAND_NOTHING;
+	}
+	return;
+    }
+
+    /* expand last argument of subcmd */
+
+    /* :sign define {name} {args}...
+     *              |
+     *              p */
+
+    /* Loop until reaching last argument. */
+    do
+    {
+	p = skipwhite(p);
+	last = p;
+	p = skiptowhite(p);
+    } while (*p != NUL);
+
+    p = vim_strchr(last, '=');
+
+    /* :sign define {name} {args}... {last}=
+     *                               |     |
+     *                            last     p */
+    if (p == NUL)
+    {
+	/* Expand last argument name (before equal sign). */
+	xp->xp_pattern = last;
+	switch (cmd_idx)
+	{
+	    case SIGNCMD_DEFINE:
+		expand_what = EXP_DEFINE;
+		break;
+	    case SIGNCMD_PLACE:
+		expand_what = EXP_PLACE;
+		break;
+	    case SIGNCMD_JUMP:
+	    case SIGNCMD_UNPLACE:
+		expand_what = EXP_UNPLACE;
+		break;
+	    default:
+		xp->xp_context = EXPAND_NOTHING;
+	}
+    }
+    else
+    {
+	/* Expand last argument value (after equal sign). */
+	xp->xp_pattern = p + 1;
+	switch (cmd_idx)
+	{
+	    case SIGNCMD_DEFINE:
+		if (STRNCMP(last, "texthl", p - last) == 0 ||
+		    STRNCMP(last, "linehl", p - last) == 0)
+		    xp->xp_context = EXPAND_HIGHLIGHT;
+		else if (STRNCMP(last, "icon", p - last) == 0)
+		    xp->xp_context = EXPAND_FILES;
+		else
+		    xp->xp_context = EXPAND_NOTHING;
+		break;
+	    case SIGNCMD_PLACE:
+		if (STRNCMP(last, "name", p - last) == 0)
+		    expand_what = EXP_SIGN_NAMES;
+		else
+		    xp->xp_context = EXPAND_NOTHING;
+		break;
+	    default:
+		xp->xp_context = EXPAND_NOTHING;
+	}
+    }
+}
+#endif
 #endif
 
 #if defined(FEAT_GUI) || defined(FEAT_CLIENTSERVER) || defined(PROTO)
diff -Naur vim72.orig/src/ex_cmds.h vim72/src/ex_cmds.h
--- vim72.orig/src/ex_cmds.h	2008-06-21 19:47:57.000000000 +0100
+++ vim72/src/ex_cmds.h	2009-07-22 22:54:23.000000000 +0100
@@ -278,7 +278,7 @@
 EX(CMD_crewind,		"crewind",	ex_cc,
 			RANGE|NOTADR|COUNT|TRLBAR|BANG),
 EX(CMD_cscope,		"cscope",	do_cscope,
-			EXTRA|NOTRLCOM|SBOXOK|XFILE),
+			EXTRA|NOTRLCOM|XFILE),
 EX(CMD_cstag,		"cstag",	do_cstag,
 			BANG|TRLBAR|WORD1),
 EX(CMD_cunmap,		"cunmap",	ex_unmap,
@@ -506,7 +506,7 @@
 EX(CMD_lclose,		"lclose",	ex_cclose,
 			RANGE|NOTADR|COUNT|TRLBAR),
 EX(CMD_lcscope,		"lcscope",	do_cscope,
-			EXTRA|NOTRLCOM|SBOXOK|XFILE),
+			EXTRA|NOTRLCOM|XFILE),
 EX(CMD_left,		"left",		ex_align,
 			TRLBAR|RANGE|WHOLEFOLD|EXTRA|CMDWIN|MODIFY),
 EX(CMD_leftabove,	"leftabove",	ex_wrongmodifier,
@@ -635,6 +635,8 @@
 			RANGE|NOTADR|ZEROR|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_noremap,		"noremap",	ex_map,
 			BANG|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
+EX(CMD_noautocmd,	"noautocmd",	ex_wrongmodifier,
+			NEEDARG|EXTRA|NOTRLCOM),
 EX(CMD_nohlsearch,	"nohlsearch",	ex_nohlsearch,
 			TRLBAR|SBOXOK|CMDWIN),
 EX(CMD_noreabbrev,	"noreabbrev",	ex_abbreviate,
@@ -651,6 +653,8 @@
 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_open,		"open",		ex_open,
 			RANGE|EXTRA),
+EX(CMD_oldfiles,	"oldfiles",	ex_oldfiles,
+			BANG|TRLBAR|SBOXOK|CMDWIN),
 EX(CMD_omap,		"omap",		ex_map,
 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_omapclear,	"omapclear",	ex_mapclear,
@@ -802,7 +806,7 @@
 EX(CMD_scriptencoding,	"scriptencoding", ex_scriptencoding,
 			WORD1|TRLBAR|CMDWIN),
 EX(CMD_scscope,		"scscope",	do_scscope,
-			EXTRA|NOTRLCOM|SBOXOK),
+			EXTRA|NOTRLCOM),
 EX(CMD_set,		"set",		ex_set,
 			TRLBAR|EXTRA|CMDWIN|SBOXOK),
 EX(CMD_setfiletype,	"setfiletype",	ex_setfiletype,
@@ -987,6 +991,8 @@
 			BANG|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
 EX(CMD_unmenu,		"unmenu",	ex_menu,
 			BANG|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN),
+EX(CMD_unsilent,	"unsilent",	ex_wrongmodifier,
+			NEEDARG|EXTRA|NOTRLCOM|SBOXOK|CMDWIN),
 EX(CMD_update,		"update",	ex_update,
 			RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|DFLALL|TRLBAR),
 EX(CMD_vglobal,		"vglobal",	ex_global,
diff -Naur vim72.orig/src/ex_docmd.c vim72/src/ex_docmd.c
--- vim72.orig/src/ex_docmd.c	2008-07-26 12:51:05.000000000 +0100
+++ vim72/src/ex_docmd.c	2009-07-22 22:54:23.000000000 +0100
@@ -364,6 +364,7 @@
 # define ex_function		ex_ni
 # define ex_delfunction		ex_ni
 # define ex_return		ex_ni
+# define ex_oldfiles		ex_ni
 #endif
 static char_u	*arg_all __ARGS((void));
 #ifdef FEAT_SESSION
@@ -1577,11 +1578,10 @@
  * If "fgetline" is get_loop_line(), return TRUE if the getline it uses equals
  * "func".  * Otherwise return TRUE when "fgetline" equals "func".
  */
-/*ARGSUSED*/
     int
 getline_equal(fgetline, cookie, func)
     char_u	*(*fgetline) __ARGS((int, void *, int));
-    void	*cookie;		/* argument for fgetline() */
+    void	*cookie UNUSED;		/* argument for fgetline() */
     char_u	*(*func) __ARGS((int, void *, int));
 {
 #ifdef FEAT_EVAL
@@ -1609,10 +1609,9 @@
  * If "fgetline" is get_loop_line(), return the cookie used by the original
  * getline function.  Otherwise return "cookie".
  */
-/*ARGSUSED*/
     void *
 getline_cookie(fgetline, cookie)
-    char_u	*(*fgetline) __ARGS((int, void *, int));
+    char_u	*(*fgetline) __ARGS((int, void *, int)) UNUSED;
     void	*cookie;		/* argument for fgetline() */
 {
 # ifdef FEAT_EVAL
@@ -1678,8 +1677,8 @@
     char_u		*errormsg = NULL;	/* error message */
     exarg_T		ea;			/* Ex command arguments */
     long		verbose_save = -1;
-    int			save_msg_scroll = 0;
-    int			did_silent = 0;
+    int			save_msg_scroll = msg_scroll;
+    int			save_msg_silent = -1;
     int			did_esilent = 0;
 #ifdef HAVE_SANDBOX
     int			did_sandbox = FALSE;
@@ -1770,7 +1769,7 @@
 			}
 			if (checkforcmd(&ea.cmd, "browse", 3))
 			{
-#ifdef FEAT_BROWSE
+#ifdef FEAT_BROWSE_CMD
 			    cmdmod.browse = TRUE;
 #endif
 			    continue;
@@ -1857,9 +1856,9 @@
 			}
 			if (!checkforcmd(&ea.cmd, "silent", 3))
 			    break;
-			++did_silent;
+			if (save_msg_silent == -1)
+			    save_msg_silent = msg_silent;
 			++msg_silent;
-			save_msg_scroll = msg_scroll;
 			if (*ea.cmd == '!' && !vim_iswhite(ea.cmd[-1]))
 			{
 			    /* ":silent!", but not "silent !cmd" */
@@ -1887,6 +1886,13 @@
 #endif
 			continue;
 
+	    case 'u':	if (!checkforcmd(&ea.cmd, "unsilent", 3))
+			    break;
+			if (save_msg_silent == -1)
+			    save_msg_silent = msg_silent;
+			msg_silent = 0;
+			continue;
+
 	    case 'v':	if (checkforcmd(&ea.cmd, "vertical", 4))
 			{
 #ifdef FEAT_VERTSPLIT
@@ -2685,19 +2691,23 @@
 
     cmdmod = save_cmdmod;
 
-    if (did_silent > 0)
+    if (save_msg_silent != -1)
     {
 	/* messages could be enabled for a serious error, need to check if the
 	 * counters don't become negative */
-	msg_silent -= did_silent;
-	if (msg_silent < 0)
-	    msg_silent = 0;
+	if (!did_emsg)
+	    msg_silent = save_msg_silent;
 	emsg_silent -= did_esilent;
 	if (emsg_silent < 0)
 	    emsg_silent = 0;
 	/* Restore msg_scroll, it's set by file I/O commands, even when no
 	 * message is actually displayed. */
 	msg_scroll = save_msg_scroll;
+
+	/* "silent reg" or "silent echo x" inside "redir" leaves msg_col
+	 * somewhere in the line.  Put it back in the first column. */
+	if (redirecting())
+	    msg_col = 0;
     }
 
 #ifdef HAVE_SANDBOX
@@ -2731,7 +2741,7 @@
     int		i;
 
     for (i = 0; cmd[i] != NUL; ++i)
-	if (cmd[i] != (*pp)[i])
+	if (((char_u *)cmd)[i] != (*pp)[i])
 	    break;
     if (i >= len && !isalpha((*pp)[i]))
     {
@@ -2748,11 +2758,10 @@
  * "full" is set to TRUE if the whole command name matched.
  * Returns NULL for an ambiguous user command.
  */
-/*ARGSUSED*/
     static char_u *
 find_command(eap, full)
     exarg_T	*eap;
-    int		*full;
+    int		*full UNUSED;
 {
     int		len;
     char_u	*p;
@@ -2797,7 +2806,7 @@
 	    /* Check for ":dl", ":dell", etc. to ":deletel": that's
 	     * :delete with the 'l' flag.  Same for 'p'. */
 	    for (i = 0; i < len; ++i)
-		if (eap->cmd[i] != "delete"[i])
+		if (eap->cmd[i] != ((char_u *)"delete")[i])
 		    break;
 	    if (i == len - 1)
 	    {
@@ -2978,11 +2987,13 @@
     {"keepmarks", 3, FALSE},
     {"leftabove", 5, FALSE},
     {"lockmarks", 3, FALSE},
+    {"noautocmd", 3, FALSE},
     {"rightbelow", 6, FALSE},
     {"sandbox", 3, FALSE},
     {"silent", 3, FALSE},
     {"tab", 3, TRUE},
     {"topleft", 2, FALSE},
+    {"unsilent", 3, FALSE},
     {"verbose", 4, TRUE},
     {"vertical", 4, FALSE},
 };
@@ -3000,7 +3011,7 @@
 
     if (VIM_ISDIGIT(*cmd))
 	p = skipwhite(skipdigits(cmd));
-    for (i = 0; i < sizeof(cmdmods) / sizeof(struct cmdmod); ++i)
+    for (i = 0; i < (int)(sizeof(cmdmods) / sizeof(struct cmdmod)); ++i)
     {
 	for (j = 0; p[j] != NUL; ++j)
 	    if (p[j] != cmdmods[i].name[j])
@@ -3028,7 +3039,7 @@
     char_u	*p;
 
     /* Check command modifiers. */
-    for (i = 0; i < sizeof(cmdmods) / sizeof(struct cmdmod); ++i)
+    for (i = 0; i < (int)(sizeof(cmdmods) / sizeof(struct cmdmod)); ++i)
     {
 	for (j = 0; name[j] != NUL; ++j)
 	    if (name[j] != cmdmods[i].name[j])
@@ -3608,6 +3619,7 @@
 	    return set_context_in_autocmd(xp, arg, FALSE);
 
 	case CMD_doautocmd:
+	case CMD_doautoall:
 	    return set_context_in_autocmd(xp, arg, TRUE);
 #endif
 	case CMD_set:
@@ -3680,6 +3692,18 @@
 	case CMD_highlight:
 	    set_context_in_highlight_cmd(xp, arg);
 	    break;
+#ifdef FEAT_CSCOPE
+	case CMD_cscope:
+	case CMD_lcscope:
+	case CMD_scscope:
+	    set_context_in_cscope_cmd(xp, arg, ea.cmdidx);
+	    break;
+#endif
+#ifdef FEAT_SIGNS
+	case CMD_sign:
+	    set_context_in_sign_cmd(xp, arg);
+	    break;
+#endif
 #ifdef FEAT_LISTCMDS
 	case CMD_bdelete:
 	case CMD_bwipeout:
@@ -3803,7 +3827,7 @@
     char_u	*cmd;
     int		*ctx;	/* pointer to xp_context or NULL */
 {
-    int		delim;
+    unsigned	delim;
 
     while (vim_strchr((char_u *)" \t0123456789.$%'/?-+,;", *cmd) != NULL)
     {
@@ -5033,10 +5057,9 @@
 /*
  * Function given to ExpandGeneric() to obtain the list of command names.
  */
-/*ARGSUSED*/
     char_u *
 get_command_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx >= (int)CMD_SIZE)
@@ -5121,7 +5144,11 @@
 	    }
 
 	    vim_free(cmd->uc_rep);
-	    cmd->uc_rep = 0;
+	    cmd->uc_rep = NULL;
+#if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
+	    vim_free(cmd->uc_compl_arg);
+	    cmd->uc_compl_arg = NULL;
+#endif
 	    break;
 	}
 
@@ -5180,6 +5207,9 @@
     {EXPAND_AUGROUP, "augroup"},
     {EXPAND_BUFFERS, "buffer"},
     {EXPAND_COMMANDS, "command"},
+#if defined(FEAT_CSCOPE)
+    {EXPAND_CSCOPE, "cscope"},
+#endif
 #if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
     {EXPAND_USER_DEFINED, "custom"},
     {EXPAND_USER_LIST, "customlist"},
@@ -5196,6 +5226,9 @@
     {EXPAND_MENUS, "menu"},
     {EXPAND_SETTINGS, "option"},
     {EXPAND_SHELLCMD, "shellcmd"},
+#if defined(FEAT_SIGNS)
+    {EXPAND_SIGN, "sign"},
+#endif
     {EXPAND_TAGS, "tag"},
     {EXPAND_TAGS_LISTFILES, "tag_listfiles"},
     {EXPAND_USER_VARS, "var"},
@@ -5479,6 +5512,9 @@
     return OK;
 }
 
+/*
+ * ":command ..."
+ */
     static void
 ex_command(eap)
     exarg_T   *eap;
@@ -5540,10 +5576,9 @@
  * ":comclear"
  * Clear all user commands, global and for current buffer.
  */
-/*ARGSUSED*/
     void
 ex_comclear(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     uc_clear(&ucmds);
     uc_clear(&curbuf->b_ucmds);
@@ -5910,7 +5945,8 @@
     char_u	*q;
 
     char_u	*start;
-    char_u	*end;
+    char_u	*end = NULL;
+    char_u	*ksp;
     size_t	len, totlen;
 
     size_t	split_len = 0;
@@ -5927,16 +5963,51 @@
 
     /*
      * Replace <> in the command by the arguments.
+     * First round: "buf" is NULL, compute length, allocate "buf".
+     * Second round: copy result into "buf".
      */
     buf = NULL;
     for (;;)
     {
-	p = cmd->uc_rep;
-	q = buf;
+	p = cmd->uc_rep;    /* source */
+	q = buf;	    /* destination */
 	totlen = 0;
-	while ((start = vim_strchr(p, '<')) != NULL
-	       && (end = vim_strchr(start + 1, '>')) != NULL)
+
+	for (;;)
 	{
+	    start = vim_strchr(p, '<');
+	    if (start != NULL)
+		end = vim_strchr(start + 1, '>');
+	    if (buf != NULL)
+	    {
+		ksp = vim_strchr(p, K_SPECIAL);
+		if (ksp != NULL && (start == NULL || ksp < start || end == NULL)
+			&& ((ksp[1] == KS_SPECIAL && ksp[2] == KE_FILLER)
+# ifdef FEAT_GUI
+			    || (ksp[1] == KS_EXTRA && ksp[2] == (int)KE_CSI)
+# endif
+			    ))
+		{
+		    /* K_SPECIAL han been put in the buffer as K_SPECIAL
+		     * KS_SPECIAL KE_FILLER, like for mappings, but
+		     * do_cmdline() doesn't handle that, so convert it back.
+		     * Also change K_SPECIAL KS_EXTRA KE_CSI into CSI. */
+		    len = ksp - p;
+		    if (len > 0)
+		    {
+			mch_memmove(q, p, len);
+			q += len;
+		    }
+		    *q++ = ksp[1] == KS_SPECIAL ? K_SPECIAL : CSI;
+		    p = ksp + 3;
+		    continue;
+		}
+	    }
+
+	    /* break if there no <item> is found */
+	    if (start == NULL || end == NULL)
+		break;
+
 	    /* Include the '>' */
 	    ++end;
 
@@ -6003,10 +6074,9 @@
 /*
  * Function given to ExpandGeneric() to obtain the list of user command names.
  */
-/*ARGSUSED*/
     char_u *
 get_user_commands(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx < curbuf->b_ucmds.ga_len)
@@ -6021,17 +6091,16 @@
  * Function given to ExpandGeneric() to obtain the list of user command
  * attributes.
  */
-/*ARGSUSED*/
     char_u *
 get_user_cmd_flags(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     static char *user_cmd_flags[] =
 	{"bang", "bar", "buffer", "complete", "count",
 	    "nargs", "range", "register"};
 
-    if (idx >= sizeof(user_cmd_flags) / sizeof(user_cmd_flags[0]))
+    if (idx >= (int)(sizeof(user_cmd_flags) / sizeof(user_cmd_flags[0])))
 	return NULL;
     return (char_u *)user_cmd_flags[idx];
 }
@@ -6039,15 +6108,14 @@
 /*
  * Function given to ExpandGeneric() to obtain the list of values for -nargs.
  */
-/*ARGSUSED*/
     char_u *
 get_user_cmd_nargs(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     static char *user_cmd_nargs[] = {"0", "1", "*", "?", "+"};
 
-    if (idx >= sizeof(user_cmd_nargs) / sizeof(user_cmd_nargs[0]))
+    if (idx >= (int)(sizeof(user_cmd_nargs) / sizeof(user_cmd_nargs[0])))
 	return NULL;
     return (char_u *)user_cmd_nargs[idx];
 }
@@ -6055,10 +6123,9 @@
 /*
  * Function given to ExpandGeneric() to obtain the list of values for -complete.
  */
-/*ARGSUSED*/
     char_u *
 get_user_cmd_complete(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     return (char_u *)command_complete[idx].name;
@@ -6236,10 +6303,9 @@
 /*
  * ":cquit".
  */
-/*ARGSUSED*/
     static void
 ex_cquit(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     getout(1);	/* this does not always pass on the exit code to the Manx
 		   compiler. why? */
@@ -6681,10 +6747,9 @@
 /*
  * ":shell".
  */
-/*ARGSUSED*/
     static void
 ex_shell(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     do_shell(NULL, 0);
 }
@@ -6988,10 +7053,9 @@
 /*
  * ":preserve".
  */
-/*ARGSUSED*/
     static void
 ex_preserve(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     curbuf->b_flags |= BF_PRESERVED;
     ml_preserve(curbuf, TRUE);
@@ -7223,10 +7287,9 @@
 /*
  * :tabs command: List tabs and their contents.
  */
-/*ARGSUSED*/
     static void
 ex_tabs(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     tabpage_T	*tp;
     win_T	*wp;
@@ -7413,7 +7476,6 @@
 /*
  * ":edit <file>" command and alikes.
  */
-/*ARGSUSED*/
     void
 do_exedit(eap, old_curwin)
     exarg_T	*eap;
@@ -7485,7 +7547,8 @@
 	/* ":new" or ":tabnew" without argument: edit an new empty buffer */
 	setpcmark();
 	(void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,
-			       ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0));
+		      ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),
+		      old_curwin == NULL ? curwin : NULL);
     }
     else if ((eap->cmdidx != CMD_split
 #ifdef FEAT_VERTSPLIT
@@ -7522,7 +7585,7 @@
 #ifdef FEAT_LISTCMDS
 		    + (eap->cmdidx == CMD_badd ? ECMD_ADDBUF : 0 )
 #endif
-		    ) == FAIL)
+		    , old_curwin == NULL ? curwin : NULL) == FAIL)
 	{
 	    /* Editing the file failed.  If the window was split, close it. */
 #ifdef FEAT_WINDOWS
@@ -7624,10 +7687,9 @@
 }
 #endif
 
-/*ARGSUSED*/
     static void
 ex_swapname(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)
 	MSG(_("No swap file"));
@@ -7640,10 +7702,9 @@
  * offset.
  * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)
  */
-/*ARGSUSED*/
     static void
 ex_syncbind(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #ifdef FEAT_SCROLLBIND
     win_T	*wp;
@@ -7784,10 +7845,10 @@
 		if (*ml_get(lnum) == NUL && u_savedel(lnum, 1L) == OK)
 		{
 		    ml_delete(lnum, FALSE);
-		    deleted_lines_mark(lnum, 1L);
 		    if (curwin->w_cursor.lnum > 1
 					     && curwin->w_cursor.lnum >= lnum)
 			--curwin->w_cursor.lnum;
+		    deleted_lines_mark(lnum, 1L);
 		}
 	    }
 	    redraw_curbuf_later(VALID);
@@ -7803,6 +7864,9 @@
 {
     vim_free(prev_dir);
     prev_dir = NULL;
+
+    vim_free(globaldir);
+    globaldir = NULL;
 }
 #endif
 
@@ -7825,6 +7889,10 @@
     else
 #endif
     {
+#ifdef FEAT_AUTOCMD
+	if (allbuf_locked())
+	    return;
+#endif
 	if (vim_strchr(p_cpo, CPO_CHDIR) != NULL && curbufIsChanged()
 							     && !eap->forceit)
 	{
@@ -7896,7 +7964,7 @@
 	    shorten_fnames(TRUE);
 
 	    /* Echo the new current directory if the command was typed. */
-	    if (KeyTyped)
+	    if (KeyTyped || p_verbose >= 5)
 		ex_pwd(eap);
 	}
 	vim_free(tofree);
@@ -7906,10 +7974,9 @@
 /*
  * ":pwd".
  */
-/*ARGSUSED*/
     static void
 ex_pwd(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     if (mch_dirname(NameBuff, MAXPATHL) == OK)
     {
@@ -8340,10 +8407,9 @@
 /*
  * ":undo".
  */
-/*ARGSUSED*/
     static void
 ex_undo(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     if (eap->addr_count == 1)	    /* :undo 123 */
 	undo_time(eap->line2, FALSE, TRUE);
@@ -8354,10 +8420,9 @@
 /*
  * ":redo".
  */
-/*ARGSUSED*/
     static void
 ex_redo(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     u_redo(1);
 }
@@ -8365,7 +8430,6 @@
 /*
  * ":earlier" and ":later".
  */
-/*ARGSUSED*/
     static void
 ex_later(eap)
     exarg_T	*eap;
@@ -8550,10 +8614,9 @@
 /*
  * ":redrawstatus": force redraw of status line(s)
  */
-/*ARGSUSED*/
     static void
 ex_redrawstatus(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #if defined(FEAT_WINDOWS)
     int		r = RedrawingDisabled;
@@ -8630,6 +8693,8 @@
     }
 
 #ifdef FEAT_SESSION
+    /* Use the short file name until ":lcd" is used.  We also don't use the
+     * short file name when 'acd' is set, that is checked later. */
     did_lcd = FALSE;
 
     /* ":mkview" or ":mkview 9": generate file name with 'viewdir' */
@@ -8749,8 +8814,8 @@
 		else if (*dirnow != NUL
 			&& (ssop_flags & SSOP_CURDIR) && globaldir != NULL)
 		{
-		    (void)mch_chdir((char *)globaldir);
-		    shorten_fnames(TRUE);
+		    if (mch_chdir((char *)globaldir) == 0)
+			shorten_fnames(TRUE);
 		}
 
 		failed |= (makeopens(fd, dirnow) == FAIL);
@@ -8814,11 +8879,10 @@
 
 #if ((defined(FEAT_SESSION) || defined(FEAT_EVAL)) && defined(vim_mkdir)) \
 	|| defined(PROTO)
-/*ARGSUSED*/
     int
 vim_mkdir_emsg(name, prot)
     char_u	*name;
-    int		prot;
+    int		prot UNUSED;
 {
     if (vim_mkdir(name, prot) != 0)
     {
@@ -9089,10 +9153,9 @@
 /*
  * ":stopinsert"
  */
-/*ARGSUSED*/
     static void
 ex_stopinsert(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     restart_edit = 0;
     stop_insert_mode = TRUE;
@@ -9366,9 +9429,8 @@
 # define SPEC_CLIENT 9
 #endif
     };
-#define SPEC_COUNT  (sizeof(spec_str) / sizeof(char *))
 
-    for (i = 0; i < SPEC_COUNT; ++i)
+    for (i = 0; i < (int)(sizeof(spec_str) / sizeof(char *)); ++i)
     {
 	len = (int)STRLEN(spec_str[i]);
 	if (STRNCMP(src, spec_str[i], len) == 0)
@@ -9506,24 +9568,50 @@
 		    break;
 		}
 		s = src + 1;
+		if (*s == '<')		/* "#<99" uses v:oldfiles */
+		    ++s;
 		i = (int)getdigits(&s);
 		*usedlen = (int)(s - src); /* length of what we expand */
 
-		buf = buflist_findnr(i);
-		if (buf == NULL)
+		if (src[1] == '<')
 		{
-		    *errormsg = (char_u *)_("E194: No alternate file name to substitute for '#'");
+		    if (*usedlen < 2)
+		    {
+			/* Should we give an error message for #<text? */
+			*usedlen = 1;
+			return NULL;
+		    }
+#ifdef FEAT_EVAL
+		    result = list_find_str(get_vim_var_list(VV_OLDFILES),
+								     (long)i);
+		    if (result == NULL)
+		    {
+			*errormsg = (char_u *)"";
+			return NULL;
+		    }
+#else
+		    *errormsg = (char_u *)_("E809: #< is not available without the +eval feature");
 		    return NULL;
+#endif
 		}
-		if (lnump != NULL)
-		    *lnump = ECMD_LAST;
-		if (buf->b_fname == NULL)
+		else
 		{
-		    result = (char_u *)"";
-		    valid = 0;	    /* Must have ":p:h" to be valid */
+		    buf = buflist_findnr(i);
+		    if (buf == NULL)
+		    {
+			*errormsg = (char_u *)_("E194: No alternate file name to substitute for '#'");
+			return NULL;
+		    }
+		    if (lnump != NULL)
+			*lnump = ECMD_LAST;
+		    if (buf->b_fname == NULL)
+		    {
+			result = (char_u *)"";
+			valid = 0;	    /* Must have ":p:h" to be valid */
+		    }
+		    else
+			result = buf->b_fname;
 		}
-		else
-		    result = buf->b_fname;
 		break;
 
 #ifdef FEAT_SEARCHPATH
@@ -9541,6 +9629,15 @@
 #ifdef FEAT_AUTOCMD
 	case SPEC_AFILE:	/* file name for autocommand */
 		result = autocmd_fname;
+		if (result != NULL && !autocmd_fname_full)
+		{
+		    /* Still need to turn the fname into a full path.  It is
+		     * postponed to avoid a delay when <afile> is not used. */
+		    autocmd_fname_full = TRUE;
+		    result = FullName_save(autocmd_fname, FALSE);
+		    vim_free(autocmd_fname);
+		    autocmd_fname = result;
+		}
 		if (result == NULL)
 		{
 		    *errormsg = (char_u *)_("E495: no autocommand file name to substitute for \"<afile>\"");
@@ -9684,7 +9781,7 @@
 	}
 
 	/* allocate memory */
-	retval = alloc(len + 1);
+	retval = alloc((unsigned)len + 1);
 	if (retval == NULL)
 	    break;
     }
@@ -10067,7 +10164,7 @@
      */
     if (put_line(fd, "let s:sx = expand(\"<sfile>:p:r\").\"x.vim\"") == FAIL
 	    || put_line(fd, "if file_readable(s:sx)") == FAIL
-	    || put_line(fd, "  exe \"source \" . s:sx") == FAIL
+	    || put_line(fd, "  exe \"source \" . fnameescape(s:sx)") == FAIL
 	    || put_line(fd, "endif") == FAIL)
 	return FAIL;
 
@@ -10485,6 +10582,9 @@
     if (buf->b_sfname != NULL
 	    && flagp == &ssop_flags
 	    && (ssop_flags & (SSOP_CURDIR | SSOP_SESDIR))
+#ifdef FEAT_AUTOCHDIR
+	    && !p_acd
+#endif
 	    && !did_lcd)
 	name = buf->b_sfname;
     else
@@ -10689,7 +10789,8 @@
 	p_viminfo = (char_u *)"'100";
     if (eap->cmdidx == CMD_rviminfo)
     {
-	if (read_viminfo(eap->arg, TRUE, TRUE, eap->forceit) == FAIL)
+	if (read_viminfo(eap->arg, VIF_WANT_INFO | VIF_WANT_MARKS
+				  | (eap->forceit ? VIF_FORCEIT : 0)) == FAIL)
 	    EMSG(_("E195: Cannot open viminfo file for reading"));
     }
     else
@@ -10850,10 +10951,9 @@
 }
 #endif
 
-/*ARGSUSED*/
     static void
 ex_digraphs(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #ifdef FEAT_DIGRAPHS
     if (*eap->arg != NUL)
@@ -10887,10 +10987,9 @@
 /*
  * ":nohlsearch"
  */
-/*ARGSUSED*/
     static void
 ex_nohlsearch(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     no_hlsearch = TRUE;
     redraw_all_later(SOME_VALID);
@@ -10969,10 +11068,9 @@
 /*
  * ":X": Get crypt key
  */
-/*ARGSUSED*/
     static void
 ex_X(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     (void)get_crypt_key(TRUE, TRUE);
 }
diff -Naur vim72.orig/src/ex_eval.c vim72/src/ex_eval.c
--- vim72.orig/src/ex_eval.c	2007-11-24 15:34:09.000000000 +0000
+++ vim72/src/ex_eval.c	2009-07-22 22:54:21.000000000 +0100
@@ -60,7 +60,9 @@
 #else
 /* Values used for the Vim release. */
 # define THROW_ON_ERROR		TRUE
+# define THROW_ON_ERROR_TRUE
 # define THROW_ON_INTERRUPT	TRUE
+# define THROW_ON_INTERRUPT_TRUE
 #endif
 
 static void	catch_exception __ARGS((except_T *excp));
@@ -1320,16 +1322,20 @@
      * and reset the did_emsg or got_int flag, so this won't happen again at
      * the next surrounding try conditional.
      */
+#ifndef THROW_ON_ERROR_TRUE
     if (did_emsg && !THROW_ON_ERROR)
     {
 	inactivate_try = TRUE;
 	did_emsg = FALSE;
     }
+#endif
+#ifndef THROW_ON_INTERRUPT_TRUE
     if (got_int && !THROW_ON_INTERRUPT)
     {
 	inactivate_try = TRUE;
 	got_int = FALSE;
     }
+#endif
     idx = cleanup_conditionals(cstack, 0, inactivate_try);
     if (idx >= 0)
     {
@@ -2254,10 +2260,9 @@
 /*
  * ":endfunction" when not after a ":function"
  */
-/*ARGSUSED*/
     void
 ex_endfunction(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     EMSG(_("E193: :endfunction not inside a function"));
 }
diff -Naur vim72.orig/src/ex_getln.c vim72/src/ex_getln.c
--- vim72.orig/src/ex_getln.c	2008-08-08 10:31:33.000000000 +0100
+++ vim72/src/ex_getln.c	2009-07-22 22:54:23.000000000 +0100
@@ -31,6 +31,8 @@
     int		cmdattr;	/* attributes for prompt */
     int		overstrike;	/* Typing mode on the command line.  Shared by
 				   getcmdline() and put_on_cmdline(). */
+    expand_T	*xpc;		/* struct being used for expansion, xp_pattern
+				   may point into cmdbuff */
     int		xp_context;	/* type of expansion */
 # ifdef FEAT_EVAL
     char_u	*xp_arg;	/* user-defined expansion arg */
@@ -38,7 +40,11 @@
 # endif
 };
 
-static struct cmdline_info ccline;	/* current cmdline_info */
+/* The current cmdline_info.  It is initialized in getcmdline() and after that
+ * used by other functions.  When invoking getcmdline() recursively it needs
+ * to be saved with save_cmdline() and restored with restore_cmdline().
+ * TODO: make it local to getcmdline() and pass it around. */
+static struct cmdline_info ccline;
 
 static int	cmd_showtail;		/* Only show path tail in lists ? */
 
@@ -134,11 +140,10 @@
  * Return pointer to allocated string if there is a commandline, NULL
  * otherwise.
  */
-/*ARGSUSED*/
     char_u *
 getcmdline(firstc, count, indent)
     int		firstc;
-    long	count;		/* only used for incremental search */
+    long	count UNUSED;	/* only used for incremental search */
     int		indent;		/* indent for inside conditionals */
 {
     int		c;
@@ -238,6 +243,7 @@
     }
 
     ExpandInit(&xpc);
+    ccline.xpc = &xpc;
 
 #ifdef FEAT_RIGHTLEFT
     if (curwin->w_p_rl && *curwin->w_p_rlc == 's'
@@ -318,7 +324,7 @@
 #endif
 
 #ifdef FEAT_DIGRAPHS
-    do_digraph(-1);		/* init digraph typahead */
+    do_digraph(-1);		/* init digraph typeahead */
 #endif
 
     /*
@@ -408,9 +414,10 @@
 #endif
 
 	/*
-	 * <S-Tab> works like CTRL-P (unless 'wc' is <S-Tab>).
+	 * When there are matching completions to select <S-Tab> works like
+	 * CTRL-P (unless 'wc' is <S-Tab>).
 	 */
-	if (c != p_wc && c == K_S_TAB && xpc.xp_numfiles != -1)
+	if (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)
 	    c = Ctrl_P;
 
 #ifdef FEAT_WILDMENU
@@ -1513,6 +1520,7 @@
 		    int		old_firstc;
 
 		    vim_free(ccline.cmdbuff);
+		    xpc.xp_context = EXPAND_NOTHING;
 		    if (hiscnt == hislen)
 			p = lookfor;	/* back to the old one */
 		    else
@@ -1839,6 +1847,7 @@
 #endif
 
     ExpandCleanup(&xpc);
+    ccline.xpc = NULL;
 
 #ifdef FEAT_SEARCH_EXTRA
     if (did_incsearch)
@@ -1990,8 +1999,8 @@
 
 #if defined(FEAT_AUTOCMD) || defined(PROTO)
 /*
- * Check if "curbuf_lock" is set and return TRUE when it is and give an error
- * message.
+ * Check if "curbuf_lock" or "allbuf_lock" is set and return TRUE when it is
+ * and give an error message.
  */
     int
 curbuf_locked()
@@ -2001,6 +2010,21 @@
 	EMSG(_("E788: Not allowed to edit another buffer now"));
 	return TRUE;
     }
+    return allbuf_locked();
+}
+
+/*
+ * Check if "allbuf_lock" is set and return TRUE when it is and give an error
+ * message.
+ */
+    int
+allbuf_locked()
+{
+    if (allbuf_lock > 0)
+    {
+	EMSG(_("E811: Not allowed to change buffer information now"));
+	return TRUE;
+    }
     return FALSE;
 }
 #endif
@@ -2088,11 +2112,10 @@
 /*
  * Get an Ex command line for the ":" command.
  */
-/* ARGSUSED */
     char_u *
-getexline(c, dummy, indent)
+getexline(c, cookie, indent)
     int		c;		/* normally ':', NUL for ":append" */
-    void	*dummy;		/* cookie not used */
+    void	*cookie UNUSED;
     int		indent;		/* indent for inside conditionals */
 {
     /* When executing a register, remove ':' that's in front of each line. */
@@ -2107,12 +2130,11 @@
  * mappings or abbreviations.
  * Returns a string in allocated memory or NULL.
  */
-/* ARGSUSED */
     char_u *
-getexmodeline(promptc, dummy, indent)
+getexmodeline(promptc, cookie, indent)
     int		promptc;	/* normally ':', NUL for ":append" and '?' for
 				   :s prompt */
-    void	*dummy;		/* cookie not used */
+    void	*cookie UNUSED;
     int		indent;		/* indent for inside conditionals */
 {
     garray_T	line_ga;
@@ -2508,6 +2530,20 @@
     }
     mch_memmove(ccline.cmdbuff, p, (size_t)ccline.cmdlen + 1);
     vim_free(p);
+
+    if (ccline.xpc != NULL
+	    && ccline.xpc->xp_pattern != NULL
+	    && ccline.xpc->xp_context != EXPAND_NOTHING
+	    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)
+    {
+	int i = (int)(ccline.xpc->xp_pattern - p);
+
+	/* If xp_pattern points inside the old cmdbuff it needs to be adjusted
+	 * to point into the newly allocated memory. */
+	if (i >= 0 && i <= ccline.cmdlen)
+	    ccline.xpc->xp_pattern = ccline.cmdbuff + i;
+    }
+
     return OK;
 }
 
@@ -2875,6 +2911,7 @@
     prev_ccline = ccline;
     ccline.cmdbuff = NULL;
     ccline.cmdprompt = NULL;
+    ccline.xpc = NULL;
 }
 
 /*
@@ -3582,6 +3619,7 @@
 ExpandInit(xp)
     expand_T	*xp;
 {
+    xp->xp_pattern = NULL;
     xp->xp_backslash = XP_BS_NONE;
 #ifndef BACKSLASH_IN_FILENAME
     xp->xp_shell = FALSE;
@@ -3791,11 +3829,10 @@
  * Returns EXPAND_NOTHING when the character that triggered expansion should
  * be inserted like a normal character.
  */
-/*ARGSUSED*/
     static int
 showmatches(xp, wildmenu)
     expand_T	*xp;
-    int		wildmenu;
+    int		wildmenu UNUSED;
 {
 #define L_SHOWFILE(m) (showtail ? sm_gettail(files_found[m]) : files_found[m])
     int		num_files;
@@ -4477,6 +4514,12 @@
 	    {EXPAND_EVENTS, get_event_name, TRUE},
 	    {EXPAND_AUGROUP, get_augroup_name, TRUE},
 #endif
+#ifdef FEAT_CSCOPE
+	    {EXPAND_CSCOPE, get_cscope_name, TRUE},
+#endif
+#ifdef FEAT_SIGNS
+	    {EXPAND_SIGN, get_sign_name, TRUE},
+#endif
 #if (defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \
 	&& (defined(FEAT_GETTEXT) || defined(FEAT_MBYTE))
 	    {EXPAND_LANGUAGE, get_lang_arg, TRUE},
@@ -4490,7 +4533,7 @@
 	 * right function to do the expansion.
 	 */
 	ret = FAIL;
-	for (i = 0; i < sizeof(tab) / sizeof(struct expgen); ++i)
+	for (i = 0; i < (int)(sizeof(tab) / sizeof(struct expgen)); ++i)
 	    if (xp->xp_context == tab[i].context)
 	    {
 		if (tab[i].ic)
@@ -4831,14 +4874,14 @@
     /* Loop over the items in the list. */
     for (li = retlist->lv_first; li != NULL; li = li->li_next)
     {
-	if (li->li_tv.v_type != VAR_STRING)
-	    continue;  /* Skip non-string items */
+	if (li->li_tv.v_type != VAR_STRING || li->li_tv.vval.v_string == NULL)
+	    continue;  /* Skip non-string items and empty strings */
 
 	if (ga_grow(&ga, 1) == FAIL)
 	    break;
 
 	((char_u **)ga.ga_data)[ga.ga_len] =
-	    vim_strsave(li->li_tv.vval.v_string);
+					 vim_strsave(li->li_tv.vval.v_string);
 	++ga.ga_len;
     }
     list_unref(retlist);
@@ -4871,7 +4914,7 @@
     if (s == NULL)
 	return FAIL;
     sprintf((char *)s, "%s/%s*.vim", dirname, pat);
-    all = globpath(p_rtp, s);
+    all = globpath(p_rtp, s, 0);
     vim_free(s);
     if (all == NULL)
 	return FAIL;
@@ -4912,9 +4955,10 @@
  * newlines.  Returns NULL for an error or no matches.
  */
     char_u *
-globpath(path, file)
+globpath(path, file, expand_options)
     char_u	*path;
     char_u	*file;
+    int		expand_options;
 {
     expand_T	xpc;
     char_u	*buf;
@@ -4943,10 +4987,10 @@
 	{
 	    add_pathsep(buf);
 	    STRCAT(buf, file);
-	    if (ExpandFromContext(&xpc, buf, &num_p, &p, WILD_SILENT) != FAIL
-								 && num_p > 0)
+	    if (ExpandFromContext(&xpc, buf, &num_p, &p,
+			     WILD_SILENT|expand_options) != FAIL && num_p > 0)
 	    {
-		ExpandEscape(&xpc, buf, num_p, p, WILD_SILENT);
+		ExpandEscape(&xpc, buf, num_p, p, WILD_SILENT|expand_options);
 		for (len = 0, i = 0; i < num_p; ++i)
 		    len += (int)STRLEN(p[i]) + 1;
 
@@ -5641,7 +5685,7 @@
 	histype1 = get_histtype(arg);
 	if (histype1 == -1)
 	{
-	    if (STRICMP(arg, "all") == 0)
+	    if (STRNICMP(arg, "all", STRLEN(arg)) == 0)
 	    {
 		histype1 = 0;
 		histype2 = HIST_COUNT-1;
@@ -6020,16 +6064,17 @@
 # endif
 	return K_IGNORE;
     }
-    cmdwin_type = ccline.cmdfirstc;
-    if (cmdwin_type == NUL)
-	cmdwin_type = '-';
+    cmdwin_type = get_cmdline_type();
 
     /* Create the command-line buffer empty. */
-    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE);
+    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);
     (void)setfname(curbuf, (char_u *)"[Command Line]", NULL, TRUE);
     set_option_value((char_u *)"bt", 0L, (char_u *)"nofile", OPT_LOCAL);
     set_option_value((char_u *)"swf", 0L, NULL, OPT_LOCAL);
     curbuf->b_p_ma = TRUE;
+#ifdef FEAT_FOLDING
+    curwin->w_p_fen = FALSE;
+#endif
 # ifdef FEAT_RIGHTLEFT
     curwin->w_p_rl = cmdmsg_rl;
     cmdmsg_rl = FALSE;
@@ -6046,7 +6091,7 @@
     /* Showing the prompt may have set need_wait_return, reset it. */
     need_wait_return = FALSE;
 
-    histtype = hist_char2type(ccline.cmdfirstc);
+    histtype = hist_char2type(cmdwin_type);
     if (histtype == HIST_CMD || histtype == HIST_DEBUG)
     {
 	if (p_wc == TAB)
diff -Naur vim72.orig/src/farsi.c vim72/src/farsi.c
--- vim72.orig/src/farsi.c	2007-12-31 16:28:10.000000000 +0000
+++ vim72/src/farsi.c	2009-07-22 22:54:22.000000000 +0100
@@ -103,7 +103,8 @@
 	case F_HE:
 		tempc = _HE;
 
-		if (p_ri && (curwin->w_cursor.col+1 < STRLEN(ml_get_curline())))
+		if (p_ri && (curwin->w_cursor.col + 1
+					 < (colnr_T)STRLEN(ml_get_curline())))
 		{
 		    inc_cursor();
 
@@ -344,7 +345,7 @@
     if (curwin->w_p_rl && p_ri)
 	return;
 
-    if ( (curwin->w_cursor.col < STRLEN(ml_get_curline())))
+    if ((curwin->w_cursor.col < (colnr_T)STRLEN(ml_get_curline())))
     {
 	if ((p_ri && curwin->w_cursor.col) || !p_ri)
 	{
@@ -565,7 +566,7 @@
 
     tempc = gchar_cursor();
 
-    if (curwin->w_cursor.col+1 < STRLEN(ml_get_curline()))
+    if (curwin->w_cursor.col + 1 < (colnr_T)STRLEN(ml_get_curline()))
     {
 	inc_cursor();
 
@@ -594,8 +595,8 @@
 {
     int	tempc;
 
-    if (!curwin->w_cursor.col &&
-	(curwin->w_cursor.col+1 == STRLEN(ml_get_curline())))
+    if (curwin->w_cursor.col != 0 &&
+	(curwin->w_cursor.col + 1 == (colnr_T)STRLEN(ml_get_curline())))
 	return;
 
     if (!curwin->w_cursor.col && p_ri)
@@ -663,8 +664,8 @@
 {
     int	tempc;
 
-    if (!curwin->w_cursor.col &&
-	(curwin->w_cursor.col+1 == STRLEN(ml_get_curline())))
+    if (curwin->w_cursor.col != 0 &&
+	(curwin->w_cursor.col + 1 == (colnr_T)STRLEN(ml_get_curline())))
 	return;
 
     if (!curwin->w_cursor.col && p_ri)
diff -Naur vim72.orig/src/feature.h vim72/src/feature.h
--- vim72.orig/src/feature.h	2008-08-06 12:00:39.000000000 +0100
+++ vim72/src/feature.h	2009-07-22 22:54:17.000000000 +0100
@@ -767,9 +767,13 @@
 
 /*
  * +browse		":browse" command.
+ *			or just the ":browse" command modifier
  */
-#if defined(FEAT_NORMAL) && (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC))
-# define FEAT_BROWSE
+#if defined(FEAT_NORMAL)
+# define FEAT_BROWSE_CMD
+# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MAC)
+#  define FEAT_BROWSE
+# endif
 #endif
 
 /*
diff -Naur vim72.orig/src/fileio.c vim72/src/fileio.c
--- vim72.orig/src/fileio.c	2008-08-06 12:01:03.000000000 +0100
+++ vim72/src/fileio.c	2009-07-22 22:54:23.000000000 +0100
@@ -69,7 +69,7 @@
 static int au_find_group __ARGS((char_u *name));
 
 # define AUGROUP_DEFAULT    -1	    /* default autocmd group */
-# define AUGROUP_ERROR	    -2	    /* errornouse autocmd group */
+# define AUGROUP_ERROR	    -2	    /* erroneous autocmd group */
 # define AUGROUP_ALL	    -3	    /* all autocmd groups */
 #endif
 
@@ -144,7 +144,9 @@
 # endif
 #endif
 static int move_lines __ARGS((buf_T *frombuf, buf_T *tobuf));
-
+#ifdef FEAT_AUTOCMD
+static char *e_auchangedbuf = N_("E812: Autocommands changed buffer or buffer name");
+#endif
 
     void
 filemess(buf, name, s, attr)
@@ -295,6 +297,19 @@
     int		conv_restlen = 0;	/* nr of bytes in conv_rest[] */
 #endif
 
+#ifdef FEAT_AUTOCMD
+    /* Remember the initial values of curbuf, curbuf->b_ffname and
+     * curbuf->b_fname to detect whether they are altered as a result of
+     * executing nasty autocommands.  Also check if "fname" and "sfname"
+     * point to one of these values. */
+    buf_T   *old_curbuf = curbuf;
+    char_u  *old_b_ffname = curbuf->b_ffname;
+    char_u  *old_b_fname = curbuf->b_fname;
+    int     using_b_ffname = (fname == curbuf->b_ffname)
+					      || (sfname == curbuf->b_ffname);
+    int     using_b_fname = (fname == curbuf->b_fname)
+					       || (sfname == curbuf->b_fname);
+#endif
     write_no_eol_lnum = 0;	/* in case it was set by the previous read */
 
     /*
@@ -589,7 +604,21 @@
 #ifdef FEAT_QUICKFIX
 		    if (!bt_dontwrite(curbuf))
 #endif
+		    {
 			check_need_swap(newfile);
+#ifdef FEAT_AUTOCMD
+			/* SwapExists autocommand may mess things up */
+			if (curbuf != old_curbuf
+				|| (using_b_ffname
+					&& (old_b_ffname != curbuf->b_ffname))
+				|| (using_b_fname
+					 && (old_b_fname != curbuf->b_fname)))
+			{
+			    EMSG(_(e_auchangedbuf));
+			    return FAIL;
+			}
+#endif
+		    }
 		    if (dir_of_file_exists(fname))
 			filemess(curbuf, sfname, (char_u *)_("[New File]"), 0);
 		    else
@@ -668,9 +697,21 @@
 #endif
     {
 	check_need_swap(newfile);
+#ifdef FEAT_AUTOCMD
+	if (!read_stdin && (curbuf != old_curbuf
+		|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))
+		|| (using_b_fname && (old_b_fname != curbuf->b_fname))))
+	{
+	    EMSG(_(e_auchangedbuf));
+	    if (!read_buffer)
+		close(fd);
+	    return FAIL;
+	}
+#endif
 #ifdef UNIX
 	/* Set swap file protection bits after creating it. */
-	if (swap_mode > 0 && curbuf->b_ml.ml_mfp->mf_fname != NULL)
+	if (swap_mode > 0 && curbuf->b_ml.ml_mfp != NULL
+			  && curbuf->b_ml.ml_mfp->mf_fname != NULL)
 	    (void)mch_setperm(curbuf->b_ml.ml_mfp->mf_fname, (long)swap_mode);
 #endif
     }
@@ -698,7 +739,6 @@
     {
 	int	m = msg_scroll;
 	int	n = msg_scrolled;
-	buf_T	*old_curbuf = curbuf;
 
 	/*
 	 * The file must be closed again, the autocommands may want to change
@@ -740,8 +780,13 @@
 	/*
 	 * Don't allow the autocommands to change the current buffer.
 	 * Try to re-open the file.
+	 *
+	 * Don't allow the autocommands to change the buffer name either
+	 * (cd for example) if it invalidates fname or sfname.
 	 */
 	if (!read_stdin && (curbuf != old_curbuf
+		|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))
+		|| (using_b_fname && (old_b_fname != curbuf->b_fname))
 		|| (fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0)) < 0))
 	{
 	    --no_wait_return;
@@ -932,7 +977,10 @@
     else
     {
 	if (eap != NULL && eap->force_ff != 0)
+	{
 	    fileformat = get_fileformat_force(curbuf, eap);
+	    try_unix = try_dos = try_mac = FALSE;
+	}
 	else if (curbuf->b_p_bin)
 	    fileformat = EOL_UNIX;		/* binary: use Unix format */
 	else if (*p_ffs == NUL)
@@ -2211,7 +2259,7 @@
     {
 	/* Use stderr for stdin, makes shell commands work. */
 	close(0);
-	dup(2);
+	ignored = dup(2);
     }
 #endif
 
@@ -2341,11 +2389,6 @@
 		STRCAT(IObuff, _("[CR missing]"));
 		c = TRUE;
 	    }
-	    if (ff_error == EOL_MAC)
-	    {
-		STRCAT(IObuff, _("[NL found]"));
-		c = TRUE;
-	    }
 	    if (split)
 	    {
 		STRCAT(IObuff, _("[long lines split]"));
@@ -2711,7 +2754,7 @@
 {
     if (!curbuf->b_marks_read && get_viminfo_parameter('\'') > 0
 						  && curbuf->b_ffname != NULL)
-	read_viminfo(NULL, FALSE, TRUE, FALSE);
+	read_viminfo(NULL, VIF_WANT_MARKS);
 
     /* Always set b_marks_read; needed when 'viminfo' is changed to include
      * the ' parameter after opening a buffer. */
@@ -3451,12 +3494,12 @@
 		{
 # ifdef UNIX
 #  ifdef HAVE_FCHOWN
-		    fchown(fd, st_old.st_uid, st_old.st_gid);
+		    ignored = fchown(fd, st_old.st_uid, st_old.st_gid);
 #  endif
 		    if (mch_stat((char *)IObuff, &st) < 0
 			    || st.st_uid != st_old.st_uid
 			    || st.st_gid != st_old.st_gid
-			    || st.st_mode != perm)
+			    || (long)st.st_mode != perm)
 			backup_copy = TRUE;
 # endif
 		    /* Close the file before removing it, on MS-Windows we
@@ -4367,14 +4410,14 @@
 		|| st.st_uid != st_old.st_uid
 		|| st.st_gid != st_old.st_gid)
 	{
-	    fchown(fd, st_old.st_uid, st_old.st_gid);
+	    ignored = fchown(fd, st_old.st_uid, st_old.st_gid);
 	    if (perm >= 0)	/* set permission again, may have changed */
 		(void)mch_setperm(wfname, perm);
 	}
 # endif
 	buf_setino(buf);
     }
-    else if (buf->b_dev < 0)
+    else if (!buf->b_dev_valid)
 	/* Set the inode when creating a new file. */
 	buf_setino(buf);
 #endif
@@ -4782,6 +4825,8 @@
     char_u	*sfname;
 {
 #ifdef FEAT_AUTOCMD
+    buf_T	*buf = curbuf;
+
     /* It's like the unnamed buffer is deleted.... */
     if (curbuf->b_p_bl)
 	apply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);
@@ -4790,6 +4835,12 @@
     if (aborting())	    /* autocmds may abort script processing */
 	return FAIL;
 # endif
+    if (curbuf != buf)
+    {
+	/* We are in another buffer now, don't do the renaming. */
+	EMSG(_(e_auchangedbuf));
+	return FAIL;
+    }
 #endif
 
     if (setfname(curbuf, fname, sfname, FALSE) == OK)
@@ -5246,13 +5297,16 @@
 	    /* Convert with iconv(). */
 	    if (ip->bw_restlen > 0)
 	    {
+		char *fp;
+
 		/* Need to concatenate the remainder of the previous call and
 		 * the bytes of the current call.  Use the end of the
 		 * conversion buffer for this. */
 		fromlen = len + ip->bw_restlen;
-		from = (char *)ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;
-		mch_memmove((void *)from, ip->bw_rest, (size_t)ip->bw_restlen);
-		mch_memmove((void *)(from + ip->bw_restlen), buf, (size_t)len);
+		fp = (char *)ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;
+		mch_memmove(fp, ip->bw_rest, (size_t)ip->bw_restlen);
+		mch_memmove(fp + ip->bw_restlen, buf, (size_t)len);
+		from = fp;
 		tolen = ip->bw_conv_buflen - fromlen;
 	    }
 	    else
@@ -5550,9 +5604,10 @@
 	    name = "ucs-4le";	/* FF FE 00 00 */
 	    len = 4;
 	}
-	else if (flags == FIO_ALL || flags == (FIO_UCS2 | FIO_ENDIAN_L))
+	else if (flags == (FIO_UCS2 | FIO_ENDIAN_L))
 	    name = "ucs-2le";	/* FF FE */
-	else if (flags == (FIO_UTF16 | FIO_ENDIAN_L))
+	else if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))
+	    /* utf-16le is preferred, it also works for ucs-2le text */
 	    name = "utf-16le";	/* FF FE */
     }
     else if (p[0] == 0xfe && p[1] == 0xff
@@ -5917,7 +5972,7 @@
 	else if (*ext == '.')
 #endif
 	{
-	    if (s - ptr > (size_t)8)
+	    if ((size_t)(s - ptr) > (size_t)8)
 	    {
 		s = ptr + 8;
 		*s = '\0';
@@ -6031,9 +6086,9 @@
 	{
 	    tbuf[FGETS_SIZE - 2] = NUL;
 #ifdef USE_CR
-	    fgets_cr((char *)tbuf, FGETS_SIZE, fp);
+	    ignoredp = fgets_cr((char *)tbuf, FGETS_SIZE, fp);
 #else
-	    fgets((char *)tbuf, FGETS_SIZE, fp);
+	    ignoredp = fgets((char *)tbuf, FGETS_SIZE, fp);
 #endif
 	} while (tbuf[FGETS_SIZE - 2] != NUL && tbuf[FGETS_SIZE - 2] != '\n');
     }
@@ -6107,12 +6162,24 @@
 #ifdef HAVE_ACL
     vim_acl_T	acl;		/* ACL from original file */
 #endif
+#if defined(UNIX) || defined(CASE_INSENSITIVE_FILENAME)
+    int		use_tmp_file = FALSE;
+#endif
 
     /*
-     * When the names are identical, there is nothing to do.
+     * When the names are identical, there is nothing to do.  When they refer
+     * to the same file (ignoring case and slash/backslash differences) but
+     * the file name differs we need to go through a temp file.
      */
     if (fnamecmp(from, to) == 0)
-	return 0;
+    {
+#ifdef CASE_INSENSITIVE_FILENAME
+	if (STRCMP(gettail(from), gettail(to)) != 0)
+	    use_tmp_file = TRUE;
+	else
+#endif
+	    return 0;
+    }
 
     /*
      * Fail if the "from" file doesn't exist.  Avoids that "to" is deleted.
@@ -6120,6 +6187,55 @@
     if (mch_stat((char *)from, &st) < 0)
 	return -1;
 
+#ifdef UNIX
+    {
+	struct stat	st_to;
+
+	/* It's possible for the source and destination to be the same file.
+	 * This happens when "from" and "to" differ in case and are on a FAT32
+	 * filesystem.  In that case go through a temp file name. */
+	if (mch_stat((char *)to, &st_to) >= 0
+		&& st.st_dev == st_to.st_dev
+		&& st.st_ino == st_to.st_ino)
+	    use_tmp_file = TRUE;
+    }
+#endif
+
+#if defined(UNIX) || defined(CASE_INSENSITIVE_FILENAME)
+    if (use_tmp_file)
+    {
+	char	tempname[MAXPATHL + 1];
+
+	/*
+	 * Find a name that doesn't exist and is in the same directory.
+	 * Rename "from" to "tempname" and then rename "tempname" to "to".
+	 */
+	if (STRLEN(from) >= MAXPATHL - 5)
+	    return -1;
+	STRCPY(tempname, from);
+	for (n = 123; n < 99999; ++n)
+	{
+	    sprintf((char *)gettail((char_u *)tempname), "%d", n);
+	    if (mch_stat(tempname, &st) < 0)
+	    {
+		if (mch_rename((char *)from, tempname) == 0)
+		{
+		    if (mch_rename(tempname, (char *)to) == 0)
+			return 0;
+		    /* Strange, the second step failed.  Try moving the
+		     * file back and return failure. */
+		    mch_rename(tempname, (char *)from);
+		    return -1;
+		}
+		/* If it fails for one temp name it will most likely fail
+		 * for any temp name, give up. */
+		return -1;
+	    }
+	}
+	return -1;
+    }
+#endif
+
     /*
      * Delete the "to" file, this is required on some systems to make the
      * mch_rename() work, on other systems it makes sure that we don't have
@@ -6260,7 +6376,7 @@
 
     if (!stuff_empty() || global_busy || !typebuf_typed()
 #ifdef FEAT_AUTOCMD
-			|| autocmd_busy || curbuf_lock > 0
+			|| autocmd_busy || curbuf_lock > 0 || allbuf_lock > 0
 #endif
 					)
 	need_check_timestamps = TRUE;		/* check later */
@@ -6353,11 +6469,10 @@
  * return 2 if a message has been displayed.
  * return 0 otherwise.
  */
-/*ARGSUSED*/
     int
 buf_check_timestamp(buf, focus)
     buf_T	*buf;
-    int		focus;		/* called for GUI focus event */
+    int		focus UNUSED;	/* called for GUI focus event */
 {
     struct stat	st;
     int		stat_res;
@@ -6462,8 +6577,10 @@
 	    set_vim_var_string(VV_FCS_REASON, (char_u *)reason, -1);
 	    set_vim_var_string(VV_FCS_CHOICE, (char_u *)"", -1);
 # endif
+	    ++allbuf_lock;
 	    n = apply_autocmds(EVENT_FILECHANGEDSHELL,
 				      buf->b_fname, buf->b_fname, FALSE, buf);
+	    --allbuf_lock;
 	    busy = FALSE;
 	    if (n)
 	    {
@@ -6511,7 +6628,10 @@
 			mesg = _("W16: Warning: Mode of file \"%s\" has changed since editing started");
 			mesg2 = _("See \":help W16\" for more info.");
 		    }
-		    /* Else: only timestamp changed, ignored */
+		    else
+			/* Only timestamp changed, store it to avoid a warning
+			 * in check_mtime() later. */
+			buf->b_mtime_read = buf->b_mtime;
 		}
 	    }
 	}
@@ -6538,6 +6658,11 @@
 	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
 							+ STRLEN(mesg2) + 2));
 	    sprintf((char *)tbuf, mesg, path);
+#ifdef FEAT_EVAL
+	    /* Set warningmsg here, before the unimportant and output-specific
+	     * mesg2 has been appended. */
+	    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);
+#endif
 #if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)
 	    if (can_reload)
 	    {
@@ -6732,10 +6857,11 @@
 #endif
 #ifdef FEAT_FOLDING
 	{
-	    win_T *wp;
+	    win_T	*wp;
+	    tabpage_T	*tp;
 
 	    /* Update folds unless they are defined manually. */
-	    FOR_ALL_WINDOWS(wp)
+	    FOR_ALL_TAB_WINDOWS(tp, wp)
 		if (wp->w_buffer == curwin->w_buffer
 			&& !foldmethodIsManual(wp))
 		    foldUpdateAll(wp);
@@ -6753,12 +6879,11 @@
     /* Careful: autocommands may have made "buf" invalid! */
 }
 
-/*ARGSUSED*/
     void
 buf_store_time(buf, st, fname)
     buf_T	*buf;
     struct stat	*st;
-    char_u	*fname;
+    char_u	*fname UNUSED;
 {
     buf->b_mtime = (long)st->st_mtime;
     buf->b_orig_size = (size_t)st->st_size;
@@ -6821,10 +6946,9 @@
  * The returned pointer is to allocated memory.
  * The returned pointer is NULL if no valid name was found.
  */
-/*ARGSUSED*/
     char_u  *
 vim_tempname(extra_char)
-    int	    extra_char;	    /* character to use in the name instead of '?' */
+    int	    extra_char UNUSED;  /* char to use in the name instead of '?' */
 {
 #ifdef USE_TMPNAM
     char_u	itmp[L_tmpnam];	/* use tmpnam() */
@@ -6853,7 +6977,7 @@
 	/*
 	 * Try the entries in TEMPDIRNAMES to create the temp directory.
 	 */
-	for (i = 0; i < sizeof(tempdirs) / sizeof(char *); ++i)
+	for (i = 0; i < (int)(sizeof(tempdirs) / sizeof(char *)); ++i)
 	{
 	    /* expand $TMP, leave room for "/v1100000/999999999" */
 	    expand_env((char_u *)tempdirs[i], itmp, TEMPNAMELEN - 20);
@@ -8245,7 +8369,7 @@
 
 	    /* Execute the modeline settings, but don't set window-local
 	     * options if we are using the current window for another buffer. */
-	    do_modelines(aco.save_curwin == NULL ? OPT_NOWIN : 0);
+	    do_modelines(curwin == aucmd_win ? OPT_NOWIN : 0);
 
 	    /* restore the current window */
 	    aucmd_restbuf(&aco);
@@ -8261,8 +8385,8 @@
 
 /*
  * Prepare for executing autocommands for (hidden) buffer "buf".
- * Search a window for the current buffer.  Save the cursor position and
- * screen offset.
+ * Search for a visible window containing the current buffer.  If there isn't
+ * one then use "aucmd_win".
  * Set "curbuf" and "curwin" to match "buf".
  * When FEAT_AUTOCMD is not defined another version is used, see below.
  */
@@ -8272,8 +8396,9 @@
     buf_T	*buf;		/* new curbuf */
 {
     win_T	*win;
-
-    aco->new_curbuf = buf;
+#ifdef FEAT_WINDOWS
+    int		save_ea;
+#endif
 
     /* Find a window that is for the new buffer */
     if (buf == curbuf)		/* be quick when buf is curbuf */
@@ -8287,42 +8412,51 @@
 	win = NULL;
 #endif
 
-    /*
-     * Prefer to use an existing window for the buffer, it has the least side
-     * effects (esp. if "buf" is curbuf).
-     * Otherwise, use curwin for "buf".  It might make some items in the
-     * window invalid.  At least save the cursor and topline.
-     */
+    /* Allocate "aucmd_win" when needed.  If this fails (out of memory) fall
+     * back to using the current window. */
+    if (win == NULL && aucmd_win == NULL)
+    {
+	win_alloc_aucmd_win();
+	if (aucmd_win == NULL)
+	    win = curwin;
+    }
+
+    aco->save_curwin = curwin;
+    aco->save_curbuf = curbuf;
     if (win != NULL)
     {
-	/* there is a window for "buf", make it the curwin */
-	aco->save_curwin = curwin;
+	/* There is a window for "buf" in the current tab page, make it the
+	 * curwin.  This is preferred, it has the least side effects (esp. if
+	 * "buf" is curbuf). */
 	curwin = win;
-	aco->save_buf = win->w_buffer;
-	aco->new_curwin = win;
     }
     else
     {
-	/* there is no window for "buf", use curwin */
-	aco->save_curwin = NULL;
-	aco->save_buf = curbuf;
-	--curbuf->b_nwindows;
-	curwin->w_buffer = buf;
+	/* There is no window for "buf", use "aucmd_win".  To minimize the side
+	 * effects, insert it in a the current tab page.
+	 * Anything related to a window (e.g., setting folds) may have
+	 * unexpected results. */
+	aucmd_win->w_buffer = buf;
 	++buf->b_nwindows;
+	win_init_empty(aucmd_win); /* set cursor and topline to safe values */
 
-	/* save cursor and topline, set them to safe values */
-	aco->save_cursor = curwin->w_cursor;
-	curwin->w_cursor.lnum = 1;
-	curwin->w_cursor.col = 0;
-	aco->save_topline = curwin->w_topline;
-	curwin->w_topline = 1;
-#ifdef FEAT_DIFF
-	aco->save_topfill = curwin->w_topfill;
-	curwin->w_topfill = 0;
+#ifdef FEAT_WINDOWS
+	/* Split the current window, put the aucmd_win in the upper half.
+	 * We don't want the BufEnter or WinEnter autocommands. */
+	block_autocmds();
+	make_snapshot(SNAP_AUCMD_IDX);
+	save_ea = p_ea;
+	p_ea = FALSE;
+	(void)win_split_ins(0, WSP_TOP, aucmd_win, 0);
+	(void)win_comp_pos();   /* recompute window positions */
+	p_ea = save_ea;
+	unblock_autocmds();
 #endif
+	curwin = aucmd_win;
     }
-
     curbuf = buf;
+    aco->new_curwin = curwin;
+    aco->new_curbuf = curbuf;
 }
 
 /*
@@ -8334,21 +8468,88 @@
 aucmd_restbuf(aco)
     aco_save_T	*aco;		/* structure holding saved values */
 {
-    if (aco->save_curwin != NULL)
+#ifdef FEAT_WINDOWS
+    int dummy;
+#endif
+
+    if (aco->new_curwin == aucmd_win)
+    {
+	--curbuf->b_nwindows;
+#ifdef FEAT_WINDOWS
+	/* Find "aucmd_win", it can't be closed, but it may be in another tab
+	 * page. Do not trigger autocommands here. */
+	block_autocmds();
+	if (curwin != aucmd_win)
+	{
+	    tabpage_T	*tp;
+	    win_T	*wp;
+
+	    FOR_ALL_TAB_WINDOWS(tp, wp)
+	    {
+		if (wp == aucmd_win)
+		{
+		    if (tp != curtab)
+			goto_tabpage_tp(tp);
+		    win_goto(aucmd_win);
+		    break;
+		}
+	    }
+	}
+
+	/* Remove the window and frame from the tree of frames. */
+	(void)winframe_remove(curwin, &dummy, NULL);
+	win_remove(curwin, NULL);
+	last_status(FALSE);	    /* may need to remove last status line */
+	restore_snapshot(SNAP_AUCMD_IDX, FALSE);
+	(void)win_comp_pos();   /* recompute window positions */
+	unblock_autocmds();
+
+	if (win_valid(aco->save_curwin))
+	    curwin = aco->save_curwin;
+	else
+	    /* Hmm, original window disappeared.  Just use the first one. */
+	    curwin = firstwin;
+# ifdef FEAT_EVAL
+	vars_clear(&aucmd_win->w_vars.dv_hashtab);  /* free all w: variables */
+# endif
+#else
+	curwin = aco->save_curwin;
+#endif
+	curbuf = curwin->w_buffer;
+
+	/* the buffer contents may have changed */
+	check_cursor();
+	if (curwin->w_topline > curbuf->b_ml.ml_line_count)
+	{
+	    curwin->w_topline = curbuf->b_ml.ml_line_count;
+#ifdef FEAT_DIFF
+	    curwin->w_topfill = 0;
+#endif
+	}
+#if defined(FEAT_GUI)
+	/* Hide the scrollbars from the aucmd_win and update. */
+	gui_mch_enable_scrollbar(&aucmd_win->w_scrollbars[SBAR_LEFT], FALSE);
+	gui_mch_enable_scrollbar(&aucmd_win->w_scrollbars[SBAR_RIGHT], FALSE);
+	gui_may_update_scrollbars();
+#endif
+    }
+    else
     {
 	/* restore curwin */
 #ifdef FEAT_WINDOWS
 	if (win_valid(aco->save_curwin))
 #endif
 	{
-	    /* restore the buffer which was previously edited by curwin, if
-	     * it's still the same window and it's valid */
+	    /* Restore the buffer which was previously edited by curwin, if
+	     * it was chagned, we are still the same window and the buffer is
+	     * valid. */
 	    if (curwin == aco->new_curwin
-		    && buf_valid(aco->save_buf)
-		    && aco->save_buf->b_ml.ml_mfp != NULL)
+		    && curbuf != aco->new_curbuf
+		    && buf_valid(aco->new_curbuf)
+		    && aco->new_curbuf->b_ml.ml_mfp != NULL)
 	    {
 		--curbuf->b_nwindows;
-		curbuf = aco->save_buf;
+		curbuf = aco->new_curbuf;
 		curwin->w_buffer = curbuf;
 		++curbuf->b_nwindows;
 	    }
@@ -8357,34 +8558,6 @@
 	    curbuf = curwin->w_buffer;
 	}
     }
-    else
-    {
-	/* restore buffer for curwin if it still exists and is loaded */
-	if (buf_valid(aco->save_buf) && aco->save_buf->b_ml.ml_mfp != NULL)
-	{
-	    --curbuf->b_nwindows;
-	    curbuf = aco->save_buf;
-	    curwin->w_buffer = curbuf;
-	    ++curbuf->b_nwindows;
-	    curwin->w_cursor = aco->save_cursor;
-	    check_cursor();
-	    /* check topline < line_count, in case lines got deleted */
-	    if (aco->save_topline <= curbuf->b_ml.ml_line_count)
-	    {
-		curwin->w_topline = aco->save_topline;
-#ifdef FEAT_DIFF
-		curwin->w_topfill = aco->save_topfill;
-#endif
-	    }
-	    else
-	    {
-		curwin->w_topline = curbuf->b_ml.ml_line_count;
-#ifdef FEAT_DIFF
-		curwin->w_topfill = 0;
-#endif
-	    }
-	}
-    }
 }
 
 static int	autocmd_nested = FALSE;
@@ -8523,6 +8696,7 @@
     char_u	*save_sourcing_name;
     linenr_T	save_sourcing_lnum;
     char_u	*save_autocmd_fname;
+    int		save_autocmd_fname_full;
     int		save_autocmd_bufnr;
     char_u	*save_autocmd_match;
     int		save_autocmd_busy;
@@ -8601,6 +8775,7 @@
      * Save the autocmd_* variables and info about the current buffer.
      */
     save_autocmd_fname = autocmd_fname;
+    save_autocmd_fname_full = autocmd_fname_full;
     save_autocmd_bufnr = autocmd_bufnr;
     save_autocmd_match = autocmd_match;
     save_autocmd_busy = autocmd_busy;
@@ -8618,14 +8793,15 @@
 	if (fname != NULL && *fname != NUL)
 	    autocmd_fname = fname;
 	else if (buf != NULL)
-	    autocmd_fname = buf->b_fname;
+	    autocmd_fname = buf->b_ffname;
 	else
 	    autocmd_fname = NULL;
     }
     else
 	autocmd_fname = fname_io;
     if (autocmd_fname != NULL)
-	autocmd_fname = FullName_save(autocmd_fname, FALSE);
+	autocmd_fname = vim_strsave(autocmd_fname);
+    autocmd_fname_full = FALSE; /* call FullName_save() later */
 
     /*
      * Set the buffer number to be used for <abuf>.
@@ -8667,9 +8843,11 @@
     else
     {
 	sfname = vim_strsave(fname);
-	/* Don't try expanding FileType, Syntax, WindowID or QuickFixCmd* */
+	/* Don't try expanding FileType, Syntax, FuncUndefined, WindowID or
+	 * QuickFixCmd* */
 	if (event == EVENT_FILETYPE
 		|| event == EVENT_SYNTAX
+		|| event == EVENT_FUNCUNDEFINED
 		|| event == EVENT_REMOTEREPLY
 		|| event == EVENT_SPELLFILEMISSING
 		|| event == EVENT_QUICKFIXCMDPRE
@@ -8810,6 +8988,7 @@
     sourcing_lnum = save_sourcing_lnum;
     vim_free(autocmd_fname);
     autocmd_fname = save_autocmd_fname;
+    autocmd_fname_full = save_autocmd_fname_full;
     autocmd_bufnr = save_autocmd_bufnr;
     autocmd_match = save_autocmd_match;
 #ifdef FEAT_EVAL
@@ -8918,7 +9097,7 @@
     {
 	apc->curpat = NULL;
 
-	/* only use a pattern when it has not been removed, has commands and
+	/* Only use a pattern when it has not been removed, has commands and
 	 * the group matches. For buffer-local autocommands only check the
 	 * buffer number. */
 	if (ap->pat != NULL && ap->cmds != NULL
@@ -8967,12 +9146,11 @@
  * Called by do_cmdline() to get the next line for ":if".
  * Returns allocated string, or NULL for end of autocommands.
  */
-/* ARGSUSED */
     static char_u *
 getnextac(c, cookie, indent)
-    int	    c;		    /* not used */
+    int	    c UNUSED;
     void    *cookie;
-    int	    indent;	    /* not used */
+    int	    indent UNUSED;
 {
     AutoPatCmd	    *acp = (AutoPatCmd *)cookie;
     char_u	    *retval;
@@ -9083,10 +9261,9 @@
  * Function given to ExpandGeneric() to obtain the list of autocommand group
  * names.
  */
-/*ARGSUSED*/
     char_u *
 get_augroup_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx == augroups.ga_len)		/* add "END" add the end */
@@ -9104,7 +9281,7 @@
 set_context_in_autocmd(xp, arg, doautocmd)
     expand_T	*xp;
     char_u	*arg;
-    int		doautocmd;	/* TRUE for :doautocmd, FALSE for :autocmd */
+    int		doautocmd;	/* TRUE for :doauto*, FALSE for :autocmd */
 {
     char_u	*p;
     int		group;
@@ -9152,10 +9329,9 @@
 /*
  * Function given to ExpandGeneric() to obtain the list of event names.
  */
-/*ARGSUSED*/
     char_u *
 get_event_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (idx < augroups.ga_len)		/* First list group names, if wanted */
@@ -9296,9 +9472,11 @@
     aco_save_T	*aco;		/* structure to save values in */
     buf_T	*buf;		/* new curbuf */
 {
-    aco->save_buf = curbuf;
+    aco->save_curbuf = curbuf;
+    --curbuf->b_nwindows;
     curbuf = buf;
     curwin->w_buffer = buf;
+    ++curbuf->b_nwindows;
 }
 
 /*
@@ -9309,8 +9487,10 @@
 aucmd_restbuf(aco)
     aco_save_T	*aco;		/* structure holding saved values */
 {
-    curbuf = aco->save_buf;
+    --curbuf->b_nwindows;
+    curbuf = aco->save_curbuf;
     curwin->w_buffer = curbuf;
+    ++curbuf->b_nwindows;
 }
 
 #endif	/* FEAT_AUTOCMD */
@@ -9467,13 +9647,12 @@
  *
  * Returns NULL when out of memory.
  */
-/*ARGSUSED*/
     char_u *
 file_pat_to_reg_pat(pat, pat_end, allow_dirs, no_bslash)
     char_u	*pat;
     char_u	*pat_end;	/* first char after pattern or NULL */
     char	*allow_dirs;	/* Result passed back out in here */
-    int		no_bslash;	/* Don't use a backward slash as pathsep */
+    int		no_bslash UNUSED; /* Don't use a backward slash as pathsep */
 {
     int		size;
     char_u	*endp;
diff -Naur vim72.orig/src/fold.c vim72/src/fold.c
--- vim72.orig/src/fold.c	2008-08-06 12:01:12.000000000 +0100
+++ vim72/src/fold.c	2009-07-22 22:54:19.000000000 +0100
@@ -48,7 +48,7 @@
 static int foldFind __ARGS((garray_T *gap, linenr_T lnum, fold_T **fpp));
 static int foldLevelWin __ARGS((win_T *wp, linenr_T lnum));
 static void checkupdate __ARGS((win_T *wp));
-static void setFoldRepeat __ARGS((linenr_T lnum, long count, int open));
+static void setFoldRepeat __ARGS((linenr_T lnum, long count, int do_open));
 static linenr_T setManualFold __ARGS((linenr_T lnum, int opening, int recurse, int *donep));
 static linenr_T setManualFoldWin __ARGS((win_T *wp, linenr_T lnum, int opening, int recurse, int *donep));
 static void foldOpenNested __ARGS((fold_T *fpr));
@@ -740,7 +740,7 @@
     garray_T	*found_ga;
     fold_T	*found_fp = NULL;
     linenr_T	found_off = 0;
-    int		use_level = FALSE;
+    int		use_level;
     int		maybe_small = FALSE;
     int		level = 0;
     linenr_T	lnum = start;
@@ -757,6 +757,7 @@
 	gap = &curwin->w_folds;
 	found_ga = NULL;
 	lnum_off = 0;
+	use_level = FALSE;
 	for (;;)
 	{
 	    if (!foldFind(gap, lnum - lnum_off, &fp))
@@ -783,20 +784,21 @@
 	else
 	{
 	    lnum = found_fp->fd_top + found_fp->fd_len + found_off;
-	    did_one = TRUE;
 
 	    if (foldmethodIsManual(curwin))
 		deleteFoldEntry(found_ga,
 		    (int)(found_fp - (fold_T *)found_ga->ga_data), recursive);
 	    else
 	    {
-		if (found_fp->fd_top + found_off < first_lnum)
-		    first_lnum = found_fp->fd_top;
-		if (lnum > last_lnum)
+		if (first_lnum > found_fp->fd_top + found_off)
+		    first_lnum = found_fp->fd_top + found_off;
+		if (last_lnum < lnum)
 		    last_lnum = lnum;
-		parseMarker(curwin);
+		if (!did_one)
+		    parseMarker(curwin);
 		deleteFoldMarkers(found_fp, recursive, found_off);
 	    }
+	    did_one = TRUE;
 
 	    /* redraw window */
 	    changed_window_setting();
@@ -811,6 +813,10 @@
 	    redraw_curbuf_later(INVERTED);
 #endif
     }
+    else
+	/* Deleting markers may make cursor column invalid. */
+	check_cursor_col();
+
     if (last_lnum > 0)
 	changed_lines(first_lnum, (colnr_T)0, last_lnum, 0L);
 }
@@ -1241,10 +1247,10 @@
  * Repeat "count" times.
  */
     static void
-setFoldRepeat(lnum, count, open)
+setFoldRepeat(lnum, count, do_open)
     linenr_T	lnum;
     long	count;
-    int		open;
+    int		do_open;
 {
     int		done;
     long	n;
@@ -1252,7 +1258,7 @@
     for (n = 0; n < count; ++n)
     {
 	done = DONE_NOTHING;
-	(void)setManualFold(lnum, open, FALSE, &done);
+	(void)setManualFold(lnum, do_open, FALSE, &done);
 	if (!(done & DONE_ACTION))
 	{
 	    /* Only give an error message when no fold could be opened. */
diff -Naur vim72.orig/src/getchar.c vim72/src/getchar.c
--- vim72.orig/src/getchar.c	2008-07-22 17:57:48.000000000 +0100
+++ vim72/src/getchar.c	2009-07-22 22:54:23.000000000 +0100
@@ -1309,6 +1309,9 @@
     return OK;
 }
 
+static int old_char = -1;	/* character put back by vungetc() */
+static int old_mod_mask;	/* mod_mask for ungotten character */
+
 #if defined(FEAT_EVAL) || defined(FEAT_EX_EXTRA) || defined(PROTO)
 
 /*
@@ -1323,6 +1326,10 @@
     if (!tp->typebuf_valid)
 	typebuf = tp->save_typebuf;
 
+    tp->old_char = old_char;
+    tp->old_mod_mask = old_mod_mask;
+    old_char = -1;
+
     tp->save_stuffbuff = stuffbuff;
     stuffbuff.bh_first.b_next = NULL;
 # ifdef USE_INPUT_BUF
@@ -1344,6 +1351,9 @@
 	typebuf = tp->save_typebuf;
     }
 
+    old_char = tp->old_char;
+    old_mod_mask = tp->old_mod_mask;
+
     free_buff(&stuffbuff);
     stuffbuff = tp->save_stuffbuff;
 # ifdef USE_INPUT_BUF
@@ -1499,9 +1509,6 @@
 #define KL_PART_KEY -1		/* keylen value for incomplete key-code */
 #define KL_PART_MAP -2		/* keylen value for incomplete mapping */
 
-static int old_char = -1;	/* character put back by vungetc() */
-static int old_mod_mask;	/* mod_mask for ungotten character */
-
 /*
  * Get the next input character.
  * Can return a special key or a multi-byte character.
@@ -3701,11 +3708,10 @@
  * Clear all mappings or abbreviations.
  * 'abbr' should be FALSE for mappings, TRUE for abbreviations.
  */
-/*ARGSUSED*/
     void
 map_clear(cmdp, arg, forceit, abbr)
     char_u	*cmdp;
-    char_u	*arg;
+    char_u	*arg UNUSED;
     int		forceit;
     int		abbr;
 {
@@ -3734,13 +3740,12 @@
 /*
  * Clear all mappings in "mode".
  */
-/*ARGSUSED*/
     void
 map_clear_int(buf, mode, local, abbr)
-    buf_T	*buf;	    /* buffer for local mappings */
-    int		mode;	    /* mode in which to delete */
-    int		local;	    /* TRUE for buffer-local mappings */
-    int		abbr;	    /* TRUE for abbreviations */
+    buf_T	*buf UNUSED;	/* buffer for local mappings */
+    int		mode;		/* mode in which to delete */
+    int		local UNUSED;	/* TRUE for buffer-local mappings */
+    int		abbr;		/* TRUE for abbreviations */
 {
     mapblock_T	*mp, **mpp;
     int		hash;
@@ -3816,7 +3821,11 @@
     int len = 1;
 
     if (msg_didout || msg_silent != 0)
+    {
 	msg_putchar('\n');
+	if (got_int)	    /* 'q' typed at MORE prompt */
+	    return;
+    }
     if ((mp->m_mode & (INSERT + CMDLINE)) == INSERT + CMDLINE)
 	msg_putchar('!');			/* :map! */
     else if (mp->m_mode & INSERT)
@@ -4702,7 +4711,7 @@
 			return FAIL;
 		    if (mp->m_noremap != REMAP_YES && fprintf(fd, "nore") < 0)
 			return FAIL;
-		    if (fprintf(fd, cmd) < 0)
+		    if (fputs(cmd, fd) < 0)
 			return FAIL;
 		    if (buf != NULL && fputs(" <buffer>", fd) < 0)
 			return FAIL;
@@ -4801,7 +4810,7 @@
 	    }
 	    if (IS_SPECIAL(c) || modifiers)	/* special key */
 	    {
-		if (fprintf(fd, (char *)get_special_key_name(c, modifiers)) < 0)
+		if (fputs((char *)get_special_key_name(c, modifiers), fd) < 0)
 		    return FAIL;
 		continue;
 	    }
diff -Naur vim72.orig/src/globals.h vim72/src/globals.h
--- vim72.orig/src/globals.h	2008-07-26 12:53:29.000000000 +0100
+++ vim72/src/globals.h	2009-07-22 22:54:23.000000000 +0100
@@ -482,8 +482,10 @@
 /*
  * While executing external commands or in Ex mode, should not insert GUI
  * events in the input buffer: Set hold_gui_events to non-zero.
+ *
+ * volatile because it is used in signal handler sig_sysmouse().
  */
-EXTERN int	hold_gui_events INIT(= 0);
+EXTERN volatile int hold_gui_events INIT(= 0);
 
 /*
  * When resizing the shell is postponed, remember the new size, and call
@@ -507,6 +509,7 @@
 EXTERN int	clip_unnamed INIT(= FALSE);
 EXTERN int	clip_autoselect INIT(= FALSE);
 EXTERN int	clip_autoselectml INIT(= FALSE);
+EXTERN int	clip_html INIT(= FALSE);
 EXTERN regprog_T *clip_exclude_prog INIT(= NULL);
 #endif
 
@@ -522,7 +525,7 @@
 EXTERN win_T	*prevwin INIT(= NULL);	/* previous window */
 # define W_NEXT(wp) ((wp)->w_next)
 # define FOR_ALL_WINDOWS(wp) for (wp = firstwin; wp != NULL; wp = wp->w_next)
-#define FOR_ALL_TAB_WINDOWS(tp, wp) \
+# define FOR_ALL_TAB_WINDOWS(tp, wp) \
     for ((tp) = first_tabpage; (tp) != NULL; (tp) = (tp)->tp_next) \
 	for ((wp) = ((tp) == curtab) \
 		? firstwin : (tp)->tp_firstwin; (wp); (wp) = (wp)->w_next)
@@ -536,6 +539,10 @@
 
 EXTERN win_T	*curwin;	/* currently active window */
 
+#ifdef FEAT_AUTOCMD
+EXTERN win_T	*aucmd_win;	/* window used in aucmd_prepbuf() */
+#endif
+
 /*
  * The window layout is kept in a tree of frames.  topframe points to the top
  * of the tree.
@@ -597,7 +604,8 @@
 EXTERN int	really_exiting INIT(= FALSE);
 				/* TRUE when we are sure to exit, e.g., after
 				 * a deadly signal */
-EXTERN int	full_screen INIT(= FALSE);
+/* volatile because it is used in signal handler deathtrap(). */
+EXTERN volatile int full_screen INIT(= FALSE);
 				/* TRUE when doing full-screen output
 				 * otherwise only writing some messages */
 
@@ -616,6 +624,11 @@
 EXTERN int	curbuf_lock INIT(= 0);
 				/* non-zero when the current buffer can't be
 				 * changed.  Used for FileChangedRO. */
+EXTERN int	allbuf_lock INIT(= 0);
+				/* non-zero when no buffer name can be
+				 * changed, no buffer can be deleted and
+				 * current directory can't be changed.
+				 * Used for SwapExists et al. */
 #endif
 #ifdef FEAT_EVAL
 # define HAVE_SANDBOX
@@ -710,7 +723,7 @@
 
 EXTERN pos_T	saved_cursor		/* w_cursor before formatting text. */
 # ifdef DO_INIT
-	= INIT_POS_T
+	= INIT_POS_T(0, 0, 0)
 # endif
 	;
 
@@ -739,10 +752,12 @@
  */
 EXTERN JMP_BUF lc_jump_env;	/* argument to SETJMP() */
 # ifdef SIGHASARG
-EXTERN int lc_signal;		/* catched signal number, 0 when no was signal
-				   catched; used for mch_libcall() */
+/* volatile because it is used in signal handlers. */
+EXTERN volatile int lc_signal;	/* caught signal number, 0 when no was signal
+				   caught; used for mch_libcall() */
 # endif
-EXTERN int lc_active INIT(= FALSE); /* TRUE when lc_jump_env is valid. */
+/* volatile because it is used in signal handler deathtrap(). */
+EXTERN volatile int lc_active INIT(= FALSE); /* TRUE when lc_jump_env is valid. */
 #endif
 
 #if defined(FEAT_MBYTE) || defined(FEAT_POSTSCRIPT)
@@ -800,11 +815,14 @@
  */
 /* length of char in bytes, including following composing chars */
 EXTERN int (*mb_ptr2len) __ARGS((char_u *p)) INIT(= latin_ptr2len);
+/* idem, with limit on string length */
+EXTERN int (*mb_ptr2len_len) __ARGS((char_u *p, int size)) INIT(= latin_ptr2len_len);
 /* byte length of char */
 EXTERN int (*mb_char2len) __ARGS((int c)) INIT(= latin_char2len);
 /* convert char to bytes, return the length */
 EXTERN int (*mb_char2bytes) __ARGS((int c, char_u *buf)) INIT(= latin_char2bytes);
 EXTERN int (*mb_ptr2cells) __ARGS((char_u *p)) INIT(= latin_ptr2cells);
+EXTERN int (*mb_ptr2cells_len) __ARGS((char_u *p, int size)) INIT(= latin_ptr2cells_len);
 EXTERN int (*mb_char2cells) __ARGS((int c)) INIT(= latin_char2cells);
 EXTERN int (*mb_off2cells) __ARGS((unsigned off, unsigned max_off)) INIT(= latin_off2cells);
 EXTERN int (*mb_ptr2char) __ARGS((char_u *p)) INIT(= latin_ptr2char);
@@ -950,7 +968,7 @@
 		    ;
 EXTERN typebuf_T typebuf		/* typeahead buffer */
 #ifdef DO_INIT
-		    = {NULL, NULL}
+		    = {NULL, NULL, 0, 0, 0, 0, 0, 0, 0}
 #endif
 		    ;
 #ifdef FEAT_EX_EXTRA
@@ -986,7 +1004,8 @@
 EXTERN FILE	*scriptout  INIT(= NULL);   /* stream to write script to */
 EXTERN int	read_cmd_fd INIT(= 0);	    /* fd to read commands from */
 
-EXTERN int	got_int INIT(= FALSE);	    /* set to TRUE when interrupt
+/* volatile because it is used in signal handler catch_sigint(). */
+EXTERN volatile int got_int INIT(= FALSE);    /* set to TRUE when interrupt
 						signal occurred */
 #ifdef USE_TERM_CONSOLE
 EXTERN int	term_console INIT(= FALSE); /* set to TRUE when console used */
@@ -1022,12 +1041,13 @@
 #endif
 #ifdef FEAT_AUTOCMD
 EXTERN char_u	*autocmd_fname INIT(= NULL); /* fname for <afile> on cmdline */
+EXTERN int	autocmd_fname_full;	     /* autocmd_fname is full path */
 EXTERN int	autocmd_bufnr INIT(= 0);     /* fnum for <abuf> on cmdline */
 EXTERN char_u	*autocmd_match INIT(= NULL); /* name for <amatch> on cmdline */
 EXTERN int	did_cursorhold INIT(= FALSE); /* set when CursorHold t'gerd */
 EXTERN pos_T	last_cursormoved	    /* for CursorMoved event */
 # ifdef DO_INIT
-			= INIT_POS_T
+			= INIT_POS_T(0, 0, 0)
 # endif
 			;
 #endif
@@ -1339,7 +1359,6 @@
 
 #ifdef FEAT_NETBEANS_INTG
 EXTERN char *netbeansArg INIT(= NULL);	/* the -nb[:host:port:passwd] arg */
-EXTERN int netbeansCloseFile INIT(= 0);	/* send killed if != 0 */
 EXTERN int netbeansFireChanges INIT(= 1); /* send buffer changes if != 0 */
 EXTERN int netbeansForcedQuit INIT(= 0);/* don't write modified files */
 EXTERN int netbeansReadFile INIT(= 1);	/* OK to read from disk if != 0 */
@@ -1548,6 +1567,14 @@
 EXTERN time_t starttime;
 
 /*
+ * Some compilers warn for not using a return value, but in some situations we
+ * can't do anything useful with the value.  Assign to this variable to avoid
+ * the warning.
+ */
+EXTERN int ignored;
+EXTERN char *ignoredp;
+
+/*
  * Optional Farsi support.  Include it here, so EXTERN and INIT are defined.
  */
 #ifdef FEAT_FKMAP
diff -Naur vim72.orig/src/gui_at_fs.c vim72/src/gui_at_fs.c
--- vim72.orig/src/gui_at_fs.c	2006-05-12 10:26:24.000000000 +0100
+++ vim72/src/gui_at_fs.c	2009-07-22 22:54:22.000000000 +0100
@@ -829,7 +829,7 @@
     text.format = FMT8BIT;
 
 #ifdef XtNinternational
-    if (_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
+    if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
     {
 	XawTextReplace(selFileField, (XawTextPosition)0,
 				    (XawTextPosition)WcsLen((wchar_t *)&SFtextBuffer[0]), &text);
@@ -851,17 +851,15 @@
 #endif
 }
 
-/* ARGSUSED */
     static void
 SFbuttonPressList(w, n, event)
-    Widget		w;
-    int			n;
-    XButtonPressedEvent	*event;
+    Widget		w UNUSED;
+    int			n UNUSED;
+    XButtonPressedEvent	*event UNUSED;
 {
     SFbuttonPressed = 1;
 }
 
-/* ARGSUSED */
     static void
 SFbuttonReleaseList(w, n, event)
     Widget		 w;
@@ -989,11 +987,10 @@
     return result;
 }
 
-/* ARGSUSED */
     static void
 SFdirModTimer(cl, id)
-    XtPointer		cl;
-    XtIntervalId	*id;
+    XtPointer		cl UNUSED;
+    XtIntervalId	*id UNUSED;
 {
     static int		n = -1;
     static int		f = 0;
@@ -1596,11 +1593,10 @@
 
 static void SFscrollTimer __ARGS((XtPointer p, XtIntervalId *id));
 
-/* ARGSUSED */
     static void
 SFscrollTimer(p, id)
     XtPointer		p;
-    XtIntervalId	*id;
+    XtIntervalId	*id UNUSED;
 {
     SFDir	*dir;
     int		save;
@@ -1695,10 +1691,9 @@
     }
 }
 
-/* ARGSUSED */
     static void
 SFenterList(w, n, event)
-    Widget		w;
+    Widget		w UNUSED;
     int			n;
     XEnterWindowEvent	*event;
 {
@@ -1719,12 +1714,11 @@
     }
 }
 
-/* ARGSUSED */
     static void
 SFleaveList(w, n, event)
-    Widget	w;
+    Widget	w UNUSED;
     int		n;
-    XEvent	*event;
+    XEvent	*event UNUSED;
 {
     if (SFcurrentInvert[n] != -1)
     {
@@ -1733,10 +1727,9 @@
     }
 }
 
-/* ARGSUSED */
     static void
 SFmotionList(w, n, event)
-    Widget		w;
+    Widget		w UNUSED;
     int			n;
     XMotionEvent	*event;
 {
@@ -1754,7 +1747,6 @@
     }
 }
 
-/* ARGSUSED */
     static void
 SFvFloatSliderMovedCallback(w, n, fnew)
     Widget	w;
@@ -1767,10 +1759,9 @@
     SFvSliderMovedCallback(w, (int)(long)n, nw);
 }
 
-/* ARGSUSED */
     static void
 SFvSliderMovedCallback(w, n, nw)
-    Widget	w;
+    Widget	w UNUSED;
     int		n;
     int		nw;
 {
@@ -1853,10 +1844,9 @@
     }
 }
 
-/* ARGSUSED */
     static void
 SFvAreaSelectedCallback(w, n, pnew)
-    Widget		w;
+    Widget	w;
     XtPointer	n;
     XtPointer	pnew;
 {
@@ -1914,10 +1904,9 @@
     SFvSliderMovedCallback(w, (int)(long)n, nw);
 }
 
-/* ARGSUSED */
     static void
 SFhSliderMovedCallback(w, n, nw)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	n;
     XtPointer	nw;
 {
@@ -1933,10 +1922,9 @@
     SFdrawList((int)(long)n, SF_DO_NOT_SCROLL);
 }
 
-/* ARGSUSED */
     static void
 SFhAreaSelectedCallback(w, n, pnew)
-    Widget		w;
+    Widget	w;
     XtPointer	n;
     XtPointer	pnew;
 {
@@ -1994,11 +1982,10 @@
     }
 }
 
-/* ARGSUSED */
     static void
 SFpathSliderMovedCallback(w, client_data, nw)
-    Widget		w;
-    XtPointer	client_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
     XtPointer	nw;
 {
     SFDir		*dir;
@@ -2031,11 +2018,10 @@
     XawTextSetInsertionPoint(selFileField, pos);
 }
 
-/* ARGSUSED */
     static void
 SFpathAreaSelectedCallback(w, client_data, pnew)
     Widget	w;
-    XtPointer	client_data;
+    XtPointer	client_data UNUSED;
     XtPointer	pnew;
 {
     int		nw = (int)(long)pnew;
@@ -2206,13 +2192,12 @@
 
 static void SFexposeList __ARGS((Widget w, XtPointer n, XEvent *event, Boolean *cont));
 
-/* ARGSUSED */
     static void
 SFexposeList(w, n, event, cont)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	n;
     XEvent	*event;
-    Boolean	*cont;
+    Boolean	*cont UNUSED;
 {
     if ((event->type == NoExpose) || event->xexpose.count)
 	return;
@@ -2222,13 +2207,12 @@
 
 static void SFmodVerifyCallback __ARGS((Widget w, XtPointer client_data, XEvent *event, Boolean *cont));
 
-/* ARGSUSED */
     static void
 SFmodVerifyCallback(w, client_data, event, cont)
-    Widget		w;
-    XtPointer		client_data;
+    Widget		w UNUSED;
+    XtPointer		client_data UNUSED;
     XEvent		*event;
-    Boolean		*cont;
+    Boolean		*cont UNUSED;
 {
     char	buf[2];
 
@@ -2241,11 +2225,11 @@
 
 static void SFokCallback __ARGS((Widget w, XtPointer cl, XtPointer cd));
 
-/* ARGSUSED */
     static void
 SFokCallback(w, cl, cd)
-    Widget	w;
-    XtPointer	cl, cd;
+    Widget	w UNUSED;
+    XtPointer	cl UNUSED;
+    XtPointer	cd UNUSED;
 {
     SFstatus = SEL_FILE_OK;
 }
@@ -2258,11 +2242,11 @@
 
 static void SFcancelCallback __ARGS((Widget w, XtPointer cl, XtPointer cd));
 
-/* ARGSUSED */
     static void
 SFcancelCallback(w, cl, cd)
-    Widget	w;
-    XtPointer	cl, cd;
+    Widget	w UNUSED;
+    XtPointer	cl UNUSED;
+    XtPointer	cd UNUSED;
 {
     SFstatus = SEL_FILE_CANCEL;
 }
@@ -2275,16 +2259,15 @@
 
 static void SFdismissAction __ARGS((Widget w, XEvent *event, String *params, Cardinal *num_params));
 
-/* ARGSUSED */
     static void
 SFdismissAction(w, event, params, num_params)
-    Widget	w;
-    XEvent *event;
-    String *params;
-    Cardinal *num_params;
+    Widget	w UNUSED;
+    XEvent	*event;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
-    if (event->type == ClientMessage &&
-	    event->xclient.data.l[0] != SFwmDeleteWindow)
+    if (event->type == ClientMessage
+	    && (Atom)event->xclient.data.l[0] != SFwmDeleteWindow)
 	return;
 
     SFstatus = SEL_FILE_CANCEL;
@@ -2703,7 +2686,7 @@
 SFtextChanged()
 {
 #if defined(FEAT_XFONTSET) && defined(XtNinternational)
-    if (_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
+    if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
     {
 	wchar_t *wcbuf=(wchar_t *)SFtextBuffer;
 
@@ -2749,7 +2732,7 @@
 #if defined(FEAT_XFONTSET) && defined(XtNinternational)
     char *buf;
 
-    if (_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
+    if ((unsigned long)_XawTextFormat((TextWidget)selFileField) == XawFmtWide)
     {
 	wchar_t *wcbuf;
 	int mbslength;
diff -Naur vim72.orig/src/gui_athena.c vim72/src/gui_athena.c
--- vim72.orig/src/gui_athena.c	2008-06-21 20:38:58.000000000 +0100
+++ vim72/src/gui_athena.c	2009-07-22 22:54:22.000000000 +0100
@@ -86,10 +86,9 @@
  * Scrollbar callback (XtNjumpProc) for when the scrollbar is dragged with the
  * left or middle mouse button.
  */
-/* ARGSUSED */
     static void
 gui_athena_scroll_cb_jump(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data, call_data;
 {
     scrollbar_T *sb, *sb_info;
@@ -122,10 +121,9 @@
  * Scrollbar callback (XtNscrollProc) for paging up or down with the left or
  * right mouse buttons.
  */
-/* ARGSUSED */
     static void
 gui_athena_scroll_cb_scroll(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data, call_data;
 {
     scrollbar_T *sb, *sb_info;
@@ -492,7 +490,7 @@
     if (menu->icon_builtin || gui_find_bitmap(menu->name, buf, "xpm") == FAIL)
     {
 	if (menu->iconidx >= 0 && menu->iconidx
-		   < (sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
+	      < (int)(sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
 	    xpm = built_in_pixmaps[menu->iconidx];
 	else
 	    xpm = tb_blank_xpm;
@@ -763,7 +761,7 @@
     XtGetValues(XtParent(widget), args, n);
 
     retval = num_children;
-    for (i = 0; i < num_children; ++i)
+    for (i = 0; i < (int)num_children; ++i)
     {
 	Widget	current = children[i];
 	vimmenu_T	*menu = NULL;
@@ -780,11 +778,10 @@
     return retval;
 }
 
-/* ARGSUSED */
     void
 gui_mch_add_menu(menu, idx)
     vimmenu_T	*menu;
-    int		idx;
+    int		idx UNUSED;
 {
     char_u	*pullright_name;
     Dimension	height, space, border;
@@ -869,7 +866,7 @@
 	    XtVaGetValues(parent->submenu_id, XtNchildren, &children,
 					      XtNnumChildren, &num_children,
 					      NULL);
-	    for (i = 0; i < num_children; ++i)
+	    for (i = 0; i < (int)num_children; ++i)
 	    {
 		XtVaSetValues(children[i],
 			      XtNrightMargin, puller_width,
@@ -913,7 +910,7 @@
     XtVaGetValues(id, XtNchildren, &children,
 		      XtNnumChildren, &num_children,
 		      NULL);
-    for (i = 0; i < num_children; ++i)
+    for (i = 0; i < (int)num_children; ++i)
     {
 	if (children[i] == ignore)
 	    continue;
@@ -1175,11 +1172,10 @@
     return pname;
 }
 
-/* ARGSUSED */
     void
 gui_mch_add_menu_item(menu, idx)
     vimmenu_T	*menu;
-    int		idx;
+    int		idx UNUSED;
 {
     vimmenu_T	*parent = menu->parent;
 
@@ -1444,7 +1440,7 @@
 		XtNchildren,	    &children,
 		XtNnumChildren,	    &numChildren,
 		NULL);
-	for (i = 0; i < numChildren; i++)
+	for (i = 0; i < (int)numChildren; i++)
 	{
 	    whgt = 0;
 
@@ -1473,10 +1469,9 @@
 #endif
 
 
-/* ARGSUSED */
     void
 gui_mch_toggle_tearoffs(enable)
-    int		enable;
+    int		enable UNUSED;
 {
     /* no tearoff menus */
 }
@@ -1537,7 +1532,7 @@
 	    else
 		get_left_margin = True;
 
-	    for (i = 0; i < num_children; ++i)
+	    for (i = 0; i < (int)num_children; ++i)
 	    {
 		if (children[i] == menu->id)
 		    continue;
@@ -1645,11 +1640,10 @@
     }
 }
 
-/*ARGSUSED*/
     static void
 gui_athena_menu_timeout(client_data, id)
     XtPointer	    client_data;
-    XtIntervalId    *id;
+    XtIntervalId    *id UNUSED;
 {
     Widget  w = (Widget)client_data;
     Widget  popup;
@@ -1678,12 +1672,11 @@
  *
  * This is called when XtPopup() is called.
  */
-/*ARGSUSED*/
     static void
 gui_athena_popup_callback(w, client_data, call_data)
     Widget	w;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     /* Assumption: XtIsSubclass(XtParent(w),simpleMenuWidgetClass) */
     vimmenu_T	*menu = (vimmenu_T *)client_data;
@@ -1711,7 +1704,6 @@
 		     NULL);
 }
 
-/* ARGSUSED */
     static void
 gui_athena_popdown_submenus_action(w, event, args, nargs)
     Widget	w;
@@ -1756,7 +1748,6 @@
     return False;
 }
 
-/* ARGSUSED */
     static void
 gui_athena_delayed_arm_action(w, event, args, nargs)
     Widget	w;
@@ -1837,7 +1828,6 @@
      * (XtIsSubclass(popup,simpleMenuWidgetClass) == True) */
 }
 
-/* ARGSUSED */
     void
 gui_mch_show_popupmenu(menu)
     vimmenu_T *menu;
@@ -2046,15 +2036,14 @@
  * Put up a file requester.
  * Returns the selected name in allocated memory, or NULL for Cancel.
  */
-/* ARGSUSED */
     char_u *
 gui_mch_browse(saving, title, dflt, ext, initdir, filter)
-    int		saving;		/* select file to write */
-    char_u	*title;		/* not used (title for the window) */
-    char_u	*dflt;		/* not used (default name) */
-    char_u	*ext;		/* not used (extension added) */
+    int		saving UNUSED;	/* select file to write */
+    char_u	*title;		/* title for the window */
+    char_u	*dflt;		/* default name */
+    char_u	*ext UNUSED;	/* extension added */
     char_u	*initdir;	/* initial directory, NULL for current dir */
-    char_u	*filter;	/* not used (file name filter) */
+    char_u	*filter UNUSED;	/* file name filter */
 {
     Position x, y;
     char_u	dirbuf[MAXPATHL];
@@ -2100,13 +2089,12 @@
  * Callback function for the textfield.  When CR is hit this works like
  * hitting the "OK" button, ESC like "Cancel".
  */
-/* ARGSUSED */
     static void
 keyhit_callback(w, client_data, event, cont)
-    Widget		w;
-    XtPointer		client_data;
+    Widget		w UNUSED;
+    XtPointer		client_data UNUSED;
     XEvent		*event;
-    Boolean		*cont;
+    Boolean		*cont UNUSED;
 {
     char	buf[2];
 
@@ -2119,12 +2107,11 @@
     }
 }
 
-/* ARGSUSED */
     static void
 butproc(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     dialogStatus = (int)(long)client_data + 1;
 }
@@ -2132,27 +2119,25 @@
 /*
  * Function called when dialog window closed.
  */
-/*ARGSUSED*/
     static void
 dialog_wm_handler(w, client_data, event, dum)
-    Widget	w;
-    XtPointer	client_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     if (event->type == ClientMessage
-	    && ((XClientMessageEvent *)event)->data.l[0] == dialogatom)
+	    && (Atom)((XClientMessageEvent *)event)->data.l[0] == dialogatom)
 	dialogStatus = 0;
 }
 
-/* ARGSUSED */
     int
 gui_mch_dialog(type, title, message, buttons, dfltbutton, textfield)
-    int		type;
+    int		type UNUSED;
     char_u	*title;
     char_u	*message;
     char_u	*buttons;
-    int		dfltbutton;
+    int		dfltbutton UNUSED;
     char_u	*textfield;
 {
     char_u		*buts;
diff -Naur vim72.orig/src/gui_at_sb.c vim72/src/gui_at_sb.c
--- vim72.orig/src/gui_at_sb.c	2004-06-07 15:32:25.000000000 +0100
+++ vim72/src/gui_at_sb.c	2009-07-22 22:54:22.000000000 +0100
@@ -198,10 +198,13 @@
     /* extension	*/  NULL
   },
   { /* simple fields */
-    /* change_sensitive	*/  XtInheritChangeSensitive
+    /* change_sensitive	*/  XtInheritChangeSensitive,
+#ifndef OLDXAW
+    /* extension */	    NULL
+#endif
   },
   { /* scrollbar fields */
-    /* ignore	    */	0
+    /* empty	    */	    0
   }
 };
 
@@ -241,7 +244,8 @@
 
     if (bottom <= 0 || bottom <= top)
 	return;
-    if ((sw = sbw->scrollbar.shadow_width) < 0)
+    sw = sbw->scrollbar.shadow_width;
+    if (sw < 0)
 	sw = 0;
     margin = MARGIN (sbw);
     floor = sbw->scrollbar.length - margin + 2;
@@ -516,13 +520,12 @@
     }
 }
 
-/* ARGSUSED */
     static void
 Initialize(request, new, args, num_args)
-    Widget	request;	/* what the client asked for */
+    Widget	request UNUSED;	/* what the client asked for */
     Widget	new;		/* what we're going to give him */
-    ArgList	args;
-    Cardinal	*num_args;
+    ArgList	args UNUSED;
+    Cardinal	*num_args UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) new;
 
@@ -556,14 +559,13 @@
 	(w, valueMask, attributes);
 }
 
-/* ARGSUSED */
     static Boolean
 SetValues(current, request, desired, args, num_args)
-    Widget  current,	    /* what I am */
-	    request,	    /* what he wants me to be */
-	    desired;	    /* what I will become */
-    ArgList args;
-    Cardinal *num_args;
+    Widget  current;	    /* what I am */
+    Widget  request UNUSED; /* what he wants me to be */
+    Widget  desired;	    /* what I will become */
+    ArgList args UNUSED;
+    Cardinal *num_args UNUSED;
 {
     ScrollbarWidget	sbw = (ScrollbarWidget) current;
     ScrollbarWidget	dsbw = (ScrollbarWidget) desired;
@@ -609,7 +611,6 @@
 }
 
 
-/* ARGSUSED */
     static void
 Redisplay(w, event, region)
     Widget w;
@@ -789,11 +790,10 @@
     }
 }
 
-/* ARGSUSED */
     static void
 RepeatNotify(client_data, idp)
     XtPointer client_data;
-    XtIntervalId *idp;
+    XtIntervalId *idp UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) client_data;
     int		    call_data;
@@ -839,46 +839,42 @@
     return (num < small) ? small : ((num > big) ? big : num);
 }
 
-/* ARGSUSED */
     static void
 ScrollOneLineUp(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollSome(w, event, -ONE_LINE_DATA);
 }
 
-/* ARGSUSED */
     static void
 ScrollOneLineDown(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollSome(w, event, ONE_LINE_DATA);
 }
 
-/* ARGSUSED */
     static void
 ScrollPageDown(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollSome(w, event, ONE_PAGE_DATA);
 }
 
-/* ARGSUSED */
     static void
 ScrollPageUp(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollSome(w, event, -ONE_PAGE_DATA);
 }
@@ -901,13 +897,12 @@
     XtCallCallbacks(w, XtNscrollProc, (XtPointer)call_data);
 }
 
-/* ARGSUSED */
     static void
 NotifyScroll(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;
-    Cardinal	*num_params;
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) w;
     Position	    x, y, loc;
@@ -991,13 +986,12 @@
 					   delay, RepeatNotify, (XtPointer)w);
 }
 
-/* ARGSUSED */
     static void
 EndScroll(w, event, params, num_params)
     Widget w;
-    XEvent *event;	/* unused */
-    String *params;	/* unused */
-    Cardinal *num_params;   /* unused */
+    XEvent *event UNUSED;
+    String *params UNUSED;
+    Cardinal *num_params UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget) w;
 
@@ -1023,13 +1017,12 @@
     return PICKLENGTH(sbw, x / width, y / height);
 }
 
-/* ARGSUSED */
     static void
 MoveThumb(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;	/* unused */
-    Cardinal	*num_params;	/* unused */
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollbarWidget	sbw = (ScrollbarWidget)w;
     Position		x, y;
@@ -1069,15 +1062,20 @@
 }
 
 
-/* ARGSUSED */
     static void
 NotifyThumb(w, event, params, num_params)
     Widget	w;
     XEvent	*event;
-    String	*params;	/* unused */
-    Cardinal	*num_params;	/* unused */
+    String	*params UNUSED;
+    Cardinal	*num_params UNUSED;
 {
     ScrollbarWidget sbw = (ScrollbarWidget)w;
+    /* Use a union to avoid a warning for the weird conversion from float to
+     * XtPointer.  Comes from Xaw/Scrollbar.c. */
+    union {
+	XtPointer xtp;
+	float xtf;
+    } xtpf;
 
     if (LookAhead(w, event))
 	return;
@@ -1085,11 +1083,11 @@
     /* thumbProc is not pretty, but is necessary for backwards
        compatibility on those architectures for which it work{s,ed};
        the intent is to pass a (truncated) float by value. */
-    XtCallCallbacks(w, XtNthumbProc, *(XtPointer*)&sbw->scrollbar.top);
+    xtpf.xtf = sbw->scrollbar.top;
+    XtCallCallbacks(w, XtNthumbProc, xtpf.xtp);
     XtCallCallbacks(w, XtNjumpProc, (XtPointer)&sbw->scrollbar.top);
 }
 
-/* ARGSUSED */
     static void
 AllocTopShadowGC(w)
     Widget w;
@@ -1103,7 +1101,6 @@
     sbw->scrollbar.top_shadow_GC = XtGetGC(w, valuemask, &myXGCV);
 }
 
-/* ARGSUSED */
     static void
 AllocBotShadowGC(w)
     Widget w;
@@ -1117,11 +1114,10 @@
     sbw->scrollbar.bot_shadow_GC = XtGetGC(w, valuemask, &myXGCV);
 }
 
-/* ARGSUSED */
     static void
 _Xaw3dDrawShadows(gw, event, region, out)
     Widget  gw;
-    XEvent  *event;
+    XEvent  *event UNUSED;
     Region  region;
     int	    out;
 {
diff -Naur vim72.orig/src/gui_beval.c vim72/src/gui_beval.c
--- vim72.orig/src/gui_beval.c	2007-05-07 20:33:41.000000000 +0100
+++ vim72/src/gui_beval.c	2009-07-22 22:54:22.000000000 +0100
@@ -15,11 +15,10 @@
 /*
  * Common code, invoked when the mouse is resting for a moment.
  */
-/*ARGSUSED*/
     void
 general_beval_cb(beval, state)
     BalloonEval *beval;
-    int state;
+    int		state UNUSED;
 {
     win_T	*wp;
     int		col;
@@ -551,9 +550,8 @@
     return FALSE; /* continue emission */
 }
 
-/*ARGSUSED*/
     static gint
-mainwin_event_cb(GtkWidget *widget, GdkEvent *event, gpointer data)
+mainwin_event_cb(GtkWidget *widget UNUSED, GdkEvent *event, gpointer data)
 {
     BalloonEval *beval = (BalloonEval *)data;
 
@@ -663,9 +661,10 @@
     return FALSE; /* don't call me again */
 }
 
-/*ARGSUSED2*/
     static gint
-balloon_expose_event_cb(GtkWidget *widget, GdkEventExpose *event, gpointer data)
+balloon_expose_event_cb(GtkWidget *widget,
+			GdkEventExpose *event,
+			gpointer data UNUSED)
 {
     gtk_paint_flat_box(widget->style, widget->window,
 		       GTK_STATE_NORMAL, GTK_SHADOW_OUT,
@@ -676,7 +675,6 @@
 }
 
 # ifndef HAVE_GTK2
-/*ARGSUSED2*/
     static void
 balloon_draw_cb(GtkWidget *widget, GdkRectangle *area, gpointer data)
 {
@@ -726,13 +724,12 @@
 /*
  * The X event handler. All it does is call the real event handler.
  */
-/*ARGSUSED*/
     static void
 pointerEventEH(w, client_data, event, unused)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
     XEvent	*event;
-    Boolean	*unused;
+    Boolean	*unused UNUSED;
 {
     BalloonEval *beval = (BalloonEval *)client_data;
     pointerEvent(beval, event);
@@ -877,11 +874,10 @@
     }
 }
 
-/*ARGSUSED*/
     static void
 timerRoutine(dx, id)
     XtPointer	    dx;
-    XtIntervalId    *id;
+    XtIntervalId    *id UNUSED;
 {
     BalloonEval *beval = (BalloonEval *)dx;
 
@@ -1291,6 +1287,23 @@
 		XtNy, ty,
 		NULL);
 #endif
+	/* Set tooltip colors */
+	{
+	    Arg args[2];
+
+#ifdef FEAT_GUI_MOTIF
+	    args[0].name = XmNbackground;
+	    args[0].value = gui.tooltip_bg_pixel;
+	    args[1].name = XmNforeground;
+	    args[1].value = gui.tooltip_fg_pixel;
+#else /* Athena */
+	    args[0].name = XtNbackground;
+	    args[0].value = gui.tooltip_bg_pixel;
+	    args[1].name = XtNforeground;
+	    args[1].value = gui.tooltip_fg_pixel;
+#endif
+	    XtSetValues(beval->balloonLabel, &args[0], XtNumber(args));
+	}
 
 	XtPopup(beval->balloonShell, XtGrabNone);
 
diff -Naur vim72.orig/src/gui.c vim72/src/gui.c
--- vim72.orig/src/gui.c	2008-07-27 20:32:14.000000000 +0100
+++ vim72/src/gui.c	2009-07-22 22:54:23.000000000 +0100
@@ -139,7 +139,7 @@
 		/* The read returns when the child closes the pipe (or when
 		 * the child dies for some reason). */
 		close(pipefd[1]);
-		(void)read(pipefd[0], &dummy, (size_t)1);
+		ignored = (int)read(pipefd[0], &dummy, (size_t)1);
 		close(pipefd[0]);
 	    }
 
@@ -678,11 +678,10 @@
  * Return OK when able to set the font.  When it failed FAIL is returned and
  * the fonts are unchanged.
  */
-/*ARGSUSED*/
     int
 gui_init_font(font_list, fontset)
     char_u	*font_list;
-    int		fontset;
+    int		fontset UNUSED;
 {
 #define FONTLEN 320
     char_u	font_name[FONTLEN];
@@ -960,7 +959,7 @@
 		guicolor_T fg, bg;
 
 		if (
-# ifdef HAVE_GTK2
+# if defined(HAVE_GTK2) && !defined(FEAT_HANGULIN)
 			preedit_get_status()
 # else
 			im_get_status()
@@ -1138,10 +1137,9 @@
  * Position the various GUI components (text area, menu).  The vertical
  * scrollbars are NOT handled here.  See gui_update_scrollbars().
  */
-/*ARGSUSED*/
     static void
 gui_position_components(total_width)
-    int	    total_width;
+    int	    total_width UNUSED;
 {
     int	    text_area_x;
     int	    text_area_y;
@@ -1374,10 +1372,9 @@
  * If "fit_to_display" is TRUE then the size may be reduced to fit the window
  * on the screen.
  */
-/*ARGSUSED*/
     void
 gui_set_shellsize(mustset, fit_to_display, direction)
-    int		mustset;		/* set by the user */
+    int		mustset UNUSED;		/* set by the user */
     int		fit_to_display;
     int		direction;		/* RESIZE_HOR, RESIZE_VER */
 {
@@ -3120,10 +3117,9 @@
  * If "oldval" is not NULL, "oldval" is the previous value, the new value is
  * in p_go.
  */
-/*ARGSUSED*/
     void
 gui_init_which_components(oldval)
-    char_u	*oldval;
+    char_u	*oldval UNUSED;
 {
 #ifdef FEAT_MENU
     static int	prev_menu_is_active = -1;
@@ -3241,7 +3237,7 @@
 	    i = Rows;
 	    gui_update_tabline();
 	    Rows = i;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (using_tabline)
 		fix_size = TRUE;
 	    if (!gui_use_tabline())
@@ -3275,9 +3271,9 @@
 		if (gui.which_scrollbars[i] != prev_which_scrollbars[i])
 		{
 		    if (i == SBAR_BOTTOM)
-			need_set_size = RESIZE_VERT;
+			need_set_size |= RESIZE_VERT;
 		    else
-			need_set_size = RESIZE_HOR;
+			need_set_size |= RESIZE_HOR;
 		    if (gui.which_scrollbars[i])
 			fix_size = TRUE;
 		}
@@ -3297,7 +3293,7 @@
 	    gui_mch_enable_menu(gui.menu_is_active);
 	    Rows = i;
 	    prev_menu_is_active = gui.menu_is_active;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (gui.menu_is_active)
 		fix_size = TRUE;
 	}
@@ -3308,7 +3304,7 @@
 	{
 	    gui_mch_show_toolbar(using_toolbar);
 	    prev_toolbar = using_toolbar;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (using_toolbar)
 		fix_size = TRUE;
 	}
@@ -3318,7 +3314,7 @@
 	{
 	    gui_mch_enable_footer(using_footer);
 	    prev_footer = using_footer;
-	    need_set_size = RESIZE_VERT;
+	    need_set_size |= RESIZE_VERT;
 	    if (using_footer)
 		fix_size = TRUE;
 	}
@@ -3330,10 +3326,11 @@
 	    prev_tearoff = using_tearoff;
 	}
 #endif
-	if (need_set_size)
+	if (need_set_size != 0)
 	{
 #ifdef FEAT_GUI_GTK
-	    long    c = Columns;
+	    long    prev_Columns = Columns;
+	    long    prev_Rows = Rows;
 #endif
 	    /* Adjust the size of the window to make the text area keep the
 	     * same size and to avoid that part of our window is off-screen
@@ -3349,11 +3346,14 @@
 	     * If you remove this, please test this command for resizing
 	     * effects (with optional left scrollbar): ":vsp|q|vsp|q|vsp|q".
 	     * Don't do this while starting up though.
-	     * And don't change Rows, it may have be reduced intentionally
-	     * when adding menu/toolbar/tabline. */
-	    if (!gui.starting)
+	     * Don't change Rows when adding menu/toolbar/tabline.
+	     * Don't change Columns when adding vertical toolbar. */
+	    if (!gui.starting && need_set_size != (RESIZE_VERT | RESIZE_HOR))
 		(void)char_avail();
-	    Columns = c;
+	    if ((need_set_size & RESIZE_VERT) == 0)
+		Rows = prev_Rows;
+	    if ((need_set_size & RESIZE_HOR) == 0)
+		Columns = prev_Columns;
 #endif
 	}
 #ifdef FEAT_WINDOWS
@@ -3879,6 +3879,21 @@
  * Scrollbar stuff:
  */
 
+/*
+ * Called when something in the window layout has changed.
+ */
+    void
+gui_may_update_scrollbars()
+{
+    if (gui.in_use && starting == 0)
+    {
+	out_flush();
+	gui_init_which_components(NULL);
+	gui_update_scrollbars(TRUE);
+    }
+    need_mouse_correct = TRUE;
+}
+
     void
 gui_update_scrollbars(force)
     int		force;	    /* Force all scrollbars to get updated */
@@ -4407,7 +4422,7 @@
     if (curwin->w_p_wrap)
 	return FALSE;
 
-    if (curwin->w_leftcol == scrollbar_value)
+    if ((long_u)curwin->w_leftcol == scrollbar_value)
 	return FALSE;
 
     curwin->w_leftcol = (colnr_T)scrollbar_value;
@@ -4420,7 +4435,7 @@
 	    && longest_lnum < curwin->w_botline
 	    && !virtual_active())
     {
-	if (scrollbar_value > scroll_line_len(curwin->w_cursor.lnum))
+	if (scrollbar_value > (long_u)scroll_line_len(curwin->w_cursor.lnum))
 	{
 	    curwin->w_cursor.lnum = longest_lnum;
 	    curwin->w_cursor.col = 0;
@@ -4666,11 +4681,10 @@
 /*
  * Find window where the mouse pointer "y" coordinate is in.
  */
-/*ARGSUSED*/
     static win_T *
 xy2win(x, y)
-    int		x;
-    int		y;
+    int		x UNUSED;
+    int		y UNUSED;
 {
 #ifdef FEAT_WINDOWS
     int		row;
@@ -5120,11 +5134,10 @@
  * of dropped files, they will be freed in this function, and caller can't use
  * fnames after call this function.
  */
-/*ARGSUSED*/
     void
 gui_handle_drop(x, y, modifiers, fnames, count)
-    int		x;
-    int		y;
+    int		x UNUSED;
+    int		y UNUSED;
     int_u	modifiers;
     char_u	**fnames;
     int		count;
diff -Naur vim72.orig/src/gui_gtk.c vim72/src/gui_gtk.c
--- vim72.orig/src/gui_gtk.c	2008-07-31 20:48:20.000000000 +0100
+++ vim72/src/gui_gtk.c	2009-07-22 22:54:22.000000000 +0100
@@ -285,14 +285,14 @@
     return image;
 }
 
-/*ARGSUSED*/
     static gint
-toolbar_button_focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
-{
-    /* When we're in a GtkPlug, we don't have window focus events, only widget focus.
-     * To emulate stand-alone gvim, if a button gets focus (e.g., <Tab> into GtkPlug)
-     * immediately pass it to mainwin.
-     */
+toolbar_button_focus_in_event(GtkWidget *widget UNUSED,
+			      GdkEventFocus *event UNUSED,
+			      gpointer data UNUSED)
+{
+    /* When we're in a GtkPlug, we don't have window focus events, only widget
+     * focus.  To emulate stand-alone gvim, if a button gets focus (e.g.,
+     * <Tab> into GtkPlug) immediately pass it to mainwin. */
     if (gtk_socket_id != 0)
 	gtk_widget_grab_focus(gui.drawarea);
 
@@ -585,9 +585,8 @@
     gtk_menu_prepend(GTK_MENU(menu->submenu_id), menu->tearoff_handle);
 }
 
-/*ARGSUSED*/
     static void
-menu_item_activate(GtkWidget *widget, gpointer data)
+menu_item_activate(GtkWidget *widget UNUSED, gpointer data)
 {
     gui_menu_cb((vimmenu_T *)data);
 
@@ -1202,9 +1201,8 @@
 #endif
 
 #ifndef USE_FILE_CHOOSER
-/*ARGSUSED*/
     static void
-browse_ok_cb(GtkWidget *widget, gpointer cbdata)
+browse_ok_cb(GtkWidget *widget UNUSED, gpointer cbdata)
 {
     gui_T *vw = (gui_T *)cbdata;
 
@@ -1218,9 +1216,8 @@
 	gtk_main_quit();
 }
 
-/*ARGSUSED*/
     static void
-browse_cancel_cb(GtkWidget *widget, gpointer cbdata)
+browse_cancel_cb(GtkWidget *widget UNUSED, gpointer cbdata)
 {
     gui_T *vw = (gui_T *)cbdata;
 
@@ -1234,9 +1231,8 @@
 	gtk_main_quit();
 }
 
-/*ARGSUSED*/
     static gboolean
-browse_destroy_cb(GtkWidget * widget)
+browse_destroy_cb(GtkWidget *widget UNUSED)
 {
     if (gui.browse_fname != NULL)
     {
@@ -1262,14 +1258,13 @@
  * initdir			initial directory, NULL for current dir
  * filter			not used (file name filter)
  */
-/*ARGSUSED*/
     char_u *
-gui_mch_browse(int saving,
+gui_mch_browse(int saving UNUSED,
 	       char_u *title,
 	       char_u *dflt,
-	       char_u *ext,
+	       char_u *ext UNUSED,
 	       char_u *initdir,
-	       char_u *filter)
+	       char_u *filter UNUSED)
 {
 #ifdef USE_FILE_CHOOSER
     GtkWidget		*fc;
@@ -1377,7 +1372,6 @@
  * dflt				default name
  * initdir			initial directory, NULL for current dir
  */
-/*ARGSUSED*/
     char_u *
 gui_mch_browsedir(
 	       char_u *title,
@@ -1460,7 +1454,6 @@
 }
 
 # ifdef FEAT_GUI_GNOME
-/* ARGSUSED */
     static int
 gui_gnome_dialog( int	type,
 		char_u	*title,
@@ -1611,7 +1604,6 @@
     GtkWidget	*dialog;
 } CancelData;
 
-/* ARGSUSED */
     static void
 dlg_button_clicked(GtkWidget * widget, ButtonData *data)
 {
@@ -1622,7 +1614,6 @@
 /*
  * This makes the Escape key equivalent to the cancel button.
  */
-/*ARGSUSED*/
     static int
 dlg_key_press_event(GtkWidget *widget, GdkEventKey *event, CancelData *data)
 {
@@ -1655,7 +1646,6 @@
 	gtk_main_quit();
 }
 
-/* ARGSUSED */
     int
 gui_mch_dialog(	int	type,		/* type of dialog */
 		char_u	*title,		/* title of dialog */
@@ -2215,7 +2205,6 @@
     GtkDialog	*dialog;	    /* Widget of the dialog */
 } DialogInfo;
 
-/*ARGSUSED2*/
     static gboolean
 dialog_key_press_event_cb(GtkWidget *widget, GdkEventKey *event, gpointer data)
 {
@@ -2398,14 +2387,13 @@
  * Note: The push_in output argument seems to affect scrolling of huge
  * menus that don't fit on the screen.	Leave it at the default for now.
  */
-/*ARGSUSED0*/
     static void
-popup_menu_position_func(GtkMenu *menu,
+popup_menu_position_func(GtkMenu *menu UNUSED,
 			 gint *x, gint *y,
 # ifdef HAVE_GTK2
-			 gboolean *push_in,
+			 gboolean *push_in UNUSED,
 # endif
-			 gpointer user_data)
+			 gpointer user_data UNUSED)
 {
     gdk_window_get_origin(gui.drawarea->window, x, y);
 
@@ -2464,13 +2452,12 @@
     GtkWidget *all;	/* 'Replace All' action button */
 } SharedFindReplace;
 
-static SharedFindReplace find_widgets = { NULL, };
-static SharedFindReplace repl_widgets = { NULL, };
+static SharedFindReplace find_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
+static SharedFindReplace repl_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
 
-/* ARGSUSED */
     static int
 find_key_press_event(
-		GtkWidget	*widget,
+		GtkWidget	*widget UNUSED,
 		GdkEventKey	*event,
 		SharedFindReplace *frdp)
 {
@@ -2962,9 +2949,8 @@
 /*
  * Callback for actions of the find and replace dialogs
  */
-/*ARGSUSED*/
     static void
-find_replace_cb(GtkWidget *widget, gpointer data)
+find_replace_cb(GtkWidget *widget UNUSED, gpointer data)
 {
     int			flags;
     char_u		*find_text;
@@ -3010,9 +2996,8 @@
 }
 
 /* our usual callback function */
-/*ARGSUSED*/
     static void
-entry_activate_cb(GtkWidget *widget, gpointer data)
+entry_activate_cb(GtkWidget *widget UNUSED, gpointer data)
 {
     gtk_widget_grab_focus(GTK_WIDGET(data));
 }
@@ -3055,10 +3040,9 @@
 /*
  * ":helpfind"
  */
-/*ARGSUSED*/
     void
 ex_helpfind(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     /* This will fail when menus are not loaded.  Well, it's only for
      * backwards compatibility anyway. */
diff -Naur vim72.orig/src/gui_gtk_f.c vim72/src/gui_gtk_f.c
--- vim72.orig/src/gui_gtk_f.c	2007-05-07 20:38:02.000000000 +0100
+++ vim72/src/gui_gtk_f.c	2009-07-22 22:54:22.000000000 +0100
@@ -227,14 +227,14 @@
 
     if (!form_type)
     {
-	GtkTypeInfo form_info =
-	{
-	    "GtkForm",
-	    sizeof(GtkForm),
-	    sizeof(GtkFormClass),
-	    (GtkClassInitFunc) gtk_form_class_init,
-	    (GtkObjectInitFunc) gtk_form_init
-	};
+	GtkTypeInfo form_info;
+
+	vim_memset(&form_info, 0, sizeof(form_info));
+	form_info.type_name = "GtkForm";
+	form_info.object_size = sizeof(GtkForm);
+	form_info.class_size = sizeof(GtkFormClass);
+	form_info.class_init_func = (GtkClassInitFunc)gtk_form_class_init;
+	form_info.object_init_func = (GtkObjectInitFunc)gtk_form_init;
 
 	form_type = gtk_type_unique(GTK_TYPE_CONTAINER, &form_info);
     }
@@ -611,10 +611,9 @@
     }
 }
 
-/*ARGSUSED1*/
     static void
 gtk_form_forall(GtkContainer	*container,
-		gboolean	include_internals,
+		gboolean	include_internals UNUSED,
 		GtkCallback	callback,
 		gpointer	callback_data)
 {
@@ -786,9 +785,8 @@
  * them or discards them, depending on whether we are obscured
  * or not.
  */
-/*ARGSUSED1*/
     static GdkFilterReturn
-gtk_form_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
+gtk_form_filter(GdkXEvent *gdk_xevent, GdkEvent *event UNUSED, gpointer data)
 {
     XEvent *xevent;
     GtkForm *form;
@@ -821,9 +819,10 @@
  * there is no corresponding event in GTK, so we have
  * to get the events from a filter
  */
-/*ARGSUSED1*/
     static GdkFilterReturn
-gtk_form_main_filter(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
+gtk_form_main_filter(GdkXEvent *gdk_xevent,
+		     GdkEvent *event UNUSED,
+		     gpointer data)
 {
     XEvent *xevent;
     GtkForm *form;
@@ -911,9 +910,8 @@
 #endif
 }
 
-/*ARGSUSED0*/
     static void
-gtk_form_child_map(GtkWidget *widget, gpointer user_data)
+gtk_form_child_map(GtkWidget *widget UNUSED, gpointer user_data)
 {
     GtkFormChild *child;
 
@@ -923,9 +921,8 @@
     gdk_window_show(child->window);
 }
 
-/*ARGSUSED0*/
     static void
-gtk_form_child_unmap(GtkWidget *widget, gpointer user_data)
+gtk_form_child_unmap(GtkWidget *widget UNUSED, gpointer user_data)
 {
     GtkFormChild *child;
 
diff -Naur vim72.orig/src/gui_gtk_x11.c vim72/src/gui_gtk_x11.c
--- vim72.orig/src/gui_gtk_x11.c	2008-07-04 11:46:24.000000000 +0100
+++ vim72/src/gui_gtk_x11.c	2009-07-22 22:54:23.000000000 +0100
@@ -107,6 +107,7 @@
     TARGET_UTF8_STRING,
     TARGET_STRING,
     TARGET_COMPOUND_TEXT,
+    TARGET_HTML,
     TARGET_TEXT,
     TARGET_TEXT_URI_LIST,
     TARGET_TEXT_PLAIN,
@@ -123,6 +124,7 @@
     {VIMENC_ATOM_NAME,	0, TARGET_VIMENC},
     {VIM_ATOM_NAME,	0, TARGET_VIM},
 #ifdef FEAT_MBYTE
+    {"text/html",	0, TARGET_HTML},
     {"UTF8_STRING",	0, TARGET_UTF8_STRING},
 #endif
     {"COMPOUND_TEXT",	0, TARGET_COMPOUND_TEXT},
@@ -140,6 +142,7 @@
 {
     {"text/uri-list",	0, TARGET_TEXT_URI_LIST},
 # ifdef FEAT_MBYTE
+    {"text/html",	0, TARGET_HTML},
     {"UTF8_STRING",	0, TARGET_UTF8_STRING},
 # endif
     {"STRING",		0, TARGET_STRING},
@@ -178,6 +181,7 @@
  * Atoms used to control/reference X11 selections.
  */
 #ifdef FEAT_MBYTE
+static GdkAtom html_atom = GDK_NONE;
 static GdkAtom utf8_string_atom = GDK_NONE;
 #endif
 #ifndef HAVE_GTK2
@@ -412,6 +416,7 @@
 #endif
 #if defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION)
 static const char *restart_command = NULL;
+static       char *abs_restart_command = NULL;
 #endif
 static int found_iconic_arg = FALSE;
 
@@ -449,8 +454,10 @@
 	char_u buf[MAXPATHL];
 
 	if (mch_FullName((char_u *)argv[0], buf, (int)sizeof(buf), TRUE) == OK)
-	    /* Tiny leak; doesn't matter, and usually we don't even get here */
-	    restart_command = (char *)vim_strsave(buf);
+	{
+	    abs_restart_command = (char *)vim_strsave(buf);
+	    restart_command = abs_restart_command;
+	}
     }
 #endif
 
@@ -611,6 +618,9 @@
 gui_mch_free_all()
 {
     vim_free(gui_argv);
+#if defined(FEAT_GUI_GNOME) && defined(FEAT_SESSION)
+    vim_free(abs_restart_command);
+#endif
 }
 #endif
 
@@ -619,9 +629,10 @@
  * Doesn't seem possible, since check_copy_area() relies on
  * this information.  --danielk
  */
-/*ARGSUSED*/
     static gint
-visibility_event(GtkWidget *widget, GdkEventVisibility *event, gpointer data)
+visibility_event(GtkWidget *widget UNUSED,
+		 GdkEventVisibility *event,
+		 gpointer data UNUSED)
 {
     gui.visibility = event->state;
     /*
@@ -638,9 +649,10 @@
 /*
  * Redraw the corresponding portions of the screen.
  */
-/*ARGSUSED*/
     static gint
-expose_event(GtkWidget *widget, GdkEventExpose *event, gpointer data)
+expose_event(GtkWidget *widget UNUSED,
+	     GdkEventExpose *event,
+	     gpointer data UNUSED)
 {
     /* Skip this when the GUI isn't set up yet, will redraw later. */
     if (gui.starting)
@@ -668,9 +680,10 @@
 /*
  * Handle changes to the "Comm" property
  */
-/*ARGSUSED2*/
     static gint
-property_event(GtkWidget *widget, GdkEventProperty *event, gpointer data)
+property_event(GtkWidget *widget,
+	       GdkEventProperty *event,
+	       gpointer data UNUSED)
 {
     if (event->type == GDK_PROPERTY_NOTIFY
 	    && event->state == (int)GDK_PROPERTY_NEW_VALUE
@@ -740,9 +753,8 @@
     blink_state = BLINK_NONE;
 }
 
-/*ARGSUSED*/
     static gint
-blink_cb(gpointer data)
+blink_cb(gpointer data UNUSED)
 {
     if (blink_state == BLINK_ON)
     {
@@ -781,9 +793,10 @@
     }
 }
 
-/*ARGSUSED*/
     static gint
-enter_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)
+enter_notify_event(GtkWidget *widget UNUSED,
+		   GdkEventCrossing *event UNUSED,
+		   gpointer data UNUSED)
 {
     if (blink_state == BLINK_NONE)
 	gui_mch_start_blink();
@@ -795,9 +808,10 @@
     return FALSE;
 }
 
-/*ARGSUSED*/
     static gint
-leave_notify_event(GtkWidget *widget, GdkEventCrossing *event, gpointer data)
+leave_notify_event(GtkWidget *widget UNUSED,
+		   GdkEventCrossing *event UNUSED,
+		   gpointer data UNUSED)
 {
     if (blink_state != BLINK_NONE)
 	gui_mch_stop_blink();
@@ -805,9 +819,10 @@
     return FALSE;
 }
 
-/*ARGSUSED*/
     static gint
-focus_in_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
+focus_in_event(GtkWidget *widget,
+	       GdkEventFocus *event UNUSED,
+	       gpointer data UNUSED)
 {
     gui_focus_change(TRUE);
 
@@ -826,9 +841,10 @@
     return TRUE;
 }
 
-/*ARGSUSED*/
     static gint
-focus_out_event(GtkWidget *widget, GdkEventFocus *event, gpointer data)
+focus_out_event(GtkWidget *widget UNUSED,
+	        GdkEventFocus *event UNUSED,
+		gpointer data UNUSED)
 {
     gui_focus_change(FALSE);
 
@@ -956,9 +972,10 @@
 /*
  * Main keyboard handler:
  */
-/*ARGSUSED*/
     static gint
-key_press_event(GtkWidget *widget, GdkEventKey *event, gpointer data)
+key_press_event(GtkWidget *widget UNUSED,
+		GdkEventKey *event,
+		gpointer data UNUSED)
 {
 #ifdef HAVE_GTK2
     /* 256 bytes is way over the top, but for safety let's reduce it only
@@ -1225,9 +1242,10 @@
 }
 
 #if defined(FEAT_XIM) && defined(HAVE_GTK2)
-/*ARGSUSED0*/
     static gboolean
-key_release_event(GtkWidget *widget, GdkEventKey *event, gpointer data)
+key_release_event(GtkWidget *widget UNUSED,
+		  GdkEventKey *event,
+		  gpointer data UNUSED)
 {
     /*
      * GTK+ 2 input methods may do fancy stuff on key release events too.
@@ -1243,11 +1261,10 @@
  * Selection handlers:
  */
 
-/*ARGSUSED*/
     static gint
-selection_clear_event(GtkWidget		*widget,
+selection_clear_event(GtkWidget		*widget UNUSED,
 		      GdkEventSelection	*event,
-		      gpointer		user_data)
+		      gpointer		user_data UNUSED)
 {
     if (event->selection == clip_plus.gtk_sel_atom)
 	clip_lose_selection(&clip_plus);
@@ -1265,12 +1282,11 @@
 #define RS_FAIL	2	/* selection_received_cb() called and failed */
 static int received_selection = RS_NONE;
 
-/*ARGSUSED*/
     static void
-selection_received_cb(GtkWidget		*widget,
+selection_received_cb(GtkWidget		*widget UNUSED,
 		      GtkSelectionData	*data,
-		      guint		time_,
-		      gpointer		user_data)
+		      guint		time_ UNUSED,
+		      gpointer		user_data UNUSED)
 {
     VimClipboard    *cbd;
     char_u	    *text;
@@ -1352,6 +1368,24 @@
 	    else
 		text = tmpbuf_utf8;
 	}
+	else if (len >= 2 && text[0] == 0xff && text[1] == 0xfe)
+	{
+	    vimconv_T conv;
+
+	    /* UTF-16, we get this for HTML */
+	    conv.vc_type = CONV_NONE;
+	    convert_setup_ext(&conv, (char_u *)"utf-16le", FALSE, p_enc, TRUE);
+
+	    if (conv.vc_type != CONV_NONE)
+	    {
+		text += 2;
+		len -= 2;
+		tmpbuf = string_convert(&conv, text, &len);
+		convert_setup(&conv, NULL, NULL);
+	    }
+	    if (tmpbuf != NULL)
+		text = tmpbuf;
+	}
     }
 #else /* !HAVE_GTK2 */
 # ifdef FEAT_MBYTE
@@ -1414,13 +1448,12 @@
  * Prepare our selection data for passing it to the external selection
  * client.
  */
-/*ARGSUSED*/
     static void
-selection_get_cb(GtkWidget	    *widget,
+selection_get_cb(GtkWidget	    *widget UNUSED,
 		 GtkSelectionData   *selection_data,
 		 guint		    info,
-		 guint		    time_,
-		 gpointer	    user_data)
+		 guint		    time_ UNUSED,
+		 gpointer	    user_data UNUSED)
 {
     char_u	    *string;
     char_u	    *tmpbuf;
@@ -1440,6 +1473,7 @@
 
     if (info != (guint)TARGET_STRING
 #ifdef FEAT_MBYTE
+	    && (!clip_html || info != (guint)TARGET_HTML)
 	    && info != (guint)TARGET_UTF8_STRING
 	    && info != (guint)TARGET_VIMENC
 #endif
@@ -1475,6 +1509,40 @@
     }
 
 #ifdef FEAT_MBYTE
+    else if (info == (guint)TARGET_HTML)
+    {
+	vimconv_T conv;
+
+	/* Since we get utf-16, we probably should set it as well. */
+	conv.vc_type = CONV_NONE;
+	convert_setup_ext(&conv, p_enc, TRUE, (char_u *)"utf-16le", FALSE);
+	if (conv.vc_type != CONV_NONE)
+	{
+	    tmpbuf = string_convert(&conv, string, &length);
+	    convert_setup(&conv, NULL, NULL);
+	    vim_free(string);
+	    string = tmpbuf;
+	}
+
+	/* Prepend the BOM: "fffe" */
+	if (string != NULL)
+	{
+	    tmpbuf = alloc(length + 2);
+	    tmpbuf[0] = 0xff;
+	    tmpbuf[1] = 0xfe;
+	    mch_memmove(tmpbuf + 2, string, (size_t)length);
+	    vim_free(string);
+	    string = tmpbuf;
+	    length += 2;
+
+	    selection_data->type = selection_data->target;
+	    selection_data->format = 16;	/* 16 bits per char */
+	    gtk_selection_data_set(selection_data, html_atom, 16,
+							      string, length);
+	    vim_free(string);
+	}
+	return;
+    }
     else if (info == (guint)TARGET_VIMENC)
     {
 	int l = STRLEN(p_enc);
@@ -1678,7 +1746,7 @@
 
 	offshoot = dx > dy ? dx : dy;
 
-	/* Make a linearly declaying timer delay with a threshold of 5 at a
+	/* Make a linearly decaying timer delay with a threshold of 5 at a
 	 * distance of 127 pixels from the main window.
 	 *
 	 * One could think endlessly about the most ergonomic variant here.
@@ -1707,9 +1775,8 @@
 /*
  * Timer used to recognize multiple clicks of the mouse button.
  */
-/*ARGSUSED0*/
     static gint
-motion_repeat_timer_cb(gpointer data)
+motion_repeat_timer_cb(gpointer data UNUSED)
 {
     int		    x;
     int		    y;
@@ -1749,9 +1816,10 @@
     return FALSE;
 }
 
-/*ARGSUSED2*/
     static gint
-motion_notify_event(GtkWidget *widget, GdkEventMotion *event, gpointer data)
+motion_notify_event(GtkWidget *widget,
+		    GdkEventMotion *event,
+		    gpointer data UNUSED)
 {
     if (event->is_hint)
     {
@@ -1777,9 +1845,10 @@
  * by our own timeout mechanism instead of the one provided by GTK+ itself.
  * This is due to the way the generic VIM code is recognizing multiple clicks.
  */
-/*ARGSUSED2*/
     static gint
-button_press_event(GtkWidget *widget, GdkEventButton *event, gpointer data)
+button_press_event(GtkWidget *widget,
+		   GdkEventButton *event,
+		   gpointer data UNUSED)
 {
     int button;
     int repeated_click = FALSE;
@@ -1855,9 +1924,10 @@
  * GTK+ 2 doesn't handle mouse buttons 4, 5, 6 and 7 the same way as GTK+ 1.
  * Instead, it abstracts scrolling via the new GdkEventScroll.
  */
-/*ARGSUSED2*/
     static gboolean
-scroll_event(GtkWidget *widget, GdkEventScroll *event, gpointer data)
+scroll_event(GtkWidget *widget,
+	     GdkEventScroll *event,
+	     gpointer data UNUSED)
 {
     int	    button;
     int_u   vim_modifiers;
@@ -1896,9 +1966,10 @@
 #endif /* HAVE_GTK2 */
 
 
-/*ARGSUSED*/
     static gint
-button_release_event(GtkWidget *widget, GdkEventButton *event, gpointer data)
+button_release_event(GtkWidget *widget UNUSED,
+		     GdkEventButton *event,
+		     gpointer data UNUSED)
 {
     int x, y;
     int_u vim_modifiers;
@@ -2100,7 +2171,6 @@
 /*
  * DND receiver.
  */
-/*ARGSUSED2*/
     static void
 drag_data_received_cb(GtkWidget		*widget,
 		      GdkDragContext	*context,
@@ -2109,7 +2179,7 @@
 		      GtkSelectionData	*data,
 		      guint		info,
 		      guint		time_,
-		      gpointer		user_data)
+		      gpointer		user_data UNUSED)
 {
     GdkModifierType state;
 
@@ -2143,7 +2213,6 @@
  * be abandoned and pop up a dialog asking the user for confirmation if
  * necessary.
  */
-/*ARGSUSED0*/
     static void
 sm_client_check_changed_any(GnomeClient	    *client,
 			    gint	    key,
@@ -2251,7 +2320,6 @@
  * for confirmation if necessary.  Save the current editing session and tell
  * the session manager how to restart Vim.
  */
-/*ARGSUSED1*/
     static gboolean
 sm_client_save_yourself(GnomeClient	    *client,
 			gint		    phase,
@@ -2339,7 +2407,6 @@
  * here since "save_yourself" has been emitted before (unless serious trouble
  * is happening).
  */
-/*ARGSUSED0*/
     static void
 sm_client_die(GnomeClient *client, gpointer data)
 {
@@ -2379,10 +2446,9 @@
 /*
  * GTK tells us that XSMP needs attention
  */
-/*ARGSUSED*/
     static gboolean
 local_xsmp_handle_requests(source, condition, data)
-    GIOChannel		*source;
+    GIOChannel		*source UNUSED;
     GIOCondition	condition;
     gpointer		data;
 {
@@ -2480,16 +2546,18 @@
  * WM_SAVE_YOURSELF hack it actually stores the session...  And yes,
  * it should work with KDE as well.
  */
-/*ARGSUSED1*/
     static GdkFilterReturn
-global_event_filter(GdkXEvent *xev, GdkEvent *event, gpointer data)
+global_event_filter(GdkXEvent *xev,
+		    GdkEvent *event UNUSED,
+		    gpointer data UNUSED)
 {
     XEvent *xevent = (XEvent *)xev;
 
     if (xevent != NULL
 	    && xevent->type == ClientMessage
 	    && xevent->xclient.message_type == GET_X_ATOM(wm_protocols_atom)
-	    && xevent->xclient.data.l[0] == GET_X_ATOM(save_yourself_atom))
+	    && (long_u)xevent->xclient.data.l[0]
+					    == GET_X_ATOM(save_yourself_atom))
     {
 	out_flush();
 	ml_sync_all(FALSE, FALSE); /* preserve all swap files */
@@ -2512,7 +2580,6 @@
 /*
  * GDK handler for X ClientMessage events.
  */
-/*ARGSUSED2*/
     static GdkFilterReturn
 gdk_wm_protocols_filter(GdkXEvent *xev, GdkEvent *event, gpointer data)
 {
@@ -2558,9 +2625,8 @@
 /*
  * Setup the window icon & xcmdsrv comm after the main window has been realized.
  */
-/*ARGSUSED*/
     static void
-mainwin_realize(GtkWidget *widget, gpointer data)
+mainwin_realize(GtkWidget *widget UNUSED, gpointer data UNUSED)
 {
 /* If you get an error message here, you still need to unpack the runtime
  * archive! */
@@ -2712,11 +2778,10 @@
 }
 
 #ifdef HAVE_GTK_MULTIHEAD
-/*ARGSUSED1*/
     static void
 mainwin_screen_changed_cb(GtkWidget  *widget,
-			  GdkScreen  *previous_screen,
-			  gpointer   data)
+			  GdkScreen  *previous_screen UNUSED,
+			  gpointer   data UNUSED)
 {
     if (!gtk_widget_has_screen(widget))
 	return;
@@ -2757,9 +2822,8 @@
  * Don't try to set any VIM scrollbar sizes anywhere here. I'm relying on the
  * fact that the main VIM engine doesn't take them into account anywhere.
  */
-/*ARGSUSED1*/
     static void
-drawarea_realize_cb(GtkWidget *widget, gpointer data)
+drawarea_realize_cb(GtkWidget *widget, gpointer data UNUSED)
 {
     GtkWidget *sbar;
 
@@ -2789,9 +2853,8 @@
 /*
  * Properly clean up on shutdown.
  */
-/*ARGSUSED0*/
     static void
-drawarea_unrealize_cb(GtkWidget *widget, gpointer data)
+drawarea_unrealize_cb(GtkWidget *widget UNUSED, gpointer data UNUSED)
 {
     /* Don't write messages to the GUI anymore */
     full_screen = FALSE;
@@ -2827,11 +2890,10 @@
 #endif
 }
 
-/*ARGSUSED0*/
     static void
-drawarea_style_set_cb(GtkWidget	*widget,
-		      GtkStyle	*previous_style,
-		      gpointer	data)
+drawarea_style_set_cb(GtkWidget	*widget UNUSED,
+		      GtkStyle	*previous_style UNUSED,
+		      gpointer	data UNUSED)
 {
     gui_mch_new_colors();
 }
@@ -2840,9 +2902,10 @@
  * Callback routine for the "delete_event" signal on the toplevel window.
  * Tries to vim gracefully, or refuses to exit with changed buffers.
  */
-/*ARGSUSED*/
     static gint
-delete_event_cb(GtkWidget *widget, GdkEventAny *event, gpointer data)
+delete_event_cb(GtkWidget *widget UNUSED,
+		GdkEventAny *event UNUSED,
+		gpointer data UNUSED)
 {
     gui_shell_closed();
     return TRUE;
@@ -2964,7 +3027,7 @@
 
     /* At start-up, don't try to set the hints until the initial
      * values have been used (those that dictate our initial size)
-     * Let forced (i.e., correct) values thruogh always.
+     * Let forced (i.e., correct) values through always.
      */
     if (!(force_width && force_height)  &&  init_window_hints_state > 0)
     {
@@ -3142,9 +3205,8 @@
 /*
  * Handle selecting an item in the tab line popup menu.
  */
-/*ARGSUSED*/
     static void
-tabline_menu_handler(GtkMenuItem *item, gpointer user_data)
+tabline_menu_handler(GtkMenuItem *item UNUSED, gpointer user_data)
 {
     /* Add the string cmd into input buffer */
     send_tabline_menu_event(clicked_page, (int)(long)user_data);
@@ -3244,13 +3306,12 @@
 /*
  * Handle selecting one of the tabs.
  */
-/*ARGSUSED*/
     static void
 on_select_tab(
-	GtkNotebook	*notebook,
-	GtkNotebookPage *page,
+	GtkNotebook	*notebook UNUSED,
+	GtkNotebookPage *page UNUSED,
 	gint		idx,
-	gpointer	data)
+	gpointer	data UNUSED)
 {
     if (!ignore_tabline_evt)
     {
@@ -3460,6 +3521,7 @@
 
     /* Initialise atoms */
 #ifdef FEAT_MBYTE
+    html_atom = gdk_atom_intern("text/html", FALSE);
     utf8_string_atom = gdk_atom_intern("UTF8_STRING", FALSE);
 #endif
 #ifndef HAVE_GTK2
@@ -3784,7 +3846,7 @@
 #endif
 
     if (gtk_socket_id != 0)
-	/* make sure keybord input can go to the drawarea */
+	/* make sure keyboard input can go to the drawarea */
 	GTK_WIDGET_SET_FLAGS(gui.drawarea, GTK_CAN_FOCUS);
 
     /*
@@ -3922,10 +3984,10 @@
 /*
  * This signal informs us about the need to rearrange our sub-widgets.
  */
-/*ARGSUSED*/
     static gint
-form_configure_event(GtkWidget *widget, GdkEventConfigure *event,
-		     gpointer data)
+form_configure_event(GtkWidget *widget UNUSED,
+		     GdkEventConfigure *event,
+		     gpointer data UNUSED)
 {
     int usable_height = event->height;
 
@@ -3948,9 +4010,8 @@
  * We can't do much more here than to trying to preserve what had been done,
  * since the window is already inevitably going away.
  */
-/*ARGSUSED0*/
     static void
-mainwin_destroy_cb(GtkObject *object, gpointer data)
+mainwin_destroy_cb(GtkObject *object UNUSED, gpointer data UNUSED)
 {
     /* Don't write messages to the GUI anymore */
     full_screen = FALSE;
@@ -3980,9 +4041,8 @@
  * scrollbar init.), actually do the standard hinst and stop the timer.
  * We'll not let the default hints be set while this timer's active.
  */
-/*ARGSUSED*/
     static gboolean
-check_startup_plug_hints(gpointer data)
+check_startup_plug_hints(gpointer data UNUSED)
 {
     if (init_window_hints_state == 1)
     {
@@ -4055,7 +4115,7 @@
 	    Columns = w;
 	if (mask & HeightValue)
 	{
-	    if (p_window > h - 1 || !option_was_set((char_u *)"window"))
+	    if (p_window > (long)h - 1 || !option_was_set((char_u *)"window"))
 		p_window = h - 1;
 	    Rows = h;
 	}
@@ -4070,14 +4130,14 @@
 
 	if (mask & (XValue | YValue))
 	{
-	    int w, h;
-	    gui_mch_get_screen_dimensions(&w, &h);
-	    h += p_ghr + get_menu_tool_height();
-	    w += get_menu_tool_width();
+	    int ww, hh;
+	    gui_mch_get_screen_dimensions(&ww, &hh);
+	    hh += p_ghr + get_menu_tool_height();
+	    ww += get_menu_tool_width();
 	    if (mask & XNegative)
-		x += w - pixel_width;
+		x += ww - pixel_width;
 	    if (mask & YNegative)
-		y += h - pixel_height;
+		y += hh - pixel_height;
 #ifdef HAVE_GTK2
 	    gtk_window_move(GTK_WINDOW(gui.mainwin), x, y);
 #else
@@ -4229,9 +4289,8 @@
 }
 
 
-/*ARGSUSED0*/
     void
-gui_mch_exit(int rc)
+gui_mch_exit(int rc UNUSED)
 {
     if (gui.mainwin != NULL)
 	gtk_widget_destroy(gui.mainwin);
@@ -4286,7 +4345,6 @@
  * report the new size through form_configure_event().  That caused the window
  * layout to be messed up.
  */
-/*ARGSUSED0*/
     static gboolean
 force_shell_resize_idle(gpointer data)
 {
@@ -4314,12 +4372,11 @@
 /*
  * Set the windows size.
  */
-/*ARGSUSED2*/
     void
 gui_mch_set_shellsize(int width, int height,
-		      int min_width,  int min_height,
-		      int base_width, int base_height,
-		      int direction)
+		      int min_width UNUSED,  int min_height UNUSED,
+		      int base_width UNUSED, int base_height UNUSED,
+		      int direction UNUSED)
 {
 #ifndef HAVE_GTK2
     /* Hack: When the form already is at the desired size, the window might
@@ -4413,9 +4470,8 @@
 }
 
 #if defined(FEAT_TITLE) || defined(PROTO)
-/*ARGSUSED*/
     void
-gui_mch_settitle(char_u *title, char_u *icon)
+gui_mch_settitle(char_u *title, char_u *icon UNUSED)
 {
 # ifdef HAVE_GTK2
     if (title != NULL && output_conv.vc_type != CONV_NONE)
@@ -4493,7 +4549,6 @@
  * Get a font structure for highlighting.
  * "cbdata" is a pointer to the global gui structure.
  */
-/*ARGSUSED*/
     static void
 font_sel_ok(GtkWidget *wgt, gpointer cbdata)
 {
@@ -4509,7 +4564,6 @@
 	gtk_main_quit();
 }
 
-/*ARGSUSED*/
     static void
 font_sel_cancel(GtkWidget *wgt, gpointer cbdata)
 {
@@ -4520,7 +4574,6 @@
 	gtk_main_quit();
 }
 
-/*ARGSUSED*/
     static void
 font_sel_destroy(GtkWidget *wgt, gpointer cbdata)
 {
@@ -4620,7 +4673,6 @@
 /*
  * Try to load the requested fontset.
  */
-/*ARGSUSED2*/
     GuiFontset
 gui_mch_get_fontset(char_u *name, int report_error, int fixed_width)
 {
@@ -4863,7 +4915,7 @@
     styled_font[1] = &gui.ital_font;
     styled_font[2] = &gui.boldital_font;
 
-    /* First free whatever was freviously there. */
+    /* First free whatever was previously there. */
     for (i = 0; i < 3; ++i)
 	if (*styled_font[i])
 	{
@@ -5012,9 +5064,8 @@
  * Initialize Vim to use the font or fontset with the given name.
  * Return FAIL if the font could not be loaded, OK otherwise.
  */
-/*ARGSUSED1*/
     int
-gui_mch_init_font(char_u *font_name, int fontset)
+gui_mch_init_font(char_u *font_name, int fontset UNUSED)
 {
 #ifdef HAVE_GTK2
     PangoFontDescription    *font_desc;
@@ -5326,9 +5377,8 @@
 /*
  * Return the name of font "font" in allocated memory.
  */
-/*ARGSUSED*/
     char_u *
-gui_mch_get_fontname(GuiFont font, char_u *name)
+gui_mch_get_fontname(GuiFont font, char_u *name UNUSED)
 {
 # ifdef HAVE_GTK2
     if (font != NOFONT)
@@ -5732,7 +5782,7 @@
 {
     int			i;
     int			offset;
-    const static int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
+    static const int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
     int			y = FILL_Y(row + 1) - 1;
 
     /* Undercurl: draw curl at the bottom of the character cell. */
@@ -6085,12 +6135,15 @@
 # ifdef FEAT_MBYTE
 	    if (enc_utf8)
 	    {
-		c = utf_ptr2char(p);
+		int pcc[MAX_MCO];
+
+		/* TODO: use the composing characters */
+		c = utfc_ptr2char_len(p, &pcc, len - (p - s));
 		if (c >= 0x10000)	/* show chars > 0xffff as ? */
 		    c = 0xbf;
 		buf[textlen].byte1 = c >> 8;
 		buf[textlen].byte2 = c;
-		p += utf_ptr2len(p);
+		p += utfc_ptr2len_len(p, len - (p - s));
 		width += utf_char2cells(c);
 	    }
 	    else
@@ -6114,8 +6167,8 @@
 	if (has_mbyte)
 	{
 	    width = 0;
-	    for (p = s; p < s + len; p += (*mb_ptr2len)(p))
-		width += (*mb_ptr2cells)(p);
+	    for (p = s; p < s + len; p += (*mb_ptr2len_len)(p, len - (p - s)))
+		width += (*mb_ptr2cells_len)(p, len - (p - s));
 	}
 	else
 # endif
@@ -6402,7 +6455,6 @@
 /*
  * Callback function, used when data is available on the SNiFF connection.
  */
-/* ARGSUSED */
     static void
 sniff_request_cb(
     gpointer	data,
@@ -6665,12 +6717,14 @@
 {
     GdkAtom	target;
     unsigned	i;
-    int		nbytes;
-    char_u	*buffer;
     time_t	start;
 
     for (i = 0; i < N_SELECTION_TARGETS; ++i)
     {
+#ifdef FEAT_MBYTE
+	if (!clip_html && selection_targets[i].info == TARGET_HTML)
+	    continue;
+#endif
 	received_selection = RS_NONE;
 	target = gdk_atom_intern(selection_targets[i].target, FALSE);
 
@@ -6690,30 +6744,14 @@
     }
 
     /* Final fallback position - use the X CUT_BUFFER0 store */
-    nbytes = 0;
-    buffer = (char_u *)XFetchBuffer(GDK_WINDOW_XDISPLAY(gui.mainwin->window),
-				    &nbytes, 0);
-    if (nbytes > 0)
-    {
-	/* Got something */
-	clip_yank_selection(MCHAR, buffer, (long)nbytes, cbd);
-	if (p_verbose > 0)
-	{
-	    verbose_enter();
-	    smsg((char_u *)_("Used CUT_BUFFER0 instead of empty selection"));
-	    verbose_leave();
-	}
-    }
-    if (buffer != NULL)
-	XFree(buffer);
+    yank_cut_buffer0(GDK_WINDOW_XDISPLAY(gui.mainwin->window), cbd);
 }
 
 /*
  * Disown the selection.
  */
-/*ARGSUSED*/
     void
-clip_mch_lose_selection(VimClipboard *cbd)
+clip_mch_lose_selection(VimClipboard *cbd UNUSED)
 {
     /* WEIRD: when using NULL to actually disown the selection, we lose the
      * selection the first time we own it. */
@@ -6741,9 +6779,8 @@
  * Send the current selection to the clipboard.  Do nothing for X because we
  * will fill in the selection only when requested by another app.
  */
-/*ARGSUSED*/
     void
-clip_mch_set_selection(VimClipboard *cbd)
+clip_mch_set_selection(VimClipboard *cbd UNUSED)
 {
 }
 
@@ -6950,7 +6987,7 @@
 	    else
 		id &= ~1;	/* they are always even (why?) */
 	}
-	else if (shape < sizeof(mshape_ids) / sizeof(int))
+	else if (shape < (int)(sizeof(mshape_ids) / sizeof(int)))
 	    id = mshape_ids[shape];
 	else
 	    return;
diff -Naur vim72.orig/src/gui_motif.c vim72/src/gui_motif.c
--- vim72.orig/src/gui_motif.c	2008-06-07 14:06:33.000000000 +0100
+++ vim72/src/gui_motif.c	2009-07-22 22:54:22.000000000 +0100
@@ -117,10 +117,9 @@
  * Call-back routines.
  */
 
-/* ARGSUSED */
     static void
 scroll_cb(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data, call_data;
 {
     scrollbar_T *sb;
@@ -136,11 +135,11 @@
 }
 
 #ifdef FEAT_GUI_TABLINE
-/*ARGSUSED*/
     static void
 tabline_cb(w, client_data, call_data)
-    Widget	w;
-    XtPointer	client_data, call_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
+    XtPointer	call_data;
 {
     XmNotebookCallbackStruct *nptr;
 
@@ -149,11 +148,11 @@
 	send_tabline_event(nptr->page_number);
 }
 
-/*ARGSUSED*/
     static void
 tabline_button_cb(w, client_data, call_data)
     Widget	w;
-    XtPointer	client_data, call_data;
+    XtPointer	client_data UNUSED;
+    XtPointer	call_data UNUSED;
 {
     int		cmd, tab_idx;
 
@@ -166,11 +165,10 @@
 /*
  * Tabline single mouse click timeout handler
  */
-/*ARGSUSED*/
     static void
 motif_tabline_timer_cb (timed_out, interval_id)
     XtPointer		timed_out;
-    XtIntervalId	*interval_id;
+    XtIntervalId	*interval_id UNUSED;
 {
     *((int *)timed_out) = TRUE;
 }
@@ -203,13 +201,12 @@
     return FALSE;
 }
 
-/*ARGSUSED*/
     static void
 tabline_menu_cb(w, closure, e, continue_dispatch)
     Widget	w;
-    XtPointer	closure;
+    XtPointer	closure UNUSED;
     XEvent	*e;
-    Boolean	*continue_dispatch;
+    Boolean	*continue_dispatch UNUSED;
 {
     Widget			tab_w;
     XButtonPressedEvent		*event;
@@ -277,11 +274,10 @@
     XtManageChild(tabLine_menu);
 }
 
-/*ARGSUSED*/
     static void
 tabline_balloon_cb(beval, state)
     BalloonEval	*beval;
-    int		state;
+    int		state UNUSED;
 {
     int		nr;
     tabpage_T	*tp;
@@ -642,13 +638,12 @@
 #endif
 }
 
-/*ARGSUSED*/
     void
 gui_mch_set_text_area_pos(x, y, w, h)
-    int	    x;
-    int	    y;
-    int	    w;
-    int	    h;
+    int	    x UNUSED;
+    int	    y UNUSED;
+    int	    w UNUSED;
+    int	    h UNUSED;
 {
 #ifdef FEAT_TOOLBAR
     /* Give keyboard focus to the textArea instead of the toolbar. */
@@ -1261,7 +1256,7 @@
     if (menu->icon_builtin || gui_find_bitmap(menu->name, buf, "xpm") == FAIL)
     {
 	if (menu->iconidx >= 0 && menu->iconidx
-		   < (sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
+	       < (int)(sizeof(built_in_pixmaps) / sizeof(built_in_pixmaps[0])))
 	    xpm = built_in_pixmaps[menu->iconidx];
 	else
 	    xpm = tb_blank_xpm;
@@ -1716,10 +1711,9 @@
     }
 }
 
-/* ARGSUSED */
     void
 gui_mch_show_popupmenu(menu)
-    vimmenu_T *menu;
+    vimmenu_T *menu UNUSED;
 {
 #ifdef MOTIF_POPUP
     XmMenuPosition(menu->submenu_id, gui_x11_get_last_mouse_event());
@@ -2046,9 +2040,8 @@
 /*
  * Callback routine for dialog mnemonic processing.
  */
-/*ARGSUSED*/
     static void
-mnemonic_event(Widget w, XtPointer call_data, XKeyEvent *event)
+mnemonic_event(Widget w, XtPointer call_data UNUSED, XKeyEvent *event)
 {
     do_mnemonic(w, event->keycode);
 }
@@ -2287,13 +2280,12 @@
  * Put up a file requester.
  * Returns the selected name in allocated memory, or NULL for Cancel.
  */
-/* ARGSUSED */
     char_u *
 gui_mch_browse(saving, title, dflt, ext, initdir, filter)
-    int		saving;		/* select file to write */
+    int		saving UNUSED;	/* select file to write */
     char_u	*title;		/* title for the window */
     char_u	*dflt;		/* default name */
-    char_u	*ext;		/* not used (extension added) */
+    char_u	*ext UNUSED;	/* not used (extension added) */
     char_u	*initdir;	/* initial directory, NULL for current dir */
     char_u	*filter;	/* file name filter */
 {
@@ -2413,12 +2405,11 @@
 /*
  * Process callback from Dialog cancel actions.
  */
-/* ARGSUSED */
     static void
 DialogCancelCB(w, client_data, call_data)
-    Widget	w;		/*  widget id		*/
-    XtPointer	client_data;	/*  data from application   */
-    XtPointer	call_data;	/*  data from widget class  */
+    Widget	w UNUSED;		/*  widget id		*/
+    XtPointer	client_data UNUSED;	/*  data from application   */
+    XtPointer	call_data UNUSED;	/*  data from widget class  */
 {
     if (browse_fname != NULL)
     {
@@ -2431,12 +2422,11 @@
 /*
  * Process callback from Dialog actions.
  */
-/* ARGSUSED */
     static void
 DialogAcceptCB(w, client_data, call_data)
-    Widget	w;		/*  widget id		*/
-    XtPointer	client_data;	/*  data from application   */
-    XtPointer	call_data;	/*  data from widget class  */
+    Widget	w UNUSED;		/*  widget id		*/
+    XtPointer	client_data UNUSED;	/*  data from application   */
+    XtPointer	call_data;		/*  data from widget class  */
 {
     XmFileSelectionBoxCallbackStruct *fcb;
 
@@ -2467,13 +2457,12 @@
  * Callback function for the textfield.  When CR is hit this works like
  * hitting the "OK" button, ESC like "Cancel".
  */
-/* ARGSUSED */
     static void
 keyhit_callback(w, client_data, event, cont)
     Widget		w;
-    XtPointer		client_data;
+    XtPointer		client_data UNUSED;
     XEvent		*event;
-    Boolean		*cont;
+    Boolean		*cont UNUSED;
 {
     char	buf[2];
     KeySym	key_sym;
@@ -2490,12 +2479,11 @@
 	XmTextFieldClearSelection(w, XtLastTimestampProcessed(gui.dpy));
 }
 
-/* ARGSUSED */
     static void
 butproc(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     dialogStatus = (int)(long)client_data + 1;
 }
@@ -2567,10 +2555,9 @@
 }
 #endif
 
-/* ARGSUSED */
     int
 gui_mch_dialog(type, title, message, button_names, dfltbutton, textfield)
-    int		type;
+    int		type UNUSED;
     char_u	*title;
     char_u	*message;
     char_u	*button_names;
@@ -3197,7 +3184,7 @@
 		XmNchildren, &children,
 		XmNnumChildren, &numChildren, NULL);
 	borders += tst + tmh;
-	for (i = 0; i < numChildren; i++)
+	for (i = 0; i < (int)numChildren; i++)
 	{
 	    whgt = 0;
 	    XtVaGetValues(children[i], XmNheight, &whgt, NULL);
@@ -3237,13 +3224,12 @@
  * I have to use footer help for backwards compatability.  Hopefully both will
  * get implemented and the user will have a choice.
  */
-/*ARGSUSED*/
     static void
 toolbarbutton_enter_cb(w, client_data, event, cont)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XEvent	*event;
-    Boolean	*cont;
+    XEvent	*event UNUSED;
+    Boolean	*cont UNUSED;
 {
     vimmenu_T	*menu = (vimmenu_T *) client_data;
 
@@ -3254,13 +3240,12 @@
     }
 }
 
-/*ARGSUSED*/
     static void
 toolbarbutton_leave_cb(w, client_data, event, cont)
-    Widget	w;
-    XtPointer	client_data;
-    XEvent	*event;
-    Boolean	*cont;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
+    XEvent	*event UNUSED;
+    Boolean	*cont UNUSED;
 {
     gui_mch_set_footer((char_u *) "");
 }
@@ -3492,10 +3477,9 @@
 /*
  * Set the fontlist for Widget "id" to use gui.menu_fontset or gui.menu_font.
  */
-/*ARGSUSED*/
     void
 gui_motif_menu_fontlist(id)
-    Widget  id;
+    Widget  id UNUSED;
 {
 #ifdef FEAT_MENU
 #ifdef FONTSET_ALWAYS
@@ -3566,8 +3550,8 @@
     Widget cancel;
 } SharedFindReplace;
 
-static SharedFindReplace find_widgets = { NULL };
-static SharedFindReplace repl_widgets = { NULL };
+static SharedFindReplace find_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
+static SharedFindReplace repl_widgets = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
 
 static void find_replace_destroy_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
 static void find_replace_dismiss_callback __ARGS((Widget w, XtPointer client_data, XtPointer call_data));
@@ -3576,12 +3560,11 @@
 static void find_replace_keypress __ARGS((Widget w, SharedFindReplace * frdp, XKeyEvent * event));
 static void find_replace_dialog_create __ARGS((char_u *entry_text, int do_replace));
 
-/*ARGSUSED*/
     static void
 find_replace_destroy_callback(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     SharedFindReplace *cd = (SharedFindReplace *)client_data;
 
@@ -3590,12 +3573,11 @@
 	cd->dialog = (Widget)0;
 }
 
-/*ARGSUSED*/
     static void
 find_replace_dismiss_callback(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     SharedFindReplace *cd = (SharedFindReplace *)client_data;
 
@@ -3603,22 +3585,20 @@
 	XtUnmanageChild(cd->dialog);
 }
 
-/*ARGSUSED*/
     static void
 entry_activate_callback(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     XmProcessTraversal((Widget)client_data, XmTRAVERSE_CURRENT);
 }
 
-/*ARGSUSED*/
     static void
 find_replace_callback(w, client_data, call_data)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	client_data;
-    XtPointer	call_data;
+    XtPointer	call_data UNUSED;
 {
     long_u	flags = (long_u)client_data;
     char	*find_text, *repl_text;
@@ -3668,10 +3648,9 @@
 	XtFree(repl_text);
 }
 
-/*ARGSUSED*/
     static void
 find_replace_keypress(w, frdp, event)
-    Widget		w;
+    Widget		w UNUSED;
     SharedFindReplace	*frdp;
     XKeyEvent		*event;
 {
diff -Naur vim72.orig/src/gui_x11.c vim72/src/gui_x11.c
--- vim72.orig/src/gui_x11.c	2008-06-08 16:13:45.000000000 +0100
+++ vim72/src/gui_x11.c	2009-07-22 22:54:22.000000000 +0100
@@ -570,22 +570,20 @@
  * Call-back routines.
  */
 
-/* ARGSUSED */
     static void
 gui_x11_timer_cb(timed_out, interval_id)
     XtPointer	    timed_out;
-    XtIntervalId    *interval_id;
+    XtIntervalId    *interval_id UNUSED;
 {
     *((int *)timed_out) = TRUE;
 }
 
-/* ARGSUSED */
     static void
 gui_x11_visibility_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     if (event->type != VisibilityNotify)
 	return;
@@ -603,13 +601,12 @@
     gui_mch_update();
 }
 
-/* ARGSUSED */
     static void
 gui_x11_expose_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     XExposeEvent	*gevent;
     int			new_x;
@@ -680,13 +677,12 @@
 }
 #endif
 
-/* ARGSUSED */
     static void
 gui_x11_resize_window_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     static int lastWidth, lastHeight;
 
@@ -727,35 +723,32 @@
 #endif
 }
 
-/* ARGSUSED */
     static void
 gui_x11_focus_change_cb(w, data, event, dum)
-    Widget	w;
-    XtPointer	data;
+    Widget	w UNUSED;
+    XtPointer	data UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     gui_focus_change(event->type == FocusIn);
 }
 
-/* ARGSUSED */
     static void
 gui_x11_enter_cb(w, data, event, dum)
-    Widget	w;
-    XtPointer	data;
-    XEvent	*event;
-    Boolean	*dum;
+    Widget	w UNUSED;
+    XtPointer	data UNUSED;
+    XEvent	*event UNUSED;
+    Boolean	*dum UNUSED;
 {
     gui_focus_change(TRUE);
 }
 
-/* ARGSUSED */
     static void
 gui_x11_leave_cb(w, data, event, dum)
-    Widget	w;
-    XtPointer	data;
-    XEvent	*event;
-    Boolean	*dum;
+    Widget	w UNUSED;
+    XtPointer	data UNUSED;
+    XEvent	*event UNUSED;
+    Boolean	*dum UNUSED;
 {
     gui_focus_change(FALSE);
 }
@@ -766,13 +759,12 @@
 # endif
 #endif
 
-/* ARGSUSED */
     void
 gui_x11_key_hit_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     XKeyPressedEvent	*ev_press;
 #ifdef FEAT_XIM
@@ -1078,13 +1070,12 @@
 #endif
 }
 
-/* ARGSUSED */
     static void
 gui_x11_mouse_cb(w, dud, event, dum)
-    Widget	w;
-    XtPointer	dud;
+    Widget	w UNUSED;
+    XtPointer	dud UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     static XtIntervalId timer = (XtIntervalId)0;
     static int	timed_out = TRUE;
@@ -1210,11 +1201,11 @@
     while (arg < *argc)
     {
 	/* Look for argv[arg] in cmdline_options[] table */
-	for (i = 0; i < XtNumber(cmdline_options); i++)
+	for (i = 0; i < (int)XtNumber(cmdline_options); i++)
 	    if (strcmp(argv[arg], cmdline_options[i].option) == 0)
 		break;
 
-	if (i < XtNumber(cmdline_options))
+	if (i < (int)XtNumber(cmdline_options))
 	{
 	    /* Remember finding "-rv" or "-reverse" */
 	    if (strcmp("-rv", argv[arg]) == 0
@@ -1319,12 +1310,11 @@
 
 static void local_xsmp_handle_requests __ARGS((XtPointer c, int *s, XtInputId *i));
 
-/*ARGSUSED*/
     static void
 local_xsmp_handle_requests(c, s, i)
-    XtPointer	c;
-    int		*s;
-    XtInputId	*i;
+    XtPointer	c UNUSED;
+    int		*s UNUSED;
+    XtInputId	*i UNUSED;
 {
     if (xsmp_handle_requests() == FAIL)
 	XtRemoveInput(_xsmp_xtinputid);
@@ -1438,7 +1428,7 @@
 	    Columns = w;
 	if (mask & HeightValue)
 	{
-	    if (p_window > h - 1 || !option_was_set((char_u *)"window"))
+	    if (p_window > (long)h - 1 || !option_was_set((char_u *)"window"))
 		p_window = h - 1;
 	    Rows = h;
 	}
@@ -1587,6 +1577,8 @@
     XtCloseDisplay(gui.dpy);
     gui.dpy = NULL;
     vimShell = (Widget)0;
+    vim_free(gui_argv);
+    gui_argv = NULL;
 }
 
 /*
@@ -1751,16 +1743,17 @@
 }
 #endif
 
-/*ARGSUSED*/
     void
 gui_mch_exit(rc)
-    int		rc;
+    int		rc UNUSED;
 {
 #if 0
     /* Lesstif gives an error message here, and so does Solaris.  The man page
      * says that this isn't needed when exiting, so just skip it. */
     XtCloseDisplay(gui.dpy);
 #endif
+    vim_free(gui_argv);
+    gui_argv = NULL;
 }
 
 /*
@@ -1795,7 +1788,6 @@
 	NULL);
 }
 
-/*ARGSUSED*/
     void
 gui_mch_set_shellsize(width, height, min_width, min_height,
 		    base_width, base_height, direction)
@@ -1805,7 +1797,7 @@
     int		min_height;
     int		base_width;
     int		base_height;
-    int		direction;
+    int		direction UNUSED;
 {
 #ifdef FEAT_XIM
     height += xim_get_status_area_height(),
@@ -1843,11 +1835,10 @@
  * If "fontset" is TRUE, load the "font_name" as a fontset.
  * Return FAIL if the font could not be loaded, OK otherwise.
  */
-/*ARGSUSED*/
     int
 gui_mch_init_font(font_name, do_fontset)
     char_u	*font_name;
-    int		do_fontset;
+    int		do_fontset UNUSED;
 {
     XFontStruct	*font = NULL;
 
@@ -2025,10 +2016,9 @@
  * Return the name of font "font" in allocated memory.
  * Don't know how to get the actual name, thus use the provided name.
  */
-/*ARGSUSED*/
     char_u *
 gui_mch_get_fontname(font, name)
-    GuiFont font;
+    GuiFont font UNUSED;
     char_u  *name;
 {
     if (name == NULL)
@@ -2450,7 +2440,7 @@
 	*colorPtr = colortable[closest];
     }
 
-    free(colortable);
+    vim_free(colortable);
     return OK;
 }
 
@@ -2517,7 +2507,7 @@
 {
     int			i;
     int			offset;
-    const static int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
+    static const int	val[8] = {1, 0, 0, 0, 1, 2, 2, 2 };
 
     XSetForeground(gui.dpy, gui.text_gc, prev_sp_color);
     for (i = FILL_X(col); i < FILL_X(col + cells); ++i)
@@ -2565,8 +2555,10 @@
 # ifdef FEAT_XFONTSET
 	    if (current_fontset != NULL)
 	    {
-		if (c >= 0x10000 && sizeof(wchar_t) <= 2)
+#  ifdef SMALL_WCHAR_T
+		if (c >= 0x10000)
 		    c = 0xbf;		/* show chars > 0xffff as ? */
+#  endif
 		((wchar_t *)buf)[wlen] = c;
 	    }
 	    else
@@ -3132,11 +3124,11 @@
     /* Nothing to do in X */
 }
 
-/* ARGSUSED */
     void
 gui_x11_menu_cb(w, client_data, call_data)
-    Widget	w;
-    XtPointer	client_data, call_data;
+    Widget	w UNUSED;
+    XtPointer	client_data;
+    XtPointer	call_data UNUSED;
 {
     gui_menu_cb((vimmenu_T *)client_data);
 }
@@ -3149,13 +3141,12 @@
  * Function called when window closed.	Works like ":qa".
  * Should put up a requester!
  */
-/*ARGSUSED*/
     static void
 gui_x11_wm_protocol_handler(w, client_data, event, dum)
-    Widget	w;
-    XtPointer	client_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     /*
      * Only deal with Client messages.
@@ -3168,7 +3159,7 @@
      * exit.  That can be cancelled though, thus Vim shouldn't exit here.
      * Just sync our swap files.
      */
-    if (((XClientMessageEvent *)event)->data.l[0] ==
+    if ((Atom)((XClientMessageEvent *)event)->data.l[0] ==
 						  wm_atoms[SAVE_YOURSELF_IDX])
     {
 	out_flush();
@@ -3181,7 +3172,7 @@
 	return;
     }
 
-    if (((XClientMessageEvent *)event)->data.l[0] !=
+    if ((Atom)((XClientMessageEvent *)event)->data.l[0] !=
 						  wm_atoms[DELETE_WINDOW_IDX])
 	return;
 
@@ -3192,13 +3183,12 @@
 /*
  * Function called when property changed. Check for incoming commands
  */
-/*ARGSUSED*/
     static void
 gui_x11_send_event_handler(w, client_data, event, dum)
-    Widget	w;
-    XtPointer	client_data;
+    Widget	w UNUSED;
+    XtPointer	client_data UNUSED;
     XEvent	*event;
-    Boolean	*dum;
+    Boolean	*dum UNUSED;
 {
     XPropertyEvent *e = (XPropertyEvent *) event;
 
@@ -3273,11 +3263,10 @@
     }
 }
 
-/* ARGSUSED */
     static void
 gui_x11_blink_cb(timed_out, interval_id)
-    XtPointer	    timed_out;
-    XtIntervalId    *interval_id;
+    XtPointer	    timed_out UNUSED;
+    XtIntervalId    *interval_id UNUSED;
 {
     if (blink_state == BLINK_ON)
     {
@@ -3439,47 +3428,37 @@
     char_u	    *signfile;
 {
     XpmAttributes   attrs;
-    XImage	    *sign;
+    XImage	    *sign = NULL;
     int		    status;
 
     /*
      * Setup the color substitution table.
      */
-    sign = NULL;
     if (signfile[0] != NUL && signfile[0] != '-')
     {
-	sign = (XImage *)alloc(sizeof(XImage));
-	if (sign != NULL)
+	XpmColorSymbol color[5] =
 	{
-	    XpmColorSymbol color[5] =
-	    {
-		{"none", NULL, 0},
-		{"iconColor1", NULL, 0},
-		{"bottomShadowColor", NULL, 0},
-		{"topShadowColor", NULL, 0},
-		{"selectColor", NULL, 0}
-	    };
-	    attrs.valuemask = XpmColorSymbols;
-	    attrs.numsymbols = 2;
-	    attrs.colorsymbols = color;
-	    attrs.colorsymbols[0].pixel = gui.back_pixel;
-	    attrs.colorsymbols[1].pixel = gui.norm_pixel;
-	    status = XpmReadFileToImage(gui.dpy, (char *)signfile,
+	    {"none", NULL, 0},
+	    {"iconColor1", NULL, 0},
+	    {"bottomShadowColor", NULL, 0},
+	    {"topShadowColor", NULL, 0},
+	    {"selectColor", NULL, 0}
+	};
+	attrs.valuemask = XpmColorSymbols;
+	attrs.numsymbols = 2;
+	attrs.colorsymbols = color;
+	attrs.colorsymbols[0].pixel = gui.back_pixel;
+	attrs.colorsymbols[1].pixel = gui.norm_pixel;
+	status = XpmReadFileToImage(gui.dpy, (char *)signfile,
 							 &sign, NULL, &attrs);
-
-	    if (status == 0)
-	    {
-		/* Sign width is fixed at two columns now.
-		if (sign->width > gui.sign_width)
-		    gui.sign_width = sign->width + 8; */
-	    }
-	    else
-	    {
-		vim_free(sign);
-		sign = NULL;
-		EMSG(_(e_signdata));
-	    }
+	if (status == 0)
+	{
+	    /* Sign width is fixed at two columns now.
+	    if (sign->width > gui.sign_width)
+	        gui.sign_width = sign->width + 8; */
 	}
+	else
+	    EMSG(_(e_signdata));
     }
 
     return (void *)sign;
@@ -3489,8 +3468,7 @@
 gui_mch_destroy_sign(sign)
     void *sign;
 {
-    XFree(((XImage *)sign)->data);
-    vim_free(sign);
+    XDestroyImage((XImage*)sign);
 }
 #endif
 
diff -Naur vim72.orig/src/gui_xmdlg.c vim72/src/gui_xmdlg.c
--- vim72.orig/src/gui_xmdlg.c	2008-06-21 17:05:32.000000000 +0100
+++ vim72/src/gui_xmdlg.c	2009-07-22 22:54:22.000000000 +0100
@@ -369,10 +369,10 @@
     char	buf[TEMP_BUF_SIZE];
     XmString	items[MAX_ENTRIES_IN_LIST];
     int		i;
-    int		index;
+    int		idx;
 
-    for (index = (int)ENCODING; index < (int)NONE; ++index)
-	count[index] = 0;
+    for (idx = (int)ENCODING; idx < (int)NONE; ++idx)
+	count[idx] = 0;
 
     /* First we insert the wild char into every single list. */
     if (fix != ENCODING)
@@ -448,7 +448,7 @@
 
 	    items[i] = XmStringCreateLocalized(list[ENCODING][i]);
 
-	    if (i < n_items)
+	    if (i < (int)n_items)
 	    {
 		/* recycle old button */
 		XtVaSetValues(children[i],
@@ -481,7 +481,7 @@
 
 	/* Destroy all the outstanding menu items.
 	 */
-	for (i = count[ENCODING]; i < n_items; ++i)
+	for (i = count[ENCODING]; i < (int)n_items; ++i)
 	{
 	    XtUnmanageChild(children[i]);
 	    XtDestroyWidget(children[i]);
@@ -503,14 +503,14 @@
     /*
      * Now loop trough the remaining lists and set them up.
      */
-    for (index = (int)NAME; index < (int)NONE; ++index)
+    for (idx = (int)NAME; idx < (int)NONE; ++idx)
     {
 	Widget w;
 
-	if (fix == (enum ListSpecifier)index)
+	if (fix == (enum ListSpecifier)idx)
 	    continue;
 
-	switch ((enum ListSpecifier)index)
+	switch ((enum ListSpecifier)idx)
 	{
 	    case NAME:
 		w = data->list[NAME];
@@ -525,28 +525,27 @@
 		w = (Widget)0;	/* for lint */
 	}
 
-	for (i = 0; i < count[index]; ++i)
+	for (i = 0; i < count[idx]; ++i)
 	{
-	    items[i] = XmStringCreateLocalized(list[index][i]);
-	    XtFree(list[index][i]);
+	    items[i] = XmStringCreateLocalized(list[idx][i]);
+	    XtFree(list[idx][i]);
 	}
 	XmListDeleteAllItems(w);
-	XmListAddItems(w, items, count[index], 1);
-	if (data->sel[index])
+	XmListAddItems(w, items, count[idx], 1);
+	if (data->sel[idx])
 	{
 	    XmStringFree(items[0]);
-	    items[0] = XmStringCreateLocalized(data->sel[index]);
+	    items[0] = XmStringCreateLocalized(data->sel[idx]);
 	    XmListSelectItem(w, items[0], False);
 	    XmListSetBottomItem(w, items[0]);
 	}
-	for (i = 0; i < count[index]; ++i)
+	for (i = 0; i < count[idx]; ++i)
 	    XmStringFree(items[i]);
     }
 }
 
-/*ARGSUSED*/
     static void
-stoggle_callback(Widget w,
+stoggle_callback(Widget w UNUSED,
 	SharedFontSelData *data,
 	XmToggleButtonCallbackStruct *call_data)
 {
@@ -695,25 +694,24 @@
 	int	    n;
 	XmString    str;
 	Arg	    args[4];
-	char	    *msg = _("no specific match");
+	char	    *nomatch_msg = _("no specific match");
 
 	n = 0;
-	str = XmStringCreateLocalized(msg);
+	str = XmStringCreateLocalized(nomatch_msg);
 	XtSetArg(args[n], XmNlabelString, str); ++n;
 	XtSetValues(data->sample, args, n);
 	apply_fontlist(data->sample);
-	XmTextSetString(data->name, msg);
+	XmTextSetString(data->name, nomatch_msg);
 	XmStringFree(str);
 
 	return False;
     }
 }
 
-/*ARGSUSED*/
     static void
 encoding_callback(Widget w,
 	SharedFontSelData *data,
-	XtPointer dummy)
+	XtPointer dummy UNUSED)
 {
     XmString str;
     XmListCallbackStruct fake_data;
@@ -752,11 +750,10 @@
     do_choice(w, data, call_data, SIZE);
 }
 
-/*ARGSUSED*/
     static void
-cancel_callback(Widget w,
+cancel_callback(Widget w UNUSED,
 	SharedFontSelData *data,
-	XmListCallbackStruct *call_data)
+	XmListCallbackStruct *call_data UNUSED)
 {
     if (data->sel[ENCODING])
     {
@@ -789,11 +786,10 @@
     data->exit = True;
 }
 
-/*ARGSUSED*/
     static void
-ok_callback(Widget w,
+ok_callback(Widget w UNUSED,
 	SharedFontSelData *data,
-	XmPushButtonCallbackStruct *call_data)
+	XmPushButtonCallbackStruct *call_data UNUSED)
 {
     char    *pattern;
     char    **name;
@@ -886,21 +882,21 @@
     {
 	int	i;
 	int	max;
-	int	index = 0;
+	int	idx = 0;
 	int	size;
-	char	str[128];
+	char	buf[128];
 
 	for (i = 0, max = 0; i < data->num; i++)
 	{
-	    get_part(fn(data, i), 7, str);
-	    size = atoi(str);
+	    get_part(fn(data, i), 7, buf);
+	    size = atoi(buf);
 	    if ((size > max) && (size < MAX_DISPLAY_SIZE))
 	    {
-		index = i;
+		idx = i;
 		max = size;
 	    }
 	}
-	strcpy(big_font, fn(data, index));
+	strcpy(big_font, fn(data, idx));
     }
     data->old = XLoadQueryFont(XtDisplay(parent), big_font);
     data->old_list = gui_motif_create_fontlist(data->old);
@@ -1217,28 +1213,28 @@
 
 	if (i != 0)
 	{
-	    char name[TEMP_BUF_SIZE];
-	    char style[TEMP_BUF_SIZE];
-	    char size[TEMP_BUF_SIZE];
-	    char encoding[TEMP_BUF_SIZE];
+	    char namebuf[TEMP_BUF_SIZE];
+	    char stylebuf[TEMP_BUF_SIZE];
+	    char sizebuf[TEMP_BUF_SIZE];
+	    char encodingbuf[TEMP_BUF_SIZE];
 	    char *found;
 
 	    found = names[0];
 
-	    name_part(found, name);
-	    style_part(found, style);
-	    size_part(found, size, data->in_pixels);
-	    encoding_part(found, encoding);
-
-	    if (strlen(name) > 0
-		    && strlen(style) > 0
-		    && strlen(size) > 0
-		    && strlen(encoding) > 0)
+	    name_part(found, namebuf);
+	    style_part(found, stylebuf);
+	    size_part(found, sizebuf, data->in_pixels);
+	    encoding_part(found, encodingbuf);
+
+	    if (strlen(namebuf) > 0
+		    && strlen(stylebuf) > 0
+		    && strlen(sizebuf) > 0
+		    && strlen(encodingbuf) > 0)
 	    {
-		data->sel[NAME] = XtNewString(name);
-		data->sel[STYLE] = XtNewString(style);
-		data->sel[SIZE] = XtNewString(size);
-		data->sel[ENCODING] = XtNewString(encoding);
+		data->sel[NAME] = XtNewString(namebuf);
+		data->sel[STYLE] = XtNewString(stylebuf);
+		data->sel[SIZE] = XtNewString(sizebuf);
+		data->sel[ENCODING] = XtNewString(encodingbuf);
 		data->font_name = XtNewString(names[0]);
 		display_sample(data);
 		XmTextSetString(data->name, data->font_name);
diff -Naur vim72.orig/src/gui_xmebw.c vim72/src/gui_xmebw.c
--- vim72.orig/src/gui_xmebw.c	2007-09-06 11:57:51.000000000 +0100
+++ vim72/src/gui_xmebw.c	2009-07-22 22:54:22.000000000 +0100
@@ -235,13 +235,12 @@
     return tmp;
 }
 
-/*ARGSUSED*/
     static int
 alloc_color(Display	*display,
 	Colormap	colormap,
 	char		*colorname,
 	XColor		*xcolor,
-	void		*closure)
+	void		*closure UNUSED)
 {
     int status;
 
@@ -595,9 +594,10 @@
 		       XtHeight(eb), eb->primitive.highlight_thickness);
 }
 
-/*ARGSUSED*/
     static void
-draw_pixmap(XmEnhancedButtonWidget eb, XEvent *event, Region region)
+draw_pixmap(XmEnhancedButtonWidget eb,
+	    XEvent *event UNUSED,
+	    Region region UNUSED)
 {
     Pixmap	pix;
     GC		gc = eb->label.normal_GC;
@@ -641,7 +641,7 @@
     height = eb->core.height - 2 * y;
     if (h < height)
 	height = h;
-    if (depth == eb->core.depth)
+    if (depth == (int)eb->core.depth)
 	XCopyArea(XtDisplay(eb), pix, XtWindow(eb), gc, 0, 0,
 		width, height, x, y);
     else if (depth == 1)
@@ -731,9 +731,11 @@
 	eb->label.normal_GC = tmp_gc;
 }
 
-/*ARGSUSED*/
     static void
-Enter(Widget wid, XEvent *event, String *params, Cardinal *num_params)
+Enter(Widget wid,
+      XEvent *event,
+      String *params UNUSED,
+      Cardinal *num_params UNUSED)
 {
     XmEnhancedButtonWidget eb = (XmEnhancedButtonWidget) wid;
     XmPushButtonCallbackStruct call_value;
@@ -818,9 +820,11 @@
     }
 }
 
-/*ARGSUSED*/
     static void
-Leave(Widget wid, XEvent *event, String *params, Cardinal *num_params)
+Leave(Widget wid,
+      XEvent *event,
+      String *params UNUSED,
+      Cardinal *num_params UNUSED)
 {
     XmEnhancedButtonWidget eb = (XmEnhancedButtonWidget)wid;
     XmPushButtonCallbackStruct call_value;
@@ -976,9 +980,8 @@
     }
 }
 
-/*ARGSUSED*/
     static void
-Initialize(Widget rq, Widget ebw, ArgList args, Cardinal *n)
+Initialize(Widget rq, Widget ebw, ArgList args UNUSED, Cardinal *n UNUSED)
 {
     XmEnhancedButtonWidget  request = (XmEnhancedButtonWidget)rq;
     XmEnhancedButtonWidget  eb = (XmEnhancedButtonWidget)ebw;
@@ -1056,9 +1059,12 @@
     free_pixmaps((XmEnhancedButtonWidget)w);
 }
 
-/*ARGSUSED*/
     static Boolean
-SetValues(Widget current, Widget request, Widget new, ArgList args, Cardinal *n)
+SetValues(Widget current,
+	  Widget request UNUSED,
+	  Widget new,
+	  ArgList args UNUSED,
+	  Cardinal *n UNUSED)
 {
     XmEnhancedButtonWidget  cur = (XmEnhancedButtonWidget) current;
     XmEnhancedButtonWidget  eb = (XmEnhancedButtonWidget) new;
@@ -1108,7 +1114,7 @@
 		if ((win_x < 0) || (win_y < 0))
 		    return False;
 
-		if ((win_x > r_width) || (win_y > r_height))
+		if ((win_x > (int)r_width) || (win_y > (int)r_height))
 		    return False;
 		draw_highlight(eb);
 		draw_shadows(eb);
@@ -1256,7 +1262,7 @@
     }
     else
     {
-	int adjust = 0;
+	adjust = 0;
 
 #if !defined(LESSTIF_VERSION) && (XmVersion > 1002)
 	/*
@@ -1268,12 +1274,11 @@
 	{
 	    case XmEXTERNAL_HIGHLIGHT:
 		adjust = (eb->primitive.highlight_thickness -
-			(eb->pushbutton.default_button_shadow_thickness ?
-			 Xm3D_ENHANCE_PIXEL : 0));
+			 (eb->pushbutton.default_button_shadow_thickness
+			  ?  Xm3D_ENHANCE_PIXEL : 0));
 		break;
 
 	    case XmINTERNAL_HIGHLIGHT:
-		adjust = 0;
 		break;
 
 	    default:
diff -Naur vim72.orig/src/hardcopy.c vim72/src/hardcopy.c
--- vim72.orig/src/hardcopy.c	2008-01-11 20:46:20.000000000 +0000
+++ vim72/src/hardcopy.c	2009-07-22 22:54:22.000000000 +0100
@@ -442,12 +442,11 @@
 /*
  * Print the page header.
  */
-/*ARGSUSED*/
     static void
 prt_header(psettings, pagenum, lnum)
     prt_settings_T  *psettings;
     int		pagenum;
-    linenr_T	lnum;
+    linenr_T	lnum UNUSED;
 {
     int		width = psettings->chars_per_line;
     int		page_line;
@@ -1881,7 +1880,7 @@
 	return FALSE;
 
     /* Find type of DSC comment */
-    for (comment = 0; comment < NUM_ELEMENTS(prt_dsc_table); comment++)
+    for (comment = 0; comment < (int)NUM_ELEMENTS(prt_dsc_table); comment++)
 	if (prt_resfile_strncmp(0, prt_dsc_table[comment].string,
 					    prt_dsc_table[comment].len) == 0)
 	    break;
@@ -2454,12 +2453,11 @@
 }
 #endif
 
-/*ARGSUSED*/
     int
 mch_print_init(psettings, jobname, forceit)
     prt_settings_T *psettings;
     char_u	*jobname;
-    int		forceit;
+    int		forceit UNUSED;
 {
     int		i;
     char	*paper_name;
@@ -2514,7 +2512,7 @@
     if (!(props & ENC_8BIT) && ((*p_pmcs != NUL) || !(props & ENC_UNICODE)))
     {
 	p_mbenc_first = NULL;
-	for (cmap = 0; cmap < NUM_ELEMENTS(prt_ps_mbfonts); cmap++)
+	for (cmap = 0; cmap < (int)NUM_ELEMENTS(prt_ps_mbfonts); cmap++)
 	    if (prt_match_encoding((char *)p_encoding, &prt_ps_mbfonts[cmap],
 								    &p_mbenc))
 	    {
@@ -2642,7 +2640,7 @@
 	paper_name = "A4";
 	paper_strlen = 2;
     }
-    for (i = 0; i < PRT_MEDIASIZE_LEN; ++i)
+    for (i = 0; i < (int)PRT_MEDIASIZE_LEN; ++i)
 	if (STRLEN(prt_mediasize[i].name) == (unsigned)paper_strlen
 		&& STRNICMP(prt_mediasize[i].name, paper_name,
 							   paper_strlen) == 0)
@@ -3308,10 +3306,9 @@
     return !prt_file_error;
 }
 
-/*ARGSUSED*/
     int
 mch_print_begin_page(str)
-    char_u	*str;
+    char_u	*str UNUSED;
 {
     int		page_num[2];
 
@@ -3379,11 +3376,10 @@
 #endif
 }
 
-/*ARGSUSED*/
     int
 mch_print_text_out(p, len)
     char_u	*p;
-    int		len;
+    int		len UNUSED;
 {
     int		need_break;
     char_u	ch;
diff -Naur vim72.orig/src/if_cscope.c vim72/src/if_cscope.c
--- vim72.orig/src/if_cscope.c	2008-06-24 17:32:34.000000000 +0100
+++ vim72/src/if_cscope.c	2009-07-22 22:54:23.000000000 +0100
@@ -46,7 +46,6 @@
 static int	    cs_find __ARGS((exarg_T *eap));
 static int	    cs_find_common __ARGS((char *opt, char *pat, int, int, int));
 static int	    cs_help __ARGS((exarg_T *eap));
-static void	    cs_init __ARGS((void));
 static void	    clear_csinfo __ARGS((int i));
 static int	    cs_insert_filelist __ARGS((char *, char *, char *,
 			struct stat *));
@@ -66,7 +65,10 @@
 static int	    cs_show __ARGS((exarg_T *eap));
 
 
-static csinfo_T	    csinfo[CSCOPE_MAX_CONNECTIONS];
+static csinfo_T *   csinfo = NULL;
+static int	    csinfo_size = 0;	/* number of items allocated in
+					   csinfo[] */
+
 static int	    eap_arg_len;    /* length of eap->arg, set in
 				       cs_lookup_cmd() */
 static cscmd_T	    cs_cmds[] =
@@ -74,7 +76,7 @@
     { "add",	cs_add,
 		N_("Add a new database"),     "add file|dir [pre-path] [flags]", 0 },
     { "find",	cs_find,
-		N_("Query for a pattern"),    FIND_USAGE, 1 },
+		N_("Query for a pattern"),    "find c|d|e|f|g|i|s|t name", 1 },
     { "help",	cs_help,
 		N_("Show this message"),      "help", 0 },
     { "kill",	cs_kill,
@@ -83,7 +85,7 @@
 		N_("Reinit all connections"), "reset", 0 },
     { "show",	cs_show,
 		N_("Show connections"),       "show", 0 },
-    { NULL }
+    { NULL, NULL, NULL, NULL, 0 }
 };
 
     static void
@@ -93,12 +95,125 @@
     (void)EMSG2(_("E560: Usage: cs[cope] %s"), cs_cmds[(int)x].usage);
 }
 
+#if defined(FEAT_CMDL_COMPL) || defined(PROTO)
+
+static enum
+{
+    EXP_CSCOPE_SUBCMD,	/* expand ":cscope" sub-commands */
+    EXP_SCSCOPE_SUBCMD,	/* expand ":scscope" sub-commands */
+    EXP_CSCOPE_FIND,	/* expand ":cscope find" arguments */
+    EXP_CSCOPE_KILL	/* expand ":cscope kill" arguments */
+} expand_what;
+
+/*
+ * Function given to ExpandGeneric() to obtain the cscope command
+ * expansion.
+ */
+    char_u *
+get_cscope_name(xp, idx)
+    expand_T	*xp UNUSED;
+    int		idx;
+{
+    int		current_idx;
+    int		i;
+
+    switch (expand_what)
+    {
+    case EXP_CSCOPE_SUBCMD:
+	/* Complete with sub-commands of ":cscope":
+	 * add, find, help, kill, reset, show */
+	return (char_u *)cs_cmds[idx].name;
+    case EXP_SCSCOPE_SUBCMD:
+	/* Complete with sub-commands of ":scscope": same sub-commands as
+	 * ":cscope" but skip commands which don't support split windows */
+	for (i = 0, current_idx = 0; cs_cmds[i].name != NULL; i++)
+	    if (cs_cmds[i].cansplit)
+		if (current_idx++ == idx)
+		    break;
+	return (char_u *)cs_cmds[i].name;
+    case EXP_CSCOPE_FIND:
+	{
+	    const char *query_type[] =
+	    {
+		"c", "d", "e", "f", "g", "i", "s", "t", NULL
+	    };
+
+	    /* Complete with query type of ":cscope find {query_type}".
+	     * {query_type} can be letters (c, d, ... t) or numbers (0, 1,
+	     * ..., 8) but only complete with letters, since numbers are
+	     * redundant. */
+	    return (char_u *)query_type[idx];
+	}
+    case EXP_CSCOPE_KILL:
+	{
+	    static char	connection[5];
+
+	    /* ":cscope kill" accepts connection numbers or partial names of
+	     * the pathname of the cscope database as argument.  Only complete
+	     * with connection numbers. -1 can also be used to kill all
+	     * connections. */
+	    for (i = 0, current_idx = 0; i < csinfo_size; i++)
+	    {
+		if (csinfo[i].fname == NULL)
+		    continue;
+		if (current_idx++ == idx)
+		{
+		    vim_snprintf(connection, sizeof(connection), "%d", i);
+		    return (char_u *)connection;
+		}
+	    }
+	    return (current_idx == idx && idx > 0) ? (char_u *)"-1" : NULL;
+	}
+    default:
+	return NULL;
+    }
+}
+
+/*
+ * Handle command line completion for :cscope command.
+ */
+    void
+set_context_in_cscope_cmd(xp, arg, cmdidx)
+    expand_T	*xp;
+    char_u	*arg;
+    cmdidx_T	cmdidx;
+{
+    char_u	*p;
+
+    /* Default: expand subcommands */
+    xp->xp_context = EXPAND_CSCOPE;
+    xp->xp_pattern = arg;
+    expand_what = (cmdidx == CMD_scscope)
+			? EXP_SCSCOPE_SUBCMD : EXP_CSCOPE_SUBCMD;
+
+    /* (part of) subcommand already typed */
+    if (*arg != NUL)
+    {
+	p = skiptowhite(arg);
+	if (*p != NUL)		    /* past first word */
+	{
+	    xp->xp_pattern = skipwhite(p);
+	    if (*skiptowhite(xp->xp_pattern) != NUL)
+		xp->xp_context = EXPAND_NOTHING;
+	    else if (STRNICMP(arg, "add", p - arg) == 0)
+		xp->xp_context = EXPAND_FILES;
+	    else if (STRNICMP(arg, "kill", p - arg) == 0)
+		expand_what = EXP_CSCOPE_KILL;
+	    else if (STRNICMP(arg, "find", p - arg) == 0)
+		expand_what = EXP_CSCOPE_FIND;
+	    else
+		xp->xp_context = EXPAND_NOTHING;
+	}
+    }
+}
+
+#endif /* FEAT_CMDL_COMPL */
+
 /*
  * PRIVATE: do_cscope_general
  *
- * find the command, print help if invalid, and the then call the
- * corresponding command function,
- * called from do_cscope and do_scscope
+ * Find the command, print help if invalid, and then call the corresponding
+ * command function.
  */
     static void
 do_cscope_general(eap, make_split)
@@ -107,7 +222,6 @@
 {
     cscmd_T *cmdp;
 
-    cs_init();
     if ((cmdp = cs_lookup_cmd(eap)) == NULL)
     {
 	cs_help(eap);
@@ -168,8 +282,6 @@
 {
     int ret = FALSE;
 
-    cs_init();
-
     if (*eap->arg == NUL)
     {
 	(void)EMSG(_("E562: Usage: cstag <ident>"));
@@ -325,7 +437,7 @@
     if (num < 0 || num > 4 || (num > 0 && !dbpath))
 	return FALSE;
 
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	if (!csinfo[i].fname)
 	    continue;
@@ -379,10 +491,9 @@
  *
  * MAXPATHL 256
  */
-/* ARGSUSED */
     static int
 cs_add(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     char *fname, *ppath, *flags = NULL;
 
@@ -569,7 +680,7 @@
     short i;
     short cnt = 0;
 
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	if (csinfo[i].fname != NULL)
 	    cnt++;
@@ -659,6 +770,7 @@
 {
     char *cmd;
     short search;
+    char *pat;
 
     switch (csoption[0])
     {
@@ -692,10 +804,17 @@
 	return NULL;
     }
 
-    if ((cmd = (char *)alloc((unsigned)(strlen(pattern) + 2))) == NULL)
+    /* Skip white space before the patter, except for text and pattern search,
+     * they may want to use the leading white space. */
+    pat = pattern;
+    if (search != 4 && search != 6)
+	while vim_iswhite(*pat)
+	    ++pat;
+
+    if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
 	return NULL;
 
-    (void)sprintf(cmd, "%d%s", search, pattern);
+    (void)sprintf(cmd, "%d%s", search, pat);
 
     return cmd;
 } /* cs_create_cmd */
@@ -869,7 +988,7 @@
 	vim_free(ppath);
 
 #if defined(UNIX)
-	if (execl("/bin/sh", "sh", "-c", cmd, NULL) == -1)
+	if (execl("/bin/sh", "sh", "-c", cmd, (char *)NULL) == -1)
 	    PERROR(_("cs_create_connection exec failed"));
 
 	exit(127);
@@ -989,7 +1108,8 @@
 {
     int i;
     char *cmd;
-    int nummatches[CSCOPE_MAX_CONNECTIONS], totmatches;
+    int *nummatches;
+    int totmatches;
 #ifdef FEAT_QUICKFIX
     char cmdletter;
     char *qfpos;
@@ -1000,13 +1120,17 @@
     if (cmd == NULL)
 	return FALSE;
 
+    nummatches = (int *)alloc(sizeof(int)*csinfo_size);
+    if (nummatches == NULL)
+	return FALSE;
+
     /* send query to all open connections, then count the total number
      * of matches so we can alloc matchesp all in one swell foop
      */
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
 	nummatches[i] = 0;
     totmatches = 0;
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	if (csinfo[i].fname == NULL || csinfo[i].to_fp == NULL)
 	    continue;
@@ -1031,7 +1155,10 @@
 	char *buf;
 
 	if (!verbose)
+	{
+	    vim_free(nummatches);
 	    return FALSE;
+	}
 
 	buf = (char *)alloc((unsigned)(strlen(opt) + strlen(pat) + strlen(nf)));
 	if (buf == NULL)
@@ -1042,6 +1169,7 @@
 	    (void)EMSG(buf);
 	    vim_free(buf);
 	}
+	vim_free(nummatches);
 	return FALSE;
     }
 
@@ -1094,6 +1222,7 @@
 		(void)EMSG(buf);
 		vim_free(buf);
 	    }
+	    vim_free(nummatches);
 	    return FALSE;
 	}
     }
@@ -1141,6 +1270,7 @@
 	}
 	mch_remove(tmp);
 	vim_free(tmp);
+	vim_free(nummatches);
 	return TRUE;
     }
     else
@@ -1152,6 +1282,7 @@
 	/* read output */
 	cs_fill_results((char *)pat, totmatches, nummatches, &matches,
 							 &contexts, &matched);
+	vim_free(nummatches);
 	if (matches == NULL)
 	    return FALSE;
 
@@ -1167,20 +1298,36 @@
  *
  * print help
  */
-/* ARGSUSED */
     static int
 cs_help(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     cscmd_T *cmdp = cs_cmds;
 
     (void)MSG_PUTS(_("cscope commands:\n"));
     while (cmdp->name != NULL)
     {
-	(void)smsg((char_u *)_("%-5s: %-30s (Usage: %s)"),
-				      cmdp->name, _(cmdp->help), cmdp->usage);
+	char *help = _(cmdp->help);
+	int  space_cnt = 30 - vim_strsize((char_u *)help);
+
+	/* Use %*s rather than %30s to ensure proper alignment in utf-8 */
+	if (space_cnt < 0)
+	    space_cnt = 0;
+	(void)smsg((char_u *)_("%-5s: %s%*s (Usage: %s)"),
+				      cmdp->name,
+				      help, space_cnt, " ",
+				      cmdp->usage);
 	if (strcmp(cmdp->name, "find") == 0)
-	    MSG_PUTS(FIND_HELP);
+	    MSG_PUTS(_("\n"
+		       "       c: Find functions calling this function\n"
+		       "       d: Find functions called by this function\n"
+		       "       e: Find this egrep pattern\n"
+		       "       f: Find this file\n"
+		       "       g: Find this definition\n"
+		       "       i: Find files #including this file\n"
+		       "       s: Find this C symbol\n"
+		       "       t: Find assignments to\n"));
+
 	cmdp++;
     }
 
@@ -1189,26 +1336,6 @@
 } /* cs_help */
 
 
-/*
- * PRIVATE: cs_init
- *
- * initialize cscope structure if not already
- */
-    static void
-cs_init()
-{
-    short i;
-    static int init_already = FALSE;
-
-    if (init_already)
-	return;
-
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
-	clear_csinfo(i);
-
-    init_already = TRUE;
-} /* cs_init */
-
     static void
 clear_csinfo(i)
     int	    i;
@@ -1257,13 +1384,12 @@
  *
  * insert a new cscope database filename into the filelist
  */
-/*ARGSUSED*/
     static int
 cs_insert_filelist(fname, ppath, flags, sb)
     char *fname;
     char *ppath;
     char *flags;
-    struct stat *sb;
+    struct stat *sb UNUSED;
 {
     short	i, j;
 #ifndef UNIX
@@ -1306,7 +1432,7 @@
 #endif
 
     i = -1; /* can be set to the index of an empty item in csinfo */
-    for (j = 0; j < CSCOPE_MAX_CONNECTIONS; j++)
+    for (j = 0; j < csinfo_size; j++)
     {
 	if (csinfo[j].fname != NULL
 #if defined(UNIX)
@@ -1333,9 +1459,25 @@
 
     if (i == -1)
     {
-	if (p_csverbose)
-	    (void)EMSG(_("E569: maximum number of cscope connections reached"));
-	return -1;
+	i = csinfo_size;
+	if (csinfo_size == 0)
+	{
+	    /* First time allocation: allocate only 1 connection. It should
+	     * be enough for most users.  If more is needed, csinfo will be
+	     * reallocated. */
+	    csinfo_size = 1;
+	    csinfo = (csinfo_T *)alloc_clear(sizeof(csinfo_T));
+	}
+	else
+	{
+	    /* Reallocate space for more connections. */
+	    csinfo_size *= 2;
+	    csinfo = vim_realloc(csinfo, sizeof(csinfo_T)*csinfo_size);
+	}
+	if (csinfo == NULL)
+	    return -1;
+	for (j = csinfo_size/2; j < csinfo_size; j++)
+	    clear_csinfo(j);
     }
 
     if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
@@ -1419,10 +1561,9 @@
  *
  * nuke em
  */
-/* ARGSUSED */
     static int
 cs_kill(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     char *stok;
     short i;
@@ -1443,15 +1584,14 @@
 	/* It must be part of a name.  We will try to find a match
 	 * within all the names in the csinfo data structure
 	 */
-	for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+	for (i = 0; i < csinfo_size; i++)
 	{
 	    if (csinfo[i].fname != NULL && strstr(csinfo[i].fname, stok))
 		break;
 	}
     }
 
-    if ((i >= CSCOPE_MAX_CONNECTIONS || i < -1 || csinfo[i].fname == NULL)
-	    && i != -1)
+    if ((i != -1) && (i >= csinfo_size || i < -1 || csinfo[i].fname == NULL))
     {
 	if (p_csverbose)
 	    (void)EMSG2(_("E261: cscope connection %s not found"), stok);
@@ -1460,7 +1600,7 @@
     {
 	if (i == -1)
 	{
-	    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+	    for (i = 0; i < csinfo_size; i++)
 	    {
 		if (csinfo[i].fname)
 		    cs_kill_execute(i, csinfo[i].fname);
@@ -1720,7 +1860,7 @@
     if (buf == NULL)
 	return;
 
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	if (nummatches_a[i] < 1)
 	    continue;
@@ -1792,7 +1932,7 @@
     if ((cntxts = (char **)alloc(sizeof(char *) * totmatches)) == NULL)
 	goto parse_out;
 
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	if (nummatches_a[i] < 1)
 	    continue;
@@ -2099,7 +2239,6 @@
 /*
  * Used to catch and ignore SIGALRM below.
  */
-/* ARGSUSED */
     static RETSIGTYPE
 sig_handler SIGDEFARG(sigarg)
 {
@@ -2239,19 +2378,21 @@
  *
  * calls cs_kill on all cscope connections then reinits
  */
-/* ARGSUSED */
     static int
 cs_reset(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     char	**dblist = NULL, **pplist = NULL, **fllist = NULL;
     int	i;
     char buf[20]; /* for sprintf " (#%d)" */
 
+    if (csinfo_size == 0)
+	return CSCOPE_SUCCESS;
+
     /* malloc our db and ppath list */
-    dblist = (char **)alloc(CSCOPE_MAX_CONNECTIONS * sizeof(char *));
-    pplist = (char **)alloc(CSCOPE_MAX_CONNECTIONS * sizeof(char *));
-    fllist = (char **)alloc(CSCOPE_MAX_CONNECTIONS * sizeof(char *));
+    dblist = (char **)alloc(csinfo_size * sizeof(char *));
+    pplist = (char **)alloc(csinfo_size * sizeof(char *));
+    fllist = (char **)alloc(csinfo_size * sizeof(char *));
     if (dblist == NULL || pplist == NULL || fllist == NULL)
     {
 	vim_free(dblist);
@@ -2260,7 +2401,7 @@
 	return CSCOPE_FAILURE;
     }
 
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	dblist[i] = csinfo[i].fname;
 	pplist[i] = csinfo[i].ppath;
@@ -2270,7 +2411,7 @@
     }
 
     /* rebuild the cscope connection list */
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
     {
 	if (dblist[i] != NULL)
 	{
@@ -2355,10 +2496,9 @@
  *
  * show all cscope connections
  */
-/* ARGSUSED */
     static int
 cs_show(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     short i;
     if (cs_cnt_connections() == 0)
@@ -2368,7 +2508,7 @@
 	MSG_PUTS_ATTR(
 	    _(" # pid    database name                       prepend path\n"),
 	    hl_attr(HLF_T));
-	for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+	for (i = 0; i < csinfo_size; i++)
 	{
 	    if (csinfo[i].fname == NULL)
 		continue;
@@ -2397,8 +2537,10 @@
 {
     int i;
 
-    for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+    for (i = 0; i < csinfo_size; i++)
 	cs_release_csp(i, TRUE);
+    vim_free(csinfo);
+    csinfo_size = 0;
 }
 
 #endif	/* FEAT_CSCOPE */
diff -Naur vim72.orig/src/if_cscope.h vim72/src/if_cscope.h
--- vim72.orig/src/if_cscope.h	2007-09-02 15:51:08.000000000 +0100
+++ vim72/src/if_cscope.h	2009-07-22 22:54:23.000000000 +0100
@@ -25,7 +25,6 @@
 
 #define CSCOPE_SUCCESS		0
 #define CSCOPE_FAILURE		-1
-#define CSCOPE_MAX_CONNECTIONS	8   /* you actually need more? */
 
 #define	CSCOPE_DBFILE		"cscope.out"
 #define	CSCOPE_PROMPT		">> "
@@ -42,17 +41,6 @@
  * f 7name	Find this file
  * i 8name	Find files #including this file
  */
-#define	FIND_USAGE "find c|d|e|f|g|i|s|t name"
-#define FIND_HELP "\n\
-       c: Find functions calling this function\n\
-       d: Find functions called by this function\n\
-       e: Find this egrep pattern\n\
-       f: Find this file\n\
-       g: Find this definition\n\
-       i: Find files #including this file\n\
-       s: Find this C symbol\n\
-       t: Find assignments to\n"
-
 
 typedef struct {
     char *  name;
diff -Naur vim72.orig/src/if_mzsch.c vim72/src/if_mzsch.c
--- vim72.orig/src/if_mzsch.c	2007-07-01 17:44:49.000000000 +0100
+++ vim72/src/if_mzsch.c	2009-07-22 22:54:23.000000000 +0100
@@ -4,6 +4,8 @@
  * Original work by Brent Fulgham <bfulgham@debian.org>
  * (Based on lots of help from Matthew Flatt)
  *
+ * TODO Convert byte-strings to char strings?
+ *
  * This consists of six parts:
  * 1. MzScheme interpreter main program
  * 2. Routines that handle the external interface between MzScheme and
@@ -18,7 +20,7 @@
  *    garbage collector will do it self
  * 2. Requires at least NORMAL features. I can't imagine why one may want
  *    to build with SMALL or TINY features but with MzScheme interface.
- * 3. I don't use K&R-style functions. Anyway, MzScheme headers are ANSI.
+ * 3. I don't use K&R-style functions. Anyways, MzScheme headers are ANSI.
  */
 
 #include "vim.h"
@@ -29,14 +31,15 @@
  * depend". */
 #if defined(FEAT_MZSCHEME) || defined(PROTO)
 
+#include <assert.h>
+
 /* Base data structures */
 #define SCHEME_VIMBUFFERP(obj)  SAME_TYPE(SCHEME_TYPE(obj), mz_buffer_type)
 #define SCHEME_VIMWINDOWP(obj)  SAME_TYPE(SCHEME_TYPE(obj), mz_window_type)
 
 typedef struct
 {
-    Scheme_Type	    tag;
-    Scheme_Env	    *env;
+    Scheme_Object   so;
     buf_T	    *buf;
 } vim_mz_buffer;
 
@@ -44,7 +47,7 @@
 
 typedef struct
 {
-    Scheme_Type	    tag;
+    Scheme_Object   so;
     win_T	    *win;
 } vim_mz_window;
 
@@ -67,19 +70,6 @@
     Scheme_Object   *port;
 } Port_Info;
 
-/* info for closed prim */
-/*
- * data have different means:
- * for do_eval it is char*
- * for do_apply is Apply_Onfo*
- * for do_load is Port_Info*
- */
-typedef struct
-{
-    void	*data;
-    Scheme_Env	*env;
-} Cmd_Info;
-
 /* info for do_apply */
 typedef struct
 {
@@ -122,7 +112,6 @@
 static Scheme_Object *insert_buffer_line_list(void *, int, Scheme_Object **);
 static Scheme_Object *get_range_start(void *, int, Scheme_Object **);
 static Scheme_Object *get_range_end(void *, int, Scheme_Object **);
-static Scheme_Object *get_buffer_namespace(void *, int, Scheme_Object **);
 static vim_mz_buffer *get_vim_curr_buffer(void);
 
 /*  Window-related commands */
@@ -163,8 +152,6 @@
 static int do_mzscheme_command(exarg_T *, void *, Scheme_Closed_Prim *what);
 static void startup_mzscheme(void);
 static char *string_to_line(Scheme_Object *obj);
-static int mzscheme_io_init(void);
-static void mzscheme_interface_init(vim_mz_buffer *self);
 static void do_output(char *mesg, long len);
 static void do_printf(char *format, ...);
 static void do_flush(void);
@@ -174,19 +161,52 @@
 static Scheme_Object *do_eval(void *, int noargc, Scheme_Object **noargv);
 static Scheme_Object *do_load(void *, int noargc, Scheme_Object **noargv);
 static Scheme_Object *do_apply(void *, int noargc, Scheme_Object **noargv);
-static void register_vim_exn(Scheme_Env *env);
+static void register_vim_exn(void);
 static vim_mz_buffer *get_buffer_arg(const char *fname, int argnum,
 	int argc, Scheme_Object **argv);
 static vim_mz_window *get_window_arg(const char *fname, int argnum,
 	int argc, Scheme_Object **argv);
-static void add_vim_exn(Scheme_Env *env);
 static int line_in_range(linenr_T, buf_T *);
 static void check_line_range(linenr_T, buf_T *);
 static void mz_fix_cursor(int lo, int hi, int extra);
 
-static int eval_in_namespace(void *, Scheme_Closed_Prim *, Scheme_Env *,
-		Scheme_Object **ret);
-static void make_modules(Scheme_Env *);
+static int eval_with_exn_handling(void *, Scheme_Closed_Prim *,
+	    Scheme_Object **ret);
+static void make_modules(void);
+static void init_exn_catching_apply(void);
+static int mzscheme_env_main(Scheme_Env *env, int argc, char **argv);
+static int mzscheme_init(void);
+#ifdef FEAT_EVAL
+static Scheme_Object *vim_to_mzscheme(typval_T *vim_value, int depth,
+	Scheme_Hash_Table *visited);
+#endif
+
+#ifdef MZ_PRECISE_GC
+static int buffer_size_proc(void *obj)
+{
+    return gcBYTES_TO_WORDS(sizeof(vim_mz_buffer));
+}
+static int buffer_mark_proc(void *obj)
+{
+    return buffer_size_proc(obj);
+}
+static int buffer_fixup_proc(void *obj)
+{
+    return buffer_size_proc(obj);
+}
+static int window_size_proc(void *obj)
+{
+    return gcBYTES_TO_WORDS(sizeof(vim_mz_window));
+}
+static int window_mark_proc(void *obj)
+{
+    return window_size_proc(obj);
+}
+static int window_fixup_proc(void *obj)
+{
+    return window_size_proc(obj);
+}
+#endif
 
 #ifdef DYNAMIC_MZSCHEME
 
@@ -260,8 +280,6 @@
     (Scheme_Closed_Prim *prim, void *data, const char *name, mzshort mina,
      mzshort maxa);
 static Scheme_Object *(*dll_scheme_make_integer_value)(long i);
-static Scheme_Object *(*dll_scheme_make_namespace)(int argc,
-	Scheme_Object *argv[]);
 static Scheme_Object *(*dll_scheme_make_pair)(Scheme_Object *car,
 	Scheme_Object *cdr);
 static Scheme_Object *(*dll_scheme_make_prim_w_arity)(Scheme_Prim *prim,
@@ -311,6 +329,17 @@
 static Scheme_Object *(*dll_scheme_char_string_to_path)
     (Scheme_Object *s);
 # endif
+static Scheme_Hash_Table *(*dll_scheme_make_hash_table)(int type);
+static void (*dll_scheme_hash_set)(Scheme_Hash_Table *table,
+	Scheme_Object *key, Scheme_Object *value);
+static Scheme_Object *(*dll_scheme_hash_get)(Scheme_Hash_Table *table,
+	Scheme_Object *key);
+static Scheme_Object *(*dll_scheme_make_double)(double d);
+# ifdef INCLUDE_MZSCHEME_BASE
+static Scheme_Object *(*dll_scheme_make_sized_byte_string)(char *chars,
+	long len, int copy);
+static Scheme_Object *(*dll_scheme_namespace_require)(Scheme_Object *req);
+# endif
 
 /* arrays are imported directly */
 # define scheme_eof dll_scheme_eof
@@ -368,7 +397,6 @@
 # define scheme_lookup_global dll_scheme_lookup_global
 # define scheme_make_closed_prim_w_arity dll_scheme_make_closed_prim_w_arity
 # define scheme_make_integer_value dll_scheme_make_integer_value
-# define scheme_make_namespace dll_scheme_make_namespace
 # define scheme_make_pair dll_scheme_make_pair
 # define scheme_make_prim_w_arity dll_scheme_make_prim_w_arity
 # if MZSCHEME_VERSION_MAJOR < 299
@@ -403,6 +431,14 @@
 #  define scheme_char_string_to_path \
     dll_scheme_char_string_to_path
 # endif
+# define scheme_make_hash_table dll_scheme_make_hash_table
+# define scheme_hash_set dll_scheme_hash_set
+# define scheme_hash_get dll_scheme_hash_get
+# define scheme_make_double dll_scheme_make_double
+# ifdef INCLUDE_MZSCHEME_BASE
+#  define scheme_make_sized_byte_string dll_scheme_make_sized_byte_string
+#  define scheme_namespace_require dll_scheme_namespace_require
+# endif
 
 typedef struct
 {
@@ -468,7 +504,6 @@
     {"scheme_make_closed_prim_w_arity",
 	(void **)&dll_scheme_make_closed_prim_w_arity},
     {"scheme_make_integer_value", (void **)&dll_scheme_make_integer_value},
-    {"scheme_make_namespace", (void **)&dll_scheme_make_namespace},
     {"scheme_make_pair", (void **)&dll_scheme_make_pair},
     {"scheme_make_prim_w_arity", (void **)&dll_scheme_make_prim_w_arity},
 # if MZSCHEME_VERSION_MAJOR < 299
@@ -502,9 +537,16 @@
     {"scheme_current_config", (void **)&dll_scheme_current_config},
     {"scheme_char_string_to_byte_string",
 	(void **)&dll_scheme_char_string_to_byte_string},
-    {"scheme_char_string_to_path",
-	(void **)&dll_scheme_char_string_to_path},
+    {"scheme_char_string_to_path", (void **)&dll_scheme_char_string_to_path},
 # endif
+    {"scheme_make_hash_table", (void **)&dll_scheme_make_hash_table},
+    {"scheme_hash_set", (void **)&dll_scheme_hash_set},
+    {"scheme_hash_get", (void **)&dll_scheme_hash_get},
+    {"scheme_make_double", (void **)&dll_scheme_make_double},
+# ifdef INCLUDE_MZSCHEME_BASE
+    {"scheme_make_sized_byte_string", (void **)&dll_scheme_make_sized_byte_string},
+    {"scheme_namespace_require", (void **)&dll_scheme_namespace_require},
+#endif
     {NULL, NULL}};
 
 static HINSTANCE hMzGC = 0;
@@ -592,6 +634,11 @@
 }
 #endif /* DYNAMIC_MZSCHEME */
 
+/* need to put it here for dynamic stuff to work */
+#ifdef INCLUDE_MZSCHEME_BASE
+# include "mzscheme_base.c"
+#endif
+
 /*
  *========================================================================
  *  1. MzScheme interpreter startup
@@ -601,21 +648,22 @@
 static Scheme_Type mz_buffer_type;
 static Scheme_Type mz_window_type;
 
-static int initialized = 0;
+static int initialized = FALSE;
 
 /* global environment */
 static Scheme_Env    *environment = NULL;
 /* output/error handlers */
 static Scheme_Object *curout = NULL;
 static Scheme_Object *curerr = NULL;
-/* vim:exn exception */
+/* exn:vim exception */
 static Scheme_Object *exn_catching_apply = NULL;
 static Scheme_Object *exn_p = NULL;
 static Scheme_Object *exn_message = NULL;
 static Scheme_Object *vim_exn = NULL; /* Vim Error exception */
- /* values for exn:vim - constructor, predicate, accessors etc */
-static Scheme_Object *vim_exn_names = NULL;
-static Scheme_Object *vim_exn_values = NULL;
+
+#if !defined(MZ_PRECISE_GC) || MZSCHEME_VERSION_MAJOR < 400
+static void *stack_base = NULL;
+#endif
 
 static long range_start;
 static long range_end;
@@ -667,11 +715,9 @@
     static void CALLBACK
 timer_proc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
 # elif defined(FEAT_GUI_GTK)
-/*ARGSUSED*/
     static gint
 timer_proc(gpointer data)
 # elif defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)
-/* ARGSUSED */
     static void
 timer_proc(XtPointer timed_out, XtIntervalId *interval_id)
 # elif defined(FEAT_GUI_MAC)
@@ -753,12 +799,64 @@
 #endif
 }
 
+    void
+mzscheme_main(void)
+{
+#if defined(MZ_PRECISE_GC) && MZSCHEME_VERSION_MAJOR >= 400
+    /* use trampoline for precise GC in MzScheme >= 4.x */
+    scheme_main_setup(TRUE, mzscheme_env_main, 0, NULL);
+#else
+    mzscheme_env_main(NULL, 0, NULL);
+#endif
+}
+
+    static int
+mzscheme_env_main(Scheme_Env *env, int argc, char **argv)
+{
+    /* neither argument nor return values are used */
+#ifdef MZ_PRECISE_GC
+# if MZSCHEME_VERSION_MAJOR < 400
+    /*
+     * Starting from version 4.x, embedding applications must use
+     * scheme_main_setup/scheme_main_stack_setup trampolines
+     * rather than setting stack base directly with scheme_set_stack_base
+     */
+    Scheme_Object   *dummy = NULL;
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, dummy);
+
+    stack_base = &__gc_var_stack__;
+# else
+    /* environment has been created by us by Scheme */
+    environment = env;
+# endif
+    /*
+     * In 4.x, all activities must be performed inside trampoline
+     * so we are forced to initialise GC immediately
+     * This can be postponed in 3.x but I see no point in implementing
+     * a feature which will work in older versions only.
+     * One would better use conservative GC if he needs dynamic MzScheme
+     */
+    mzscheme_init();
+#else
+    int dummy = 0;
+    stack_base = (void *)&dummy;
+#endif
+    main_loop(FALSE, FALSE);
+#if defined(MZ_PRECISE_GC) && MZSCHEME_VERSION_MAJOR < 400
+    /* releasing dummy */
+    MZ_GC_REG();
+    MZ_GC_UNREG();
+#endif
+    return 0;
+}
+
     static void
 startup_mzscheme(void)
 {
-    Scheme_Object *proc_make_security_guard;
-
-    scheme_set_stack_base(NULL, 1);
+#if !defined(MZ_PRECISE_GC) || MZSCHEME_VERSION_MAJOR < 400
+    scheme_set_stack_base(stack_base, 1);
+#endif
 
     MZ_REGISTER_STATIC(environment);
     MZ_REGISTER_STATIC(curout);
@@ -767,10 +865,35 @@
     MZ_REGISTER_STATIC(exn_p);
     MZ_REGISTER_STATIC(exn_message);
     MZ_REGISTER_STATIC(vim_exn);
-    MZ_REGISTER_STATIC(vim_exn_names);
-    MZ_REGISTER_STATIC(vim_exn_values);
 
+#if !defined(MZ_PRECISE_GC) || MZSCHEME_VERSION_MAJOR < 400
+    /* in newer versions of precise GC the initial env has been created */
     environment = scheme_basic_env();
+#endif
+    MZ_GC_CHECK();
+
+#ifdef INCLUDE_MZSCHEME_BASE
+    {
+	/*
+	 * versions 4.x do not provide Scheme bindings by defaults
+	 * we need to add them explicitly
+	 */
+	Scheme_Object *scheme_base_symbol = NULL;
+	MZ_GC_DECL_REG(1);
+	MZ_GC_VAR_IN_REG(0, scheme_base_symbol);
+	MZ_GC_REG();
+	/* invoke function from generated and included base.c */
+	declare_modules(environment);
+	scheme_base_symbol = scheme_intern_symbol("scheme/base");
+	MZ_GC_CHECK();
+	scheme_namespace_require(scheme_base_symbol);
+	MZ_GC_CHECK();
+	MZ_GC_UNREG();
+    }
+#endif
+    register_vim_exn();
+    /* use new environment to initialise exception handling */
+    init_exn_catching_apply();
 
     /* redirect output */
     scheme_console_output = do_output;
@@ -778,48 +901,131 @@
 
 #ifdef MZSCHEME_COLLECTS
     /* setup 'current-library-collection-paths' parameter */
-    scheme_set_param(scheme_config, MZCONFIG_COLLECTION_PATHS,
-	    scheme_make_pair(
 # if MZSCHEME_VERSION_MAJOR >= 299
-		scheme_char_string_to_path(
-		    scheme_byte_string_to_char_string(
-			scheme_make_byte_string(MZSCHEME_COLLECTS))),
+    {
+	Scheme_Object	*coll_byte_string = NULL;
+	Scheme_Object	*coll_char_string = NULL;
+	Scheme_Object	*coll_path = NULL;
+	Scheme_Object	*coll_pair = NULL;
+	Scheme_Config	*config = NULL;
+
+	MZ_GC_DECL_REG(5);
+	MZ_GC_VAR_IN_REG(0, coll_byte_string);
+	MZ_GC_VAR_IN_REG(1, coll_char_string);
+	MZ_GC_VAR_IN_REG(2, coll_path);
+	MZ_GC_VAR_IN_REG(3, coll_pair);
+	MZ_GC_VAR_IN_REG(4, config);
+	MZ_GC_REG();
+	coll_byte_string = scheme_make_byte_string(MZSCHEME_COLLECTS);
+	MZ_GC_CHECK();
+	coll_char_string = scheme_byte_string_to_char_string(coll_byte_string);
+	MZ_GC_CHECK();
+	coll_path = scheme_char_string_to_path(coll_char_string);
+	MZ_GC_CHECK();
+	coll_pair = scheme_make_pair(coll_path, scheme_null);
+	MZ_GC_CHECK();
+	config = scheme_config;
+	MZ_GC_CHECK();
+	scheme_set_param(config, MZCONFIG_COLLECTION_PATHS, coll_pair);
+	MZ_GC_CHECK();
+	MZ_GC_UNREG();
+    }
 # else
-		scheme_make_string(MZSCHEME_COLLECTS),
+    {
+	Scheme_Object	*coll_string = NULL;
+	Scheme_Object	*coll_pair = NULL;
+	Scheme_Config	*config = NULL;
+
+	MZ_GC_DECL_REG(3);
+	MZ_GC_VAR_IN_REG(0, coll_string);
+	MZ_GC_VAR_IN_REG(1, coll_pair);
+	MZ_GC_VAR_IN_REG(2, config);
+	MZ_GC_REG();
+	coll_string = scheme_make_string(MZSCHEME_COLLECTS);
+	MZ_GC_CHECK();
+	coll_pair = scheme_make_pair(coll_string, scheme_null);
+	MZ_GC_CHECK();
+	config = scheme_config;
+	MZ_GC_CHECK();
+	scheme_set_param(config, MZCONFIG_COLLECTION_PATHS, coll_pair);
+	MZ_GC_CHECK();
+	MZ_GC_UNREG();
+    }
 # endif
-		scheme_null));
 #endif
 #ifdef HAVE_SANDBOX
-    /* setup sandbox guards */
-    proc_make_security_guard = scheme_lookup_global(
-	    scheme_intern_symbol("make-security-guard"),
-	    environment);
-    if (proc_make_security_guard != NULL)
-    {
-	Scheme_Object *args[3];
-	Scheme_Object *guard;
-	args[0] = scheme_get_param(scheme_config, MZCONFIG_SECURITY_GUARD);
-	args[1] = scheme_make_prim_w_arity(sandbox_file_guard,
-		"sandbox-file-guard", 3, 3);
-	args[2] = scheme_make_prim_w_arity(sandbox_network_guard,
-		"sandbox-network-guard", 4, 4);
-	guard = scheme_apply(proc_make_security_guard, 3, args);
-	scheme_set_param(scheme_config, MZCONFIG_SECURITY_GUARD, guard);
+    {
+	Scheme_Object	*make_security_guard = NULL;
+	MZ_GC_DECL_REG(1);
+	MZ_GC_VAR_IN_REG(0, make_security_guard);
+	MZ_GC_REG();
+
+#if MZSCHEME_VERSION_MAJOR < 400
+	{
+	    Scheme_Object	*make_security_guard_symbol = NULL;
+	    MZ_GC_DECL_REG(1);
+	    MZ_GC_VAR_IN_REG(0, make_security_guard_symbol);
+	    MZ_GC_REG();
+	    make_security_guard_symbol = scheme_intern_symbol("make-security-guard");
+	    MZ_GC_CHECK();
+	    make_security_guard = scheme_lookup_global(
+		    make_security_guard_symbol, environment);
+	    MZ_GC_UNREG();
+	}
+#else
+	make_security_guard = scheme_builtin_value("make-security-guard");
+	MZ_GC_CHECK();
+#endif
+
+	/* setup sandbox guards */
+	if (make_security_guard != NULL)
+	{
+	    Scheme_Object   *args[3] = {NULL, NULL, NULL};
+	    Scheme_Object   *guard = NULL;
+	    Scheme_Config   *config = NULL;
+	    MZ_GC_DECL_REG(5);
+	    MZ_GC_ARRAY_VAR_IN_REG(0, args, 3);
+	    MZ_GC_VAR_IN_REG(3, guard);
+	    MZ_GC_VAR_IN_REG(4, config);
+	    MZ_GC_REG();
+	    config = scheme_config;
+	    MZ_GC_CHECK();
+	    args[0] = scheme_get_param(config, MZCONFIG_SECURITY_GUARD);
+	    MZ_GC_CHECK();
+	    args[1] = scheme_make_prim_w_arity(sandbox_file_guard,
+		    "sandbox-file-guard", 3, 3);
+	    args[2] = scheme_make_prim_w_arity(sandbox_network_guard,
+		    "sandbox-network-guard", 4, 4);
+	    guard = scheme_apply(make_security_guard, 3, args);
+	    MZ_GC_CHECK();
+	    scheme_set_param(config, MZCONFIG_SECURITY_GUARD, guard);
+	    MZ_GC_CHECK();
+	    MZ_GC_UNREG();
+	}
+	MZ_GC_UNREG();
     }
 #endif
     /* Create buffer and window types for use in Scheme code */
     mz_buffer_type = scheme_make_type("<vim-buffer>");
+    MZ_GC_CHECK();
     mz_window_type = scheme_make_type("<vim-window>");
+    MZ_GC_CHECK();
+#ifdef MZ_PRECISE_GC
+    GC_register_traversers(mz_buffer_type,
+	    buffer_size_proc, buffer_mark_proc, buffer_fixup_proc,
+	    TRUE, TRUE);
+    GC_register_traversers(mz_window_type,
+	    window_size_proc, window_mark_proc, window_fixup_proc,
+	    TRUE, TRUE);
+#endif
 
-    register_vim_exn(environment);
-    make_modules(environment);
+    make_modules();
 
     /*
      * setup callback to receive notifications
      * whether thread scheduling is (or not) required
      */
     scheme_notify_multithread = notify_multithread;
-    initialized = 1;
 }
 
 /*
@@ -829,71 +1035,38 @@
     static int
 mzscheme_init(void)
 {
-    int do_require = FALSE;
-
     if (!initialized)
     {
-	do_require = TRUE;
 #ifdef DYNAMIC_MZSCHEME
 	if (!mzscheme_enabled(TRUE))
 	{
-	    EMSG(_("???: Sorry, this command is disabled, the MzScheme library could not be loaded."));
+	    EMSG(_("E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded."));
 	    return -1;
 	}
 #endif
 	startup_mzscheme();
-
-	if (mzscheme_io_init())
-	    return -1;
-
+	initialized = TRUE;
     }
-    /* recreate ports each call effectivelly clearing these ones */
-    curout = scheme_make_string_output_port();
-    curerr = scheme_make_string_output_port();
-    scheme_set_param(scheme_config, MZCONFIG_OUTPUT_PORT, curout);
-    scheme_set_param(scheme_config, MZCONFIG_ERROR_PORT, curerr);
-
-    if (do_require)
-    {
-	/* auto-instantiate in basic env */
-	eval_in_namespace("(require (prefix vimext: vimext))", do_eval,
-		environment, NULL);
-    }
-
-    return 0;
-}
-
-/*
- * This routine fills the namespace with various important routines that can
- * be used within MzScheme.
- */
-    static void
-mzscheme_interface_init(vim_mz_buffer *mzbuff)
-{
-    Scheme_Object   *attach;
-
-    mzbuff->env = (Scheme_Env *)scheme_make_namespace(0, NULL);
-
-    /*
-     * attach instantiated modules from global namespace
-     * so they can be easily instantiated in the buffer namespace
-     */
-    attach = scheme_lookup_global(
-	    scheme_intern_symbol("namespace-attach-module"),
-	    environment);
-
-    if (attach != NULL)
     {
-	Scheme_Object   *ret;
-	Scheme_Object	*args[2];
-
-	args[0] = (Scheme_Object *)environment;
-	args[1] = scheme_intern_symbol("vimext");
-
-	ret = (Scheme_Object *)mzvim_apply(attach, 2, args);
+	Scheme_Config	*config = NULL;
+	MZ_GC_DECL_REG(1);
+	MZ_GC_VAR_IN_REG(0, config);
+	MZ_GC_REG();
+	config = scheme_config;
+	MZ_GC_CHECK();
+	/* recreate ports each call effectivelly clearing these ones */
+	curout = scheme_make_string_output_port();
+	MZ_GC_CHECK();
+	curerr = scheme_make_string_output_port();
+	MZ_GC_CHECK();
+	scheme_set_param(config, MZCONFIG_OUTPUT_PORT, curout);
+	MZ_GC_CHECK();
+	scheme_set_param(config, MZCONFIG_ERROR_PORT, curerr);
+	MZ_GC_CHECK();
+	MZ_GC_UNREG();
     }
 
-    add_vim_exn(mzbuff->env);
+    return 0;
 }
 
 /*
@@ -903,28 +1076,25 @@
  */
 
 /*
- * Evaluate command in namespace with exception handling
+ * Evaluate command with exception handling
  */
     static int
-eval_in_namespace(void *data, Scheme_Closed_Prim *what, Scheme_Env *env,
-		Scheme_Object **ret)
+eval_with_exn_handling(void *data, Scheme_Closed_Prim *what, Scheme_Object **ret)
 {
-    Scheme_Object   *value;
-    Scheme_Object   *exn;
-    Cmd_Info	    info;   /* closure info */
-
-    info.data = data;
-    info.env = env;
-
-    scheme_set_param(scheme_config, MZCONFIG_ENV,
-	    (Scheme_Object *) env);
-    /*
-     * ensure all evaluations will be in current buffer namespace,
-     * the second argument to scheme_eval_string isn't enough!
-     */
-    value = _apply_thunk_catch_exceptions(
-	    scheme_make_closed_prim_w_arity(what, &info, "mzvim", 0, 0),
-	    &exn);
+    Scheme_Object   *value = NULL;
+    Scheme_Object   *exn = NULL;
+    Scheme_Object   *prim = NULL;
+
+    MZ_GC_DECL_REG(3);
+    MZ_GC_VAR_IN_REG(0, value);
+    MZ_GC_VAR_IN_REG(1, exn);
+    MZ_GC_VAR_IN_REG(2, prim);
+    MZ_GC_REG();
+
+    prim = scheme_make_closed_prim_w_arity(what, data, "mzvim", 0, 0);
+    MZ_GC_CHECK();
+    value = _apply_thunk_catch_exceptions(prim, &exn);
+    MZ_GC_CHECK();
 
     if (!value)
     {
@@ -932,9 +1102,11 @@
 	/* Got an exn? */
 	if (value)
 	{
-	    scheme_display(value, curerr);  /*  Send to stderr-vim */
+	    scheme_display(value, curerr);   /*  Send to stderr-vim */
+	    MZ_GC_CHECK();
 	    do_flush();
 	}
+	MZ_GC_UNREG();
 	/* `raise' was called on some arbitrary value */
 	return FAIL;
     }
@@ -943,9 +1115,13 @@
 	*ret = value;
     /* Print any result, as long as it's not a void */
     else if (!SCHEME_VOIDP(value))
+    {
 	scheme_display(value, curout);  /* Send to stdout-vim */
+	MZ_GC_CHECK();
+    }
 
     do_flush();
+    MZ_GC_UNREG();
     return OK;
 }
 
@@ -959,7 +1135,7 @@
     range_start = eap->line1;
     range_end = eap->line2;
 
-    return eval_in_namespace(data, what, get_vim_curr_buffer()->env, NULL);
+    return eval_with_exn_handling(data, what, NULL);
 }
 
 /*
@@ -976,6 +1152,7 @@
 	bp->buf = INVALID_BUFFER_VALUE;
 	buf->b_mzscheme_ref = NULL;
 	scheme_gc_ptr_ok(bp);
+	MZ_GC_CHECK();
     }
 }
 
@@ -992,6 +1169,7 @@
 	wp->win = INVALID_WINDOW_VALUE;
 	win->w_mzscheme_ref = NULL;
 	scheme_gc_ptr_ok(wp);
+	MZ_GC_CHECK();
     }
 }
 
@@ -1016,18 +1194,6 @@
     }
 }
 
-/* eval MzScheme string */
-    void *
-mzvim_eval_string(char_u *str)
-{
-    Scheme_Object *ret = NULL;
-    if (mzscheme_init())
-	return FAIL;
-
-    eval_in_namespace(str, do_eval, get_vim_curr_buffer()->env, &ret);
-    return ret;
-}
-
 /*
  * apply MzScheme procedure with arguments,
  * handling errors
@@ -1035,43 +1201,65 @@
     Scheme_Object *
 mzvim_apply(Scheme_Object *proc, int argc, Scheme_Object **argv)
 {
-    Apply_Info	data;
-    Scheme_Object *ret = NULL;
-
     if (mzscheme_init())
 	return FAIL;
+    else
+    {
+	Apply_Info	data = {NULL, 0, NULL};
+	Scheme_Object	*ret = NULL;
 
-    data.proc = proc;
-    data.argc = argc;
-    data.argv = argv;
-
-    eval_in_namespace(&data, do_apply, get_vim_curr_buffer()->env, &ret);
-    return ret;
+	MZ_GC_DECL_REG(5);
+	MZ_GC_VAR_IN_REG(0, ret);
+	MZ_GC_VAR_IN_REG(1, data.proc);
+	MZ_GC_ARRAY_VAR_IN_REG(2, data.argv, argc);
+	MZ_GC_REG();
+
+	data.proc = proc;
+	data.argc = argc;
+	data.argv = argv;
+
+	eval_with_exn_handling(&data, do_apply, &ret);
+	MZ_GC_UNREG();
+	return ret;
+    }
 }
 
     static Scheme_Object *
 do_load(void *data, int noargc, Scheme_Object **noargv)
 {
-    Cmd_Info	    *info = (Cmd_Info *)data;
-    Scheme_Object   *result = scheme_void;
-    Scheme_Object   *expr;
-    char_u	    *file = scheme_malloc_fail_ok(
-					  scheme_malloc_atomic, MAXPATHL + 1);
-    Port_Info	    *pinfo = (Port_Info *)(info->data);
+    Scheme_Object   *expr = NULL;
+    Scheme_Object   *result = NULL;
+    char	    *file = NULL;
+    Port_Info	    *pinfo = (Port_Info *)data;
+
+    MZ_GC_DECL_REG(3);
+    MZ_GC_VAR_IN_REG(0, expr);
+    MZ_GC_VAR_IN_REG(1, result);
+    MZ_GC_VAR_IN_REG(2, file);
+    MZ_GC_REG();
+
+    file = (char *)scheme_malloc_fail_ok(scheme_malloc_atomic, MAXPATHL + 1);
+    MZ_GC_CHECK();
 
     /* make Vim expansion */
-    expand_env((char_u *)pinfo->name, file, MAXPATHL);
-    /* scheme_load looks strange working with namespaces and error handling*/
+    expand_env((char_u *)pinfo->name, (char_u *)file, MAXPATHL);
     pinfo->port = scheme_open_input_file(file, "mzfile");
-    scheme_count_lines(pinfo->port); /* to get accurate read error location*/
+    MZ_GC_CHECK();
+    scheme_count_lines(pinfo->port);  /* to get accurate read error location*/
+    MZ_GC_CHECK();
 
     /* Like REPL but print only last result */
     while (!SCHEME_EOFP(expr = scheme_read(pinfo->port)))
-	result = scheme_eval(expr, info->env);
+    {
+	result = scheme_eval(expr, environment);
+	MZ_GC_CHECK();
+    }
 
     /* errors will be caught in do_mzscheme_comamnd and ex_mzfile */
     scheme_close_input_port(pinfo->port);
+    MZ_GC_CHECK();
     pinfo->port = NULL;
+    MZ_GC_UNREG();
     return result;
 }
 
@@ -1079,13 +1267,20 @@
     void
 ex_mzfile(exarg_T *eap)
 {
-    Port_Info	pinfo;
+    Port_Info	pinfo = {NULL, NULL};
+
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, pinfo.port);
+    MZ_GC_REG();
 
     pinfo.name = (char *)eap->arg;
-    pinfo.port = NULL;
     if (do_mzscheme_command(eap, &pinfo, do_load) != OK
 	    && pinfo.port != NULL)	/* looks like port was not closed */
+    {
 	scheme_close_input_port(pinfo.port);
+	MZ_GC_CHECK();
+    }
+    MZ_GC_UNREG();
 }
 
 
@@ -1105,14 +1300,12 @@
 		"(with-handlers ([void (lambda (exn) (cons #f exn))]) "
 		"(cons #t (thunk))))";
 
-	/* make sure we have a namespace with the standard syntax: */
-	Scheme_Env *env = (Scheme_Env *)scheme_make_namespace(0, NULL);
-	add_vim_exn(env);
-
-	exn_catching_apply = scheme_eval_string(e, env);
-	exn_p = scheme_lookup_global(scheme_intern_symbol("exn?"), env);
-	exn_message = scheme_lookup_global(
-		scheme_intern_symbol("exn-message"), env);
+	exn_catching_apply = scheme_eval_string(e, environment);
+	MZ_GC_CHECK();
+	exn_p = scheme_builtin_value("exn?");
+	MZ_GC_CHECK();
+	exn_message = scheme_builtin_value("exn-message");
+	MZ_GC_CHECK();
     }
 }
 
@@ -1126,8 +1319,6 @@
 {
     Scheme_Object *v;
 
-    init_exn_catching_apply();
-
     v = _scheme_apply(exn_catching_apply, 1, &f);
     /* v is a pair: (cons #t value) or (cons #f exn) */
 
@@ -1143,8 +1334,6 @@
     static Scheme_Object *
 extract_exn_message(Scheme_Object *v)
 {
-    init_exn_catching_apply();
-
     if (SCHEME_TRUEP(_scheme_apply(exn_p, 1, &v)))
 	return _scheme_apply(exn_message, 1, &v);
     else
@@ -1154,16 +1343,13 @@
     static Scheme_Object *
 do_eval(void *s, int noargc, Scheme_Object **noargv)
 {
-    Cmd_Info	*info = (Cmd_Info *)s;
-
-    return scheme_eval_string_all((char *)(info->data), info->env, TRUE);
+    return scheme_eval_string_all((char *)s, environment, TRUE);
 }
 
     static Scheme_Object *
 do_apply(void *a, int noargc, Scheme_Object **noargv)
 {
-    Apply_Info	*info = (Apply_Info *)(((Cmd_Info *)a)->data);
-
+    Apply_Info	*info = (Apply_Info *)a;
     return scheme_apply(info->proc, info->argc, info->argv);
 }
 
@@ -1221,6 +1407,7 @@
     long length;
 
     buff = scheme_get_sized_string_output(curerr, &length);
+    MZ_GC_CHECK();
     if (length)
     {
 	do_err_output(buff, length);
@@ -1228,17 +1415,11 @@
     }
 
     buff = scheme_get_sized_string_output(curout, &length);
+    MZ_GC_CHECK();
     if (length)
 	do_output(buff, length);
 }
 
-    static int
-mzscheme_io_init(void)
-{
-    /* Nothing needed so far... */
-    return 0;
-}
-
 /*
  *========================================================================
  *  4. Implementation of the Vim Features for MzScheme
@@ -1265,22 +1446,30 @@
 vim_eval(void *data, int argc, Scheme_Object **argv)
 {
 #ifdef FEAT_EVAL
-    Vim_Prim	    *prim = (Vim_Prim *)data;
-    char	    *expr;
-    char	    *str;
-    Scheme_Object   *result;
+    Vim_Prim		*prim = (Vim_Prim *)data;
+    char		*expr;
+    Scheme_Object	*result;
+    /* hash table to store visited values to avoid infinite loops */
+    Scheme_Hash_Table	*visited = NULL;
+    typval_T		*vim_result;
+
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, visited);
+    MZ_GC_REG();
 
-    expr = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
+    visited = scheme_make_hash_table(SCHEME_hash_ptr);
+    MZ_GC_CHECK();
 
-    str = (char *)eval_to_string((char_u *)expr, NULL, TRUE);
+    expr = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
+    vim_result = eval_expr((char_u *)expr, NULL);
 
-    if (str == NULL)
+    if (vim_result == NULL)
 	raise_vim_exn(_("invalid expression"));
 
-    result = scheme_make_string(str);
-
-    vim_free(str);
+    result = vim_to_mzscheme(vim_result, 1, visited);
+    free_tv(vim_result);
 
+    MZ_GC_UNREG();
     return result;
 #else
     raise_vim_exn(_("expressions disabled at compile time"));
@@ -1320,7 +1509,7 @@
     Vim_Prim	    *prim = (Vim_Prim *)data;
     char_u	    *name;
     long	    value;
-    char_u	    *strval;
+    char	    *strval;
     int		    rc;
     Scheme_Object   *rval;
     int		    opt_flags = 0;
@@ -1335,6 +1524,7 @@
 	{
 	    MZ_REGISTER_STATIC(M_global);
 	    M_global = scheme_intern_symbol("global");
+	    MZ_GC_CHECK();
 	}
 
 	if (argv[1] == M_global)
@@ -1356,7 +1546,7 @@
 	    scheme_wrong_type(prim->name, "vim-buffer/window", 1, argc, argv);
     }
 
-    rc = get_option_value(name, &value, &strval, opt_flags);
+    rc = get_option_value(name, &value, (char_u **)&strval, opt_flags);
     curbuf = save_curb;
     curwin = save_curw;
 
@@ -1366,6 +1556,7 @@
 	return scheme_make_integer_value(value);
     case 0:
 	rval = scheme_make_string(strval);
+	MZ_GC_CHECK();
 	vim_free(strval);
 	return rval;
     case -1:
@@ -1395,6 +1586,7 @@
 	{
 	    MZ_REGISTER_STATIC(M_global);
 	    M_global = scheme_intern_symbol("global");
+	    MZ_GC_CHECK();
 	}
 
 	if (argv[1] == M_global)
@@ -1465,7 +1657,10 @@
 
     for (w = firstwin; w != NULL; w = w->w_next)
 	if (w->w_buffer == buf->buf)
+	{
 	    list = scheme_make_pair(window_new(w), list);
+	    MZ_GC_CHECK();
+	}
 
     return list;
 }
@@ -1473,7 +1668,11 @@
     static Scheme_Object *
 window_new(win_T *win)
 {
-    vim_mz_window *self;
+    vim_mz_window *self = NULL;
+
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, self);
+    MZ_GC_REG();
 
     /* We need to handle deletion of windows underneath us.
      * If we add a "w_mzscheme_ref" field to the win_T structure,
@@ -1487,13 +1686,14 @@
 	return win->w_mzscheme_ref;
 
     self = scheme_malloc_fail_ok(scheme_malloc, sizeof(vim_mz_window));
-
     vim_memset(self, 0, sizeof(vim_mz_window));
     scheme_dont_gc_ptr(self);	/* because win isn't visible to GC */
+    MZ_GC_CHECK();
     win->w_mzscheme_ref = self;
     self->win = win;
-    self->tag = mz_window_type;
+    self->so.type = mz_window_type;
 
+    MZ_GC_UNREG();
     return (Scheme_Object *)(self);
 }
 
@@ -1662,7 +1862,6 @@
 /*
  *===========================================================================
  *  6. Vim Buffer-related Manipulation Functions
- *     Note that each buffer should have its own private namespace.
  *===========================================================================
  */
 
@@ -1671,14 +1870,14 @@
 mzscheme_open_buffer(void *data, int argc, Scheme_Object **argv)
 {
     Vim_Prim	    *prim = (Vim_Prim *)data;
-    char	    *fname;
+    char_u	    *fname;
     int		    num = 0;
     Scheme_Object   *onum;
 
 #ifdef HAVE_SANDBOX
     sandbox_check();
 #endif
-    fname = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
+    fname = (char_u *)SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
     /* TODO make open existing file */
     num = buflist_add(fname, BLN_LISTED | BLN_CURBUF);
 
@@ -1714,7 +1913,7 @@
     buf_T	*buf;
     char_u	*fname;
 
-    fname = SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
+    fname = (char_u *)SCHEME_STR_VAL(GUARANTEE_STRING(prim->name, 0));
 
     for (buf = firstbuf; buf; buf = buf->b_next)
 	if (buf->b_ffname == NULL || buf->b_sfname == NULL)
@@ -1785,7 +1984,7 @@
     Vim_Prim	    *prim = (Vim_Prim *)data;
     vim_mz_buffer   *buf = get_buffer_arg(prim->name, 0, argc, argv);
 
-    return scheme_make_string(buf->buf->b_ffname);
+    return scheme_make_string((char *)buf->buf->b_ffname);
 }
 
 /* (curr-buff) */
@@ -1798,7 +1997,11 @@
     static Scheme_Object *
 buffer_new(buf_T *buf)
 {
-    vim_mz_buffer *self;
+    vim_mz_buffer *self = NULL;
+
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, self);
+    MZ_GC_REG();
 
     /* We need to handle deletion of buffers underneath us.
      * If we add a "b_mzscheme_ref" field to the buf_T structure,
@@ -1808,15 +2011,14 @@
 	return buf->b_mzscheme_ref;
 
     self = scheme_malloc_fail_ok(scheme_malloc, sizeof(vim_mz_buffer));
-
     vim_memset(self, 0, sizeof(vim_mz_buffer));
-    scheme_dont_gc_ptr(self);	/* because buf isn't visible to GC */
+    scheme_dont_gc_ptr(self); /* because buf isn't visible to GC */
+    MZ_GC_CHECK();
     buf->b_mzscheme_ref = self;
     self->buf = buf;
-    self->tag = mz_buffer_type;
-
-    mzscheme_interface_init(self);	/* Set up namespace */
+    self->so.type = mz_buffer_type;
 
+    MZ_GC_UNREG();
     return (Scheme_Object *)(self);
 }
 
@@ -1847,14 +2049,14 @@
     Vim_Prim	    *prim = (Vim_Prim *)data;
     vim_mz_buffer   *buf;
     int		    linenr;
-    char	    *line;
+    char_u	    *line;
 
     buf = get_buffer_arg(prim->name, 1, argc, argv);
     linenr = SCHEME_INT_VAL(GUARANTEE_INTEGER(prim->name, 0));
     line = ml_get_buf(buf->buf, (linenr_T)linenr, FALSE);
 
     raise_if_error();
-    return scheme_make_string(line);
+    return scheme_make_string((char *)line);
 }
 
 
@@ -1871,7 +2073,11 @@
     Vim_Prim	    *prim = (Vim_Prim *)data;
     vim_mz_buffer   *buf;
     int		    i, hi, lo, n;
-    Scheme_Object   *list;
+    Scheme_Object   *list = NULL;
+
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, list);
+    MZ_GC_REG();
 
     buf = get_buffer_arg(prim->name, 2, argc, argv);
     list = scheme_null;
@@ -1899,8 +2105,9 @@
 
 	/* Set the list item */
 	list = scheme_make_pair(str, list);
+	MZ_GC_CHECK();
     }
-
+    MZ_GC_UNREG();
     return list;
 }
 
@@ -1927,11 +2134,14 @@
      */
     Vim_Prim	    *prim = (Vim_Prim *)data;
     vim_mz_buffer   *buf;
-    Scheme_Object   *line;
+    Scheme_Object   *line = NULL;
     char	    *save;
-    buf_T	    *savebuf;
     int		    n;
 
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, line);
+    MZ_GC_REG();
+
 #ifdef HAVE_SANDBOX
     sandbox_check();
 #endif
@@ -1945,7 +2155,8 @@
 
     if (SCHEME_FALSEP(line))
     {
-	savebuf = curbuf;
+	buf_T	    *savebuf = curbuf;
+
 	curbuf = buf->buf;
 
 	if (u_savedel((linenr_T)n, 1L) == FAIL)
@@ -1958,39 +2169,62 @@
 	    curbuf = savebuf;
 	    raise_vim_exn(_("cannot delete line"));
 	}
-	deleted_lines_mark((linenr_T)n, 1L);
 	if (buf->buf == curwin->w_buffer)
 	    mz_fix_cursor(n, n + 1, -1);
+	deleted_lines_mark((linenr_T)n, 1L);
 
 	curbuf = savebuf;
 
+	MZ_GC_UNREG();
 	raise_if_error();
 	return scheme_void;
     }
+    else
+    {
+	/* Otherwise it's a line */
+	buf_T	    *savebuf = curbuf;
 
-    /* Otherwise it's a line */
-    save = string_to_line(line);
-    savebuf = curbuf;
+	save = string_to_line(line);
 
-    curbuf = buf->buf;
+	curbuf = buf->buf;
+
+	if (u_savesub((linenr_T)n) == FAIL)
+	{
+	    curbuf = savebuf;
+	    vim_free(save);
+	    raise_vim_exn(_("cannot save undo information"));
+	}
+	else if (ml_replace((linenr_T)n, (char_u *)save, TRUE) == FAIL)
+	{
+	    curbuf = savebuf;
+	    vim_free(save);
+	    raise_vim_exn(_("cannot replace line"));
+	}
+	else
+	{
+	    vim_free(save);
+	    changed_bytes((linenr_T)n, 0);
+	}
 
-    if (u_savesub((linenr_T)n) == FAIL)
-    {
-	curbuf = savebuf;
-	raise_vim_exn(_("cannot save undo information"));
-    }
-    else if (ml_replace((linenr_T)n, (char_u *)save, TRUE) == FAIL)
-    {
 	curbuf = savebuf;
-	raise_vim_exn(_("cannot replace line"));
-    }
-    else
-	changed_bytes((linenr_T)n, 0);
 
-    curbuf = savebuf;
+	/* Check that the cursor is not beyond the end of the line now. */
+	if (buf->buf == curwin->w_buffer)
+	    check_cursor_col();
 
-    raise_if_error();
-    return scheme_void;
+	MZ_GC_UNREG();
+	raise_if_error();
+	return scheme_void;
+    }
+}
+
+    static void
+free_array(char **array)
+{
+    char **curr = array;
+    while (*curr != NULL)
+	vim_free(*curr++);
+    vim_free(array);
 }
 
 /*
@@ -2015,15 +2249,15 @@
      *	  3. Anything else - this is an error.
      */
     Vim_Prim	    *prim = (Vim_Prim *)data;
-    vim_mz_buffer   *buf;
-    Scheme_Object   *line_list;
-    Scheme_Object   *line;
-    Scheme_Object   *rest;
-    char	    **array;
-    buf_T	    *savebuf;
+    vim_mz_buffer   *buf = NULL;
+    Scheme_Object   *line_list = NULL;
     int		    i, old_len, new_len, hi, lo;
     long	    extra;
 
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, line_list);
+    MZ_GC_REG();
+
 #ifdef HAVE_SANDBOX
     sandbox_check();
 #endif
@@ -2049,7 +2283,7 @@
 
     if (SCHEME_FALSEP(line_list) || SCHEME_NULLP(line_list))
     {
-	savebuf = curbuf;
+	buf_T	*savebuf = curbuf;
 	curbuf = buf->buf;
 
 	if (u_savedel((linenr_T)lo, (long)old_len) == FAIL)
@@ -2065,105 +2299,128 @@
 		    curbuf = savebuf;
 		    raise_vim_exn(_("cannot delete line"));
 		}
-	    deleted_lines_mark((linenr_T)lo, (long)old_len);
 	    if (buf->buf == curwin->w_buffer)
 		mz_fix_cursor(lo, hi, -old_len);
+	    deleted_lines_mark((linenr_T)lo, (long)old_len);
 	}
 
 	curbuf = savebuf;
 
+	MZ_GC_UNREG();
 	raise_if_error();
 	return scheme_void;
     }
+    else
+    {
+	buf_T	*savebuf = curbuf;
 
-    /* List */
-    new_len = scheme_proper_list_length(line_list);
-    if (new_len < 0)	/* improper or cyclic list */
-	scheme_wrong_type(prim->name, "proper list",
-		2, argc, argv);
+	/* List */
+	new_len = scheme_proper_list_length(line_list);
+	MZ_GC_CHECK();
+	if (new_len < 0)	/* improper or cyclic list */
+	    scheme_wrong_type(prim->name, "proper list",
+		    2, argc, argv);
+	else
+	{
+	    char		**array = NULL;
+	    Scheme_Object   *line = NULL;
+	    Scheme_Object   *rest = NULL;
+
+	    MZ_GC_DECL_REG(2);
+	    MZ_GC_VAR_IN_REG(0, line);
+	    MZ_GC_VAR_IN_REG(1, rest);
+	    MZ_GC_REG();
 
-    /* Using MzScheme allocator, so we don't need to free this and
-     * can safely keep pointers to GC collected strings
-     */
-    array = (char **)scheme_malloc_fail_ok(scheme_malloc,
-		(unsigned)(new_len * sizeof(char *)));
+	    array = (char **)alloc(new_len * sizeof(char *));
+	    vim_memset(array, 0, new_len * sizeof(char *));
 
-    rest = line_list;
-    for (i = 0; i < new_len; ++i)
-    {
-	line = SCHEME_CAR(rest);
-	rest = SCHEME_CDR(rest);
-	if (!SCHEME_STRINGP(line))
-	    scheme_wrong_type(prim->name, "string-list", 2, argc, argv);
-	array[i] = string_to_line(line);
-    }
+	    rest = line_list;
+	    for (i = 0; i < new_len; ++i)
+	    {
+		line = SCHEME_CAR(rest);
+		rest = SCHEME_CDR(rest);
+		if (!SCHEME_STRINGP(line))
+		{
+		    free_array(array);
+		    scheme_wrong_type(prim->name, "string-list", 2, argc, argv);
+		}
+		array[i] = string_to_line(line);
+	    }
 
-    savebuf = curbuf;
-    curbuf = buf->buf;
+	    curbuf = buf->buf;
 
-    if (u_save((linenr_T)(lo-1), (linenr_T)hi) == FAIL)
-    {
-	curbuf = savebuf;
-	raise_vim_exn(_("cannot save undo information"));
-    }
+	    if (u_save((linenr_T)(lo-1), (linenr_T)hi) == FAIL)
+	    {
+		curbuf = savebuf;
+		free_array(array);
+		raise_vim_exn(_("cannot save undo information"));
+	    }
 
-    /*
-     * If the size of the range is reducing (ie, new_len < old_len) we
-     * need to delete some old_len. We do this at the start, by
-     * repeatedly deleting line "lo".
-     */
-    for (i = 0; i < old_len - new_len; ++i)
-    {
-	if (ml_delete((linenr_T)lo, FALSE) == FAIL)
-	{
-	    curbuf = savebuf;
-	    raise_vim_exn(_("cannot delete line"));
-	}
-	extra--;
-    }
+	    /*
+	     * If the size of the range is reducing (ie, new_len < old_len) we
+	     * need to delete some old_len. We do this at the start, by
+	     * repeatedly deleting line "lo".
+	     */
+	    for (i = 0; i < old_len - new_len; ++i)
+	    {
+		if (ml_delete((linenr_T)lo, FALSE) == FAIL)
+		{
+		    curbuf = savebuf;
+		    free_array(array);
+		    raise_vim_exn(_("cannot delete line"));
+		}
+		extra--;
+	    }
 
-    /*
-     * For as long as possible, replace the existing old_len with the
-     * new old_len. This is a more efficient operation, as it requires
-     * less memory allocation and freeing.
-     */
-    for (i = 0; i < old_len && i < new_len; i++)
-	if (ml_replace((linenr_T)(lo+i), (char_u *)array[i], TRUE) == FAIL)
-	{
-	    curbuf = savebuf;
-	    raise_vim_exn(_("cannot replace line"));
-	}
+	    /*
+	     * For as long as possible, replace the existing old_len with the
+	     * new old_len. This is a more efficient operation, as it requires
+	     * less memory allocation and freeing.
+	     */
+	    for (i = 0; i < old_len && i < new_len; i++)
+		if (ml_replace((linenr_T)(lo+i), (char_u *)array[i], TRUE) == FAIL)
+		{
+		    curbuf = savebuf;
+		    free_array(array);
+		    raise_vim_exn(_("cannot replace line"));
+		}
 
-    /*
-     * Now we may need to insert the remaining new_len.  We don't need to
-     * free the string passed back because MzScheme has control of that
-     * memory.
-     */
-    while (i < new_len)
-    {
-	if (ml_append((linenr_T)(lo + i - 1),
-		(char_u *)array[i], 0, FALSE) == FAIL)
-	{
-	    curbuf = savebuf;
-	    raise_vim_exn(_("cannot insert line"));
+	    /*
+	     * Now we may need to insert the remaining new_len.  We don't need to
+	     * free the string passed back because MzScheme has control of that
+	     * memory.
+	     */
+	    while (i < new_len)
+	    {
+		if (ml_append((linenr_T)(lo + i - 1),
+			    (char_u *)array[i], 0, FALSE) == FAIL)
+		{
+		    curbuf = savebuf;
+		    free_array(array);
+		    raise_vim_exn(_("cannot insert line"));
+		}
+		++i;
+		++extra;
+	    }
+	    MZ_GC_UNREG();
+	    free_array(array);
 	}
-	++i;
-	++extra;
-    }
 
-    /*
-     * Adjust marks. Invalidate any which lie in the
-     * changed range, and move any in the remainder of the buffer.
-     */
-    mark_adjust((linenr_T)lo, (linenr_T)(hi - 1), (long)MAXLNUM, (long)extra);
-    changed_lines((linenr_T)lo, 0, (linenr_T)hi, (long)extra);
+	/*
+	 * Adjust marks. Invalidate any which lie in the
+	 * changed range, and move any in the remainder of the buffer.
+	 */
+	mark_adjust((linenr_T)lo, (linenr_T)(hi - 1), (long)MAXLNUM, (long)extra);
+	changed_lines((linenr_T)lo, 0, (linenr_T)hi, (long)extra);
 
-    if (buf->buf == curwin->w_buffer)
-	mz_fix_cursor(lo, hi, extra);
-    curbuf = savebuf;
+	if (buf->buf == curwin->w_buffer)
+	    mz_fix_cursor(lo, hi, extra);
+	curbuf = savebuf;
 
-    raise_if_error();
-    return scheme_void;
+	MZ_GC_UNREG();
+	raise_if_error();
+	return scheme_void;
+    }
 }
 
 /*
@@ -2181,15 +2438,15 @@
 insert_buffer_line_list(void *data, int argc, Scheme_Object **argv)
 {
     Vim_Prim	    *prim = (Vim_Prim *)data;
-    vim_mz_buffer   *buf;
-    Scheme_Object   *list;
-    Scheme_Object   *line;
-    Scheme_Object   *rest;
-    char	    **array;
-    char	    *str;
-    buf_T	    *savebuf;
+    vim_mz_buffer   *buf = NULL;
+    Scheme_Object   *list = NULL;
+    char	    *str = NULL;
     int		    i, n, size;
 
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, list);
+    MZ_GC_REG();
+
 #ifdef HAVE_SANDBOX
     sandbox_check();
 #endif
@@ -2208,89 +2465,99 @@
 	check_line_range(n, buf->buf);
     if (SCHEME_STRINGP(list))
     {
-	str = string_to_line(list);
+	buf_T	    *savebuf = curbuf;
 
-	savebuf = curbuf;
+	str = string_to_line(list);
 	curbuf = buf->buf;
 
 	if (u_save((linenr_T)n, (linenr_T)(n+1)) == FAIL)
 	{
 	    curbuf = savebuf;
+	    vim_free(str);
 	    raise_vim_exn(_("cannot save undo information"));
 	}
 	else if (ml_append((linenr_T)n, (char_u *)str, 0, FALSE) == FAIL)
 	{
 	    curbuf = savebuf;
+	    vim_free(str);
 	    raise_vim_exn(_("cannot insert line"));
 	}
 	else
+	{
+	    vim_free(str);
 	    appended_lines_mark((linenr_T)n, 1L);
+	}
 
 	curbuf = savebuf;
 	update_screen(VALID);
 
+	MZ_GC_UNREG();
 	raise_if_error();
 	return scheme_void;
     }
 
     /* List */
     size = scheme_proper_list_length(list);
+    MZ_GC_CHECK();
     if (size < 0)	/* improper or cyclic list */
 	scheme_wrong_type(prim->name, "proper list",
 		2, argc, argv);
-
-    /* Using MzScheme allocator, so we don't need to free this and
-     * can safely keep pointers to GC collected strings
-     */
-    array = (char **)scheme_malloc_fail_ok(
-	    scheme_malloc, (unsigned)(size * sizeof(char *)));
-
-    rest = list;
-    for (i = 0; i < size; ++i)
+    else
     {
-	line = SCHEME_CAR(rest);
-	rest = SCHEME_CDR(rest);
-	array[i] = string_to_line(line);
-    }
+	Scheme_Object   *line = NULL;
+	Scheme_Object   *rest = NULL;
+	char		**array;
+	buf_T		*savebuf = curbuf;
+
+	MZ_GC_DECL_REG(2);
+	MZ_GC_VAR_IN_REG(0, line);
+	MZ_GC_VAR_IN_REG(1, rest);
+	MZ_GC_REG();
 
-    savebuf = curbuf;
-    curbuf = buf->buf;
+	array = (char **)alloc(size * sizeof(char *));
+	vim_memset(array, 0, size * sizeof(char *));
 
-    if (u_save((linenr_T)n, (linenr_T)(n + 1)) == FAIL)
-    {
-	curbuf = savebuf;
-	raise_vim_exn(_("cannot save undo information"));
-    }
-    else
-    {
+	rest = list;
 	for (i = 0; i < size; ++i)
-	    if (ml_append((linenr_T)(n + i), (char_u *)array[i],
-			0, FALSE) == FAIL)
-	    {
-		curbuf = savebuf;
-		raise_vim_exn(_("cannot insert line"));
-	    }
+	{
+	    line = SCHEME_CAR(rest);
+	    rest = SCHEME_CDR(rest);
+	    array[i] = string_to_line(line);
+	}
 
-	if (i > 0)
-	    appended_lines_mark((linenr_T)n, (long)i);
-    }
+	curbuf = buf->buf;
 
-    curbuf = savebuf;
-    update_screen(VALID);
+	if (u_save((linenr_T)n, (linenr_T)(n + 1)) == FAIL)
+	{
+	    curbuf = savebuf;
+	    free_array(array);
+	    raise_vim_exn(_("cannot save undo information"));
+	}
+	else
+	{
+	    for (i = 0; i < size; ++i)
+		if (ml_append((linenr_T)(n + i), (char_u *)array[i],
+			    0, FALSE) == FAIL)
+		{
+		    curbuf = savebuf;
+		    free_array(array);
+		    raise_vim_exn(_("cannot insert line"));
+		}
 
+	    if (i > 0)
+		appended_lines_mark((linenr_T)n, (long)i);
+	}
+	free_array(array);
+	MZ_GC_UNREG();
+	curbuf = savebuf;
+	update_screen(VALID);
+    }
+
+    MZ_GC_UNREG();
     raise_if_error();
     return scheme_void;
 }
 
-/* (get-buff-namespace [buffer]) */
-    static Scheme_Object *
-get_buffer_namespace(void *data, int argc, Scheme_Object **argv)
-{
-    Vim_Prim	*prim = (Vim_Prim *)data;
-
-    return (Scheme_Object *)get_buffer_arg(prim->name, 0, argc, argv)->env;
-}
-
 /*
  * Predicates
  */
@@ -2345,40 +2612,172 @@
 /*
  * Convert an MzScheme string into a Vim line.
  *
- * The result is in allocated memory. All internal nulls are replaced by
- * newline characters. It is an error for the string to contain newline
- * characters.
+ * All internal nulls are replaced by newline characters.
+ * It is an error for the string to contain newline characters.
  *
+ * Returns pointer to Vim allocated memory
  */
     static char *
 string_to_line(Scheme_Object *obj)
 {
-    char	*str;
+    char	*scheme_str = NULL;
+    char	*vim_str = NULL;
     long	len;
     int		i;
 
-    str = scheme_display_to_string(obj, &len);
+    scheme_str = scheme_display_to_string(obj, &len);
 
     /* Error checking: String must not contain newlines, as we
      * are replacing a single line, and we must replace it with
      * a single line.
      */
-    if (memchr(str, '\n', len))
+    if (memchr(scheme_str, '\n', len))
 	scheme_signal_error(_("string cannot contain newlines"));
 
+    vim_str = (char *)alloc(len + 1);
+
     /* Create a copy of the string, with internal nulls replaced by
      * newline characters, as is the vim convention.
      */
     for (i = 0; i < len; ++i)
     {
-	if (str[i] == '\0')
-	    str[i] = '\n';
+	if (scheme_str[i] == '\0')
+	    vim_str[i] = '\n';
+	else
+	    vim_str[i] = scheme_str[i];
+    }
+
+    vim_str[i] = '\0';
+
+    MZ_GC_CHECK();
+    return vim_str;
+}
+
+#ifdef FEAT_EVAL
+/*
+ * Convert Vim value into MzScheme, adopted from if_python.c
+ */
+    static Scheme_Object *
+vim_to_mzscheme(typval_T *vim_value, int depth, Scheme_Hash_Table *visited)
+{
+    Scheme_Object   *result = NULL;
+    int		    new_value = TRUE;
+
+    MZ_GC_DECL_REG(1);
+    MZ_GC_VAR_IN_REG(0, result);
+    MZ_GC_REG();
+
+    /* Avoid infinite recursion */
+    if (depth > 100)
+    {
+	MZ_GC_UNREG();
+	return scheme_void;
+    }
+
+    /* Check if we run into a recursive loop.  The item must be in visited
+     * then and we can use it again.
+     */
+    result = scheme_hash_get(visited, (Scheme_Object *)vim_value);
+    MZ_GC_CHECK();
+    if (result != NULL) /* found, do nothing */
+	new_value = FALSE;
+    else if (vim_value->v_type == VAR_STRING)
+    {
+	result = scheme_make_string((char *)vim_value->vval.v_string);
+	MZ_GC_CHECK();
+    }
+    else if (vim_value->v_type == VAR_NUMBER)
+    {
+	result = scheme_make_integer((long)vim_value->vval.v_number);
+	MZ_GC_CHECK();
+    }
+# ifdef FEAT_FLOAT
+    else if (vim_value->v_type == VAR_FLOAT)
+    {
+	result = scheme_make_double((double)vim_value->vval.v_float);
+	MZ_GC_CHECK();
+    }
+# endif
+    else if (vim_value->v_type == VAR_LIST)
+    {
+	list_T		*list = vim_value->vval.v_list;
+	listitem_T	*curr;
+
+	if (list == NULL || list->lv_first == NULL)
+	    result = scheme_null;
+	else
+	{
+	    Scheme_Object   *obj = NULL;
+
+	    MZ_GC_DECL_REG(1);
+	    MZ_GC_VAR_IN_REG(0, obj);
+	    MZ_GC_REG();
+
+	    curr = list->lv_last;
+	    obj = vim_to_mzscheme(&curr->li_tv, depth + 1, visited);
+	    result = scheme_make_pair(obj, scheme_null);
+	    MZ_GC_CHECK();
+
+	    while (curr != list->lv_first)
+	    {
+		curr = curr->li_prev;
+		obj = vim_to_mzscheme(&curr->li_tv, depth + 1, visited);
+		result = scheme_make_pair(obj, result);
+		MZ_GC_CHECK();
+	    }
+	}
+	MZ_GC_UNREG();
     }
+    else if (vim_value->v_type == VAR_DICT)
+    {
+	Scheme_Object	  *key = NULL;
+	Scheme_Object	  *obj = NULL;
+
+	MZ_GC_DECL_REG(2);
+	MZ_GC_VAR_IN_REG(0, key);
+	MZ_GC_VAR_IN_REG(1, obj);
+	MZ_GC_REG();
 
-    str[i] = '\0';
+	result = (Scheme_Object *)scheme_make_hash_table(SCHEME_hash_ptr);
+	MZ_GC_CHECK();
+	if (vim_value->vval.v_dict != NULL)
+	{
+	    hashtab_T	*ht = &vim_value->vval.v_dict->dv_hashtab;
+	    long_u	todo = ht->ht_used;
+	    hashitem_T	*hi;
+	    dictitem_T	*di;
 
-    return str;
+	    for (hi = ht->ht_array; todo > 0; ++hi)
+	    {
+		if (!HASHITEM_EMPTY(hi))
+		{
+		    --todo;
+
+		    di = dict_lookup(hi);
+		    obj = vim_to_mzscheme(&di->di_tv, depth + 1, visited);
+		    key = scheme_make_string((char *)hi->hi_key);
+		    MZ_GC_CHECK();
+		    scheme_hash_set((Scheme_Hash_Table *)result, key, obj);
+		    MZ_GC_CHECK();
+		}
+	    }
+	}
+	MZ_GC_UNREG();
+    }
+    else
+    {
+	result = scheme_void;
+	new_value = FALSE;
+    }
+    if (new_value)
+    {
+	scheme_hash_set(visited, (Scheme_Object *)vim_value, result);
+	MZ_GC_CHECK();
+    }
+    MZ_GC_UNREG();
+    return result;
 }
+#endif
 
 /*
  * Check to see whether a Vim error has been reported, or a keyboard
@@ -2394,50 +2793,59 @@
  * register Scheme exn:vim
  */
     static void
-register_vim_exn(Scheme_Env *env)
+register_vim_exn(void)
 {
-    Scheme_Object   *exn_name = scheme_intern_symbol("exn:vim");
+    int	nc = 0;
+    int i;
+    Scheme_Object   *struct_exn = NULL;
+    Scheme_Object   *exn_name = NULL;
+
+    MZ_GC_DECL_REG(2);
+    MZ_GC_VAR_IN_REG(0, struct_exn);
+    MZ_GC_VAR_IN_REG(1, exn_name);
+    MZ_GC_REG();
+
+    exn_name = scheme_intern_symbol("exn:vim");
+    MZ_GC_CHECK();
+    struct_exn = scheme_builtin_value("struct:exn");
+    MZ_GC_CHECK();
 
     if (vim_exn == NULL)
 	vim_exn = scheme_make_struct_type(exn_name,
-		scheme_builtin_value("struct:exn"), NULL, 0, 0, NULL, NULL
+		struct_exn, NULL, 0, 0, NULL, NULL
 #if MZSCHEME_VERSION_MAJOR >= 299
 		, NULL
 #endif
 		);
 
-    if (vim_exn_values == NULL)
-    {
-	int	nc = 0;
 
-	Scheme_Object   **exn_names = scheme_make_struct_names(
-		exn_name, scheme_null, 0, &nc);
-	Scheme_Object   **exn_values = scheme_make_struct_values(
-		vim_exn, exn_names, nc, 0);
-
-	vim_exn_names = scheme_make_vector(nc, scheme_false);
-	vim_exn_values = scheme_make_vector(nc, scheme_false);
-	/* remember names and values */
-	mch_memmove(SCHEME_VEC_ELS(vim_exn_names), exn_names,
-		nc * sizeof(Scheme_Object *));
-	mch_memmove(SCHEME_VEC_ELS(vim_exn_values), exn_values,
-		nc * sizeof(Scheme_Object *));
+    {
+	Scheme_Object   **tmp = NULL;
+	Scheme_Object   *exn_names[5] = {NULL, NULL, NULL, NULL, NULL};
+	Scheme_Object   *exn_values[5] = {NULL, NULL, NULL, NULL, NULL};
+	MZ_GC_DECL_REG(6);
+	MZ_GC_ARRAY_VAR_IN_REG(0, exn_names, 5);
+	MZ_GC_ARRAY_VAR_IN_REG(3, exn_values, 5);
+	MZ_GC_REG();
+
+	tmp = scheme_make_struct_names(exn_name, scheme_null, 0, &nc);
+	assert(nc <= 5);
+	mch_memmove(exn_names, tmp, nc * sizeof(Scheme_Object *));
+	MZ_GC_CHECK();
+
+	tmp = scheme_make_struct_values(vim_exn, exn_names, nc, 0);
+	mch_memmove(exn_values, tmp, nc * sizeof(Scheme_Object *));
+	MZ_GC_CHECK();
+
+	for (i = 0; i < nc; i++)
+	{
+	    scheme_add_global_symbol(exn_names[i],
+		    exn_values[i], environment);
+	    MZ_GC_CHECK();
+	}
+	MZ_GC_UNREG();
     }
-
-    add_vim_exn(env);
-}
-
-/*
- * Add stuff of exn:vim to env
- */
-    static void
-add_vim_exn(Scheme_Env *env)
-{
-    int i;
-
-    for (i = 0; i < SCHEME_VEC_SIZE(vim_exn_values); i++)
-	scheme_add_global_symbol(SCHEME_VEC_ELS(vim_exn_names)[i],
-		SCHEME_VEC_ELS(vim_exn_values)[i], env);
+    MZ_GC_UNREG();
 }
 
 /*
@@ -2446,26 +2854,54 @@
     void
 raise_vim_exn(const char *add_info)
 {
-    Scheme_Object   *argv[2];
-    char_u	    *fmt = _("Vim error: ~a");
+    char	    *fmt = _("Vim error: ~a");
+    Scheme_Object   *argv[2] = {NULL, NULL};
+    Scheme_Object   *exn = NULL;
+
+    MZ_GC_DECL_REG(4);
+    MZ_GC_ARRAY_VAR_IN_REG(0, argv, 2);
+    MZ_GC_VAR_IN_REG(3, exn);
+    MZ_GC_REG();
 
     if (add_info != NULL)
     {
-	Scheme_Object   *info = scheme_make_string(add_info);
-	argv[0] = scheme_byte_string_to_char_string(scheme_make_string(
-		scheme_format(fmt, strlen(fmt), 1, &info, NULL)));
+	char		*c_string = NULL;
+	Scheme_Object	*byte_string = NULL;
+	Scheme_Object   *info = NULL;
+
+	MZ_GC_DECL_REG(3);
+	MZ_GC_VAR_IN_REG(0, c_string);
+	MZ_GC_VAR_IN_REG(1, byte_string);
+	MZ_GC_VAR_IN_REG(2, info);
+	MZ_GC_REG();
+
+	info = scheme_make_string(add_info);
+	MZ_GC_CHECK();
+	c_string = scheme_format(fmt, STRLEN(fmt), 1, &info, NULL);
+	MZ_GC_CHECK();
+	byte_string = scheme_make_string(c_string);
+	MZ_GC_CHECK();
+	argv[0] = scheme_byte_string_to_char_string(byte_string);
+	MZ_GC_CHECK();
 	SCHEME_SET_IMMUTABLE(argv[0]);
+	MZ_GC_UNREG();
     }
     else
 	argv[0] = scheme_make_string(_("Vim error"));
+    MZ_GC_CHECK();
 
 #if MZSCHEME_VERSION_MAJOR < 360
     argv[1] = scheme_current_continuation_marks();
+    MZ_GC_CHECK();
 #else
     argv[1] = scheme_current_continuation_marks(NULL);
+    MZ_GC_CHECK();
 #endif
 
-    scheme_raise(scheme_make_struct_instance(vim_exn, 2, argv));
+    exn = scheme_make_struct_instance(vim_exn, 2, argv);
+    MZ_GC_CHECK();
+    scheme_raise(exn);
+    MZ_GC_UNREG();
 }
 
     void
@@ -2572,6 +3008,8 @@
 	    curwin->w_cursor.lnum = lo;
 	    check_cursor();
 	}
+	else
+	    check_cursor_col();
 	changed_cline_bef_curs();
     }
     invalidate_botline();
@@ -2597,7 +3035,6 @@
     {mzscheme_open_buffer, "open-buff", 1, 1},
     {get_buffer_by_name, "get-buff-by-name", 1, 1},
     {get_buffer_by_num, "get-buff-by-num", 1, 1},
-    {get_buffer_namespace, "get-buff-namespace", 0, 1},
     /*
      * Window-related commands
      */
@@ -2655,23 +3092,35 @@
 }
 
     static void
-make_modules(Scheme_Env *env)
+make_modules()
 {
-    int		i;
-    Scheme_Env	*mod;
-
-    mod = scheme_primitive_module(scheme_intern_symbol("vimext"), env);
+    int		    i;
+    Scheme_Env	    *mod = NULL;
+    Scheme_Object   *vimext_symbol = NULL;
+    Scheme_Object   *closed_prim = NULL;
+
+    MZ_GC_DECL_REG(3);
+    MZ_GC_VAR_IN_REG(0, mod);
+    MZ_GC_VAR_IN_REG(1, vimext_symbol);
+    MZ_GC_VAR_IN_REG(2, closed_prim);
+    MZ_GC_REG();
+
+    vimext_symbol = scheme_intern_symbol("vimext");
+    MZ_GC_CHECK();
+    mod = scheme_primitive_module(vimext_symbol, environment);
+    MZ_GC_CHECK();
     /* all prims made closed so they can access their own names */
-    for (i = 0; i < sizeof(prims)/sizeof(prims[0]); i++)
+    for (i = 0; i < (int)(sizeof(prims)/sizeof(prims[0])); i++)
     {
 	Vim_Prim *prim = prims + i;
-	scheme_add_global(prim->name,
-		scheme_make_closed_prim_w_arity(prim->prim, prim, prim->name,
-		    prim->mina, prim->maxa),
-		mod);
+	closed_prim = scheme_make_closed_prim_w_arity(prim->prim, prim, prim->name,
+			    prim->mina, prim->maxa);
+	scheme_add_global(prim->name, closed_prim, mod);
+	MZ_GC_CHECK();
     }
-    scheme_add_global("global-namespace", (Scheme_Object *)environment, mod);
     scheme_finish_primitive_module(mod);
+    MZ_GC_CHECK();
+    MZ_GC_UNREG();
 }
 
 #ifdef HAVE_SANDBOX
@@ -2699,21 +3148,25 @@
 	{
 	    MZ_REGISTER_STATIC(M_write);
 	    M_write = scheme_intern_symbol("write");
+	    MZ_GC_CHECK();
 	}
 	if (M_read == NULL)
 	{
 	    MZ_REGISTER_STATIC(M_read);
 	    M_read = scheme_intern_symbol("read");
+	    MZ_GC_CHECK();
 	}
 	if (M_execute == NULL)
 	{
 	    MZ_REGISTER_STATIC(M_execute);
 	    M_execute = scheme_intern_symbol("execute");
+	    MZ_GC_CHECK();
 	}
 	if (M_delete == NULL)
 	{
 	    MZ_REGISTER_STATIC(M_delete);
 	    M_delete = scheme_intern_symbol("delete");
+	    MZ_GC_CHECK();
 	}
 
 	while (!SCHEME_NULLP(requested_access))
diff -Naur vim72.orig/src/if_mzsch.h vim72/src/if_mzsch.h
--- vim72.orig/src/if_mzsch.h	2006-03-24 16:09:53.000000000 +0000
+++ vim72/src/if_mzsch.h	2009-07-22 22:54:22.000000000 +0100
@@ -11,6 +11,7 @@
 
 /* #ifdef needed for "make depend" */
 #ifdef FEAT_MZSCHEME
+# include <schvers.h>
 # include <scheme.h>
 #endif
 
@@ -46,4 +47,31 @@
 # define scheme_byte_string_to_char_string(obj) (obj)
 #endif
 
+/* Precise GC macros */
+#ifndef MZ_GC_DECL_REG
+# define MZ_GC_DECL_REG(size)            /* empty */
+#endif
+#ifndef MZ_GC_VAR_IN_REG
+# define MZ_GC_VAR_IN_REG(x, v)          /* empty */
+#endif
+#ifndef MZ_GC_ARRAY_VAR_IN_REG
+# define MZ_GC_ARRAY_VAR_IN_REG(x, v, l) /* empty */
+#endif
+#ifndef MZ_GC_REG
+# define MZ_GC_REG()                     /* empty */
+#endif
+#ifndef MZ_GC_UNREG
+# define MZ_GC_UNREG()                   /* empty */
+#endif
+
+#ifdef MZSCHEME_FORCE_GC
+/*
+ * force garbage collection to check all references are registered
+ * seg faults will indicate not registered refs
+ */
+# define MZ_GC_CHECK() scheme_collect_garbage();
+#else
+# define MZ_GC_CHECK()			/* empty */
+#endif
+
 #endif /* _IF_MZSCH_H_ */
diff -Naur vim72.orig/src/if_perl.xs vim72/src/if_perl.xs
--- vim72.orig/src/if_perl.xs	2008-07-17 21:55:09.000000000 +0100
+++ vim72/src/if_perl.xs	2009-07-22 22:54:23.000000000 +0100
@@ -136,6 +136,9 @@
 #  define Perl_newXS_flags dll_Perl_newXS_flags
 #endif
 # define Perl_sv_free dll_Perl_sv_free
+# if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
+#  define Perl_sv_free2 dll_Perl_sv_free2
+# endif
 # define Perl_sv_isa dll_Perl_sv_isa
 # define Perl_sv_magic dll_Perl_sv_magic
 # define Perl_sv_setiv dll_Perl_sv_setiv
@@ -163,7 +166,7 @@
 # define Perl_Isv_yes_ptr dll_Perl_Isv_yes_ptr
 # define boot_DynaLoader dll_boot_DynaLoader
 
-# define Perl_sys_init3 dll_Perl_sys_init3
+# define Perl_sys_init dll_Perl_sys_init
 # define Perl_sys_term dll_Perl_sys_term
 # define Perl_ISv_ptr dll_Perl_ISv_ptr
 # define Perl_Istack_max_ptr dll_Perl_Istack_max_ptr
@@ -268,7 +271,8 @@
 static void (*boot_DynaLoader)_((pTHX_ CV*));
 
 #if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
-static void (*Perl_sys_init3)(int* argc, char*** argv, char*** env);
+static void (*Perl_sv_free2)(pTHX_ SV*);
+static void (*Perl_sys_init)(int* argc, char*** argv);
 static void (*Perl_sys_term)(void);
 static SV** (*Perl_ISv_ptr)(register PerlInterpreter*);
 static SV*** (*Perl_Istack_max_ptr)(register PerlInterpreter*);
@@ -367,7 +371,8 @@
     {"Perl_TXpv_ptr", (PERL_PROC*)&Perl_TXpv_ptr},
     {"Perl_Tna_ptr", (PERL_PROC*)&Perl_Tna_ptr},
 #else
-    {"Perl_sys_init3", (PERL_PROC*)&Perl_sys_init3},
+    {"Perl_sv_free2", (PERL_PROC*)&Perl_sv_free2},
+    {"Perl_sys_init", (PERL_PROC*)&Perl_sys_init},
     {"Perl_sys_term", (PERL_PROC*)&Perl_sys_term},
     {"Perl_ISv_ptr", (PERL_PROC*)&Perl_ISv_ptr},
     {"Perl_Istack_sp_ptr", (PERL_PROC*)&Perl_Istack_sp_ptr},
@@ -455,7 +460,7 @@
     static char *argv[] = { "", "-e", "" };
 
 #if (PERL_REVISION == 5) && (PERL_VERSION >= 10)
-    Perl_sys_init3(&argc, (char***)&argv, NULL);
+    Perl_sys_init(&argc, (char***)&argv);
 #endif
     perl_interp = perl_alloc();
     perl_construct(perl_interp);
@@ -715,9 +720,11 @@
 #ifdef HAVE_SANDBOX
     if (sandbox)
     {
+# ifndef MAKE_TEST  /* avoid a warning for unreachable code */
 	if ((safe = perl_get_sv( "VIM::safe", FALSE )) == NULL || !SvTRUE(safe))
 	    EMSG(_("E299: Perl evaluation forbidden in sandbox without the Safe module"));
 	else
+# endif
 	{
 	    PUSHMARK(SP);
 	    XPUSHs(safe);
@@ -1228,9 +1235,8 @@
 		    if (u_savedel(lnum, 1) == OK)
 		    {
 			ml_delete(lnum, 0);
+			check_cursor();
 			deleted_lines_mark(lnum, 1L);
-			if (aco.save_buf == curbuf)
-			    check_cursor();
 		    }
 
 		    /* restore curwin/curbuf and a few other things */
diff -Naur vim72.orig/src/if_python.c vim72/src/if_python.c
--- vim72.orig/src/if_python.c	2008-07-17 22:09:32.000000000 +0100
+++ vim72/src/if_python.c	2009-07-22 22:54:23.000000000 +0100
@@ -531,6 +531,12 @@
 	if (PythonMod_Init())
 	    goto fail;
 
+	/* Remove the element from sys.path that was added because of our
+	 * argv[0] value in PythonMod_Init().  Previously we used an empty
+	 * string, but dependinding on the OS we then get an empty entry or
+	 * the current directory in sys.path. */
+	PyRun_SimpleString("import sys; sys.path = filter(lambda x: x != '/must>not&exist', sys.path)");
+
 	/* the first python thread is vim's, release the lock */
 	Python_SaveThread();
 
@@ -1090,9 +1096,8 @@
 
 /* Vim module - Implementation
  */
-/*ARGSUSED*/
     static PyObject *
-VimCommand(PyObject *self, PyObject *args)
+VimCommand(PyObject *self UNUSED, PyObject *args)
 {
     char *cmd;
     PyObject *result;
@@ -1145,14 +1150,23 @@
 
     /* Check if we run into a recursive loop.  The item must be in lookupDict
      * then and we can use it again. */
-    sprintf(ptrBuf, PRINTF_DECIMAL_LONG_U, (long_u)our_tv);
-    result = PyDict_GetItemString(lookupDict, ptrBuf);
-    if (result != NULL)
-	Py_INCREF(result);
-    else if (our_tv->v_type == VAR_STRING)
+    if ((our_tv->v_type == VAR_LIST && our_tv->vval.v_list != NULL)
+	    || (our_tv->v_type == VAR_DICT && our_tv->vval.v_dict != NULL))
+    {
+	sprintf(ptrBuf, PRINTF_DECIMAL_LONG_U,
+	        our_tv->v_type == VAR_LIST ? (long_u)our_tv->vval.v_list
+		                           : (long_u)our_tv->vval.v_dict);
+	result = PyDict_GetItemString(lookupDict, ptrBuf);
+	if (result != NULL)
+	{
+	    Py_INCREF(result);
+	    return result;
+	}
+    }
+
+    if (our_tv->v_type == VAR_STRING)
     {
 	result = Py_BuildValue("s", our_tv->vval.v_string);
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
     }
     else if (our_tv->v_type == VAR_NUMBER)
     {
@@ -1161,7 +1175,6 @@
 	/* For backwards compatibility numbers are stored as strings. */
 	sprintf(buf, "%ld", (long)our_tv->vval.v_number);
 	result = Py_BuildValue("s", buf);
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
     }
 # ifdef FEAT_FLOAT
     else if (our_tv->v_type == VAR_FLOAT)
@@ -1170,7 +1183,6 @@
 
 	sprintf(buf, "%f", our_tv->vval.v_float);
 	result = Py_BuildValue("s", buf);
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
     }
 # endif
     else if (our_tv->v_type == VAR_LIST)
@@ -1179,10 +1191,11 @@
 	listitem_T	*curr;
 
 	result = PyList_New(0);
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
 
 	if (list != NULL)
 	{
+	    PyDict_SetItemString(lookupDict, ptrBuf, result);
+
 	    for (curr = list->lv_first; curr != NULL; curr = curr->li_next)
 	    {
 		newObj = VimToPython(&curr->li_tv, depth + 1, lookupDict);
@@ -1194,7 +1207,6 @@
     else if (our_tv->v_type == VAR_DICT)
     {
 	result = PyDict_New();
-	PyDict_SetItemString(lookupDict, ptrBuf, result);
 
 	if (our_tv->vval.v_dict != NULL)
 	{
@@ -1203,6 +1215,8 @@
 	    hashitem_T	*hi;
 	    dictitem_T	*di;
 
+	    PyDict_SetItemString(lookupDict, ptrBuf, result);
+
 	    for (hi = ht->ht_array; todo > 0; ++hi)
 	    {
 		if (!HASHITEM_EMPTY(hi))
@@ -1227,9 +1241,8 @@
 }
 #endif
 
-/*ARGSUSED*/
     static PyObject *
-VimEval(PyObject *self, PyObject *args)
+VimEval(PyObject *self UNUSED, PyObject *args)
 {
 #ifdef FEAT_EVAL
     char	*expr;
@@ -1879,9 +1892,8 @@
 /* Buffer list object - Implementation
  */
 
-/*ARGSUSED*/
     static PyInt
-BufListLength(PyObject *self)
+BufListLength(PyObject *self UNUSED)
 {
     buf_T	*b = firstbuf;
     PyInt	n = 0;
@@ -1895,9 +1907,8 @@
     return n;
 }
 
-/*ARGSUSED*/
     static PyObject *
-BufListItem(PyObject *self, PyInt n)
+BufListItem(PyObject *self UNUSED, PyInt n)
 {
     buf_T *b;
 
@@ -2195,9 +2206,8 @@
 
 /* Window list object - Implementation
  */
-/*ARGSUSED*/
     static PyInt
-WinListLength(PyObject *self)
+WinListLength(PyObject *self UNUSED)
 {
     win_T	*w = firstwin;
     PyInt	n = 0;
@@ -2211,9 +2221,8 @@
     return n;
 }
 
-/*ARGSUSED*/
     static PyObject *
-WinListItem(PyObject *self, PyInt n)
+WinListItem(PyObject *self UNUSED, PyInt n)
 {
     win_T *w;
 
@@ -2259,9 +2268,8 @@
 
 /* Current items object - Implementation
  */
-/*ARGSUSED*/
     static PyObject *
-CurrentGetattr(PyObject *self, char *name)
+CurrentGetattr(PyObject *self UNUSED, char *name)
 {
     if (strcmp(name, "buffer") == 0)
 	return (PyObject *)BufferNew(curbuf);
@@ -2280,9 +2288,8 @@
     }
 }
 
-/*ARGSUSED*/
     static int
-CurrentSetattr(PyObject *self, char *name, PyObject *value)
+CurrentSetattr(PyObject *self UNUSED, char *name, PyObject *value)
 {
     if (strcmp(name, "line") == 0)
     {
@@ -2345,7 +2352,8 @@
 {
     PyObject *mod;
     PyObject *dict;
-    static char *(argv[2]) = {"", NULL};
+    /* The special value is removed from sys.path in Python_Init(). */
+    static char *(argv[2]) = {"/must>not&exist/foo", NULL};
 
     /* Fixups... */
     BufferType.ob_type = &PyType_Type;
@@ -2489,9 +2497,9 @@
 	    PyErr_SetVim(_("cannot delete line"));
 	else
 	{
-	    deleted_lines_mark((linenr_T)n, 1L);
 	    if (buf == curwin->w_buffer)
 		py_fix_cursor((linenr_T)n, (linenr_T)n + 1, (linenr_T)-1);
+	    deleted_lines_mark((linenr_T)n, 1L);
 	}
 
 	curbuf = savebuf;
@@ -2588,10 +2596,9 @@
 		    break;
 		}
 	    }
-	    deleted_lines_mark((linenr_T)lo, (long)i);
-
 	    if (buf == curwin->w_buffer)
 		py_fix_cursor((linenr_T)lo, (linenr_T)hi, (linenr_T)-n);
+	    deleted_lines_mark((linenr_T)lo, (long)i);
 	}
 
 	curbuf = savebuf;
diff -Naur vim72.orig/src/if_ruby.c vim72/src/if_ruby.c
--- vim72.orig/src/if_ruby.c	2007-09-10 09:40:38.000000000 +0100
+++ vim72/src/if_ruby.c	2009-07-22 22:54:22.000000000 +0100
@@ -492,7 +492,7 @@
     }
 }
 
-static VALUE vim_message(VALUE self, VALUE str)
+static VALUE vim_message(VALUE self UNUSED, VALUE str)
 {
     char *buff, *p;
 
@@ -505,20 +505,20 @@
     return Qnil;
 }
 
-static VALUE vim_set_option(VALUE self, VALUE str)
+static VALUE vim_set_option(VALUE self UNUSED, VALUE str)
 {
     do_set((char_u *)STR2CSTR(str), 0);
     update_screen(NOT_VALID);
     return Qnil;
 }
 
-static VALUE vim_command(VALUE self, VALUE str)
+static VALUE vim_command(VALUE self UNUSED, VALUE str)
 {
     do_cmdline_cmd((char_u *)STR2CSTR(str));
     return Qnil;
 }
 
-static VALUE vim_evaluate(VALUE self, VALUE str)
+static VALUE vim_evaluate(VALUE self UNUSED, VALUE str)
 {
 #ifdef FEAT_EVAL
     char_u *value = eval_to_string((char_u *)STR2CSTR(str), NULL, TRUE);
@@ -580,7 +580,7 @@
     return INT2NUM(n);
 }
 
-static VALUE buffer_s_aref(VALUE self, VALUE num)
+static VALUE buffer_s_aref(VALUE self UNUSED, VALUE num)
 {
     buf_T *b;
     int n = NUM2INT(num);
@@ -629,7 +629,9 @@
 	return line ? rb_str_new2(line) : Qnil;
     }
     rb_raise(rb_eIndexError, "index %d out of buffer", n);
+#ifndef __GNUC__
     return Qnil; /* For stop warning */
+#endif
 }
 
 static VALUE buffer_aref(VALUE self, VALUE num)
@@ -668,7 +670,9 @@
     else
     {
 	rb_raise(rb_eIndexError, "index %d out of buffer", n);
+#ifndef __GNUC__
 	return Qnil; /* For stop warning */
+#endif
     }
     return str;
 }
@@ -789,7 +793,7 @@
     return get_buffer_line(curbuf, curwin->w_cursor.lnum);
 }
 
-static VALUE set_current_line(VALUE self, VALUE str)
+static VALUE set_current_line(VALUE self UNUSED, VALUE str)
 {
     return set_buffer_line(curbuf, curwin->w_cursor.lnum, str);
 }
@@ -815,7 +819,7 @@
 #endif
 }
 
-static VALUE window_s_aref(VALUE self, VALUE num)
+static VALUE window_s_aref(VALUE self UNUSED, VALUE num)
 {
     win_T *w;
     int n = NUM2INT(num);
@@ -897,7 +901,7 @@
     return Qnil;
 }
 
-static VALUE f_p(int argc, VALUE *argv, VALUE self)
+static VALUE f_p(int argc, VALUE *argv, VALUE self UNUSED)
 {
     int i;
     VALUE str = rb_str_new("", 0);
diff -Naur vim72.orig/src/if_tcl.c vim72/src/if_tcl.c
--- vim72.orig/src/if_tcl.c	2007-05-07 20:50:14.000000000 +0100
+++ vim72/src/if_tcl.c	2009-07-22 22:54:22.000000000 +0100
@@ -161,7 +161,7 @@
 # endif
 
 /*
- * Declare HANDLE for perl.dll and function pointers.
+ * Declare HANDLE for tcl.dll and function pointers.
  */
 static HANDLE hTclLib = NULL;
 Tcl_Interp* (*dll_Tcl_CreateInterp)();
@@ -182,7 +182,7 @@
  * Make all runtime-links of tcl.
  *
  * 1. Get module handle using LoadLibraryEx.
- * 2. Get pointer to perl function by GetProcAddress.
+ * 2. Get pointer to tcl function by GetProcAddress.
  * 3. Repeat 2, until get all functions will be used.
  *
  * Parameter 'libname' provides name of DLL.
@@ -290,10 +290,9 @@
  */
 #define TCL_EXIT	5
 
-/* ARGSUSED */
     static int
 exitcmd(dummy, interp, objc, objv)
-    ClientData dummy;
+    ClientData dummy UNUSED;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
@@ -315,10 +314,9 @@
     return TCL_ERROR;
 }
 
-/* ARGSUSED */
     static int
 catchcmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
@@ -356,10 +354,9 @@
 /*
  *  "::vim::beep" - what Vi[m] does best :-)
  */
-/* ARGSUSED */
     static int
 beepcmd(dummy, interp, objc, objv)
-    ClientData dummy;
+    ClientData dummy UNUSED;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
@@ -378,10 +375,9 @@
  *  "::vim::buffer {N}" - create buffer command for buffer N.
  *  "::vim::buffer new" - create a new buffer (not implemented)
  */
-/* ARGSUSED */
     static int
 buffercmd(dummy, interp, objc, objv)
-    ClientData dummy;
+    ClientData dummy UNUSED;
     Tcl_Interp *interp;
     int objc;
     Tcl_Obj *CONST objv[];
@@ -475,10 +471,9 @@
 /*
  * "::vim::window list" - create list of window commands.
  */
-/* ARGSUSED */
     static int
 windowcmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
@@ -1130,10 +1125,9 @@
 }
 
 
-/* ARGSUSED */
     static int
 commandcmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
@@ -1145,10 +1139,9 @@
     return err;
 }
 
-/* ARGSUSED */
     static int
 optioncmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
@@ -1160,10 +1153,9 @@
     return err;
 }
 
-/* ARGSUSED */
     static int
 exprcmd(dummy, interp, objc, objv)
-    ClientData	dummy;
+    ClientData	dummy UNUSED;
     Tcl_Interp	*interp;
     int		objc;
     Tcl_Obj	*CONST objv[];
@@ -1584,11 +1576,10 @@
     I/O Channel
 ********************************************/
 
-/* ARGSUSED */
     static int
 channel_close(instance, interp)
     ClientData	instance;
-    Tcl_Interp	*interp;
+    Tcl_Interp	*interp UNUSED;
 {
     int		err = 0;
 
@@ -1602,12 +1593,11 @@
     return err;
 }
 
-/* ARGSUSED */
     static int
 channel_input(instance, buf, bufsiz, errptr)
-    ClientData	instance;
-    char	*buf;
-    int		bufsiz;
+    ClientData	instance UNUSED;
+    char	*buf UNUSED;
+    int		bufsiz UNUSED;
     int		*errptr;
 {
 
@@ -1659,21 +1649,19 @@
     return result;
 }
 
-/* ARGSUSED */
     static void
 channel_watch(instance, mask)
-    ClientData	instance;
-    int		mask;
+    ClientData	instance UNUSED;
+    int		mask UNUSED;
 {
     Tcl_SetErrno(EINVAL);
 }
 
-/* ARGSUSED */
     static int
 channel_gethandle(instance, direction, handleptr)
-    ClientData	instance;
-    int		direction;
-    ClientData	*handleptr;
+    ClientData	instance UNUSED;
+    int		direction UNUSED;
+    ClientData	*handleptr UNUSED;
 {
     Tcl_SetErrno(EINVAL);
     return EINVAL;
@@ -1682,16 +1670,31 @@
 
 static Tcl_ChannelType channel_type =
 {
-    "vimmessage",
-    NULL,   /* blockmode */
-    channel_close,
-    channel_input,
-    channel_output,
-    NULL,   /* seek */
-    NULL,   /* set option */
-    NULL,   /* get option */
-    channel_watch,
-    channel_gethandle
+    "vimmessage",	/* typeName */
+    NULL,		/* version */
+    channel_close,	/* closeProc */
+    channel_input,	/* inputProc */
+    channel_output,	/* outputProc */
+    NULL,		/* seekProc */
+    NULL,		/* setOptionProc */
+    NULL,		/* getOptionProc */
+    channel_watch,	/* watchProc */
+    channel_gethandle,	/* getHandleProc */
+    NULL,		/* close2Proc */
+    NULL,		/* blockModeProc */
+#ifdef TCL_CHANNEL_VERSION_2
+    NULL,		/* flushProc */
+    NULL,		/* handlerProc */
+#endif
+#ifdef TCL_CHANNEL_VERSION_3
+    NULL,		/* wideSeekProc */
+#endif
+#ifdef TCL_CHANNEL_VERSION_4
+    NULL,		/* threadActionProc */
+#endif
+#ifdef TCL_CHANNEL_VERSION_5
+    NULL		/* truncateProc */
+#endif
 };
 
 /**********************************
diff -Naur vim72.orig/src/if_xcmdsrv.c vim72/src/if_xcmdsrv.c
--- vim72.orig/src/if_xcmdsrv.c	2008-07-18 14:05:03.000000000 +0100
+++ vim72/src/if_xcmdsrv.c	2009-07-22 22:54:22.000000000 +0100
@@ -682,7 +682,7 @@
      * Scan all of the names out of the property.
      */
     ga_init2(&ga, 1, 100);
-    for (p = regProp; (p - regProp) < numItems; p++)
+    for (p = regProp; (long_u)(p - regProp) < numItems; p++)
     {
 	entry = p;
 	while (*p != 0 && !isspace(*p))
@@ -736,7 +736,7 @@
 		+ serverReply.ga_len;
 	    e.id = w;
 	    ga_init2(&e.strings, 1, 100);
-	    memcpy(p, &e, sizeof(e));
+	    mch_memmove(p, &e, sizeof(e));
 	    serverReply.ga_len++;
 	}
     }
@@ -969,7 +969,7 @@
      */
     returnValue = (int_u)None;
     entry = NULL;	/* Not needed, but eliminates compiler warning. */
-    for (p = regProp; (p - regProp) < numItems; )
+    for (p = regProp; (long_u)(p - regProp) < numItems; )
     {
 	entry = p;
 	while (*p != 0 && !isspace(*p))
@@ -986,7 +986,7 @@
 
     if (loose != NULL && returnValue == (int_u)None && !IsSerialName(name))
     {
-	for (p = regProp; (p - regProp) < numItems; )
+	for (p = regProp; (long_u)(p - regProp) < numItems; )
 	{
 	    entry = p;
 	    while (*p != 0 && !isspace(*p))
@@ -1018,7 +1018,7 @@
 	p++;
 	count = numItems - (p - regProp);
 	if (count > 0)
-	    memcpy(entry, p, count);
+	    mch_memmove(entry, p, count);
 	XChangeProperty(dpy, RootWindow(dpy, 0), registryProperty, XA_STRING,
 			8, PropModeReplace, regProp,
 			(int)(numItems - (p - entry)));
@@ -1056,7 +1056,7 @@
 	return;
 
     /* Scan the property for the window id.  */
-    for (p = regProp; (p - regProp) < numItems; )
+    for (p = regProp; (long_u)(p - regProp) < numItems; )
     {
 	if (*p != 0)
 	{
@@ -1072,7 +1072,7 @@
 		p++;
 		lastHalf = numItems - (p - regProp);
 		if (lastHalf > 0)
-		    memcpy(entry, p, lastHalf);
+		    mch_memmove(entry, p, lastHalf);
 		numItems = (entry - regProp) + lastHalf;
 		p = entry;
 		continue;
@@ -1196,7 +1196,7 @@
      * one time;  each iteration through the outer loop handles a
      * single command or result.
      */
-    for (p = propInfo; (p - propInfo) < numItems; )
+    for (p = propInfo; (long_u)(p - propInfo) < numItems; )
     {
 	/*
 	 * Ignore leading NULs; each command or result starts with a
@@ -1230,7 +1230,7 @@
 	    serial = (char_u *)"";
 	    script = NULL;
 	    enc = NULL;
-	    while (p - propInfo < numItems && *p == '-')
+	    while ((long_u)(p - propInfo) < numItems && *p == '-')
 	    {
 		switch (p[1])
 		{
@@ -1333,7 +1333,7 @@
 	    res = (char_u *)"";
 	    code = 0;
 	    enc = NULL;
-	    while ((p-propInfo) < numItems && *p == '-')
+	    while ((long_u)(p - propInfo) < numItems && *p == '-')
 	    {
 		switch (p[1])
 		{
@@ -1401,7 +1401,7 @@
 	    gotWindow = 0;
 	    str = (char_u *)"";
 	    enc = NULL;
-	    while ((p-propInfo) < numItems && *p == '-')
+	    while ((long_u)(p - propInfo) < numItems && *p == '-')
 	    {
 		switch (p[1])
 		{
@@ -1489,11 +1489,10 @@
 /*
  * Another X Error handler, just used to check for errors.
  */
-/* ARGSUSED */
     static int
 x_error_check(dpy, error_event)
-    Display	*dpy;
-    XErrorEvent	*error_event;
+    Display	*dpy UNUSED;
+    XErrorEvent	*error_event UNUSED;
 {
     got_x_error = TRUE;
     return 0;
diff -Naur vim72.orig/src/macros.h vim72/src/macros.h
--- vim72.orig/src/macros.h	2007-08-04 12:44:18.000000000 +0100
+++ vim72/src/macros.h	2009-07-22 22:54:22.000000000 +0100
@@ -127,15 +127,31 @@
 #ifdef FEAT_LANGMAP
 /*
  * Adjust chars in a language according to 'langmap' option.
- * NOTE that there is NO overhead if 'langmap' is not set; but even
- * when set we only have to do 2 ifs and an array lookup.
+ * NOTE that there is no noticeable overhead if 'langmap' is not set.
+ * When set the overhead for characters < 256 is small.
  * Don't apply 'langmap' if the character comes from the Stuff buffer.
  * The do-while is just to ignore a ';' after the macro.
  */
-# define LANGMAP_ADJUST(c, condition) do { \
-	if (*p_langmap && (condition) && !KeyStuffed && (c) >= 0 && (c) < 256) \
-	    c = langmap_mapchar[c]; \
+# ifdef FEAT_MBYTE
+#  define LANGMAP_ADJUST(c, condition) \
+    do { \
+        if (*p_langmap && (condition) && !KeyStuffed && (c) >= 0) \
+	{ \
+	    if ((c) < 256) \
+		c = langmap_mapchar[c]; \
+	    else \
+		c = langmap_adjust_mb(c); \
+	} \
     } while (0)
+# else
+#  define LANGMAP_ADJUST(c, condition) \
+    do { \
+        if (*p_langmap && (condition) && !KeyStuffed && (c) >= 0 && (c) < 256) \
+            c = langmap_mapchar[c]; \
+    } while (0)
+# endif
+#else
+# define LANGMAP_ADJUST(c, condition) /* nop */
 #endif
 
 /*
@@ -268,7 +284,7 @@
 # define mb_cptr2len(p)	    (enc_utf8 ? utf_ptr2len(p) : (*mb_ptr2len)(p))
 
 # define MB_COPY_CHAR(f, t) if (has_mbyte) mb_copy_char(&f, &t); else *t++ = *f++
-# define MB_CHARLEN(p)	    (has_mbyte ? mb_charlen(p) : STRLEN(p))
+# define MB_CHARLEN(p)	    (has_mbyte ? mb_charlen(p) : (int)STRLEN(p))
 # define PTR2CHAR(p)	    (has_mbyte ? mb_ptr2char(p) : (int)*(p))
 #else
 # define mb_ptr_adv(p)		++p
diff -Naur vim72.orig/src/main.c vim72/src/main.c
--- vim72.orig/src/main.c	2008-07-24 09:40:56.000000000 +0100
+++ vim72/src/main.c	2009-07-22 22:54:22.000000000 +0100
@@ -645,11 +645,12 @@
 
 #ifdef FEAT_VIMINFO
     /*
-     * Read in registers, history etc, but not marks, from the viminfo file
+     * Read in registers, history etc, but not marks, from the viminfo file.
+     * This is where v:oldfiles gets filled.
      */
     if (*p_viminfo != NUL)
     {
-	read_viminfo(NULL, TRUE, FALSE, FALSE);
+	read_viminfo(NULL, VIF_WANT_INFO | VIF_GET_OLDFILES);
 	TIME_MSG("reading viminfo");
     }
 #endif
@@ -934,8 +935,14 @@
 
     /*
      * Call the main command loop.  This never returns.
+     * For embedded MzScheme the main_loop will be called by Scheme
+     * for proper stack tracking
      */
+#ifndef FEAT_MZSCHEME
     main_loop(FALSE, FALSE);
+#else
+    mzscheme_main();
+#endif
 
     return 0;
 }
@@ -1457,7 +1464,8 @@
 	++initstr;
     }
 
-    if (TOLOWER_ASC(initstr[0]) == 'g' || initstr[0] == 'k')
+    /* "gvim" starts the GUI.  Also accept "Gvim" for MS-Windows. */
+    if (TOLOWER_ASC(initstr[0]) == 'g')
     {
 	main_start_gui();
 #ifdef FEAT_GUI
@@ -1503,12 +1511,12 @@
  *
  * Also find the --server... arguments and --socketid and --windowid
  */
-/*ARGSUSED*/
     static void
 early_arg_scan(parmp)
-    mparm_T	*parmp;
+    mparm_T	*parmp UNUSED;
 {
-#if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER)
+#if defined(FEAT_XCLIPBOARD) || defined(FEAT_CLIENTSERVER) \
+	|| !defined(FEAT_NETBEANS_INTG)
     int		argc = parmp->argc;
     char	**argv = parmp->argv;
     int		i;
@@ -1580,6 +1588,14 @@
 	else if (STRICMP(argv[i], "--echo-wid") == 0)
 	    echo_wid_arg = TRUE;
 # endif
+# ifndef FEAT_NETBEANS_INTG
+	else if (strncmp(argv[i], "-nb", (size_t)3) == 0)
+        {
+            mch_errmsg(_("'-nb' cannot be used: not enabled at compile time\n"));
+            mch_exit(2);
+        }
+# endif
+
     }
 #endif
 }
@@ -2361,7 +2377,7 @@
      * Is there any other system that cannot do this?
      */
     close(0);
-    dup(2);
+    ignored = dup(2);
 #endif
 }
 
@@ -2369,10 +2385,9 @@
  * Create the requested number of windows and edit buffers in them.
  * Also does recovery if "recoverymode" set.
  */
-/*ARGSUSED*/
     static void
 create_windows(parmp)
-    mparm_T	*parmp;
+    mparm_T	*parmp UNUSED;
 {
 #ifdef FEAT_WINDOWS
     int		dorewind;
@@ -2586,7 +2601,7 @@
 # endif
 	    (void)do_ecmd(0, arg_idx < GARGCOUNT
 			  ? alist_name(&GARGLIST[arg_idx]) : NULL,
-			  NULL, NULL, ECMD_LASTL, ECMD_HIDE);
+			  NULL, NULL, ECMD_LASTL, ECMD_HIDE, curwin);
 # ifdef HAS_SWAP_EXISTS_ACTION
 	    if (swap_exists_did_quit)
 	    {
@@ -3840,10 +3855,9 @@
  * return an allocated string.  Otherwise return "data".
  * "*tofree" is set to the result when it needs to be freed later.
  */
-/*ARGSUSED*/
     char_u *
 serverConvert(client_enc, data, tofree)
-    char_u *client_enc;
+    char_u *client_enc UNUSED;
     char_u *data;
     char_u **tofree;
 {
diff -Naur vim72.orig/src/Makefile vim72/src/Makefile
--- vim72.orig/src/Makefile	2008-08-09 15:50:04.000000000 +0100
+++ vim72/src/Makefile	2009-07-22 22:54:22.000000000 +0100
@@ -105,8 +105,8 @@
 # 4. "make test"  {{{1
 #	This is optional.  This will run Vim scripts on a number of test
 #	files, and compare the produced output with the expected output.
-#	If all is well, you will get the "ALL DONE" message in the end.  See
-#	below (search for "/^test").
+#	If all is well, you will get the "ALL DONE" message in the end.  If a
+#	test fails you get "TEST FAILURE".  See below (search for "/^test").
 #
 # 5. "make install"  {{{1
 #	If the new Vim seems to be working OK you can install it and the
@@ -533,6 +533,11 @@
 #CFLAGS = -g -DDEBUG -Wall -Wshadow -Wmissing-prototypes
 #CFLAGS = -g -O2 '-DSTARTUPTIME="vimstartup"' -fno-strength-reduce -Wall -Wmissing-prototypes
 
+# Use this with GCC to check for mistakes, unused arguments, etc.
+#CFLAGS = -g -Wall -Wextra -Wmissing-prototypes -Wunreachable-code
+#PYTHON_CFLAGS_EXTRA = -Wno-missing-field-initializers
+#MZSCHEME_CFLAGS_EXTRA = -Wno-unreachable-code -Wno-unused-parameter
+
 # EFENCE - Electric-Fence malloc debugging: catches memory accesses beyond
 # allocated memory (and makes every malloc()/free() very slow).
 # Electric Fence is free (search ftp sites).
@@ -551,7 +556,13 @@
 # }}}
 
 # LINT - for running lint
+#  For standard Unix lint
+LINT = lint
 LINT_OPTIONS = -beprxzF
+#  For splint
+#  It doesn't work well, crashes on include files and non-ascii characters.
+#LINT = splint
+#LINT_OPTIONS = +unixlib -weak -macrovarprefixexclude -showfunc -linelen 9999
 
 # PROFILING - Uncomment the next two lines to do profiling with gcc and gprof.
 # Might not work with GUI or Perl.
@@ -1259,16 +1270,16 @@
 #     This is for cproto 3 patchlevel 8 or below
 #     __inline, __attribute__ and __extension__ are not recognized by cproto
 #     G_IMPLEMENT_INLINES is to avoid functions defined in glib/gutils.h.
-NO_ATTR = -D__inline= -D__inline__= -DG_IMPLEMENT_INLINES \
-	  -D"__attribute__\\(x\\)=" -D"__asm__\\(x\\)=" \
-	  -D__extension__= -D__restrict="" \
-	  -D__gnuc_va_list=char -D__builtin_va_list=char
+#NO_ATTR = -D__inline= -D__inline__= -DG_IMPLEMENT_INLINES \
+#	  -D"__attribute__\\(x\\)=" -D"__asm__\\(x\\)=" \
+#	  -D__extension__= -D__restrict="" \
+#	  -D__gnuc_va_list=char -D__builtin_va_list=char
 
 #
-#     This is for cproto 3 patchlevel 9 or above (currently 4.6)
+#     This is for cproto 3 patchlevel 9 or above (currently 4.6, 4.7g)
 #     __inline and __attribute__ are now recognized by cproto
 #     -D"foo()=" is not supported by all compilers so do not use it
-# NO_ATTR=
+NO_ATTR=
 #
 #     maybe the "/usr/bin/cc -E" has to be adjusted for some systems
 # This is for cproto 3.5 patchlevel 3:
@@ -1432,6 +1443,7 @@
 	$(SNIFF_SRC) $(WORKSHOP_SRC) $(WSDEBUG_SRC) $(NETBEANS_SRC)
 #LINT_SRC = $(SRC)
 #LINT_SRC = $(ALL_SRC)
+#LINT_SRC = $(BASIC_SRC)
 
 OBJ = \
 	objects/buffer.o \
@@ -1737,7 +1749,8 @@
 # messages.  Don't worry about that.
 # If there is a real error, there will be a difference between "test.out" and
 # a "test99.ok" file.
-# If everything is alright, the final message will be "ALL DONE".
+# If everything is alright, the final message will be "ALL DONE".  If not you
+# get "TEST FAILURE".
 #
 test check:
 	$(MAKE) -f Makefile $(VIMTARGET)
@@ -2187,6 +2200,7 @@
 	-rm -f $(TOOLS) auto/osdef.h auto/pathdef.c auto/if_perl.c
 	-rm -f conftest* *~ auto/link.sed
 	-rm -rf $(APPDIR)
+	-rm -rf mzscheme_base.c
 	if test -d $(PODIR); then \
 		cd $(PODIR); $(MAKE) prefix=$(DESTDIR)$(prefix) clean; \
 	fi
@@ -2272,12 +2286,12 @@
 
 # Run lint.  Clean up the *.ln files that are sometimes left behind.
 lint:
-	lint $(LINT_OPTIONS) $(LINT_CFLAGS) $(LINT_EXTRA) $(LINT_SRC)
+	$(LINT) $(LINT_OPTIONS) $(LINT_CFLAGS) $(LINT_EXTRA) $(LINT_SRC)
 	-rm -f *.ln
 
 # Check dosinst.c with lint.
 lintinstall:
-	lint $(LINT_OPTIONS) -DWIN32 -DUNIX_LINT dosinst.c
+	$(LINT) $(LINT_OPTIONS) -DWIN32 -DUNIX_LINT dosinst.c
 	-rm -f dosinst.ln
 
 ###########################################################################
@@ -2420,8 +2434,11 @@
 objects/if_xcmdsrv.o: if_xcmdsrv.c
 	$(CCC) -o $@ if_xcmdsrv.c
 
-objects/if_mzsch.o: if_mzsch.c
-	$(CCC) -o $@ if_mzsch.c
+objects/if_mzsch.o: if_mzsch.c $(MZSCHEME_EXTRA)
+	$(CCC) -o $@ $(MZSCHEME_CFLAGS_EXTRA) if_mzsch.c
+ 
+mzscheme_base.c:
+	$(MZSCHEME_MZC) --c-mods mzscheme_base.c ++lib scheme/base
 
 objects/if_perl.o: auto/if_perl.c
 	$(CCC) -o $@ auto/if_perl.c
@@ -2430,7 +2447,7 @@
 	$(CCC) -o $@ if_perlsfio.c
 
 objects/if_python.o: if_python.c
-	$(CCC) -o $@ if_python.c
+	$(CCC) -o $@ $(PYTHON_CFLAGS_EXTRA) if_python.c
 
 objects/if_ruby.o: if_ruby.c
 	$(CCC) -o $@ if_ruby.c
diff -Naur vim72.orig/src/mark.c vim72/src/mark.c
--- vim72.orig/src/mark.c	2008-08-08 23:06:49.000000000 +0100
+++ vim72/src/mark.c	2009-07-22 22:54:22.000000000 +0100
@@ -884,10 +884,9 @@
 /*
  * print the jumplist
  */
-/*ARGSUSED*/
     void
 ex_jumps(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     int		i;
     char_u	*name;
@@ -933,10 +932,9 @@
 /*
  * print the changelist
  */
-/*ARGSUSED*/
     void
 ex_changes(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     int		i;
     char_u	*name;
@@ -1023,6 +1021,9 @@
     int		fnum = curbuf->b_fnum;
     linenr_T	*lp;
     win_T	*win;
+#ifdef FEAT_WINDOWS
+    tabpage_T	*tab;
+#endif
 
     if (line2 < line1 && amount_after == 0L)	    /* nothing to do */
 	return;
@@ -1064,7 +1065,7 @@
 	/* quickfix marks */
 	qf_mark_adjust(NULL, line1, line2, amount, amount_after);
 	/* location lists */
-	FOR_ALL_WINDOWS(win)
+	FOR_ALL_TAB_WINDOWS(tab, win)
 	    qf_mark_adjust(win, line1, line2, amount, amount_after);
 #endif
 
@@ -1086,7 +1087,7 @@
     /*
      * Adjust items in all windows related to the current buffer.
      */
-    FOR_ALL_WINDOWS(win)
+    FOR_ALL_TAB_WINDOWS(tab, win)
     {
 #ifdef FEAT_JUMPLIST
 	if (!cmdmod.lockmarks)
@@ -1627,15 +1628,17 @@
 
 /*
  * Handle marks in the viminfo file:
- * fp_out == NULL   read marks for current buffer only
- * fp_out != NULL   copy marks for buffers not in buffer list
+ * fp_out != NULL: copy marks for buffers not in buffer list
+ * fp_out == NULL && (flags & VIF_WANT_MARKS): read marks for curbuf only
+ * fp_out == NULL && (flags & VIF_GET_OLDFILES | VIF_FORCEIT): fill v:oldfiles
  */
     void
-copy_viminfo_marks(virp, fp_out, count, eof)
+copy_viminfo_marks(virp, fp_out, count, eof, flags)
     vir_T	*virp;
     FILE	*fp_out;
     int		count;
     int		eof;
+    int		flags;
 {
     char_u	*line = virp->vir_line;
     buf_T	*buf;
@@ -1647,10 +1650,23 @@
     char_u	*p;
     char_u	*name_buf;
     pos_T	pos;
+#ifdef FEAT_EVAL
+    list_T	*list = NULL;
+#endif
 
     if ((name_buf = alloc(LSIZE)) == NULL)
 	return;
     *name_buf = NUL;
+
+#ifdef FEAT_EVAL
+    if (fp_out == NULL && (flags & (VIF_GET_OLDFILES | VIF_FORCEIT)))
+    {
+	list = list_alloc();
+	if (list != NULL)
+	    set_vim_var_list(VV_OLDFILES, list);
+    }
+#endif
+
     num_marked_files = get_viminfo_parameter('\'');
     while (!eof && (count < num_marked_files || fp_out == NULL))
     {
@@ -1681,6 +1697,11 @@
 	    p++;
 	*p = NUL;
 
+#ifdef FEAT_EVAL
+	if (list != NULL)
+	    list_append_string(list, str, -1);
+#endif
+
 	/*
 	 * If fp_out == NULL, load marks for current buffer.
 	 * If fp_out != NULL, copy marks for buffers not in buflist.
@@ -1688,7 +1709,7 @@
 	load_marks = copy_marks_out = FALSE;
 	if (fp_out == NULL)
 	{
-	    if (curbuf->b_ffname != NULL)
+	    if ((flags & VIF_WANT_MARKS) && curbuf->b_ffname != NULL)
 	    {
 		if (*name_buf == NUL)	    /* only need to do this once */
 		    home_replace(NULL, curbuf->b_ffname, name_buf, LSIZE, TRUE);
diff -Naur vim72.orig/src/mbyte.c vim72/src/mbyte.c
--- vim72.orig/src/mbyte.c	2008-07-14 13:38:05.000000000 +0100
+++ vim72/src/mbyte.c	2009-07-22 22:54:23.000000000 +0100
@@ -127,7 +127,10 @@
 static int dbcs_char2len __ARGS((int c));
 static int dbcs_char2bytes __ARGS((int c, char_u *buf));
 static int dbcs_ptr2len __ARGS((char_u *p));
+static int dbcs_ptr2len_len __ARGS((char_u *p, int size));
+static int utf_ptr2cells_len __ARGS((char_u *p, int size));
 static int dbcs_char2cells __ARGS((int c));
+static int dbcs_ptr2cells_len __ARGS((char_u *p, int size));
 static int dbcs_ptr2char __ARGS((char_u *p));
 
 /* Lookup table to quickly get the length in bytes of a UTF-8 character from
@@ -606,9 +609,11 @@
     if (enc_utf8)
     {
 	mb_ptr2len = utfc_ptr2len;
+	mb_ptr2len_len = utfc_ptr2len_len;
 	mb_char2len = utf_char2len;
 	mb_char2bytes = utf_char2bytes;
 	mb_ptr2cells = utf_ptr2cells;
+	mb_ptr2cells_len = utf_ptr2cells_len;
 	mb_char2cells = utf_char2cells;
 	mb_off2cells = utf_off2cells;
 	mb_ptr2char = utf_ptr2char;
@@ -617,9 +622,11 @@
     else if (enc_dbcs != 0)
     {
 	mb_ptr2len = dbcs_ptr2len;
+	mb_ptr2len_len = dbcs_ptr2len_len;
 	mb_char2len = dbcs_char2len;
 	mb_char2bytes = dbcs_char2bytes;
 	mb_ptr2cells = dbcs_ptr2cells;
+	mb_ptr2cells_len = dbcs_ptr2cells_len;
 	mb_char2cells = dbcs_char2cells;
 	mb_off2cells = dbcs_off2cells;
 	mb_ptr2char = dbcs_ptr2char;
@@ -628,9 +635,11 @@
     else
     {
 	mb_ptr2len = latin_ptr2len;
+	mb_ptr2len_len = latin_ptr2len_len;
 	mb_char2len = latin_char2len;
 	mb_char2bytes = latin_char2bytes;
 	mb_ptr2cells = latin_ptr2cells;
+	mb_ptr2cells_len = latin_ptr2cells_len;
 	mb_char2cells = latin_char2cells;
 	mb_off2cells = latin_off2cells;
 	mb_ptr2char = latin_ptr2char;
@@ -717,7 +726,7 @@
 		     * where mblen() returns 0 for invalid character.
 		     * Therefore, following condition includes 0.
 		     */
-		    (void)mblen(NULL, 0);	/* First reset the state. */
+		    ignored = mblen(NULL, 0);	/* First reset the state. */
 		    if (mblen(buf, (size_t)1) <= 0)
 			n = 2;
 		    else
@@ -1015,10 +1024,9 @@
  * Return length in bytes of character "c".
  * Returns 1 for a single-byte character.
  */
-/* ARGSUSED */
     int
 latin_char2len(c)
-    int		c;
+    int		c UNUSED;
 {
     return 1;
 }
@@ -1070,7 +1078,6 @@
  * Get byte length of character at "*p" but stop at a NUL.
  * For UTF-8 this includes following composing characters.
  * Returns 0 when *p is NUL.
- *
  */
     int
 latin_ptr2len(p)
@@ -1092,6 +1099,40 @@
     return len;
 }
 
+/*
+ * mb_ptr2len_len() function pointer.
+ * Like mb_ptr2len(), but limit to read "size" bytes.
+ * Returns 0 for an empty string.
+ * Returns 1 for an illegal char or an incomplete byte sequence.
+ */
+    int
+latin_ptr2len_len(p, size)
+    char_u	*p;
+    int		size;
+{
+    if (size < 1 || *p == NUL)
+	return 0;
+    return 1;
+}
+
+    static int
+dbcs_ptr2len_len(p, size)
+    char_u	*p;
+    int		size;
+{
+    int		len;
+
+    if (size < 1 || *p == NUL)
+	return 0;
+    if (size == 1)
+	return 1;
+    /* Check that second byte is not missing. */
+    len = MB_BYTE2LEN(*p);
+    if (len == 2 && p[1] == NUL)
+	len = 1;
+    return len;
+}
+
 struct interval
 {
     unsigned short first;
@@ -1248,10 +1289,9 @@
  * Return the number of display cells character at "*p" occupies.
  * This doesn't take care of unprintable characters, use ptr2cells() for that.
  */
-/*ARGSUSED*/
     int
 latin_ptr2cells(p)
-    char_u	*p;
+    char_u	*p UNUSED;
 {
     return 1;
 }
@@ -1289,14 +1329,62 @@
 }
 
 /*
+ * mb_ptr2cells_len() function pointer.
+ * Like mb_ptr2cells(), but limit string length to "size".
+ * For an empty string or truncated character returns 1.
+ */
+    int
+latin_ptr2cells_len(p, size)
+    char_u	*p UNUSED;
+    int		size UNUSED;
+{
+    return 1;
+}
+
+    static int
+utf_ptr2cells_len(p, size)
+    char_u	*p;
+    int		size;
+{
+    int		c;
+
+    /* Need to convert to a wide character. */
+    if (size > 0 && *p >= 0x80)
+    {
+	if (utf_ptr2len_len(p, size) < utf8len_tab[*p])
+	    return 1;
+	c = utf_ptr2char(p);
+	/* An illegal byte is displayed as <xx>. */
+	if (utf_ptr2len(p) == 1 || c == NUL)
+	    return 4;
+	/* If the char is ASCII it must be an overlong sequence. */
+	if (c < 0x80)
+	    return char2cells(c);
+	return utf_char2cells(c);
+    }
+    return 1;
+}
+
+    static int
+dbcs_ptr2cells_len(p, size)
+    char_u	*p;
+    int		size;
+{
+    /* Number of cells is equal to number of bytes, except for euc-jp when
+     * the first byte is 0x8e. */
+    if (size <= 1 || (enc_dbcs == DBCS_JPNU && *p == 0x8e))
+	return 1;
+    return MB_BYTE2LEN(*p);
+}
+
+/*
  * mb_char2cells() function pointer.
  * Return the number of display cells character "c" occupies.
  * Only takes care of multi-byte chars, not "^C" and such.
  */
-/*ARGSUSED*/
     int
 latin_char2cells(c)
-    int		c;
+    int		c UNUSED;
 {
     return 1;
 }
@@ -1318,11 +1406,10 @@
  * Return number of display cells for char at ScreenLines[off].
  * We make sure that the offset used is less than "max_off".
  */
-/*ARGSUSED*/
     int
 latin_off2cells(off, max_off)
-    unsigned	off;
-    unsigned	max_off;
+    unsigned	off UNUSED;
+    unsigned	max_off UNUSED;
 {
     return 1;
 }
@@ -1720,6 +1807,7 @@
 /*
  * Return the number of bytes the UTF-8 encoding of the character at "p[size]"
  * takes.  This includes following composing characters.
+ * Returns 0 for an empty string.
  * Returns 1 for an illegal char or an incomplete byte sequence.
  */
     int
@@ -1732,7 +1820,7 @@
     int		prevlen;
 #endif
 
-    if (*p == NUL)
+    if (size < 1 || *p == NUL)
 	return 0;
     if (p[0] < 0x80 && (size == 1 || p[1] < 0x80)) /* be quick for ASCII */
 	return 1;
@@ -2419,11 +2507,10 @@
  * Return offset from "p" to the first byte of the character it points into.
  * Returns 0 when already at the first byte of a character.
  */
-/*ARGSUSED*/
     int
 latin_head_off(base, p)
-    char_u	*base;
-    char_u	*p;
+    char_u	*base UNUSED;
+    char_u	*p UNUSED;
 {
     return 0;
 }
@@ -2540,7 +2627,6 @@
     return (int)(p - q);
 }
 
-#if defined(FEAT_EVAL) || defined(PROTO)
 /*
  * Copy a character from "*fp" to "*tp" and advance the pointers.
  */
@@ -2555,7 +2641,6 @@
     *tp += l;
     *fp += l;
 }
-#endif
 
 /*
  * Return the offset from "p" to the first byte of a character.  When "p" is
@@ -3133,7 +3218,7 @@
 	else
 	    s = p + 1;
     }
-    for (i = 0; s[i] != NUL && s + i < buf + sizeof(buf) - 1; ++i)
+    for (i = 0; s[i] != NUL && i < (int)sizeof(buf) - 1; ++i)
     {
 	if (s[i] == '_' || s[i] == '-')
 	    buf[i] = '-';
@@ -3180,7 +3265,7 @@
 
 # if defined(USE_ICONV) || defined(PROTO)
 
-static char_u *iconv_string __ARGS((vimconv_T *vcp, char_u *str, int slen, int *unconvlenp));
+static char_u *iconv_string __ARGS((vimconv_T *vcp, char_u *str, int slen, int *unconvlenp, int *resultlenp));
 
 /*
  * Call iconv_open() with a check if iconv() works properly (there are broken
@@ -3241,13 +3326,15 @@
  * If "unconvlenp" is not NULL handle the string ending in an incomplete
  * sequence and set "*unconvlenp" to the length of it.
  * Returns the converted string in allocated memory.  NULL for an error.
+ * If resultlenp is not NULL, sets it to the result length in bytes.
  */
     static char_u *
-iconv_string(vcp, str, slen, unconvlenp)
+iconv_string(vcp, str, slen, unconvlenp, resultlenp)
     vimconv_T	*vcp;
     char_u	*str;
     int		slen;
     int		*unconvlenp;
+    int		*resultlenp;
 {
     const char	*from;
     size_t	fromlen;
@@ -3333,6 +3420,9 @@
 	/* Not enough room or skipping illegal sequence. */
 	done = to - (char *)result;
     }
+
+    if (resultlenp != NULL)
+	*resultlenp = (int)(to - (char *)result);
     return result;
 }
 
@@ -3584,9 +3674,10 @@
  * Callback invoked when the user finished preediting.
  * Put the final string into the input buffer.
  */
-/*ARGSUSED0*/
     static void
-im_commit_cb(GtkIMContext *context, const gchar *str, gpointer data)
+im_commit_cb(GtkIMContext *context UNUSED,
+	     const gchar *str,
+	     gpointer data UNUSED)
 {
     int	slen = (int)STRLEN(str);
     int	add_to_input = TRUE;
@@ -3672,9 +3763,8 @@
 /*
  * Callback invoked after start to the preedit.
  */
-/*ARGSUSED*/
     static void
-im_preedit_start_cb(GtkIMContext *context, gpointer data)
+im_preedit_start_cb(GtkIMContext *context UNUSED, gpointer data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("im_preedit_start_cb()\n");
@@ -3689,9 +3779,8 @@
 /*
  * Callback invoked after end to the preedit.
  */
-/*ARGSUSED*/
     static void
-im_preedit_end_cb(GtkIMContext *context, gpointer data)
+im_preedit_end_cb(GtkIMContext *context UNUSED, gpointer data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("im_preedit_end_cb()\n");
@@ -3750,9 +3839,8 @@
  * remaining input from within the "retrieve_surrounding" signal handler, this
  * might not be necessary.  Gotta ask on vim-dev for opinions.
  */
-/*ARGSUSED1*/
     static void
-im_preedit_changed_cb(GtkIMContext *context, gpointer data)
+im_preedit_changed_cb(GtkIMContext *context, gpointer data UNUSED)
 {
     char    *preedit_string = NULL;
     int	    cursor_index    = 0;
@@ -4618,11 +4706,10 @@
     }
 }
 
-/*ARGSUSED*/
     void
 im_set_position(row, col)
-    int		row;
-    int		col;
+    int		row UNUSED;
+    int		col UNUSED;
 {
     xim_set_preedit();
 }
@@ -4929,12 +5016,11 @@
 static void xim_instantiate_cb __ARGS((Display *display, XPointer client_data, XPointer	call_data));
 static void xim_destroy_cb __ARGS((XIM im, XPointer client_data, XPointer call_data));
 
-/*ARGSUSED*/
     static void
 xim_instantiate_cb(display, client_data, call_data)
     Display	*display;
-    XPointer	client_data;
-    XPointer	call_data;
+    XPointer	client_data UNUSED;
+    XPointer	call_data UNUSED;
 {
     Window	x11_window;
     Display	*x11_display;
@@ -4954,12 +5040,11 @@
 					 xim_instantiate_cb, NULL);
 }
 
-/*ARGSUSED*/
     static void
 xim_destroy_cb(im, client_data, call_data)
-    XIM		im;
-    XPointer	client_data;
-    XPointer	call_data;
+    XIM		im UNUSED;
+    XPointer	client_data UNUSED;
+    XPointer	call_data UNUSED;
 {
     Window	x11_window;
     Display	*x11_display;
@@ -5278,9 +5363,10 @@
     }
 }
 
-/*ARGSUSED*/
     static void
-preedit_start_cbproc(XIC xic, XPointer client_data, XPointer call_data)
+preedit_start_cbproc(XIC thexic UNUSED,
+	             XPointer client_data UNUSED,
+		     XPointer call_data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("xim_decide_input_style()\n");
@@ -5312,9 +5398,10 @@
 static GSList *key_press_event_queue = NULL;
 static gboolean processing_queued_event = FALSE;
 
-/*ARGSUSED*/
     static void
-preedit_draw_cbproc(XIC xic, XPointer client_data, XPointer call_data)
+preedit_draw_cbproc(XIC thexic UNUSED,
+		    XPointer client_data UNUSED,
+		    XPointer call_data)
 {
     XIMPreeditDrawCallbackStruct *draw_data;
     XIMText	*text;
@@ -5386,7 +5473,7 @@
 			draw_feedback = (char *)alloc(draw_data->chg_first
 							      + text->length);
 		    else
-			draw_feedback = realloc(draw_feedback,
+			draw_feedback = vim_realloc(draw_feedback,
 					 draw_data->chg_first + text->length);
 		    if (draw_feedback != NULL)
 		    {
@@ -5453,18 +5540,20 @@
     return -1;
 }
 
-/*ARGSUSED*/
     static void
-preedit_caret_cbproc(XIC xic, XPointer client_data, XPointer call_data)
+preedit_caret_cbproc(XIC thexic UNUSED,
+		     XPointer client_data UNUSED,
+		     XPointer call_data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("preedit_caret_cbproc()\n");
 #endif
 }
 
-/*ARGSUSED*/
     static void
-preedit_done_cbproc(XIC xic, XPointer client_data, XPointer call_data)
+preedit_done_cbproc(XIC thexic UNUSED,
+		    XPointer client_data UNUSED,
+		    XPointer call_data UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("preedit_done_cbproc()\n");
@@ -5503,9 +5592,8 @@
     }
 }
 
-/*ARGSUSED*/
     int
-xim_queue_key_press_event(GdkEventKey *event, int down)
+xim_queue_key_press_event(GdkEventKey *event, int down UNUSED)
 {
 #ifdef XIM_DEBUG
     xim_log("xim_queue_key_press_event()\n");
@@ -5521,9 +5609,8 @@
     return TRUE;
 }
 
-/*ARGSUSED*/
     static void
-preedit_callback_setup(GdkIC *ic)
+preedit_callback_setup(GdkIC *ic UNUSED)
 {
     XIC xxic;
     XVaNestedList preedit_attr;
@@ -5548,9 +5635,8 @@
     XFree(preedit_attr);
 }
 
-/*ARGSUSED*/
     static void
-reset_state_setup(GdkIC *ic)
+reset_state_setup(GdkIC *ic UNUSED)
 {
 #ifdef USE_X11R6_XIM
     /* don't change the input context when we call reset */
@@ -5756,8 +5842,25 @@
     char_u	*from;
     char_u	*to;
 {
+    return convert_setup_ext(vcp, from, TRUE, to, TRUE);
+}
+
+/*
+ * As convert_setup(), but only when from_unicode_is_utf8 is TRUE will all
+ * "from" unicode charsets be considered utf-8.  Same for "to".
+ */
+    int
+convert_setup_ext(vcp, from, from_unicode_is_utf8, to, to_unicode_is_utf8)
+    vimconv_T	*vcp;
+    char_u	*from;
+    int		from_unicode_is_utf8;
+    char_u	*to;
+    int		to_unicode_is_utf8;
+{
     int		from_prop;
     int		to_prop;
+    int		from_is_utf8;
+    int		to_is_utf8;
 
     /* Reset to no conversion. */
 # ifdef USE_ICONV
@@ -5775,37 +5878,46 @@
 
     from_prop = enc_canon_props(from);
     to_prop = enc_canon_props(to);
-    if ((from_prop & ENC_LATIN1) && (to_prop & ENC_UNICODE))
+    if (from_unicode_is_utf8)
+	from_is_utf8 = from_prop & ENC_UNICODE;
+    else
+	from_is_utf8 = from_prop == ENC_UNICODE;
+    if (to_unicode_is_utf8)
+	to_is_utf8 = to_prop & ENC_UNICODE;
+    else
+	to_is_utf8 = to_prop == ENC_UNICODE;
+
+    if ((from_prop & ENC_LATIN1) && to_is_utf8)
     {
 	/* Internal latin1 -> utf-8 conversion. */
 	vcp->vc_type = CONV_TO_UTF8;
 	vcp->vc_factor = 2;	/* up to twice as long */
     }
-    else if ((from_prop & ENC_LATIN9) && (to_prop & ENC_UNICODE))
+    else if ((from_prop & ENC_LATIN9) && to_is_utf8)
     {
 	/* Internal latin9 -> utf-8 conversion. */
 	vcp->vc_type = CONV_9_TO_UTF8;
 	vcp->vc_factor = 3;	/* up to three as long (euro sign) */
     }
-    else if ((from_prop & ENC_UNICODE) && (to_prop & ENC_LATIN1))
+    else if (from_is_utf8 && (to_prop & ENC_LATIN1))
     {
 	/* Internal utf-8 -> latin1 conversion. */
 	vcp->vc_type = CONV_TO_LATIN1;
     }
-    else if ((from_prop & ENC_UNICODE) && (to_prop & ENC_LATIN9))
+    else if (from_is_utf8 && (to_prop & ENC_LATIN9))
     {
 	/* Internal utf-8 -> latin9 conversion. */
 	vcp->vc_type = CONV_TO_LATIN9;
     }
 #ifdef WIN3264
     /* Win32-specific codepage <-> codepage conversion without iconv. */
-    else if (((from_prop & ENC_UNICODE) || encname2codepage(from) > 0)
-	    && ((to_prop & ENC_UNICODE) || encname2codepage(to) > 0))
+    else if ((from_is_utf8 || encname2codepage(from) > 0)
+	    && (to_is_utf8 || encname2codepage(to) > 0))
     {
 	vcp->vc_type = CONV_CODEPAGE;
 	vcp->vc_factor = 2;	/* up to twice as long */
-	vcp->vc_cpfrom = (from_prop & ENC_UNICODE) ? 0 : encname2codepage(from);
-	vcp->vc_cpto = (to_prop & ENC_UNICODE) ? 0 : encname2codepage(to);
+	vcp->vc_cpfrom = from_is_utf8 ? 0 : encname2codepage(from);
+	vcp->vc_cpto = to_is_utf8 ? 0 : encname2codepage(to);
     }
 #endif
 #ifdef MACOS_X
@@ -5813,7 +5925,7 @@
     {
 	vcp->vc_type = CONV_MAC_LATIN1;
     }
-    else if ((from_prop & ENC_MACROMAN) && (to_prop & ENC_UNICODE))
+    else if ((from_prop & ENC_MACROMAN) && to_is_utf8)
     {
 	vcp->vc_type = CONV_MAC_UTF8;
 	vcp->vc_factor = 2;	/* up to twice as long */
@@ -5822,7 +5934,7 @@
     {
 	vcp->vc_type = CONV_LATIN1_MAC;
     }
-    else if ((from_prop & ENC_UNICODE) && (to_prop & ENC_MACROMAN))
+    else if (from_is_utf8 && (to_prop & ENC_MACROMAN))
     {
 	vcp->vc_type = CONV_UTF8_MAC;
     }
@@ -5832,8 +5944,8 @@
     {
 	/* Use iconv() for conversion. */
 	vcp->vc_fd = (iconv_t)my_iconv_open(
-		(to_prop & ENC_UNICODE) ? (char_u *)"utf-8" : to,
-		(from_prop & ENC_UNICODE) ? (char_u *)"utf-8" : from);
+		to_is_utf8 ? (char_u *)"utf-8" : to,
+		from_is_utf8 ? (char_u *)"utf-8" : from);
 	if (vcp->vc_fd != (iconv_t)-1)
 	{
 	    vcp->vc_type = CONV_ICONV;
@@ -6089,9 +6201,7 @@
 
 # ifdef USE_ICONV
 	case CONV_ICONV:	/* conversion with output_conv.vc_fd */
-	    retval = iconv_string(vcp, ptr, len, unconvlenp);
-	    if (retval != NULL && lenp != NULL)
-		*lenp = (int)STRLEN(retval);
+	    retval = iconv_string(vcp, ptr, len, unconvlenp, lenp);
 	    break;
 # endif
 # ifdef WIN3264
@@ -6103,7 +6213,7 @@
 
 	    /* 1. codepage/UTF-8  ->  ucs-2. */
 	    if (vcp->vc_cpfrom == 0)
-		tmp_len = utf8_to_ucs2(ptr, len, NULL, NULL);
+		tmp_len = utf8_to_utf16(ptr, len, NULL, NULL);
 	    else
 		tmp_len = MultiByteToWideChar(vcp->vc_cpfrom, 0,
 							      ptr, len, 0, 0);
@@ -6111,13 +6221,13 @@
 	    if (tmp == NULL)
 		break;
 	    if (vcp->vc_cpfrom == 0)
-		utf8_to_ucs2(ptr, len, tmp, unconvlenp);
+		utf8_to_utf16(ptr, len, tmp, unconvlenp);
 	    else
 		MultiByteToWideChar(vcp->vc_cpfrom, 0, ptr, len, tmp, tmp_len);
 
 	    /* 2. ucs-2  ->  codepage/UTF-8. */
 	    if (vcp->vc_cpto == 0)
-		retlen = ucs2_to_utf8(tmp, tmp_len, NULL);
+		retlen = utf16_to_utf8(tmp, tmp_len, NULL);
 	    else
 		retlen = WideCharToMultiByte(vcp->vc_cpto, 0,
 						    tmp, tmp_len, 0, 0, 0, 0);
@@ -6125,7 +6235,7 @@
 	    if (retval != NULL)
 	    {
 		if (vcp->vc_cpto == 0)
-		    ucs2_to_utf8(tmp, tmp_len, retval);
+		    utf16_to_utf8(tmp, tmp_len, retval);
 		else
 		    WideCharToMultiByte(vcp->vc_cpto, 0,
 					  tmp, tmp_len, retval, retlen, 0, 0);
diff -Naur vim72.orig/src/memline.c vim72/src/memline.c
--- vim72.orig/src/memline.c	2008-07-13 17:19:22.000000000 +0100
+++ vim72/src/memline.c	2009-07-22 22:54:21.000000000 +0100
@@ -1554,10 +1554,15 @@
 	    for (i = 0; i < num_files; ++i)
 		if (fullpathcmp(p, files[i], TRUE) & FPC_SAME)
 		{
+		    /* Remove the name from files[i].  Move further entries
+		     * down.  When the array becomes empty free it here, since
+		     * FreeWild() won't be called below. */
 		    vim_free(files[i]);
-		    --num_files;
-		    for ( ; i < num_files; ++i)
-			files[i] = files[i + 1];
+		    if (--num_files == 0)
+			vim_free(files);
+		    else
+			for ( ; i < num_files; ++i)
+			    files[i] = files[i + 1];
 		}
 	}
 	if (nr > 0)
@@ -3522,7 +3527,7 @@
 	    if (errno == EINVAL || errno == ENOENT)
 	    {
 		/* Found non-symlink or not existing file, stop here.
-		 * When at the first level use the unmodifed name, skip the
+		 * When at the first level use the unmodified name, skip the
 		 * call to vim_FullName(). */
 		if (depth == 1)
 		    return FAIL;
@@ -3766,8 +3771,10 @@
     set_vim_var_string(VV_SWAPCHOICE, NULL, -1);
 
     /* Trigger SwapExists autocommands with <afile> set to the file being
-     * edited. */
+     * edited.  Disallow changing directory here. */
+    ++allbuf_lock;
     apply_autocmds(EVENT_SWAPEXISTS, buf->b_fname, NULL, FALSE, NULL);
+    --allbuf_lock;
 
     set_vim_var_string(VV_SWAPNAME, NULL, -1);
 
@@ -3793,6 +3800,7 @@
  *
  * Note: If BASENAMELEN is not correct, you will get error messages for
  *	 not being able to open the swapfile
+ * Note: May trigger SwapExists autocmd, pointers may change!
  */
     static char_u *
 findswapname(buf, dirp, old_fname)
@@ -4560,7 +4568,7 @@
 			buf->b_ml.ml_chunksize + curix,
 			(buf->b_ml.ml_usedchunks - curix) *
 			sizeof(chunksize_T));
-	    /* Compute length of first half of lines in the splitted chunk */
+	    /* Compute length of first half of lines in the split chunk */
 	    size = 0;
 	    linecnt = 0;
 	    while (curline < buf->b_ml.ml_line_count
diff -Naur vim72.orig/src/menu.c vim72/src/menu.c
--- vim72.orig/src/menu.c	2008-06-21 20:53:43.000000000 +0100
+++ vim72/src/menu.c	2009-07-22 22:54:22.000000000 +0100
@@ -231,7 +231,7 @@
 		if (skipdigits(menu_path + 7) == p)
 		{
 		    menuarg.iconidx = atoi((char *)menu_path + 7);
-		    if (menuarg.iconidx >= TOOLBAR_NAME_COUNT)
+		    if (menuarg.iconidx >= (int)TOOLBAR_NAME_COUNT)
 			menuarg.iconidx = -1;
 		    else
 			menuarg.icon_builtin = TRUE;
@@ -239,7 +239,7 @@
 	    }
 	    else
 	    {
-		for (i = 0; i < TOOLBAR_NAME_COUNT; ++i)
+		for (i = 0; i < (int)TOOLBAR_NAME_COUNT; ++i)
 		    if (STRNCMP(toolbar_names[i], menu_path, p - menu_path)
 									 == 0)
 		    {
@@ -1120,6 +1120,7 @@
 	parent = menu;
 	menu = menu->children;
     }
+    vim_free(path_name);
 
     /* Now we have found the matching menu, and we list the mappings */
 						    /* Highlight title */
@@ -1340,10 +1341,9 @@
  * Function given to ExpandGeneric() to obtain the list of (sub)menus (not
  * entries).
  */
-/*ARGSUSED*/
     char_u *
 get_menu_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     static vimmenu_T	*menu = NULL;
@@ -1377,10 +1377,9 @@
  * Function given to ExpandGeneric() to obtain the list of menus and menu
  * entries.
  */
-/*ARGSUSED*/
     char_u *
 get_menu_names(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     static vimmenu_T	*menu = NULL;
@@ -1738,10 +1737,9 @@
 /*
  * Return TRUE if the menu is the tearoff menu.
  */
-/*ARGSUSED*/
     static int
 menu_is_tearoff(name)
-    char_u *name;
+    char_u *name UNUSED;
 {
 #ifdef FEAT_GUI
     return (STRCMP(name, TEAR_STRING) == 0);
@@ -2342,10 +2340,9 @@
  * This function is also defined without the +multi_lang feature, in which
  * case the commands are ignored.
  */
-/*ARGSUSED*/
     void
 ex_menutranslate(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
 #ifdef FEAT_MULTI_LANG
     char_u		*arg = eap->arg;
diff -Naur vim72.orig/src/message.c vim72/src/message.c
--- vim72.orig/src/message.c	2008-07-09 19:24:55.000000000 +0100
+++ vim72/src/message.c	2009-07-22 22:54:23.000000000 +0100
@@ -107,7 +107,7 @@
 }
 
 #if defined(FEAT_EVAL) || defined(FEAT_X11) || defined(USE_XSMP) \
-    || defined(PROTO)
+    || defined(FEAT_GUI_GTK) || defined(PROTO)
 /*
  * Like msg() but keep it silent when 'verbosefile' is set.
  */
@@ -818,10 +818,9 @@
 /*
  * ":messages" command.
  */
-/*ARGSUSED*/
     void
 ex_messages(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     struct msg_hist *p;
     char_u	    *s;
@@ -976,7 +975,7 @@
 		    }
 		}
 		else if (msg_scrolled > Rows - 2
-				     && (c == 'j' || c == K_DOWN || c == 'd'))
+			 && (c == 'j' || c == K_DOWN || c == 'd' || c == 'f'))
 		    c = K_IGNORE;
 	    }
 	} while ((had_got_int && c == Ctrl_C)
@@ -2504,7 +2503,6 @@
 	    break;
 
 	case 'u':		/* Up half a page */
-	case K_PAGEUP:
 	    scroll = -(Rows / 2);
 	    break;
 
@@ -2513,10 +2511,12 @@
 	    break;
 
 	case 'b':		/* one page back */
+	case K_PAGEUP:
 	    scroll = -(Rows - 1);
 	    break;
 
 	case ' ':		/* one extra page */
+	case 'f':
 	case K_PAGEDOWN:
 	case K_LEFTMOUSE:
 	    scroll = Rows - 1;
@@ -2552,7 +2552,6 @@
 	    {
 		/* Jump to the choices of the dialog. */
 		retval = TRUE;
-		lines_left = Rows - 1;
 	    }
 	    else
 #endif
@@ -2560,6 +2559,9 @@
 		got_int = TRUE;
 		quit_more = TRUE;
 	    }
+	    /* When there is some more output (wrapping line) display that
+	     * without another prompt. */
+	    lines_left = Rows - 1;
 	    break;
 
 #ifdef FEAT_CLIPBOARD
@@ -3020,11 +3022,7 @@
     if (*p_vfile != NUL)
 	verbose_write(s, maxlen);
 
-    if (redir_fd != NULL
-#ifdef FEAT_EVAL
-			  || redir_reg || redir_vname
-#endif
-				       )
+    if (redirecting())
     {
 	/* If the string doesn't start with CR or NL, go to msg_col */
 	if (*s != '\n' && *s != '\r')
@@ -3071,6 +3069,16 @@
     }
 }
 
+    int
+redirecting()
+{
+    return redir_fd != NULL
+#ifdef FEAT_EVAL
+			  || redir_reg || redir_vname
+#endif
+				       ;
+}
+
 /*
  * Before giving verbose message.
  * Must always be called paired with verbose_leave()!
@@ -3281,15 +3289,15 @@
  * A '&' in a button name becomes a shortcut, so each '&' should be before a
  * different letter.
  */
-/* ARGSUSED */
     int
 do_dialog(type, title, message, buttons, dfltbutton, textfield)
-    int		type;
-    char_u	*title;
+    int		type UNUSED;
+    char_u	*title UNUSED;
     char_u	*message;
     char_u	*buttons;
     int		dfltbutton;
-    char_u	*textfield;	/* IObuff for inputdialog(), NULL otherwise */
+    char_u	*textfield UNUSED;	/* IObuff for inputdialog(), NULL
+					   otherwise */
 {
     int		oldState;
     int		retval = 0;
@@ -3309,7 +3317,10 @@
     {
 	c = gui_mch_dialog(type, title, message, buttons, dfltbutton,
 								   textfield);
-	msg_end_prompt();
+	/* avoid a hit-enter prompt without clearing the cmdline */
+	need_wait_return = FALSE;
+	emsg_on_display = FALSE;
+	cmdline_row = msg_row;
 
 	/* Flush output to avoid that further messages and redrawing is done
 	 * in the wrong order. */
@@ -4009,7 +4020,7 @@
 	if (*p != '%')
 	{
 	    char    *q = strchr(p + 1, '%');
-	    size_t  n = (q == NULL) ? STRLEN(p) : (q - p);
+	    size_t  n = (q == NULL) ? STRLEN(p) : (size_t)(q - p);
 
 	    /* Copy up to the next '%' or NUL without any changes. */
 	    if (str_l < str_m)
@@ -4256,7 +4267,8 @@
 				  precision <= (size_t)0x7fffffffL ? precision
 						       : (size_t)0x7fffffffL);
 #endif
-			str_arg_l = (q == NULL) ? precision : q - str_arg;
+			str_arg_l = (q == NULL) ? precision
+						      : (size_t)(q - str_arg);
 		    }
 		    break;
 
@@ -4356,7 +4368,8 @@
 					    get_a_arg(arg_idx);
 #else
 # if defined(FEAT_EVAL)
-					    tvs != NULL ? tv_nr(tvs, &arg_idx) :
+					    tvs != NULL ? (unsigned)
+							tv_nr(tvs, &arg_idx) :
 # endif
 						va_arg(ap, unsigned int);
 #endif
@@ -4369,7 +4382,8 @@
 					    get_a_arg(arg_idx);
 #else
 # if defined(FEAT_EVAL)
-					    tvs != NULL ? tv_nr(tvs, &arg_idx) :
+					    tvs != NULL ? (unsigned long)
+							tv_nr(tvs, &arg_idx) :
 # endif
 						va_arg(ap, unsigned long int);
 #endif
@@ -4556,7 +4570,13 @@
 			remove_trailing_zeroes = TRUE;
 		    }
 
-		    if (fmt_spec == 'f' && abs_f > 1.0e307)
+		    if (fmt_spec == 'f' &&
+#ifdef VAX
+			    abs_f > 1.0e38
+#else
+			    abs_f > 1.0e307
+#endif
+			    )
 		    {
 			/* Avoid a buffer overflow */
 			strcpy(tmp, "inf");
@@ -4585,61 +4605,62 @@
 			if (remove_trailing_zeroes)
 			{
 			    int i;
-			    char *p;
+			    char *tp;
 
 			    /* Using %g or %G: remove superfluous zeroes. */
 			    if (fmt_spec == 'f')
-				p = tmp + str_arg_l - 1;
+				tp = tmp + str_arg_l - 1;
 			    else
 			    {
-				p = (char *)vim_strchr((char_u *)tmp,
+				tp = (char *)vim_strchr((char_u *)tmp,
 						 fmt_spec == 'e' ? 'e' : 'E');
-				if (p != NULL)
+				if (tp != NULL)
 				{
 				    /* Remove superfluous '+' and leading
 				     * zeroes from the exponent. */
-				    if (p[1] == '+')
+				    if (tp[1] == '+')
 				    {
 					/* Change "1.0e+07" to "1.0e07" */
-					STRMOVE(p + 1, p + 2);
+					STRMOVE(tp + 1, tp + 2);
 					--str_arg_l;
 				    }
-				    i = (p[1] == '-') ? 2 : 1;
-				    while (p[i] == '0')
+				    i = (tp[1] == '-') ? 2 : 1;
+				    while (tp[i] == '0')
 				    {
 					/* Change "1.0e07" to "1.0e7" */
-					STRMOVE(p + i, p + i + 1);
+					STRMOVE(tp + i, tp + i + 1);
 					--str_arg_l;
 				    }
-				    --p;
+				    --tp;
 				}
 			    }
 
-			    if (p != NULL && !precision_specified)
+			    if (tp != NULL && !precision_specified)
 				/* Remove trailing zeroes, but keep the one
 				 * just after a dot. */
-				while (p > tmp + 2 && *p == '0' && p[-1] != '.')
+				while (tp > tmp + 2 && *tp == '0'
+							     && tp[-1] != '.')
 				{
-				    STRMOVE(p, p + 1);
-				    --p;
+				    STRMOVE(tp, tp + 1);
+				    --tp;
 				    --str_arg_l;
 				}
 			}
 			else
 			{
-			    char *p;
+			    char *tp;
 
 			    /* Be consistent: some printf("%e") use 1.0e+12
 			     * and some 1.0e+012.  Remove one zero in the last
 			     * case. */
-			    p = (char *)vim_strchr((char_u *)tmp,
+			    tp = (char *)vim_strchr((char_u *)tmp,
 						 fmt_spec == 'e' ? 'e' : 'E');
-			    if (p != NULL && (p[1] == '+' || p[1] == '-')
-					  && p[2] == '0'
-					  && vim_isdigit(p[3])
-					  && vim_isdigit(p[4]))
+			    if (tp != NULL && (tp[1] == '+' || tp[1] == '-')
+					  && tp[2] == '0'
+					  && vim_isdigit(tp[3])
+					  && vim_isdigit(tp[4]))
 			    {
-				STRMOVE(p + 2, p + 3);
+				STRMOVE(tp + 2, tp + 3);
 				--str_arg_l;
 			    }
 			}
@@ -4685,7 +4706,8 @@
 			size_t avail = str_m - str_l;
 
 			vim_memset(str + str_l, zero_padding ? '0' : ' ',
-					     (size_t)pn > avail ? avail : pn);
+					     (size_t)pn > avail ? avail
+								: (size_t)pn);
 		    }
 		    str_l += pn;
 		}
@@ -4712,7 +4734,8 @@
 			size_t avail = str_m - str_l;
 
 			mch_memmove(str + str_l, str_arg,
-					     (size_t)zn > avail ? avail : zn);
+					     (size_t)zn > avail ? avail
+								: (size_t)zn);
 		    }
 		    str_l += zn;
 		}
@@ -4727,7 +4750,8 @@
 			size_t avail = str_m-str_l;
 
 			vim_memset(str + str_l, '0',
-					     (size_t)zn > avail ? avail : zn);
+					     (size_t)zn > avail ? avail
+								: (size_t)zn);
 		    }
 		    str_l += zn;
 		}
@@ -4746,7 +4770,7 @@
 
 			mch_memmove(str + str_l,
 				str_arg + zero_padding_insertion_ind,
-				(size_t)sn > avail ? avail : sn);
+				(size_t)sn > avail ? avail : (size_t)sn);
 		    }
 		    str_l += sn;
 		}
@@ -4766,7 +4790,8 @@
 			size_t avail = str_m - str_l;
 
 			vim_memset(str + str_l, ' ',
-					     (size_t)pn > avail ? avail : pn);
+					     (size_t)pn > avail ? avail
+								: (size_t)pn);
 		    }
 		    str_l += pn;
 		}
diff -Naur vim72.orig/src/misc1.c vim72/src/misc1.c
--- vim72.orig/src/misc1.c	2008-07-12 20:20:53.000000000 +0100
+++ vim72/src/misc1.c	2009-07-22 22:54:23.000000000 +0100
@@ -2188,12 +2188,11 @@
  *
  * return FAIL for failure, OK otherwise
  */
-/*ARGSUSED*/
     int
 del_bytes(count, fixpos_arg, use_delcombine)
     long	count;
     int		fixpos_arg;
-    int		use_delcombine;	    /* 'delcombine' option applies */
+    int		use_delcombine UNUSED;	    /* 'delcombine' option applies */
 {
     char_u	*oldp, *newp;
     colnr_T	oldlen;
@@ -2346,12 +2345,13 @@
     int		undo;		/* if TRUE, prepare for undo */
 {
     long	n;
+    linenr_T	first = curwin->w_cursor.lnum;
 
     if (nlines <= 0)
 	return;
 
     /* save the deleted lines for undo */
-    if (undo && u_savedel(curwin->w_cursor.lnum, nlines) == FAIL)
+    if (undo && u_savedel(first, nlines) == FAIL)
 	return;
 
     for (n = 0; n < nlines; )
@@ -2359,18 +2359,21 @@
 	if (curbuf->b_ml.ml_flags & ML_EMPTY)	    /* nothing to delete */
 	    break;
 
-	ml_delete(curwin->w_cursor.lnum, TRUE);
+	ml_delete(first, TRUE);
 	++n;
 
 	/* If we delete the last line in the file, stop */
-	if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
+	if (first > curbuf->b_ml.ml_line_count)
 	    break;
     }
-    /* adjust marks, mark the buffer as changed and prepare for displaying */
-    deleted_lines_mark(curwin->w_cursor.lnum, n);
 
+    /* Correct the cursor position before calling deleted_lines_mark(), it may
+     * trigger a callback to display the cursor. */
     curwin->w_cursor.col = 0;
     check_cursor_lnum();
+
+    /* adjust marks, mark the buffer as changed and prepare for displaying */
+    deleted_lines_mark(first, n);
 }
 
     int
@@ -2622,6 +2625,8 @@
 
 /*
  * Like deleted_lines(), but adjust marks first.
+ * Make sure the cursor is on a valid line before calling, a GUI callback may
+ * be triggered to display the cursor.
  */
     void
 deleted_lines_mark(lnum, count)
@@ -2717,6 +2722,9 @@
     long	xtra;
 {
     win_T	*wp;
+#ifdef FEAT_WINDOWS
+    tabpage_T	*tp;
+#endif
     int		i;
 #ifdef FEAT_JUMPLIST
     int		cols;
@@ -2769,7 +2777,7 @@
 		    curbuf->b_changelistlen = JUMPLISTSIZE - 1;
 		    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,
 					  sizeof(pos_T) * (JUMPLISTSIZE - 1));
-		    FOR_ALL_WINDOWS(wp)
+		    FOR_ALL_TAB_WINDOWS(tp, wp)
 		    {
 			/* Correct position in changelist for other windows on
 			 * this buffer. */
@@ -2777,7 +2785,7 @@
 			    --wp->w_changelistidx;
 		    }
 		}
-		FOR_ALL_WINDOWS(wp)
+		FOR_ALL_TAB_WINDOWS(tp, wp)
 		{
 		    /* For other windows, if the position in the changelist is
 		     * at the end it stays at the end. */
@@ -2796,7 +2804,7 @@
 #endif
     }
 
-    FOR_ALL_WINDOWS(wp)
+    FOR_ALL_TAB_WINDOWS(tp, wp)
     {
 	if (wp->w_buffer == curbuf)
 	{
@@ -2955,6 +2963,8 @@
     int	    col;		/* column for message; non-zero when in insert
 				   mode and 'showmode' is on */
 {
+    static char *w_readonly = N_("W10: Warning: Changing a readonly file");
+
     if (curbuf->b_did_warn == FALSE
 	    && curbufIsChanged() == 0
 #ifdef FEAT_AUTOCMD
@@ -2977,8 +2987,10 @@
 	if (msg_row == Rows - 1)
 	    msg_col = col;
 	msg_source(hl_attr(HLF_W));
-	MSG_PUTS_ATTR(_("W10: Warning: Changing a readonly file"),
-						   hl_attr(HLF_W) | MSG_HIST);
+	MSG_PUTS_ATTR(_(w_readonly), hl_attr(HLF_W) | MSG_HIST);
+#ifdef FEAT_EVAL
+	set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_readonly), -1);
+#endif
 	msg_clr_eos();
 	(void)msg_end();
 	if (msg_silent == 0 && !silent_mode)
@@ -3245,9 +3257,9 @@
 
     /* When using ":silent" assume that <CR> was entered. */
     if (mouse_used != NULL)
-	MSG_PUTS(_("Type number or click with mouse (<Enter> cancels): "));
+	MSG_PUTS(_("Type number and <Enter> or click with mouse (empty cancels): "));
     else
-	MSG_PUTS(_("Choice number (<Enter> cancels): "));
+	MSG_PUTS(_("Type number and <Enter> (empty cancels): "));
 
     /* Set the state such that text can be selected/copied/pasted and we still
      * get mouse events. */
@@ -3264,6 +3276,7 @@
 	cmdline_row = msg_row - 1;
 	need_wait_return = FALSE;
 	msg_didany = FALSE;
+	msg_didout = FALSE;
     }
     else
 	cmdline_row = save_cmdline_row;
@@ -4141,10 +4154,9 @@
 /*
  * Function given to ExpandGeneric() to obtain an environment variable name.
  */
-/*ARGSUSED*/
     char_u *
 get_env_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
 # if defined(AMIGA) || defined(__MRC__) || defined(__SC__)
@@ -4736,9 +4748,9 @@
 	 * If it is then restrict the search to below this line and try again.
 	 */
 	line = ml_get(pos->lnum);
-	for (p = line; *p && (unsigned)(p - line) < pos->col; ++p)
+	for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)
 	    p = skip_string(p);
-	if ((unsigned)(p - line) <= pos->col)
+	if ((colnr_T)(p - line) <= pos->col)
 	    break;
 	cur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;
 	if (cur_maxcomment <= 0)
@@ -6269,7 +6281,7 @@
      * check for that.
      */
     if ((State & INSERT)
-	    && curwin->w_cursor.col < STRLEN(linecopy)
+	    && curwin->w_cursor.col < (colnr_T)STRLEN(linecopy)
 	    && linecopy[curwin->w_cursor.col] == ')')
 	linecopy[curwin->w_cursor.col] = NUL;
 
@@ -8522,11 +8534,25 @@
     for (setsuf = p_su; *setsuf; )
     {
 	setsuflen = copy_option_part(&setsuf, suf_buf, MAXSUFLEN, ".,");
-	if (fnamelen >= setsuflen
-		&& fnamencmp(suf_buf, fname + fnamelen - setsuflen,
-					      (size_t)setsuflen) == 0)
-	    break;
-	setsuflen = 0;
+	if (setsuflen == 0)
+	{
+	    char_u *tail = gettail(fname);
+
+	    /* empty entry: match name without a '.' */
+	    if (vim_strchr(tail, '.') == NULL)
+	    {
+		setsuflen = 1;
+		break;
+	    }
+	}
+	else
+	{
+	    if (fnamelen >= setsuflen
+		    && fnamencmp(suf_buf, fname + fnamelen - setsuflen,
+						  (size_t)setsuflen) == 0)
+		break;
+	    setsuflen = 0;
+	}
     }
     return (setsuflen != 0);
 }
@@ -8728,7 +8754,7 @@
 	/* The active codepage differs from 'encoding'.  Attempt using the
 	 * wide function.  If it fails because it is not implemented fall back
 	 * to the non-wide version (for Windows 98) */
-	wn = enc_to_ucs2(buf, NULL);
+	wn = enc_to_utf16(buf, NULL);
 	if (wn != NULL)
 	{
 	    hFind = FindFirstFileW(wn, &wfb);
@@ -8756,7 +8782,7 @@
 #ifdef WIN3264
 # ifdef FEAT_MBYTE
 	if (wn != NULL)
-	    p = ucs2_to_enc(wfb.cFileName, NULL);   /* p is allocated here */
+	    p = utf16_to_enc(wfb.cFileName, NULL);   /* p is allocated here */
 	else
 # endif
 	    p = (char_u *)fb.cFileName;
@@ -8830,7 +8856,7 @@
 	    if (wn != NULL)
 	    {
 		vim_free(wn);
-		wn = enc_to_ucs2(buf, NULL);
+		wn = enc_to_utf16(buf, NULL);
 		if (wn != NULL)
 		    hFind = FindFirstFileW(wn, &wfb);
 	    }
@@ -9188,7 +9214,7 @@
 		else if (vim_strpbrk(p, (char_u *)"$~") != NULL)
 		{
 		    vim_free(p);
-		    ga_clear(&ga);
+		    ga_clear_strings(&ga);
 		    i = mch_expand_wildcards(num_pat, pat, num_file, file,
 								       flags);
 		    recursive = FALSE;
diff -Naur vim72.orig/src/misc2.c vim72/src/misc2.c
--- vim72.orig/src/misc2.c	2008-07-23 20:12:56.000000000 +0100
+++ vim72/src/misc2.c	2009-07-22 22:54:22.000000000 +0100
@@ -496,7 +496,8 @@
 {
     colnr_T len;
 #ifdef FEAT_VIRTUALEDIT
-    colnr_T oldcol = curwin->w_cursor.col + curwin->w_cursor.coladd;
+    colnr_T oldcol = curwin->w_cursor.col;
+    colnr_T oldcoladd = curwin->w_cursor.col + curwin->w_cursor.coladd;
 #endif
 
     len = (colnr_T)STRLEN(ml_get_curline());
@@ -535,7 +536,13 @@
     if (oldcol == MAXCOL)
 	curwin->w_cursor.coladd = 0;
     else if (ve_flags == VE_ALL)
-	curwin->w_cursor.coladd = oldcol - curwin->w_cursor.col;
+    {
+	if (oldcoladd > curwin->w_cursor.col)
+	    curwin->w_cursor.coladd = oldcoladd - curwin->w_cursor.col;
+	else
+	    /* avoid weird number when there is a miscalculation or overflow */
+	    curwin->w_cursor.coladd = 0;
+    }
 #endif
 }
 
@@ -873,7 +880,7 @@
 	    /* 3. check for available memory: call mch_avail_mem() */
 	    if (mch_avail_mem(TRUE) < KEEP_ROOM && !releasing)
 	    {
-		vim_free((char *)p);	/* System is low... no go! */
+		free((char *)p);	/* System is low... no go! */
 		p = NULL;
 	    }
 	    else
@@ -1010,6 +1017,9 @@
 # if defined(FEAT_PROFILE)
     do_cmdline_cmd((char_u *)"profdel *");
 # endif
+# if defined(FEAT_KEYMAP)
+    do_cmdline_cmd((char_u *)"set keymap=");
+#endif
 
 # ifdef FEAT_TITLE
     free_titles();
@@ -1034,6 +1044,9 @@
     free_regexp_stuff();
     free_tag_stuff();
     free_cd_dir();
+# ifdef FEAT_SIGNS
+    free_signs();
+# endif
 # ifdef FEAT_EVAL
     set_expr_line(NULL);
 # endif
@@ -1062,11 +1075,12 @@
 
 #ifdef FEAT_QUICKFIX
     {
-	win_T	*win;
+	win_T	    *win;
+	tabpage_T   *tab;
 
 	qf_free_all(NULL);
 	/* Free all location lists */
-	FOR_ALL_WINDOWS(win)
+	FOR_ALL_TAB_WINDOWS(tab, win)
 	    qf_free_all(win);
     }
 #endif
@@ -1257,7 +1271,6 @@
     return escaped_string;
 }
 
-#if !defined(BACKSLASH_IN_FILENAME) || defined(FEAT_EVAL) || defined(PROTO)
 /*
  * Return TRUE when 'shell' has "csh" in the tail.
  */
@@ -1266,9 +1279,7 @@
 {
     return (strstr((char *)gettail(p_sh), "csh") != NULL);
 }
-#endif
 
-#if defined(FEAT_EVAL) || defined(PROTO)
 /*
  * Escape "string" for use as a shell argument with system().
  * This uses single quotes, except when we know we need to use double qoutes
@@ -1391,7 +1402,6 @@
 
     return escaped_string;
 }
-#endif
 
 /*
  * Like vim_strsave(), but make all characters uppercase.
@@ -2565,7 +2575,7 @@
     int		key;
     int		dlen = 0;
 
-    key = find_special_key(srcp, &modifiers, keycode);
+    key = find_special_key(srcp, &modifiers, keycode, FALSE);
     if (key == 0)
 	return 0;
 
@@ -2601,10 +2611,11 @@
  * returns 0 if there is no match.
  */
     int
-find_special_key(srcp, modp, keycode)
+find_special_key(srcp, modp, keycode, keep_x_key)
     char_u	**srcp;
     int		*modp;
-    int		keycode; /* prefer key code, e.g. K_DEL instead of DEL */
+    int		keycode;     /* prefer key code, e.g. K_DEL instead of DEL */
+    int		keep_x_key;  /* don't translate xHome to Home key */
 {
     char_u	*last_dash;
     char_u	*end_of_name;
@@ -2672,7 +2683,8 @@
 	    else
 	    {
 		key = get_special_key_code(last_dash + 1);
-		key = handle_x_keys(key);
+		if (!keep_x_key)
+		    key = handle_x_keys(key);
 	    }
 
 	    /*
@@ -2829,7 +2841,7 @@
 get_key_name(i)
     int	    i;
 {
-    if (i >= KEY_NAMES_TABLE_LEN)
+    if (i >= (int)KEY_NAMES_TABLE_LEN)
 	return NULL;
     return  key_names_table[i].name;
 }
@@ -3857,7 +3869,8 @@
      * use filename.
      */
 #ifdef UNIX
-    int			ffv_dev;	/* device number (-1 if not set) */
+    int			ffv_dev_valid;	/* ffv_dev and ffv_ino were set */
+    dev_t		ffv_dev;	/* device number */
     ino_t		ffv_ino;	/* inode number */
 #endif
     /* The memory for this struct is allocated according to the length of
@@ -4047,13 +4060,12 @@
  * This function silently ignores a few errors, vim_findfile() will have
  * limited functionality then.
  */
-/*ARGSUSED*/
     void *
 vim_findfile_init(path, filename, stopdirs, level, free_visited, find_what,
 					   search_ctx_arg, tagfile, rel_fname)
     char_u	*path;
     char_u	*filename;
-    char_u	*stopdirs;
+    char_u	*stopdirs UNUSED;
     int		level;
     int		free_visited;
     int		find_what;
@@ -4698,7 +4710,8 @@
 				stackp->ffs_filearray_cur = i + 1;
 				ff_push(search_ctx, stackp);
 
-				simplify_filename(file_path);
+				if (!path_with_url(file_path))
+				    simplify_filename(file_path);
 				if (mch_dirname(ff_expand_buffer, MAXPATHL)
 									== OK)
 				{
@@ -5050,10 +5063,9 @@
     {
 	if (
 #ifdef UNIX
-		!url
-		    ? (vp->ffv_dev == st.st_dev
-			&& vp->ffv_ino == st.st_ino)
-		    :
+		!url ? (vp->ffv_dev_valid && vp->ffv_dev == st.st_dev
+						  && vp->ffv_ino == st.st_ino)
+		     :
 #endif
 		fnamecmp(vp->ffv_fname, ff_expand_buffer) == 0
 	   )
@@ -5078,14 +5090,14 @@
 #ifdef UNIX
 	if (!url)
 	{
+	    vp->ffv_dev_valid = TRUE;
 	    vp->ffv_ino = st.st_ino;
 	    vp->ffv_dev = st.st_dev;
 	    vp->ffv_fname[0] = NUL;
 	}
 	else
 	{
-	    vp->ffv_ino = 0;
-	    vp->ffv_dev = -1;
+	    vp->ffv_dev_valid = FALSE;
 #endif
 	    STRCPY(vp->ffv_fname, ff_expand_buffer);
 #ifdef UNIX
diff -Naur vim72.orig/src/move.c vim72/src/move.c
--- vim72.orig/src/move.c	2008-07-12 17:26:47.000000000 +0100
+++ vim72/src/move.c	2009-07-22 22:54:21.000000000 +0100
@@ -280,18 +280,20 @@
 
 	if (curwin->w_botline <= curbuf->b_ml.ml_line_count)
 	{
-	    if (curwin->w_cursor.lnum < curwin->w_botline
-		    && ((long)curwin->w_cursor.lnum
+	    if (curwin->w_cursor.lnum < curwin->w_botline)
+	    {
+	      if (((long)curwin->w_cursor.lnum
 					     >= (long)curwin->w_botline - p_so
 #ifdef FEAT_FOLDING
 			|| hasAnyFolding(curwin)
 #endif
 			))
-	    {
+	      {
 		lineoff_T	loff;
 
-		/* Cursor is above botline, check if there are 'scrolloff'
-		 * window lines below the cursor.  If not, need to scroll. */
+		/* Cursor is (a few lines) above botline, check if there are
+		 * 'scrolloff' window lines below the cursor.  If not, need to
+		 * scroll. */
 		n = curwin->w_empty_rows;
 		loff.lnum = curwin->w_cursor.lnum;
 #ifdef FEAT_FOLDING
@@ -317,6 +319,10 @@
 		if (n >= p_so)
 		    /* sufficient context, no need to scroll */
 		    check_botline = FALSE;
+	      }
+	      else
+		  /* sufficient context, no need to scroll */
+		  check_botline = FALSE;
 	    }
 	    if (check_botline)
 	    {
@@ -509,6 +515,9 @@
     /* Approximate the value of w_botline */
     wp->w_botline += lnum - wp->w_topline;
     wp->w_topline = lnum;
+#ifdef FEAT_AUTOCMD
+    wp->w_topline_was_set = TRUE;
+#endif
 #ifdef FEAT_DIFF
     wp->w_topfill = 0;
 #endif
@@ -1229,11 +1238,10 @@
 /*
  * Scroll the current window down by "line_count" logical lines.  "CTRL-Y"
  */
-/*ARGSUSED*/
     void
 scrolldown(line_count, byfold)
     long	line_count;
-    int		byfold;		/* TRUE: count a closed fold as one line */
+    int		byfold UNUSED;	/* TRUE: count a closed fold as one line */
 {
     long	done = 0;	/* total # of physical lines done */
     int		wrow;
@@ -1340,11 +1348,10 @@
 /*
  * Scroll the current window up by "line_count" logical lines.  "CTRL-E"
  */
-/*ARGSUSED*/
     void
 scrollup(line_count, byfold)
     long	line_count;
-    int		byfold;		/* TRUE: count a closed fold as one line */
+    int		byfold UNUSED;	/* TRUE: count a closed fold as one line */
 {
 #if defined(FEAT_FOLDING) || defined(FEAT_DIFF)
     linenr_T	lnum;
diff -Naur vim72.orig/src/nbdebug.c vim72/src/nbdebug.c
--- vim72.orig/src/nbdebug.c	2008-06-22 16:38:58.000000000 +0100
+++ vim72/src/nbdebug.c	2009-07-22 22:54:20.000000000 +0100
@@ -33,7 +33,6 @@
 u_int		 nb_dlevel = 0;		/* nb_debug verbosity level */
 
 void		 nbdb(char *, ...);
-void		 nbtrace(char *, ...);
 
 static int	 lookup(char *);
 #ifdef USE_NB_ERRORHANDLER
@@ -100,25 +99,6 @@
 }    /* end nbdebug_log_init */
 
 
-
-
-void
-nbtrace(
-	char		*fmt,
-	...)
-{
-	va_list		 ap;
-
-	if (nb_debug!= NULL && (nb_dlevel & (NB_TRACE | NB_TRACE_VERBOSE))) {
-		va_start(ap, fmt);
-		vfprintf(nb_debug, fmt, ap);
-		va_end(ap);
-		fflush(nb_debug);
-	}
-
-}    /* end nbtrace */
-
-
 void
 nbdbg(
 	char		*fmt,
@@ -136,23 +116,6 @@
 }    /* end nbdbg */
 
 
-void
-nbprt(
-	char		*fmt,
-	...)
-{
-	va_list		 ap;
-
-	if (nb_debug != NULL && nb_dlevel & NB_PRINT) {
-		va_start(ap, fmt);
-		vfprintf(nb_debug, fmt, ap);
-		va_end(ap);
-		fflush(nb_debug);
-	}
-
-}    /* end nbprt */
-
-
 static int
 lookup(
 	char		*file)
diff -Naur vim72.orig/src/nbdebug.h vim72/src/nbdebug.h
--- vim72.orig/src/nbdebug.h	2008-06-22 15:31:50.000000000 +0100
+++ vim72/src/nbdebug.h	2009-07-22 22:54:20.000000000 +0100
@@ -43,8 +43,6 @@
 
 
 void		 nbdbg(char *, ...);
-void		 nbprt(char *, ...);
-void		 nbtrace(char *, ...);
 
 void nbdebug_wait __ARGS((u_int wait_flags, char *wait_var, u_int wait_secs));
 void nbdebug_log_init __ARGS((char *log_var, char *level_var));
@@ -70,19 +68,5 @@
 {
 }
 
-void
-nbprt(
-	char		*fmt,
-	...)
-{
-}
-
-void
-nbtrace(
-	char		*fmt,
-	...)
-{
-}
-
 #endif /* NBDEBUG */
 #endif /* NBDEBUG_H */
diff -Naur vim72.orig/src/netbeans.c vim72/src/netbeans.c
--- vim72.orig/src/netbeans.c	2008-07-13 17:19:54.000000000 +0100
+++ vim72/src/netbeans.c	2009-07-22 22:54:23.000000000 +0100
@@ -32,6 +32,7 @@
 /* WinSock API is separated from C API, thus we can't use read(), write(),
  * errno... */
 # define sock_errno WSAGetLastError()
+# undef ECONNREFUSED
 # define ECONNREFUSED WSAECONNREFUSED
 # ifdef EINTR
 #  undef EINTR
@@ -700,7 +701,6 @@
 /*
  * Read and process a command from netbeans.
  */
-/*ARGSUSED*/
 #if defined(FEAT_GUI_W32) || defined(PROTO)
 /* Use this one when generating prototypes, the others are static. */
     void
@@ -708,12 +708,15 @@
 #else
 # ifdef FEAT_GUI_MOTIF
     static void
-messageFromNetbeans(XtPointer clientData, int *unused1, XtInputId *unused2)
+messageFromNetbeans(XtPointer clientData UNUSED,
+		    int *unused1 UNUSED,
+		    XtInputId *unused2 UNUSED)
 # endif
 # ifdef FEAT_GUI_GTK
     static void
-messageFromNetbeans(gpointer clientData, gint unused1,
-						    GdkInputCondition unused2)
+messageFromNetbeans(gpointer clientData UNUSED,
+		    gint unused1 UNUSED,
+		    GdkInputCondition unused2 UNUSED)
 # endif
 #endif
 {
@@ -769,11 +772,14 @@
 	return; /* don't try to parse it */
     }
 
-#ifdef FEAT_GUI_GTK
+#if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32)
+    /* Let the main loop handle messages. */
+# ifdef FEAT_GUI_GTK
     if (gtk_main_level() > 0)
 	gtk_main_quit();
+# endif
 #else
-    /* Parse the messages, but avoid recursion. */
+    /* Parse the messages now, but avoid recursion. */
     if (level == 1)
 	netbeans_parse_messages();
 
@@ -1043,7 +1049,7 @@
 	nbdebug(("EVT: %s", buf));
 /*	nb_send(buf, "netbeans_end");    avoid "write failed" messages */
 	if (sd >= 0)
-	    sock_write(sd, buf, (int)STRLEN(buf));  /* ignore errors */
+	    ignored = sock_write(sd, buf, (int)STRLEN(buf));
     }
 }
 
@@ -1582,7 +1588,9 @@
 			    buf_delsign(buf->bufp, id);
 			}
 			else
+			{
 			    nbdebug(("    No sign on line %d\n", i));
+			}
 		    }
 
 		    nbdebug(("    Deleting lines %d through %d\n", del_from_lnum, del_to_lnum));
@@ -1795,7 +1803,7 @@
 	    buf->displayname = NULL;
 
 	    netbeansReadFile = 0; /* don't try to open disk file */
-	    do_ecmd(0, NULL, 0, 0, ECMD_ONE, ECMD_HIDE + ECMD_OLDBUF);
+	    do_ecmd(0, NULL, 0, 0, ECMD_ONE, ECMD_HIDE + ECMD_OLDBUF, curwin);
 	    netbeansReadFile = 1;
 	    buf->bufp = curbuf;
 	    maketitle();
@@ -1921,7 +1929,7 @@
 	    vim_free(path);
 	    if (bufp == NULL)
 	    {
-	    	nbdebug(("    File %s not found in setBufferNumber\n", args));
+		nbdebug(("    File %s not found in setBufferNumber\n", args));
 		EMSG2("E642: File %s not found in setBufferNumber", args);
 		return FAIL;
 	    }
@@ -1960,7 +1968,7 @@
 
 	    netbeansReadFile = 0; /* don't try to open disk file */
 	    do_ecmd(0, (char_u *)buf->displayname, 0, 0, ECMD_ONE,
-						     ECMD_HIDE + ECMD_OLDBUF);
+					     ECMD_HIDE + ECMD_OLDBUF, curwin);
 	    netbeansReadFile = 1;
 	    buf->bufp = curbuf;
 	    maketitle();
@@ -1979,7 +1987,7 @@
 	    vim_free(buf->displayname);
 	    buf->displayname = nb_unquote(args, NULL);
 	    do_ecmd(0, (char_u *)buf->displayname, NULL, NULL, ECMD_ONE,
-						     ECMD_HIDE + ECMD_OLDBUF);
+					     ECMD_HIDE + ECMD_OLDBUF, curwin);
 	    buf->bufp = curbuf;
 	    buf->initDone = TRUE;
 	    doupdate = 1;
@@ -2141,7 +2149,9 @@
 #endif
 	    }
 	    else
+	    {
 		nbdebug(("    BAD POSITION in setDot: %s\n", s));
+	    }
 
 	    /* gui_update_cursor(TRUE, FALSE); */
 	    /* update_curbuf(NOT_VALID); */
@@ -2277,9 +2287,6 @@
 	    int serNum;
 	    int localTypeNum;
 	    int typeNum;
-# ifdef NBDEBUG
-	    int len;
-# endif
 	    pos_T *pos;
 
 	    if (buf == NULL || buf->bufp == NULL)
@@ -2303,13 +2310,10 @@
 	    pos = get_off_or_lnum(buf->bufp, &args);
 
 	    cp = (char *)args;
-# ifdef NBDEBUG
-	    len =
-# endif
-		strtol(cp, &cp, 10);
+	    ignored = (int)strtol(cp, &cp, 10);
 	    args = (char_u *)cp;
 # ifdef NBDEBUG
-	    if (len != -1)
+	    if (ignored != -1)
 	    {
 		nbdebug(("    partial line annotation -- Not Yet Implemented!\n"));
 	    }
@@ -2321,7 +2325,7 @@
 	    }
 	    if (pos)
 	    {
-		coloncmd(":sign place %d line=%d name=%d buffer=%d",
+		coloncmd(":sign place %d line=%ld name=%d buffer=%d",
 			   serNum, pos->lnum, typeNum, buf->bufp->b_fnum);
 		if (typeNum == curPCtype)
 		    coloncmd(":sign jump %d buffer=%d", serNum,
@@ -2425,7 +2429,7 @@
 				GUARDED) == 0)
 			    {
 				coloncmd(
-				    ":sign place %d line=%d name=%d buffer=%d",
+				    ":sign place %d line=%ld name=%d buffer=%d",
 				     guardId++, lnum, GUARDED,
 				     buf->bufp->b_fnum);
 			    }
@@ -2582,7 +2586,7 @@
     va_list ap;
 
     va_start(ap, cmd);
-    vsprintf(buf, cmd, ap);
+    vim_vsnprintf(buf, sizeof(buf), cmd, ap, NULL);
     va_end(ap);
 
     nbdebug(("    COLONCMD %s\n", buf));
@@ -2747,11 +2751,10 @@
  * cursor and sends it to the debugger for evaluation.  The debugger should
  * respond with a showBalloon command when there is a useful result.
  */
-/*ARGSUSED*/
     void
 netbeans_beval_cb(
 	BalloonEval	*beval,
-	int		 state)
+	int		 state UNUSED)
 {
     win_T	*wp;
     char_u	*text;
@@ -2924,44 +2927,26 @@
 }
 
 /*
- * Tell netbeans a file was closed.
+ * Tell netbeans that a file was deleted or wiped out.
  */
     void
-netbeans_file_closed(buf_T *bufp)
+netbeans_file_killed(buf_T *bufp)
 {
     int		bufno = nb_getbufno(bufp);
     nbbuf_T	*nbbuf = nb_get_buf(bufno);
     char	buffer[2*MAXPATHL];
 
-    if (!haveConnection || bufno < 0)
+    if (!haveConnection || bufno == -1)
 	return;
 
-    if (!netbeansCloseFile)
-    {
-	nbdebug(("Ignoring file_closed for %s. File was closed from IDE\n",
-		    bufp->b_ffname));
-	return;
-    }
-
-    nbdebug(("netbeans_file_closed:\n"));
-    nbdebug(("    Closing bufno: %d", bufno));
-    if (curbuf != NULL && curbuf != bufp)
-    {
-	nbdebug(("    Curbuf bufno:  %d\n", nb_getbufno(curbuf)));
-    }
-    else if (curbuf == bufp)
-    {
-	nbdebug(("    curbuf == bufp\n"));
-    }
-
-    if (bufno <= 0)
-	return;
+    nbdebug(("netbeans_file_killed:\n"));
+    nbdebug(("    Killing bufno: %d", bufno));
 
     sprintf(buffer, "%d:killed=%d\n", bufno, r_cmdno);
 
     nbdebug(("EVT: %s", buffer));
 
-    nb_send(buffer, "netbeans_file_closed");
+    nb_send(buffer, "netbeans_file_killed");
 
     if (nbbuf != NULL)
 	nbbuf->bufp = NULL;
@@ -3082,9 +3067,8 @@
 /*
  * Send netbeans an unmodufied command.
  */
-/*ARGSUSED*/
     void
-netbeans_unmodified(buf_T *bufp)
+netbeans_unmodified(buf_T *bufp UNUSED)
 {
 #if 0
     char_u	buf[128];
@@ -3391,13 +3375,12 @@
  * buf->signmapused[]	maps buffer-local annotation IDs to an index in
  *			globalsignmap[].
  */
-/*ARGSUSED*/
     static void
 addsigntype(
     nbbuf_T	*buf,
     int		typeNum,
     char_u	*typeName,
-    char_u	*tooltip,
+    char_u	*tooltip UNUSED,
     char_u	*glyphFile,
     int		use_fg,
     int		fg,
diff -Naur vim72.orig/src/normal.c vim72/src/normal.c
--- vim72.orig/src/normal.c	2008-07-31 21:03:08.000000000 +0100
+++ vim72/src/normal.c	2009-07-22 22:54:22.000000000 +0100
@@ -183,6 +183,8 @@
 static void	nv_cursorhold __ARGS((cmdarg_T *cap));
 #endif
 
+static char *e_noident = N_("E349: No identifier under cursor");
+
 /*
  * Function to be called for a Normal or Visual mode command.
  * The argument is a cmdarg_T.
@@ -491,14 +493,14 @@
     int		i;
 
     /* Fill the index table with a one to one relation. */
-    for (i = 0; i < NV_CMDS_SIZE; ++i)
+    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)
 	nv_cmd_idx[i] = i;
 
     /* Sort the commands by the command character.  */
     qsort((void *)&nv_cmd_idx, (size_t)NV_CMDS_SIZE, sizeof(short), nv_compare);
 
     /* Find the first entry that can't be indexed by the command character. */
-    for (i = 0; i < NV_CMDS_SIZE; ++i)
+    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)
 	if (i != nv_cmds[nv_cmd_idx[i]].cmd_char)
 	    break;
     nv_max_linear = i - 1;
@@ -559,11 +561,10 @@
 /*
  * Execute a command in Normal mode.
  */
-/*ARGSUSED*/
     void
 normal_cmd(oap, toplevel)
     oparg_T	*oap;
-    int		toplevel;		/* TRUE when called from main() */
+    int		toplevel UNUSED;	/* TRUE when called from main() */
 {
     cmdarg_T	ca;			/* command arguments */
     int		c;
@@ -578,6 +579,9 @@
     static int	old_mapped_len = 0;
 #endif
     int		idx;
+#ifdef FEAT_EVAL
+    int		set_prevcount = FALSE;
+#endif
 
     vim_memset(&ca, 0, sizeof(ca));	/* also resets ca.retval */
     ca.oap = oap;
@@ -613,7 +617,12 @@
     /* When not finishing an operator and no register name typed, reset the
      * count. */
     if (!finish_op && !oap->regname)
+    {
 	ca.opcount = 0;
+#ifdef FEAT_EVAL
+	set_prevcount = TRUE;
+#endif
+    }
 
 #ifdef FEAT_AUTOCMD
     /* Restore counts from before receiving K_CURSORHOLD.  This means after
@@ -641,10 +650,7 @@
      * Get the command character from the user.
      */
     c = safe_vgetc();
-
-#ifdef FEAT_LANGMAP
     LANGMAP_ADJUST(c, TRUE);
-#endif
 
 #ifdef FEAT_VISUAL
     /*
@@ -717,7 +723,15 @@
 	     * command, so that v:count can be used in an expression mapping
 	     * right after the count. */
 	    if (toplevel && stuff_empty())
-		set_vcount(ca.count0, ca.count0 == 0 ? 1 : ca.count0);
+	    {
+		long count = ca.count0;
+
+		/* multiply with ca.opcount the same way as below */
+		if (ca.opcount != 0)
+		    count = ca.opcount * (count == 0 ? 1 : count);
+		set_vcount(count, count == 0 ? 1 : count, set_prevcount);
+		set_prevcount = FALSE;  /* only set v:prevcount once */
+	    }
 #endif
 	    if (ctrl_w)
 	    {
@@ -726,9 +740,7 @@
 	    }
 	    ++no_zero_mapping;		/* don't map zero here */
 	    c = plain_vgetc();
-#ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(c, TRUE);
-#endif
 	    --no_zero_mapping;
 	    if (ctrl_w)
 	    {
@@ -751,9 +763,7 @@
 	    ++no_mapping;
 	    ++allow_keys;		/* no mapping for nchar, but keys */
 	    c = plain_vgetc();		/* get next character */
-#ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(c, TRUE);
-#endif
 	    --no_mapping;
 	    --allow_keys;
 #ifdef FEAT_CMDL_INFO
@@ -804,7 +814,7 @@
      * Only set v:count when called from main() and not a stuffed command.
      */
     if (toplevel && stuff_empty())
-	set_vcount(ca.count0, ca.count1);
+	set_vcount(ca.count0, ca.count1, set_prevcount);
 #endif
 
     /*
@@ -941,9 +951,7 @@
 	     * "gr", "g'" and "g`".
 	     */
 	    ca.nchar = plain_vgetc();
-#ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(ca.nchar, TRUE);
-#endif
 #ifdef FEAT_CMDL_INFO
 	    need_flushbuf |= add_to_showcmd(ca.nchar);
 #endif
@@ -1044,10 +1052,8 @@
 		}
 #endif
 
-#ifdef FEAT_LANGMAP
 		/* adjust chars > 127, except after "tTfFr" commands */
 		LANGMAP_ADJUST(*cp, !lang);
-#endif
 #ifdef FEAT_RIGHTLEFT
 		/* adjust Hebrew mapped char */
 		if (p_hkmap && lang && KeyTyped)
@@ -1132,7 +1138,8 @@
 	out_flush();
 #endif
 #ifdef FEAT_AUTOCMD
-    did_cursorhold = FALSE;
+    if (ca.cmdchar != K_IGNORE)
+	did_cursorhold = FALSE;
 #endif
 
     State = NORMAL;
@@ -2180,10 +2187,9 @@
 /*
  * Handle the "g@" operator: call 'operatorfunc'.
  */
-/*ARGSUSED*/
     static void
 op_function(oap)
-    oparg_T	*oap;
+    oparg_T	*oap UNUSED;
 {
 #ifdef FEAT_EVAL
     char_u	*(argv[1]);
@@ -3509,7 +3515,7 @@
 	if (find_type & FIND_STRING)
 	    EMSG(_("E348: No string under cursor"));
 	else
-	    EMSG(_("E349: No identifier under cursor"));
+	    EMSG(_(e_noident));
 	return 0;
     }
     ptr += col;
@@ -3701,13 +3707,13 @@
 #ifdef FEAT_VISUAL
     if (VIsual_active && !char_avail())
     {
-	int		i = lt(VIsual, curwin->w_cursor);
+	int		cursor_bot = lt(VIsual, curwin->w_cursor);
 	long		lines;
 	colnr_T		leftcol, rightcol;
 	linenr_T	top, bot;
 
 	/* Show the size of the Visual area. */
-	if (i)
+	if (cursor_bot)
 	{
 	    top = VIsual.lnum;
 	    bot = curwin->w_cursor.lnum;
@@ -3726,14 +3732,23 @@
 
 	if (VIsual_mode == Ctrl_V)
 	{
+#ifdef FEAT_LINEBREAK
+	    char_u *saved_sbr = p_sbr;
+
+	    /* Make 'sbr' empty for a moment to get the correct size. */
+	    p_sbr = empty_option;
+#endif
 	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
+#ifdef FEAT_LINEBREAK
+	    p_sbr = saved_sbr;
+#endif
 	    sprintf((char *)showcmd_buf, "%ldx%ld", lines,
 					      (long)(rightcol - leftcol + 1));
 	}
 	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
 	    sprintf((char *)showcmd_buf, "%ld", lines);
 	else
-	    sprintf((char *)showcmd_buf, "%ld", (long)(i
+	    sprintf((char *)showcmd_buf, "%ld", (long)(cursor_bot
 		    ? curwin->w_cursor.col - VIsual.col
 		    : VIsual.col - curwin->w_cursor.col) + (*p_sel != 'e'));
 	showcmd_buf[SHOWCMD_COLS] = NUL;	/* truncate */
@@ -4083,10 +4098,9 @@
  * Command character that doesn't do anything, but unlike nv_ignore() does
  * start edit().  Used for "startinsert" executed while starting up.
  */
-/*ARGSUSED */
     static void
 nv_nop(cap)
-    cmdarg_T	*cap;
+    cmdarg_T	*cap UNUSED;
 {
 }
 
@@ -4611,9 +4625,7 @@
 	    ++no_mapping;
 	    ++allow_keys;   /* no mapping for nchar, but allow key codes */
 	    nchar = plain_vgetc();
-#ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(nchar, TRUE);
-#endif
 	    --no_mapping;
 	    --allow_keys;
 #ifdef FEAT_CMDL_INFO
@@ -4969,9 +4981,7 @@
 		++no_mapping;
 		++allow_keys;   /* no mapping for nchar, but allow key codes */
 		nchar = plain_vgetc();
-#ifdef FEAT_LANGMAP
 		LANGMAP_ADJUST(nchar, TRUE);
-#endif
 		--no_mapping;
 		--allow_keys;
 #ifdef FEAT_CMDL_INFO
@@ -5228,7 +5238,7 @@
 	if (cap->oap->op_type != OP_NOP
 		&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count
 		    || cap->oap->start.col >
-					 STRLEN(ml_get(cap->oap->start.lnum))))
+			       (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))))
 	    clearopbeep(cap->oap);
     }
 }
@@ -5469,6 +5479,20 @@
 		STRCPY(buf, "he! ");
 	    else
 	    {
+		/* An external command will probably use an argument starting
+		 * with "-" as an option.  To avoid trouble we skip the "-". */
+		while (*ptr == '-' && n > 0)
+		{
+		    ++ptr;
+		    --n;
+		}
+		if (n == 0)
+		{
+		    EMSG(_(e_noident));	 /* found dashes only */
+		    vim_free(buf);
+		    return;
+		}
+
 		/* When a count is given, turn it into a range.  Is this
 		 * really what we want? */
 		isman = (STRCMP(kp, "man") == 0);
@@ -5511,37 +5535,59 @@
     /*
      * Now grab the chars in the identifier
      */
-    if (cmdchar == '*')
-	aux_ptr = (char_u *)(p_magic ? "/.*~[^$\\" : "/^$\\");
-    else if (cmdchar == '#')
-	aux_ptr = (char_u *)(p_magic ? "/?.*~[^$\\" : "/?^$\\");
-    else if (cmdchar == 'K' && !kp_help)
-	aux_ptr = (char_u *)" \t\\\"|!";
-    else
-	/* Don't escape spaces and Tabs in a tag with a backslash */
-	aux_ptr = (char_u *)"\\|\"";
-
-    p = buf + STRLEN(buf);
-    while (n-- > 0)
-    {
-	/* put a backslash before \ and some others */
-	if (vim_strchr(aux_ptr, *ptr) != NULL)
-	    *p++ = '\\';
-#ifdef FEAT_MBYTE
-	/* When current byte is a part of multibyte character, copy all bytes
-	 * of that character. */
-	if (has_mbyte)
+    if (cmdchar == 'K' && !kp_help)
+    {
+	/* Escape the argument properly for a shell command */
+	ptr = vim_strnsave(ptr, n);
+	p = vim_strsave_shellescape(ptr, TRUE);
+	vim_free(ptr);
+	if (p == NULL)
 	{
-	    int i;
-	    int len = (*mb_ptr2len)(ptr) - 1;
-
-	    for (i = 0; i < len && n >= 1; ++i, --n)
-		*p++ = *ptr++;
+	    vim_free(buf);
+	    return;
 	}
+	buf = (char_u *)vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);
+	if (buf == NULL)
+	{
+	    vim_free(buf);
+	    vim_free(p);
+	    return;
+	}
+	STRCAT(buf, p);
+	vim_free(p);
+    }
+    else
+    {
+	if (cmdchar == '*')
+	    aux_ptr = (char_u *)(p_magic ? "/.*~[^$\\" : "/^$\\");
+	else if (cmdchar == '#')
+	    aux_ptr = (char_u *)(p_magic ? "/?.*~[^$\\" : "/?^$\\");
+	else
+	    /* Don't escape spaces and Tabs in a tag with a backslash */
+	    aux_ptr = (char_u *)"\\|\"\n*?[";
+
+	p = buf + STRLEN(buf);
+	while (n-- > 0)
+	{
+	    /* put a backslash before \ and some others */
+	    if (vim_strchr(aux_ptr, *ptr) != NULL)
+		*p++ = '\\';
+#ifdef FEAT_MBYTE
+	    /* When current byte is a part of multibyte character, copy all
+	     * bytes of that character. */
+	    if (has_mbyte)
+	    {
+		int i;
+		int len = (*mb_ptr2len)(ptr) - 1;
+
+		for (i = 0; i < len && n >= 1; ++i, --n)
+		    *p++ = *ptr++;
+	    }
 #endif
-	*p++ = *ptr++;
+	    *p++ = *ptr++;
+	}
+	*p = NUL;
     }
-    *p = NUL;
 
     /*
      * Execute the command.
@@ -5767,7 +5813,10 @@
     for (n = cap->count1; n > 0; --n)
     {
 	if ((!PAST_LINE && oneright() == FAIL)
-		|| (PAST_LINE && *ml_get_cursor() == NUL))
+#ifdef FEAT_VISUAL
+		|| (PAST_LINE && *ml_get_cursor() == NUL)
+#endif
+		)
 	{
 	    /*
 	     *	  <Space> wraps to next line if 'whichwrap' has 's'.
@@ -6011,7 +6060,7 @@
 	    autowrite(curbuf, FALSE);
 	setpcmark();
 	(void)do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,
-					       P_HID(curbuf) ? ECMD_HIDE : 0);
+				       P_HID(curbuf) ? ECMD_HIDE : 0, curwin);
 	if (cap->nchar == 'F' && lnum >= 0)
 	{
 	    curwin->w_cursor.lnum = lnum;
@@ -6728,6 +6777,8 @@
     /* Visual mode "r" */
     if (VIsual_active)
     {
+	if (got_int)
+	    reset_VIsual();
 	nv_operator(cap);
 	return;
     }
@@ -7784,7 +7835,7 @@
 	else
 	    i = curwin->w_leftcol;
 	/* Go to the middle of the screen line.  When 'number' is on and lines
-	 * are wrapping the middle can be more to the left.*/
+	 * are wrapping the middle can be more to the left. */
 	if (cap->nchar == 'm')
 	    i += (W_WIDTH(curwin) - curwin_col_off()
 		    + ((curwin->w_p_wrap && i > 0)
@@ -9192,10 +9243,9 @@
 }
 
 #ifdef FEAT_SNIFF
-/*ARGSUSED*/
     static void
 nv_sniff(cap)
-    cmdarg_T	*cap;
+    cmdarg_T	*cap UNUSED;
 {
     ProcessSniffRequests();
 }
@@ -9211,10 +9261,9 @@
 #endif
 
 #ifdef FEAT_DND
-/*ARGSUSED*/
     static void
 nv_drop(cap)
-    cmdarg_T	*cap;
+    cmdarg_T	*cap UNUSED;
 {
     do_put('~', BACKWARD, 1L, PUT_CURSEND);
 }
@@ -9226,7 +9275,6 @@
  * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the
  * input buffer.  "did_cursorhold" is set to avoid retriggering.
  */
-/*ARGSUSED*/
     static void
 nv_cursorhold(cap)
     cmdarg_T	*cap;
diff -Naur vim72.orig/src/ops.c vim72/src/ops.c
--- vim72.orig/src/ops.c	2008-06-21 21:08:59.000000000 +0100
+++ vim72/src/ops.c	2009-07-22 22:54:23.000000000 +0100
@@ -72,11 +72,11 @@
  */
 struct block_def
 {
-    int		startspaces;	/* 'extra' cols of first char */
-    int		endspaces;	/* 'extra' cols of first char */
+    int		startspaces;	/* 'extra' cols before first char */
+    int		endspaces;	/* 'extra' cols after last char */
     int		textlen;	/* chars in block */
-    char_u	*textstart;	/* pointer to 1st char in block */
-    colnr_T	textcol;	/* cols of chars (at least part.) in block */
+    char_u	*textstart;	/* pointer to 1st char (partially) in block */
+    colnr_T	textcol;	/* index of chars (partially) in block */
     colnr_T	start_vcol;	/* start col of 1st char wholly inside block */
     colnr_T	end_vcol;	/* start col of 1st char wholly after block */
 #ifdef FEAT_VISUALEXTRA
@@ -382,18 +382,16 @@
 {
     int			left = (oap->op_type == OP_LSHIFT);
     int			oldstate = State;
-    int			total, split;
-    char_u		*newp, *oldp, *midp, *ptr;
+    int			total;
+    char_u		*newp, *oldp;
     int			oldcol = curwin->w_cursor.col;
     int			p_sw = (int)curbuf->b_p_sw;
     int			p_ts = (int)curbuf->b_p_ts;
     struct block_def	bd;
-    int			internal = 0;
     int			incr;
-    colnr_T		vcol, col = 0, ws_vcol;
+    colnr_T		ws_vcol;
     int			i = 0, j = 0;
     int			len;
-
 #ifdef FEAT_RIGHTLEFT
     int			old_p_ri = p_ri;
 
@@ -456,67 +454,90 @@
     }
     else /* left */
     {
-	vcol = oap->start_vcol;
-	/* walk vcol past ws to be removed */
-	for (midp = oldp + bd.textcol;
-	      vcol < (oap->start_vcol + total) && vim_iswhite(*midp); )
-	{
-	    incr = lbr_chartabsize_adv(&midp, (colnr_T)vcol);
-	    vcol += incr;
-	}
-	/* internal is the block-internal ws replacing a split TAB */
-	if (vcol > (oap->start_vcol + total))
-	{
-	    /* we have to split the TAB *(midp-1) */
-	    internal = vcol - (oap->start_vcol + total);
-	}
-	/* if 'expandtab' is not set, use TABs */
+	colnr_T	    destination_col;	/* column to which text in block will
+					   be shifted */
+	char_u	    *verbatim_copy_end;	/* end of the part of the line which is
+					   copied verbatim */
+	colnr_T	    verbatim_copy_width;/* the (displayed) width of this part
+					   of line */
+	unsigned    fill;		/* nr of spaces that replace a TAB */
+	unsigned    new_line_len;	/* the length of the line after the
+					   block shift */
+	size_t	    block_space_width;
+	size_t	    shift_amount;
+	char_u	    *non_white = bd.textstart;
+	colnr_T	    non_white_col;
 
-	split = bd.startspaces + internal;
-	if (split > 0)
-	{
-	    if (!curbuf->b_p_et)
-	    {
-		for (ptr = oldp, col = 0; ptr < oldp+bd.textcol; )
-		    col += lbr_chartabsize_adv(&ptr, (colnr_T)col);
+	/*
+	 * Firstly, let's find the first non-whitespace character that is
+	 * displayed after the block's start column and the character's column
+	 * number. Also, let's calculate the width of all the whitespace
+	 * characters that are displayed in the block and precede the searched
+	 * non-whitespace character.
+	 */
 
-		/* col+1 now equals the start col of the first char of the
-		 * block (may be < oap.start_vcol if we're splitting a TAB) */
-		i = ((col % p_ts) + split) / p_ts; /* number of tabs */
-	    }
-	    if (i)
-		j = ((col % p_ts) + split) % p_ts; /* number of spp */
-	    else
-		j = split;
-	}
+	/* If "bd.startspaces" is set, "bd.textstart" points to the character,
+	 * the part of which is displayed at the block's beginning. Let's start
+	 * searching from the next character. */
+	if (bd.startspaces)
+	    mb_ptr_adv(non_white);
 
-	newp = alloc_check(bd.textcol + i + j + (unsigned)STRLEN(midp) + 1);
-	if (newp == NULL)
-	    return;
-	vim_memset(newp, NUL, (size_t)(bd.textcol + i + j + STRLEN(midp) + 1));
+	/* The character's column is in "bd.start_vcol".  */
+	non_white_col = bd.start_vcol;
 
-	/* copy first part we want to keep */
-	mch_memmove(newp, oldp, (size_t)bd.textcol);
-	/* Now copy any TABS and spp to ensure correct alignment! */
-	while (vim_iswhite(*midp))
+	while (vim_iswhite(*non_white))
 	{
-	    if (*midp == TAB)
-		i++;
-	    else /*space */
-		j++;
-	    midp++;
+	    incr = lbr_chartabsize_adv(&non_white, non_white_col);
+	    non_white_col += incr;
 	}
-	/* We might have an extra TAB worth of spp now! */
-	if (j / p_ts && !curbuf->b_p_et)
+
+	block_space_width = non_white_col - oap->start_vcol;
+	/* We will shift by "total" or "block_space_width", whichever is less.
+	 */
+	shift_amount = (block_space_width < (size_t)total
+					 ? block_space_width : (size_t)total);
+
+	/* The column to which we will shift the text.  */
+	destination_col = (colnr_T)(non_white_col - shift_amount);
+
+	/* Now let's find out how much of the beginning of the line we can
+	 * reuse without modification.  */
+	verbatim_copy_end = bd.textstart;
+	verbatim_copy_width = bd.start_vcol;
+
+	/* If "bd.startspaces" is set, "bd.textstart" points to the character
+	 * preceding the block. We have to subtract its width to obtain its
+	 * column number.  */
+	if (bd.startspaces)
+	    verbatim_copy_width -= bd.start_char_vcols;
+	while (verbatim_copy_width < destination_col)
 	{
-	    i++;
-	    j -= p_ts;
+	    incr = lbr_chartabsize(verbatim_copy_end, verbatim_copy_width);
+	    if (verbatim_copy_width + incr > destination_col)
+		break;
+	    verbatim_copy_width += incr;
+	    mb_ptr_adv(verbatim_copy_end);
 	}
-	copy_chars(newp + bd.textcol, (size_t)i, TAB);
-	copy_spaces(newp + bd.textcol + i, (size_t)j);
 
-	/* the end */
-	STRMOVE(newp + STRLEN(newp), midp);
+	/* If "destination_col" is different from the width of the initial
+	 * part of the line that will be copied, it means we encountered a tab
+	 * character, which we will have to partly replace with spaces.  */
+	fill = destination_col - verbatim_copy_width;
+
+	/* The replacement line will consist of:
+	 * - the beginning of the original line up to "verbatim_copy_end",
+	 * - "fill" number of spaces,
+	 * - the rest of the line, pointed to by non_white.  */
+	new_line_len = (unsigned)(verbatim_copy_end - oldp)
+		       + fill
+		       + (unsigned)STRLEN(non_white) + 1;
+
+	newp = alloc_check(new_line_len);
+	if (newp == NULL)
+	    return;
+	mch_memmove(newp, oldp, (size_t)(verbatim_copy_end - oldp));
+	copy_spaces(newp + (verbatim_copy_end - oldp), (size_t)fill);
+	STRMOVE(newp + (verbatim_copy_end - oldp) + fill, non_white);
     }
     /* replace the line */
     ml_replace(curwin->w_cursor.lnum, newp, FALSE);
@@ -1122,6 +1143,8 @@
     return OK;
 }
 
+static int execreg_lastc = NUL;
+
 /*
  * execute a yank register: copy it into the stuff buffer
  *
@@ -1134,7 +1157,6 @@
     int	    addcr;		/* always add '\n' to end of line */
     int	    silent;		/* set "silent" flag in typeahead buffer */
 {
-    static int	lastc = NUL;
     long	i;
     char_u	*p;
     int		retval = OK;
@@ -1142,12 +1164,12 @@
 
     if (regname == '@')			/* repeat previous one */
     {
-	if (lastc == NUL)
+	if (execreg_lastc == NUL)
 	{
 	    EMSG(_("E748: No previously used register"));
 	    return FAIL;
 	}
-	regname = lastc;
+	regname = execreg_lastc;
     }
 					/* check for valid regname */
     if (regname == '%' || regname == '#' || !valid_yank_reg(regname, FALSE))
@@ -1155,7 +1177,7 @@
 	emsg_invreg(regname);
 	return FAIL;
     }
-    lastc = regname;
+    execreg_lastc = regname;
 
 #ifdef FEAT_CLIPBOARD
     regname = may_get_selection(regname);
@@ -2209,12 +2231,15 @@
     {
 	for (; pos.lnum <= oap->end.lnum; ++pos.lnum)
 	{
+	    int one_change;
+
 	    block_prep(oap, &bd, pos.lnum, FALSE);
 	    pos.col = bd.textcol;
-	    did_change = swapchars(oap->op_type, &pos, bd.textlen);
+	    one_change = swapchars(oap->op_type, &pos, bd.textlen);
+	    did_change |= one_change;
 
 # ifdef FEAT_NETBEANS_INTG
-	    if (usingNetbeans && did_change)
+	    if (usingNetbeans && one_change)
 	    {
 		char_u *ptr = ml_get_buf(curbuf, pos.lnum, FALSE);
 
@@ -4848,7 +4873,8 @@
  * - textlen includes the first/last char to be (partly) deleted
  * - start/endspaces is the number of columns that are taken by the
  *   first/last deleted char minus the number of columns that have to be
- *   deleted.  for yank and tilde:
+ *   deleted.
+ * for yank and tilde:
  * - textlen includes the first/last char to be wholly yanked
  * - start/endspaces is the number of columns of the first/last yanked char
  *   that are to be yanked.
@@ -5312,11 +5338,14 @@
 
     /* We only get here (hopefully) if line[0] == '"' */
     str = virp->vir_line + 1;
+
+    /* If the line starts with "" this is the y_previous register. */
     if (*str == '"')
     {
 	set_prev = TRUE;
 	str++;
     }
+
     if (!ASCII_ISALNUM(*str) && *str != '-')
     {
 	if (viminfo_error("E577: ", _("Illegal register name"), virp->vir_line))
@@ -5326,6 +5355,14 @@
     get_yank_register(*str++, FALSE);
     if (!force && y_current->y_array != NULL)
 	do_it = FALSE;
+
+    if (*str == '@')
+    {
+	/* "x@: register x used for @@ */
+	if (force || execreg_lastc == NUL)
+	    execreg_lastc = str[-1];
+    }
+
     size = 0;
     limit = 100;	/* Optimized for registers containing <= 100 lines */
     if (do_it)
@@ -5335,7 +5372,7 @@
 	vim_free(y_current->y_array);
 	array = y_current->y_array =
 		       (char_u **)alloc((unsigned)(limit * sizeof(char_u *)));
-	str = skipwhite(str);
+	str = skipwhite(skiptowhite(str));
 	if (STRNCMP(str, "CHAR", 4) == 0)
 	    y_current->y_type = MCHAR;
 #ifdef FEAT_VISUAL
@@ -5418,6 +5455,7 @@
     max_kbyte = get_viminfo_parameter('s');
     if (max_kbyte == 0)
 	return;
+
     for (i = 0; i < NUM_REGISTERS; i++)
     {
 	if (y_regs[i].y_array == NULL)
@@ -5472,7 +5510,10 @@
 	if (y_previous == &y_regs[i])
 	    fprintf(fp, "\"");
 	c = get_register_name(i);
-	fprintf(fp, "\"%c\t%s\t%d\n", c, type,
+	fprintf(fp, "\"%c", c);
+	if (c == execreg_lastc)
+	    fprintf(fp, "@");
+	fprintf(fp, "\t%s\t%d\n", type,
 #ifdef FEAT_VISUAL
 		    (int)y_regs[i].y_width
 #else
@@ -5550,6 +5591,29 @@
     if (dpy != NULL && str != NULL && motion_type >= 0
 					       && len < 1024*1024 && len > 0)
     {
+#ifdef FEAT_MBYTE
+	/* The CUT_BUFFER0 is supposed to always contain latin1.  Convert from
+	 * 'enc' when it is a multi-byte encoding.  When 'enc' is an 8-bit
+	 * encoding conversion usually doesn't work, so keep the text as-is.
+	 */
+	if (has_mbyte)
+	{
+	    char_u	*conv_str = str;
+	    vimconv_T	vc;
+
+	    vc.vc_type = CONV_NONE;
+	    if (convert_setup(&vc, p_enc, (char_u *)"latin1") == OK)
+	    {
+		conv_str = string_convert(&vc, str, (int*)&len);
+		if (conv_str != NULL)
+		{
+		    vim_free(str);
+		    str = conv_str;
+		}
+		convert_setup(&vc, NULL, NULL);
+	    }
+	}
+#endif
 	XStoreBuffer(dpy, (char *)str, (int)len, 0);
 	XFlush(dpy);
     }
@@ -6258,11 +6322,20 @@
 
 	    if (VIsual_mode == Ctrl_V)
 	    {
+#ifdef FEAT_LINEBREAK
+		char_u * saved_sbr = p_sbr;
+
+		/* Make 'sbr' empty for a moment to get the correct size. */
+		p_sbr = empty_option;
+#endif
 		oparg.is_VIsual = 1;
 		oparg.block_mode = TRUE;
 		oparg.op_type = OP_NOP;
 		getvcols(curwin, &min_pos, &max_pos,
 					  &oparg.start_vcol, &oparg.end_vcol);
+#ifdef FEAT_LINEBREAK
+		p_sbr = saved_sbr;
+#endif
 		if (curwin->w_curswant == MAXCOL)
 		    oparg.end_vcol = MAXCOL;
 		/* Swap the start, end vcol if needed */
@@ -6366,7 +6439,7 @@
 	    {
 		getvcols(curwin, &min_pos, &max_pos, &min_pos.col,
 								&max_pos.col);
-		sprintf((char *)buf1, _("%ld Cols; "),
+		vim_snprintf((char *)buf1, sizeof(buf1), _("%ld Cols; "),
 			(long)(oparg.end_vcol - oparg.start_vcol + 1));
 	    }
 	    else
@@ -6374,13 +6447,15 @@
 
 	    if (char_count_cursor == byte_count_cursor
 						  && char_count == byte_count)
-		sprintf((char *)IObuff, _("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes"),
+		vim_snprintf((char *)IObuff, IOSIZE,
+			_("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Bytes"),
 			buf1, line_count_selected,
 			(long)curbuf->b_ml.ml_line_count,
 			word_count_cursor, word_count,
 			byte_count_cursor, byte_count);
 	    else
-		sprintf((char *)IObuff, _("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes"),
+		vim_snprintf((char *)IObuff, IOSIZE,
+			_("Selected %s%ld of %ld Lines; %ld of %ld Words; %ld of %ld Chars; %ld of %ld Bytes"),
 			buf1, line_count_selected,
 			(long)curbuf->b_ml.ml_line_count,
 			word_count_cursor, word_count,
@@ -6392,20 +6467,22 @@
 	{
 	    p = ml_get_curline();
 	    validate_virtcol();
-	    col_print(buf1, (int)curwin->w_cursor.col + 1,
+	    col_print(buf1, sizeof(buf1), (int)curwin->w_cursor.col + 1,
 		    (int)curwin->w_virtcol + 1);
-	    col_print(buf2, (int)STRLEN(p), linetabsize(p));
+	    col_print(buf2, sizeof(buf2), (int)STRLEN(p), linetabsize(p));
 
 	    if (char_count_cursor == byte_count_cursor
 		    && char_count == byte_count)
-		sprintf((char *)IObuff, _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld"),
+		vim_snprintf((char *)IObuff, IOSIZE,
+		    _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Byte %ld of %ld"),
 		    (char *)buf1, (char *)buf2,
 		    (long)curwin->w_cursor.lnum,
 		    (long)curbuf->b_ml.ml_line_count,
 		    word_count_cursor, word_count,
 		    byte_count_cursor, byte_count);
 	    else
-		sprintf((char *)IObuff, _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld"),
+		vim_snprintf((char *)IObuff, IOSIZE,
+		    _("Col %s of %s; Line %ld of %ld; Word %ld of %ld; Char %ld of %ld; Byte %ld of %ld"),
 		    (char *)buf1, (char *)buf2,
 		    (long)curwin->w_cursor.lnum,
 		    (long)curbuf->b_ml.ml_line_count,
diff -Naur vim72.orig/src/option.c vim72/src/option.c
--- vim72.orig/src/option.c	2008-07-18 14:05:33.000000000 +0100
+++ vim72/src/option.c	2009-07-22 22:54:24.000000000 +0100
@@ -387,6 +387,9 @@
     char_u	*def_val[2];	/* default values for variable (vi and vim) */
 #ifdef FEAT_EVAL
     scid_T	scriptID;	/* script in which the option was last set */
+# define SCRIPTID_INIT , 0
+#else
+# define SCRIPTID_INIT
 #endif
 };
 
@@ -400,8 +403,9 @@
 #define P_NUM		0x02	/* the option is numeric */
 #define P_STRING	0x04	/* the option is a string */
 #define P_ALLOCED	0x08	/* the string option is in allocated memory,
-				    must use vim_free() when assigning new
-				    value. Not set if default is the same. */
+				   must use free_string_option() when
+				   assigning new value. Not set if default is
+				   the same. */
 #define P_EXPAND	0x10	/* environment expansion.  NOTE: P_EXPAND can
 				   never be used for local or hidden options! */
 #define P_NODEFAULT	0x40	/* don't set to default value */
@@ -477,7 +481,7 @@
 #else
 			    (char_u *)224L,
 #endif
-					    (char_u *)0L}},
+					    (char_u *)0L} SCRIPTID_INIT},
     {"antialias",   "anti", P_BOOL|P_VI_DEF|P_VIM|P_RCLR,
 #if defined(FEAT_GUI) && defined(MACOS_X)
 			    (char_u *)&p_antialias, PV_NONE,
@@ -486,35 +490,35 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)FALSE}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"arabic",	    "arab", P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_ARABIC
 			    (char_u *)VAR_WIN, PV_ARAB,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"arabicshape", "arshape", P_BOOL|P_VI_DEF|P_VIM|P_RCLR,
 #ifdef FEAT_ARABIC
 			    (char_u *)&p_arshape, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"allowrevins", "ari",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_ari, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"altkeymap",   "akm",  P_BOOL|P_VI_DEF,
 #ifdef FEAT_FKMAP
 			    (char_u *)&p_altkeymap, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"ambiwidth",  "ambw",  P_STRING|P_VI_DEF|P_RCLR,
 #if defined(FEAT_MBYTE)
 			    (char_u *)&p_ambw, PV_NONE,
@@ -523,27 +527,27 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
 #ifdef FEAT_AUTOCHDIR
     {"autochdir",  "acd",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_acd, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
 #endif
     {"autoindent",  "ai",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ai, PV_AI,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"autoprint",   "ap",   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"autoread",    "ar",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ar, PV_AR,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"autowrite",   "aw",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_aw, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"autowriteall","awa",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_awa, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"background",  "bg",   P_STRING|P_VI_DEF|P_RCLR,
 			    (char_u *)&p_bg, PV_NONE,
 			    {
@@ -552,13 +556,13 @@
 #else
 			    (char_u *)"light",
 #endif
-					    (char_u *)0L}},
+					    (char_u *)0L} SCRIPTID_INIT},
     {"backspace",   "bs",   P_STRING|P_VI_DEF|P_VIM|P_COMMA|P_NODUP,
 			    (char_u *)&p_bs, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"backup",	    "bk",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_bk, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"backupcopy",  "bkc",  P_STRING|P_VIM|P_COMMA|P_NODUP,
 			    (char_u *)&p_bkc, PV_NONE,
 #ifdef UNIX
@@ -566,10 +570,10 @@
 #else
 			    {(char_u *)"auto", (char_u *)"auto"}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"backupdir",   "bdir", P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP|P_SECURE,
 			    (char_u *)&p_bdir, PV_NONE,
-			    {(char_u *)DFLT_BDIR, (char_u *)0L}},
+			    {(char_u *)DFLT_BDIR, (char_u *)0L} SCRIPTID_INIT},
     {"backupext",   "bex",  P_STRING|P_VI_DEF|P_NFNAME,
 			    (char_u *)&p_bex, PV_NONE,
 			    {
@@ -578,7 +582,7 @@
 #else
 			    (char_u *)"~",
 #endif
-					    (char_u *)0L}},
+					    (char_u *)0L} SCRIPTID_INIT},
     {"backupskip",  "bsk",  P_STRING|P_VI_DEF|P_COMMA,
 #ifdef FEAT_WILDIGN
 			    (char_u *)&p_bsk, PV_NONE,
@@ -587,40 +591,40 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
 #ifdef FEAT_BEVAL
     {"balloondelay","bdlay",P_NUM|P_VI_DEF,
 			    (char_u *)&p_bdlay, PV_NONE,
-			    {(char_u *)600L, (char_u *)0L}},
+			    {(char_u *)600L, (char_u *)0L} SCRIPTID_INIT},
     {"ballooneval", "beval",P_BOOL|P_VI_DEF|P_NO_MKRC,
 			    (char_u *)&p_beval, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
 # ifdef FEAT_EVAL
     {"balloonexpr", "bexpr", P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
 			    (char_u *)&p_bexpr, PV_BEXPR,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
 # endif
 #endif
     {"beautify",    "bf",   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"binary",	    "bin",  P_BOOL|P_VI_DEF|P_RSTAT,
 			    (char_u *)&p_bin, PV_BIN,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"bioskey",	    "biosk",P_BOOL|P_VI_DEF,
 #ifdef MSDOS
 			    (char_u *)&p_biosk, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"bomb",	    NULL,   P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_bomb, PV_BOMB,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"breakat",	    "brk",  P_STRING|P_VI_DEF|P_RALL|P_FLAGLIST,
 #ifdef FEAT_LINEBREAK
 			    (char_u *)&p_breakat, PV_NONE,
@@ -629,7 +633,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"browsedir",   "bsdir",P_STRING|P_VI_DEF,
 #ifdef FEAT_BROWSE
 			    (char_u *)&p_bsdir, PV_NONE,
@@ -638,7 +642,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"bufhidden",   "bh",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
 #if defined(FEAT_QUICKFIX)
 			    (char_u *)&p_bh, PV_BH,
@@ -647,11 +651,11 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"buflisted",   "bl",   P_BOOL|P_VI_DEF|P_NOGLOB,
 			    (char_u *)&p_bl, PV_BL,
 			    {(char_u *)1L, (char_u *)0L}
-			    },
+			    SCRIPTID_INIT},
     {"buftype",	    "bt",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
 #if defined(FEAT_QUICKFIX)
 			    (char_u *)&p_bt, PV_BT,
@@ -660,7 +664,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"casemap",	    "cmp",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_cmp, PV_NONE,
@@ -669,7 +673,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cdpath",	    "cd",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_SEARCHPATH
 			    (char_u *)&p_cdpath, PV_NONE,
@@ -678,7 +682,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cedit",	    NULL,   P_STRING,
 #ifdef FEAT_CMDWIN
 			    (char_u *)&p_cedit, PV_NONE,
@@ -687,7 +691,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"charconvert",  "ccv", P_STRING|P_VI_DEF|P_SECURE,
 #if defined(FEAT_MBYTE) && defined(FEAT_EVAL)
 			    (char_u *)&p_ccv, PV_NONE,
@@ -696,14 +700,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cindent",	    "cin",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_CINDENT
 			    (char_u *)&p_cin, PV_CIN,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"cinkeys",	    "cink", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_CINDENT
 			    (char_u *)&p_cink, PV_CINK,
@@ -712,14 +716,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cinoptions",  "cino", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_CINDENT
 			    (char_u *)&p_cino, PV_CINO,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"cinwords",    "cinw", P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)
 			    (char_u *)&p_cinw, PV_CINW,
@@ -729,7 +733,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"clipboard",   "cb",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_CLIPBOARD
 			    (char_u *)&p_cb, PV_NONE,
@@ -743,20 +747,20 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cmdheight",   "ch",   P_NUM|P_VI_DEF|P_RALL,
 			    (char_u *)&p_ch, PV_NONE,
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"cmdwinheight", "cwh", P_NUM|P_VI_DEF,
 #ifdef FEAT_CMDWIN
 			    (char_u *)&p_cwh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)7L, (char_u *)0L}},
+			    {(char_u *)7L, (char_u *)0L} SCRIPTID_INIT},
     {"columns",	    "co",   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
 			    (char_u *)&Columns, PV_NONE,
-			    {(char_u *)80L, (char_u *)0L}},
+			    {(char_u *)80L, (char_u *)0L} SCRIPTID_INIT},
     {"comments",    "com",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_COMMENTS
 			    (char_u *)&p_com, PV_COM,
@@ -766,7 +770,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"commentstring", "cms", P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_FOLDING
 			    (char_u *)&p_cms, PV_CMS,
@@ -775,12 +779,12 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
 			    /* P_PRI_MKRC isn't needed here, optval_default()
 			     * always returns TRUE for 'compatible' */
     {"compatible",  "cp",   P_BOOL|P_RALL,
 			    (char_u *)&p_cp, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)FALSE}},
+			    {(char_u *)TRUE, (char_u *)FALSE} SCRIPTID_INIT},
     {"complete",    "cpt",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_cpt, PV_CPT,
@@ -789,7 +793,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"completefunc", "cfu", P_STRING|P_ALLOCED|P_VI_DEF|P_SECURE,
 #ifdef FEAT_COMPL_FUNC
 			    (char_u *)&p_cfu, PV_CFU,
@@ -798,7 +802,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"completeopt",   "cot",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_cot, PV_NONE,
@@ -807,34 +811,35 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"confirm",     "cf",   P_BOOL|P_VI_DEF,
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
 			    (char_u *)&p_confirm, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"conskey",	    "consk",P_BOOL|P_VI_DEF,
 #ifdef MSDOS
 			    (char_u *)&p_consk, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"copyindent",  "ci",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_ci, PV_CI,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"cpoptions",   "cpo",  P_STRING|P_VIM|P_RALL|P_FLAGLIST,
 			    (char_u *)&p_cpo, PV_NONE,
-			    {(char_u *)CPO_VI, (char_u *)CPO_VIM}},
+			    {(char_u *)CPO_VI, (char_u *)CPO_VIM}
+			    SCRIPTID_INIT},
     {"cscopepathcomp", "cspc", P_NUM|P_VI_DEF|P_VIM,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_cspc, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"cscopeprg",   "csprg", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_csprg, PV_NONE,
@@ -843,7 +848,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cscopequickfix", "csqf", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #if defined(FEAT_CSCOPE) && defined(FEAT_QUICKFIX)
 			    (char_u *)&p_csqf, PV_NONE,
@@ -852,45 +857,45 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"cscopetag",   "cst",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_cst, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"cscopetagorder", "csto", P_NUM|P_VI_DEF|P_VIM,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_csto, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"cscopeverbose", "csverb", P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_CSCOPE
 			    (char_u *)&p_csverbose, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"cursorcolumn", "cuc", P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_SYN_HL
 			    (char_u *)VAR_WIN, PV_CUC,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"cursorline",   "cul", P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_SYN_HL
 			    (char_u *)VAR_WIN, PV_CUL,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"debug",	    NULL,   P_STRING|P_VI_DEF,
 			    (char_u *)&p_debug, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"define",	    "def",  P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_FIND_ID
 			    (char_u *)&p_def, PV_DEF,
@@ -899,28 +904,28 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"delcombine", "deco",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_deco, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"dictionary",  "dict", P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_dict, PV_DICT,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"diff",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN|P_NOGLOB,
 #ifdef FEAT_DIFF
 			    (char_u *)VAR_WIN, PV_DIFF,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"diffexpr",    "dex",  P_STRING|P_VI_DEF|P_SECURE,
 #if defined(FEAT_DIFF) && defined(FEAT_EVAL)
 			    (char_u *)&p_dex, PV_NONE,
@@ -929,7 +934,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"diffopt",	    "dip",  P_STRING|P_ALLOCED|P_VI_DEF|P_RWIN|P_COMMA|P_NODUP,
 #ifdef FEAT_DIFF
 			    (char_u *)&p_dip, PV_NONE,
@@ -938,20 +943,20 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)NULL}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"digraph",	    "dg",   P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_DIGRAPHS
 			    (char_u *)&p_dg, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"directory",   "dir",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP|P_SECURE,
 			    (char_u *)&p_dir, PV_NONE,
-			    {(char_u *)DFLT_DIR, (char_u *)0L}},
+			    {(char_u *)DFLT_DIR, (char_u *)0L} SCRIPTID_INIT},
     {"display",	    "dy",   P_STRING|P_VI_DEF|P_COMMA|P_RALL|P_NODUP,
 			    (char_u *)&p_dy, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"eadirection", "ead",  P_STRING|P_VI_DEF,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)&p_ead, PV_NONE,
@@ -960,10 +965,10 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"edcompatible","ed",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ed, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"encoding",    "enc",  P_STRING|P_VI_DEF|P_RCLR,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_enc, PV_NONE,
@@ -972,19 +977,19 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"endofline",   "eol",  P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
 			    (char_u *)&p_eol, PV_EOL,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"equalalways", "ea",   P_BOOL|P_VI_DEF|P_RALL,
 			    (char_u *)&p_ea, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"equalprg",    "ep",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_ep, PV_EP,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"errorbells",  "eb",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_eb, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"errorfile",   "ef",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_ef, PV_NONE,
@@ -993,32 +998,32 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"errorformat", "efm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_efm, PV_EFM,
-			    {(char_u *)DFLT_EFM, (char_u *)0L},
+			    {(char_u *)DFLT_EFM, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"esckeys",	    "ek",   P_BOOL|P_VIM,
 			    (char_u *)&p_ek, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"eventignore", "ei",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_AUTOCMD
 			    (char_u *)&p_ei, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"expandtab",   "et",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_et, PV_ET,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"exrc",	    "ex",   P_BOOL|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_exrc, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"fileencoding","fenc", P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_RBUF|P_NO_MKRC,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_fenc, PV_FENC,
@@ -1027,7 +1032,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"fileencodings","fencs", P_STRING|P_VI_DEF|P_COMMA,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_fencs, PV_NONE,
@@ -1036,13 +1041,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"fileformat",  "ff",   P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_NO_MKRC,
 			    (char_u *)&p_ff, PV_FF,
-			    {(char_u *)DFLT_FF, (char_u *)0L}},
+			    {(char_u *)DFLT_FF, (char_u *)0L} SCRIPTID_INIT},
     {"fileformats", "ffs",  P_STRING|P_VIM|P_COMMA|P_NODUP,
 			    (char_u *)&p_ffs, PV_NONE,
-			    {(char_u *)DFLT_FFS_VI, (char_u *)DFLT_FFS_VIM}},
+			    {(char_u *)DFLT_FFS_VI, (char_u *)DFLT_FFS_VIM}
+			    SCRIPTID_INIT},
     {"filetype",    "ft",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB|P_NFNAME,
 #ifdef FEAT_AUTOCMD
 			    (char_u *)&p_ft, PV_FT,
@@ -1051,7 +1057,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"fillchars",   "fcs",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
 #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
 			    (char_u *)&p_fcs, PV_NONE,
@@ -1060,27 +1066,27 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"fkmap",	    "fk",   P_BOOL|P_VI_DEF,
 #ifdef FEAT_FKMAP
 			    (char_u *)&p_fkmap, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"flash",	    "fl",   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
 #ifdef FEAT_FOLDING
     {"foldclose",   "fcl",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP|P_RWIN,
 			    (char_u *)&p_fcl, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"foldcolumn",  "fdc",  P_NUM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDC,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"foldenable",  "fen",  P_BOOL|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FEN,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"foldexpr",    "fde",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
 # ifdef FEAT_EVAL
 			    (char_u *)VAR_WIN, PV_FDE,
@@ -1089,33 +1095,34 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 # endif
-			    },
+			    SCRIPTID_INIT},
     {"foldignore",  "fdi",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDI,
-			    {(char_u *)"#", (char_u *)NULL}},
+			    {(char_u *)"#", (char_u *)NULL} SCRIPTID_INIT},
     {"foldlevel",   "fdl",  P_NUM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDL,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"foldlevelstart","fdls", P_NUM|P_VI_DEF,
 			    (char_u *)&p_fdls, PV_NONE,
-			    {(char_u *)-1L, (char_u *)0L}},
+			    {(char_u *)-1L, (char_u *)0L} SCRIPTID_INIT},
     {"foldmarker",  "fmr",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|
 						       P_RWIN|P_COMMA|P_NODUP,
 			    (char_u *)VAR_WIN, PV_FMR,
-			    {(char_u *)"{{{,}}}", (char_u *)NULL}},
+			    {(char_u *)"{{{,}}}", (char_u *)NULL}
+			    SCRIPTID_INIT},
     {"foldmethod",  "fdm",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDM,
-			    {(char_u *)"manual", (char_u *)NULL}},
+			    {(char_u *)"manual", (char_u *)NULL} SCRIPTID_INIT},
     {"foldminlines","fml",  P_NUM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FML,
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"foldnestmax", "fdn",  P_NUM|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_FDN,
-			    {(char_u *)20L, (char_u *)0L}},
+			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
     {"foldopen",    "fdo",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_fdo, PV_NONE,
 		 {(char_u *)"block,hor,mark,percent,quickfix,search,tag,undo",
-							       (char_u *)0L}},
+						 (char_u *)0L} SCRIPTID_INIT},
     {"foldtext",    "fdt",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
 # ifdef FEAT_EVAL
 			    (char_u *)VAR_WIN, PV_FDT,
@@ -1124,7 +1131,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 # endif
-			    },
+			    SCRIPTID_INIT},
 #endif
     {"formatexpr", "fex",   P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
 #ifdef FEAT_EVAL
@@ -1134,16 +1141,18 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"formatoptions","fo",  P_STRING|P_ALLOCED|P_VIM|P_FLAGLIST,
 			    (char_u *)&p_fo, PV_FO,
-			    {(char_u *)DFLT_FO_VI, (char_u *)DFLT_FO_VIM}},
+			    {(char_u *)DFLT_FO_VI, (char_u *)DFLT_FO_VIM}
+			    SCRIPTID_INIT},
     {"formatlistpat","flp", P_STRING|P_ALLOCED|P_VI_DEF,
 			    (char_u *)&p_flp, PV_FLP,
-			    {(char_u *)"^\\s*\\d\\+[\\]:.)}\\t ]\\s*", (char_u *)0L}},
+			    {(char_u *)"^\\s*\\d\\+[\\]:.)}\\t ]\\s*",
+						 (char_u *)0L} SCRIPTID_INIT},
     {"formatprg",   "fp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_fp, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"fsync",       "fs",   P_BOOL|P_SECURE|P_VI_DEF,
 #ifdef HAVE_FSYNC
 			    (char_u *)&p_fs, PV_NONE,
@@ -1152,22 +1161,22 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"gdefault",    "gd",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_gd, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"graphic",	    "gr",   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"grepformat",  "gfm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_gefm, PV_NONE,
-			    {(char_u *)DFLT_GREPFORMAT, (char_u *)0L},
+			    {(char_u *)DFLT_GREPFORMAT, (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"grepprg",	    "gp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_gp, PV_GP,
@@ -1185,15 +1194,15 @@
 			    (char_u *)"SEARCH/NUMBERS ",
 #   else
 			    (char_u *)"grep -n ",
-#endif
-#endif
+#   endif
+#  endif
 # endif
-			    (char_u *)0L},
+			    (char_u *)0L}
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"guicursor",    "gcr",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef CURSOR_SHAPE
 			    (char_u *)&p_guicursor, PV_NONE,
@@ -1208,7 +1217,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guifont",	    "gfn",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
 #ifdef FEAT_GUI
 			    (char_u *)&p_guifont, PV_NONE,
@@ -1217,7 +1226,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guifontset",  "gfs",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA,
 #if defined(FEAT_GUI) && defined(FEAT_XFONTSET)
 			    (char_u *)&p_guifontset, PV_NONE,
@@ -1226,7 +1235,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guifontwide", "gfw",  P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
 #if defined(FEAT_GUI) && defined(FEAT_MBYTE)
 			    (char_u *)&p_guifontwide, PV_NONE,
@@ -1235,14 +1244,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guiheadroom", "ghr",  P_NUM|P_VI_DEF,
 #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
 			    (char_u *)&p_ghr, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)50L, (char_u *)0L}},
+			    {(char_u *)50L, (char_u *)0L} SCRIPTID_INIT},
     {"guioptions",  "go",   P_STRING|P_VI_DEF|P_RALL|P_FLAGLIST,
 #if defined(FEAT_GUI)
 			    (char_u *)&p_go, PV_NONE,
@@ -1255,14 +1264,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guipty",	    NULL,   P_BOOL|P_VI_DEF,
 #if defined(FEAT_GUI)
 			    (char_u *)&p_guipty, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"guitablabel",  "gtl", P_STRING|P_VI_DEF|P_RWIN,
 #if defined(FEAT_GUI_TABLINE)
 			    (char_u *)&p_gtl, PV_NONE,
@@ -1271,7 +1280,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"guitabtooltip",  "gtt", P_STRING|P_VI_DEF|P_RWIN,
 #if defined(FEAT_GUI_TABLINE)
 			    (char_u *)&p_gtt, PV_NONE,
@@ -1280,20 +1289,21 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-				    },
+			    SCRIPTID_INIT},
     {"hardtabs",    "ht",   P_NUM|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"helpfile",    "hf",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_hf, PV_NONE,
-			    {(char_u *)DFLT_HELPFILE, (char_u *)0L}},
+			    {(char_u *)DFLT_HELPFILE, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"helpheight",  "hh",   P_NUM|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_hh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)20L, (char_u *)0L}},
+			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
     {"helplang",    "hlg",  P_STRING|P_VI_DEF|P_COMMA,
 #ifdef FEAT_MULTI_LANG
 			    (char_u *)&p_hlg, PV_NONE,
@@ -1302,64 +1312,65 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-    },
+			    SCRIPTID_INIT},
     {"hidden",	    "hid",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_hid, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"highlight",   "hl",   P_STRING|P_VI_DEF|P_RCLR|P_COMMA|P_NODUP,
 			    (char_u *)&p_hl, PV_NONE,
-			    {(char_u *)HIGHLIGHT_INIT, (char_u *)0L}},
+			    {(char_u *)HIGHLIGHT_INIT, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"history",	    "hi",   P_NUM|P_VIM,
 			    (char_u *)&p_hi, PV_NONE,
-			    {(char_u *)0L, (char_u *)20L}},
+			    {(char_u *)0L, (char_u *)20L} SCRIPTID_INIT},
     {"hkmap",	    "hk",   P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_hkmap, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"hkmapp",	    "hkp",  P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_hkmapp, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"hlsearch",    "hls",  P_BOOL|P_VI_DEF|P_VIM|P_RALL,
 			    (char_u *)&p_hls, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"icon",	    NULL,   P_BOOL|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_icon, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"iconstring",  NULL,   P_STRING|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_iconstring, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"ignorecase",  "ic",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ic, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"imactivatekey","imak",P_STRING|P_VI_DEF,
 #if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
 			    (char_u *)&p_imak, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"imcmdline",   "imc",  P_BOOL|P_VI_DEF,
 #ifdef USE_IM_CONTROL
 			    (char_u *)&p_imcmdline, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"imdisable",   "imd",  P_BOOL|P_VI_DEF,
 #ifdef USE_IM_CONTROL
 			    (char_u *)&p_imdisable, PV_NONE,
@@ -1371,7 +1382,7 @@
 #else
 			    {(char_u *)FALSE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"iminsert",    "imi",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_iminsert, PV_IMI,
 #ifdef B_IMODE_IM
@@ -1379,7 +1390,7 @@
 #else
 			    {(char_u *)B_IMODE_NONE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"imsearch",    "ims",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_imsearch, PV_IMS,
 #ifdef B_IMODE_IM
@@ -1387,7 +1398,7 @@
 #else
 			    {(char_u *)B_IMODE_NONE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"include",	    "inc",  P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_FIND_ID
 			    (char_u *)&p_inc, PV_INC,
@@ -1396,7 +1407,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"includeexpr", "inex", P_STRING|P_ALLOCED|P_VI_DEF,
 #if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)
 			    (char_u *)&p_inex, PV_INEX,
@@ -1405,10 +1416,10 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"incsearch",   "is",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_is, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"indentexpr", "inde",  P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
 #if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
 			    (char_u *)&p_inde, PV_INDE,
@@ -1417,7 +1428,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"indentkeys", "indk",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 #if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
 			    (char_u *)&p_indk, PV_INDK,
@@ -1426,13 +1437,13 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"infercase",   "inf",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_inf, PV_INF,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"insertmode",  "im",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_im, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"isfname",	    "isf",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_isf, PV_NONE,
 			    {
@@ -1455,7 +1466,7 @@
 #  endif
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"isident",	    "isi",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_isi, PV_NONE,
 			    {
@@ -1472,7 +1483,7 @@
 			    (char_u *)"@,48-57,_,192-255",
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"iskeyword",   "isk",  P_STRING|P_ALLOCED|P_VIM|P_COMMA|P_NODUP,
 			    (char_u *)&p_isk, PV_ISK,
 			    {
@@ -1491,7 +1502,7 @@
 				ISK_LATIN1
 # endif
 #endif
-				}},
+			    } SCRIPTID_INIT},
     {"isprint",	    "isp",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
 			    (char_u *)&p_isp, PV_NONE,
 			    {
@@ -1507,10 +1518,10 @@
 			    ISP_LATIN1,
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"joinspaces",  "js",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_js, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"key",	    NULL,   P_STRING|P_ALLOCED|P_VI_DEF|P_NO_MKRC,
 #ifdef FEAT_CRYPT
 			    (char_u *)&p_key, PV_KEY,
@@ -1519,7 +1530,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"keymap",	    "kmp",  P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF|P_RSTAT|P_NFNAME|P_PRI_MKRC,
 #ifdef FEAT_KEYMAP
 			    (char_u *)&p_keymap, PV_KMAP,
@@ -1528,14 +1539,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #endif
-	},
+			    SCRIPTID_INIT},
     {"keymodel",    "km",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_VISUAL
 			    (char_u *)&p_km, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"keywordprg",  "kp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_kp, PV_KP,
 			    {
@@ -1556,7 +1567,7 @@
 # endif
 #endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"langmap",     "lmap", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_LANGMAP
 			    (char_u *)&p_langmap, PV_NONE,
@@ -1565,31 +1576,31 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL,
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"langmenu",    "lm",   P_STRING|P_VI_DEF|P_NFNAME,
 #if defined(FEAT_MENU) && defined(FEAT_MULTI_LANG)
 			    (char_u *)&p_lm, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"laststatus",  "ls",   P_NUM|P_VI_DEF|P_RALL,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_ls, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"lazyredraw",  "lz",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_lz, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"linebreak",   "lbr",  P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_LINEBREAK
 			    (char_u *)VAR_WIN, PV_LBR,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"lines",	    NULL,   P_NUM|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RCLR,
 			    (char_u *)&Rows, PV_NONE,
 			    {
@@ -1598,7 +1609,7 @@
 #else
 			    (char_u *)24L,
 #endif
-					    (char_u *)0L}},
+					    (char_u *)0L} SCRIPTID_INIT},
     {"linespace",   "lsp",  P_NUM|P_VI_DEF|P_RCLR,
 #ifdef FEAT_GUI
 			    (char_u *)&p_linespace, PV_NONE,
@@ -1610,14 +1621,14 @@
 #else
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"lisp",	    NULL,   P_BOOL|P_VI_DEF,
 #ifdef FEAT_LISP
 			    (char_u *)&p_lisp, PV_LISP,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"lispwords",   "lw",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_LISP
 			    (char_u *)&p_lispwords, PV_NONE,
@@ -1626,24 +1637,24 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)"", (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"list",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_LIST,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"listchars",   "lcs",  P_STRING|P_VI_DEF|P_RALL|P_COMMA|P_NODUP,
 			    (char_u *)&p_lcs, PV_NONE,
-			    {(char_u *)"eol:$", (char_u *)0L}},
+			    {(char_u *)"eol:$", (char_u *)0L} SCRIPTID_INIT},
     {"loadplugins", "lpl",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_lpl, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
 #ifdef FEAT_GUI_MAC
     {"macatsui",    NULL,   P_BOOL|P_VI_DEF|P_RCLR,
 			    (char_u *)&p_macatsui, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
 #endif
     {"magic",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_magic, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"makeef",	    "mef",  P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_mef, PV_NONE,
@@ -1652,7 +1663,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"makeprg",	    "mp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_mp, PV_MP,
@@ -1665,49 +1676,52 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"matchpairs",  "mps",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_mps, PV_MPS,
-			    {(char_u *)"(:),{:},[:]", (char_u *)0L}},
+			    {(char_u *)"(:),{:},[:]", (char_u *)0L}
+			    SCRIPTID_INIT},
     {"matchtime",   "mat",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_mat, PV_NONE,
-			    {(char_u *)5L, (char_u *)0L}},
+			    {(char_u *)5L, (char_u *)0L} SCRIPTID_INIT},
     {"maxcombine",  "mco",  P_NUM|P_VI_DEF,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_mco, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)2, (char_u *)0L}},
+			    {(char_u *)2, (char_u *)0L} SCRIPTID_INIT},
     {"maxfuncdepth", "mfd", P_NUM|P_VI_DEF,
 #ifdef FEAT_EVAL
 			    (char_u *)&p_mfd, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)100L, (char_u *)0L}},
+			    {(char_u *)100L, (char_u *)0L} SCRIPTID_INIT},
     {"maxmapdepth", "mmd",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_mmd, PV_NONE,
-			    {(char_u *)1000L, (char_u *)0L}},
+			    {(char_u *)1000L, (char_u *)0L} SCRIPTID_INIT},
     {"maxmem",	    "mm",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_mm, PV_NONE,
-			    {(char_u *)DFLT_MAXMEM, (char_u *)0L}},
+			    {(char_u *)DFLT_MAXMEM, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"maxmempattern","mmp", P_NUM|P_VI_DEF,
 			    (char_u *)&p_mmp, PV_NONE,
-			    {(char_u *)1000L, (char_u *)0L}},
+			    {(char_u *)1000L, (char_u *)0L} SCRIPTID_INIT},
     {"maxmemtot",   "mmt",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_mmt, PV_NONE,
-			    {(char_u *)DFLT_MAXMEMTOT, (char_u *)0L}},
+			    {(char_u *)DFLT_MAXMEMTOT, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"menuitems",   "mis",  P_NUM|P_VI_DEF,
 #ifdef FEAT_MENU
 			    (char_u *)&p_mis, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)25L, (char_u *)0L}},
+			    {(char_u *)25L, (char_u *)0L} SCRIPTID_INIT},
     {"mesg",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"mkspellmem",  "msm",  P_STRING|P_VI_DEF|P_EXPAND|P_SECURE,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_msm, PV_NONE,
@@ -1716,22 +1730,22 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-    },
+			    SCRIPTID_INIT},
     {"modeline",    "ml",   P_BOOL|P_VIM,
 			    (char_u *)&p_ml, PV_ML,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"modelines",   "mls",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_mls, PV_NONE,
-			    {(char_u *)5L, (char_u *)0L}},
+			    {(char_u *)5L, (char_u *)0L} SCRIPTID_INIT},
     {"modifiable",  "ma",   P_BOOL|P_VI_DEF|P_NOGLOB,
 			    (char_u *)&p_ma, PV_MA,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"modified",    "mod",  P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
 			    (char_u *)&p_mod, PV_MOD,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"more",	    NULL,   P_BOOL|P_VIM,
 			    (char_u *)&p_more, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"mouse",	    NULL,   P_STRING|P_VI_DEF|P_FLAGLIST,
 			    (char_u *)&p_mouse, PV_NONE,
 			    {
@@ -1740,21 +1754,21 @@
 #else
 				(char_u *)"",
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"mousefocus",   "mousef", P_BOOL|P_VI_DEF,
 #ifdef FEAT_GUI
 			    (char_u *)&p_mousef, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"mousehide",   "mh",   P_BOOL|P_VI_DEF,
 #ifdef FEAT_GUI
 			    (char_u *)&p_mh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"mousemodel",  "mousem", P_STRING|P_VI_DEF,
 			    (char_u *)&p_mousem, PV_NONE,
 			    {
@@ -1767,7 +1781,7 @@
 				(char_u *)"extend",
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"mouseshape",  "mouses",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_MOUSESHAPE
 			    (char_u *)&p_mouseshape, PV_NONE,
@@ -1776,33 +1790,34 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"mousetime",   "mouset",	P_NUM|P_VI_DEF,
 			    (char_u *)&p_mouset, PV_NONE,
-			    {(char_u *)500L, (char_u *)0L}},
+			    {(char_u *)500L, (char_u *)0L} SCRIPTID_INIT},
     {"mzquantum",  "mzq",   P_NUM,
 #ifdef FEAT_MZSCHEME
 			    (char_u *)&p_mzq, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)100L, (char_u *)100L}},
+			    {(char_u *)100L, (char_u *)100L} SCRIPTID_INIT},
     {"novice",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"nrformats",   "nf",   P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_nf, PV_NF,
-			    {(char_u *)"octal,hex", (char_u *)0L}},
+			    {(char_u *)"octal,hex", (char_u *)0L}
+			    SCRIPTID_INIT},
     {"number",	    "nu",   P_BOOL|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_NU,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"numberwidth", "nuw",  P_NUM|P_RWIN|P_VIM,
 #ifdef FEAT_LINEBREAK
 			    (char_u *)VAR_WIN, PV_NUW,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)8L, (char_u *)4L}},
+			    {(char_u *)8L, (char_u *)4L} SCRIPTID_INIT},
     {"omnifunc",    "ofu",  P_STRING|P_ALLOCED|P_VI_DEF|P_SECURE,
 #ifdef FEAT_COMPL_FUNC
 			    (char_u *)&p_ofu, PV_OFU,
@@ -1811,10 +1826,10 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"open",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"opendevice",  "odev", P_BOOL|P_VI_DEF,
 #if defined(MSDOS) || defined(MSWIN) || defined(OS2)
 			    (char_u *)&p_odev, PV_NONE,
@@ -1822,13 +1837,13 @@
 			    (char_u *)NULL, PV_NONE,
 #endif
 			    {(char_u *)FALSE, (char_u *)FALSE}
-			    },
+			    SCRIPTID_INIT},
     {"operatorfunc", "opfunc", P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_opfunc, PV_NONE,
-			    {(char_u *)"", (char_u *)0L} },
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"optimize",    "opt",  P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"osfiletype",  "oft",  P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_OSFILETYPE
 			    (char_u *)&p_oft, PV_OFT,
@@ -1837,17 +1852,17 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"paragraphs",  "para", P_STRING|P_VI_DEF,
 			    (char_u *)&p_para, PV_NONE,
 			    {(char_u *)"IPLPPPQPP TPHPLIPpLpItpplpipbp",
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"paste",	    NULL,   P_BOOL|P_VI_DEF|P_PRI_MKRC,
 			    (char_u *)&p_paste, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"pastetoggle", "pt",   P_STRING|P_VI_DEF,
 			    (char_u *)&p_pt, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"patchexpr",   "pex",  P_STRING|P_VI_DEF|P_SECURE,
 #if defined(FEAT_DIFF) && defined(FEAT_EVAL)
 			    (char_u *)&p_pex, PV_NONE,
@@ -1856,10 +1871,10 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"patchmode",   "pm",   P_STRING|P_VI_DEF|P_NFNAME,
 			    (char_u *)&p_pm, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"path",	    "pa",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_path, PV_PATH,
 			    {
@@ -1872,24 +1887,24 @@
 			    (char_u *)".,/usr/include,,",
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"preserveindent", "pi", P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_pi, PV_PI,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"previewheight", "pvh", P_NUM|P_VI_DEF,
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
 			    (char_u *)&p_pvh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)12L, (char_u *)0L}},
+			    {(char_u *)12L, (char_u *)0L} SCRIPTID_INIT},
     {"previewwindow", "pvw", P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
 			    (char_u *)VAR_WIN, PV_PVW,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"printdevice", "pdev", P_STRING|P_VI_DEF|P_SECURE,
 #ifdef FEAT_PRINTER
 			    (char_u *)&p_pdev, PV_NONE,
@@ -1898,7 +1913,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printencoding", "penc", P_STRING|P_VI_DEF,
 #ifdef FEAT_POSTSCRIPT
 			    (char_u *)&p_penc, PV_NONE,
@@ -1907,7 +1922,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printexpr", "pexpr",  P_STRING|P_VI_DEF,
 #ifdef FEAT_POSTSCRIPT
 			    (char_u *)&p_pexpr, PV_NONE,
@@ -1916,7 +1931,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printfont", "pfn",    P_STRING|P_VI_DEF,
 #ifdef FEAT_PRINTER
 			    (char_u *)&p_pfn, PV_NONE,
@@ -1931,7 +1946,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printheader", "pheader",  P_STRING|P_VI_DEF|P_GETTEXT,
 #ifdef FEAT_PRINTER
 			    (char_u *)&p_header, PV_NONE,
@@ -1940,7 +1955,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
    {"printmbcharset", "pmbcs",  P_STRING|P_VI_DEF,
 #if defined(FEAT_POSTSCRIPT) && defined(FEAT_MBYTE)
 			    (char_u *)&p_pmcs, PV_NONE,
@@ -1949,7 +1964,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printmbfont", "pmbfn",  P_STRING|P_VI_DEF,
 #if defined(FEAT_POSTSCRIPT) && defined(FEAT_MBYTE)
 			    (char_u *)&p_pmfn, PV_NONE,
@@ -1958,7 +1973,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"printoptions", "popt", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_PRINTER
 			    (char_u *)&p_popt, PV_NONE,
@@ -1967,17 +1982,17 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"prompt",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_prompt, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"pumheight",   "ph",   P_NUM|P_VI_DEF,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_ph, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"quoteescape", "qe",   P_STRING|P_ALLOCED|P_VI_DEF,
 #ifdef FEAT_TEXTOBJ
 			    (char_u *)&p_qe, PV_QE,
@@ -1986,47 +2001,47 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"readonly",    "ro",   P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
 			    (char_u *)&p_ro, PV_RO,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"redraw",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"redrawtime",  "rdt",  P_NUM|P_VI_DEF,
 #ifdef FEAT_RELTIME
 			    (char_u *)&p_rdt, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)2000L, (char_u *)0L}},
+			    {(char_u *)2000L, (char_u *)0L} SCRIPTID_INIT},
     {"remap",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_remap, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"report",	    NULL,   P_NUM|P_VI_DEF,
 			    (char_u *)&p_report, PV_NONE,
-			    {(char_u *)2L, (char_u *)0L}},
+			    {(char_u *)2L, (char_u *)0L} SCRIPTID_INIT},
     {"restorescreen", "rs", P_BOOL|P_VI_DEF,
 #ifdef WIN3264
 			    (char_u *)&p_rs, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"revins",	    "ri",   P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)&p_ri, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"rightleft",   "rl",   P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)VAR_WIN, PV_RL,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"rightleftcmd", "rlc", P_STRING|P_ALLOCED|P_VI_DEF|P_RWIN,
 #ifdef FEAT_RIGHTLEFT
 			    (char_u *)VAR_WIN, PV_RLC,
@@ -2035,40 +2050,41 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"ruler",	    "ru",   P_BOOL|P_VI_DEF|P_VIM|P_RSTAT,
 #ifdef FEAT_CMDL_INFO
 			    (char_u *)&p_ru, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"rulerformat", "ruf",  P_STRING|P_VI_DEF|P_ALLOCED|P_RSTAT,
 #ifdef FEAT_STL_OPT
 			    (char_u *)&p_ruf, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"runtimepath", "rtp",  P_STRING|P_VI_DEF|P_EXPAND|P_COMMA|P_NODUP|P_SECURE,
 			    (char_u *)&p_rtp, PV_NONE,
-			    {(char_u *)DFLT_RUNTIMEPATH, (char_u *)0L}},
+			    {(char_u *)DFLT_RUNTIMEPATH, (char_u *)0L}
+			    SCRIPTID_INIT},
     {"scroll",	    "scr",  P_NUM|P_NO_MKRC|P_VI_DEF,
 			    (char_u *)VAR_WIN, PV_SCROLL,
-			    {(char_u *)12L, (char_u *)0L}},
+			    {(char_u *)12L, (char_u *)0L} SCRIPTID_INIT},
     {"scrollbind",  "scb",  P_BOOL|P_VI_DEF,
 #ifdef FEAT_SCROLLBIND
 			    (char_u *)VAR_WIN, PV_SCBIND,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"scrolljump",  "sj",   P_NUM|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sj, PV_NONE,
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"scrolloff",   "so",   P_NUM|P_VI_DEF|P_VIM|P_RALL,
 			    (char_u *)&p_so, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"scrollopt",   "sbo",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_SCROLLBIND
 			    (char_u *)&p_sbo, PV_NONE,
@@ -2077,27 +2093,29 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"sections",    "sect", P_STRING|P_VI_DEF,
 			    (char_u *)&p_sections, PV_NONE,
-			    {(char_u *)"SHNHH HUnhsh", (char_u *)0L}},
+			    {(char_u *)"SHNHH HUnhsh", (char_u *)0L}
+			    SCRIPTID_INIT},
     {"secure",	    NULL,   P_BOOL|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_secure, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"selection",   "sel",  P_STRING|P_VI_DEF,
 #ifdef FEAT_VISUAL
 			    (char_u *)&p_sel, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"inclusive", (char_u *)0L}},
+			    {(char_u *)"inclusive", (char_u *)0L}
+			    SCRIPTID_INIT},
     {"selectmode",  "slm",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_VISUAL
 			    (char_u *)&p_slm, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"sessionoptions", "ssop", P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_SESSION
 			    (char_u *)&p_ssop, PV_NONE,
@@ -2107,7 +2125,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"shell",	    "sh",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_sh, PV_NONE,
 			    {
@@ -2136,7 +2154,7 @@
 #  endif
 # endif
 #endif /* VMS */
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"shellcmdflag","shcf", P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_shcf, PV_NONE,
 			    {
@@ -2149,7 +2167,7 @@
 			    (char_u *)"-c",
 # endif
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"shellpipe",   "sp",   P_STRING|P_VI_DEF|P_SECURE,
 #ifdef FEAT_QUICKFIX
 			    (char_u *)&p_sp, PV_NONE,
@@ -2168,30 +2186,30 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-    },
+			    SCRIPTID_INIT},
     {"shellquote",  "shq",  P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_shq, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"shellredir",  "srr",  P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_srr, PV_NONE,
-			    {(char_u *)">", (char_u *)0L}},
+			    {(char_u *)">", (char_u *)0L} SCRIPTID_INIT},
     {"shellslash",  "ssl",   P_BOOL|P_VI_DEF,
 #ifdef BACKSLASH_IN_FILENAME
 			    (char_u *)&p_ssl, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"shelltemp",   "stmp", P_BOOL,
 			    (char_u *)&p_stmp, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"shelltype",   "st",   P_NUM|P_VI_DEF,
 #ifdef AMIGA
 			    (char_u *)&p_st, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"shellxquote", "sxq",  P_STRING|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_sxq, PV_NONE,
 			    {
@@ -2200,30 +2218,31 @@
 #else
 			    (char_u *)"",
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"shiftround",  "sr",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sr, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"shiftwidth",  "sw",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_sw, PV_SW,
-			    {(char_u *)8L, (char_u *)0L}},
+			    {(char_u *)8L, (char_u *)0L} SCRIPTID_INIT},
     {"shortmess",   "shm",  P_STRING|P_VIM|P_FLAGLIST,
 			    (char_u *)&p_shm, PV_NONE,
-			    {(char_u *)"", (char_u *)"filnxtToO"}},
+			    {(char_u *)"", (char_u *)"filnxtToO"}
+			    SCRIPTID_INIT},
     {"shortname",   "sn",   P_BOOL|P_VI_DEF,
 #ifdef SHORT_FNAME
 			    (char_u *)NULL, PV_NONE,
 #else
 			    (char_u *)&p_sn, PV_SN,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"showbreak",   "sbr",  P_STRING|P_VI_DEF|P_RALL,
 #ifdef FEAT_LINEBREAK
 			    (char_u *)&p_sbr, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"showcmd",	    "sc",   P_BOOL|P_VIM,
 #ifdef FEAT_CMDL_INFO
 			    (char_u *)&p_sc, PV_NONE,
@@ -2236,58 +2255,58 @@
 #else
 				(char_u *)TRUE
 #endif
-				}},
+				} SCRIPTID_INIT},
     {"showfulltag", "sft",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_sft, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"showmatch",   "sm",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_sm, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"showmode",    "smd",  P_BOOL|P_VIM,
 			    (char_u *)&p_smd, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"showtabline", "stal", P_NUM|P_VI_DEF|P_RALL,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_stal, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"sidescroll",  "ss",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_ss, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"sidescrolloff", "siso", P_NUM|P_VI_DEF|P_VIM|P_RBUF,
 			    (char_u *)&p_siso, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"slowopen",    "slow", P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"smartcase",   "scs",  P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_scs, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"smartindent", "si",   P_BOOL|P_VI_DEF|P_VIM,
 #ifdef FEAT_SMARTINDENT
 			    (char_u *)&p_si, PV_SI,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"smarttab",    "sta",  P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sta, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"softtabstop", "sts",  P_NUM|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sts, PV_STS,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"sourceany",   NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"spell",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
 #ifdef FEAT_SPELL
 			    (char_u *)VAR_WIN, PV_SPELL,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"spellcapcheck", "spc", P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_spc, PV_SPC,
@@ -2296,7 +2315,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"spellfile",   "spf",  P_STRING|P_EXPAND|P_ALLOCED|P_VI_DEF|P_SECURE|P_COMMA,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_spf, PV_SPF,
@@ -2305,7 +2324,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"spelllang",   "spl",  P_STRING|P_ALLOCED|P_VI_DEF|P_COMMA|P_RBUF|P_EXPAND,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_spl, PV_SPL,
@@ -2314,7 +2333,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"spellsuggest", "sps", P_STRING|P_VI_DEF|P_EXPAND|P_SECURE|P_COMMA,
 #ifdef FEAT_SPELL
 			    (char_u *)&p_sps, PV_NONE,
@@ -2323,35 +2342,35 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-    },
+			    SCRIPTID_INIT},
     {"splitbelow",  "sb",   P_BOOL|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_sb, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"splitright",  "spr",  P_BOOL|P_VI_DEF,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)&p_spr, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"startofline", "sol",  P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_sol, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"statusline"  ,"stl",  P_STRING|P_VI_DEF|P_ALLOCED|P_RSTAT,
 #ifdef FEAT_STL_OPT
 			    (char_u *)&p_stl, PV_STL,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"suffixes",    "su",   P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_su, PV_NONE,
 			    {(char_u *)".bak,~,.o,.h,.info,.swp,.obj",
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"suffixesadd", "sua",  P_STRING|P_VI_DEF|P_ALLOCED|P_COMMA|P_NODUP,
 #ifdef FEAT_SEARCHPATH
 			    (char_u *)&p_sua, PV_SUA,
@@ -2360,16 +2379,16 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"swapfile",    "swf",  P_BOOL|P_VI_DEF|P_RSTAT,
 			    (char_u *)&p_swf, PV_SWF,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"swapsync",    "sws",  P_STRING|P_VI_DEF,
 			    (char_u *)&p_sws, PV_NONE,
-			    {(char_u *)"fsync", (char_u *)0L}},
+			    {(char_u *)"fsync", (char_u *)0L} SCRIPTID_INIT},
     {"switchbuf",   "swb",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_swb, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"synmaxcol",   "smc",  P_NUM|P_VI_DEF|P_RBUF,
 #ifdef FEAT_SYN_HL
 			    (char_u *)&p_smc, PV_SMC,
@@ -2378,7 +2397,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"syntax",	    "syn",  P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB|P_NFNAME,
 #ifdef FEAT_SYN_HL
 			    (char_u *)&p_syn, PV_SYN,
@@ -2387,24 +2406,24 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"tabline",	    "tal",  P_STRING|P_VI_DEF|P_RALL,
 #ifdef FEAT_STL_OPT
 			    (char_u *)&p_tal, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"tabpagemax",  "tpm",  P_NUM|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_tpm, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)10L, (char_u *)0L}},
+			    {(char_u *)10L, (char_u *)0L} SCRIPTID_INIT},
     {"tabstop",	    "ts",   P_NUM|P_VI_DEF|P_RBUF,
 			    (char_u *)&p_ts, PV_TS,
-			    {(char_u *)8L, (char_u *)0L}},
+			    {(char_u *)8L, (char_u *)0L} SCRIPTID_INIT},
     {"tagbsearch",  "tbs",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_tbs, PV_NONE,
 #ifdef VMS	/* binary searching doesn't appear to work on VMS */
@@ -2412,13 +2431,13 @@
 #else
 			    {(char_u *)TRUE, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"taglength",   "tl",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_tl, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"tagrelative", "tr",   P_BOOL|P_VIM,
 			    (char_u *)&p_tr, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)TRUE}},
+			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
     {"tags",	    "tag",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_tags, PV_TAGS,
 			    {
@@ -2427,20 +2446,20 @@
 #else
 			    (char_u *)"./tags,tags",
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"tagstack",    "tgst", P_BOOL|P_VI_DEF,
 			    (char_u *)&p_tgst, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"term",	    NULL,   P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
 			    (char_u *)&T_NAME, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"termbidi", "tbidi",   P_BOOL|P_VI_DEF,
 #ifdef FEAT_ARABIC
 			    (char_u *)&p_tbidi, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"termencoding", "tenc", P_STRING|P_VI_DEF|P_RCLR,
 #ifdef FEAT_MBYTE
 			    (char_u *)&p_tenc, PV_NONE,
@@ -2449,13 +2468,14 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"terse",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_terse, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"textauto",    "ta",   P_BOOL|P_VIM,
 			    (char_u *)&p_ta, PV_NONE,
-			    {(char_u *)DFLT_TEXTAUTO, (char_u *)TRUE}},
+			    {(char_u *)DFLT_TEXTAUTO, (char_u *)TRUE}
+			    SCRIPTID_INIT},
     {"textmode",    "tx",   P_BOOL|P_VI_DEF|P_NO_MKRC,
 			    (char_u *)&p_tx, PV_TX,
 			    {
@@ -2464,40 +2484,40 @@
 #else
 			    (char_u *)FALSE,
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"textwidth",   "tw",   P_NUM|P_VI_DEF|P_VIM,
 			    (char_u *)&p_tw, PV_TW,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"thesaurus",   "tsr",  P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_INS_EXPAND
 			    (char_u *)&p_tsr, PV_TSR,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"tildeop",	    "top",  P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_to, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"timeout",	    "to",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_timeout, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"timeoutlen",  "tm",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_tm, PV_NONE,
-			    {(char_u *)1000L, (char_u *)0L}},
+			    {(char_u *)1000L, (char_u *)0L} SCRIPTID_INIT},
     {"title",	    NULL,   P_BOOL|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_title, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"titlelen",    NULL,   P_NUM|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_titlelen, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)85L, (char_u *)0L}},
+			    {(char_u *)85L, (char_u *)0L} SCRIPTID_INIT},
     {"titleold",    NULL,   P_STRING|P_VI_DEF|P_GETTEXT|P_SECURE|P_NO_MKRC,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_titleold, PV_NONE,
@@ -2507,49 +2527,50 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"titlestring", NULL,   P_STRING|P_VI_DEF,
 #ifdef FEAT_TITLE
 			    (char_u *)&p_titlestring, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
 #if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)
     {"toolbar",     "tb",   P_STRING|P_COMMA|P_VI_DEF|P_NODUP,
 			    (char_u *)&p_toolbar, PV_NONE,
-			    {(char_u *)"icons,tooltips", (char_u *)0L}},
+			    {(char_u *)"icons,tooltips", (char_u *)0L}
+			    SCRIPTID_INIT},
 #endif
 #if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK) && defined(HAVE_GTK2)
     {"toolbariconsize",	"tbis", P_STRING|P_VI_DEF,
 			    (char_u *)&p_tbis, PV_NONE,
-			    {(char_u *)"small", (char_u *)0L}},
+			    {(char_u *)"small", (char_u *)0L} SCRIPTID_INIT},
 #endif
     {"ttimeout",    NULL,   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_ttimeout, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"ttimeoutlen", "ttm",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_ttm, PV_NONE,
-			    {(char_u *)-1L, (char_u *)0L}},
+			    {(char_u *)-1L, (char_u *)0L} SCRIPTID_INIT},
     {"ttybuiltin",  "tbi",  P_BOOL|P_VI_DEF,
 			    (char_u *)&p_tbi, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"ttyfast",	    "tf",   P_BOOL|P_NO_MKRC|P_VI_DEF,
 			    (char_u *)&p_tf, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"ttymouse",    "ttym", P_STRING|P_NODEFAULT|P_NO_MKRC|P_VI_DEF,
 #if defined(FEAT_MOUSE) && (defined(UNIX) || defined(VMS))
 			    (char_u *)&p_ttym, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"ttyscroll",   "tsl",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_ttyscroll, PV_NONE,
-			    {(char_u *)999L, (char_u *)0L}},
+			    {(char_u *)999L, (char_u *)0L} SCRIPTID_INIT},
     {"ttytype",	    "tty",  P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
 			    (char_u *)&T_NAME, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"undolevels",  "ul",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_ul, PV_NONE,
 			    {
@@ -2558,19 +2579,19 @@
 #else
 			    (char_u *)100L,
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"updatecount", "uc",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_uc, PV_NONE,
-			    {(char_u *)200L, (char_u *)0L}},
+			    {(char_u *)200L, (char_u *)0L} SCRIPTID_INIT},
     {"updatetime",  "ut",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_ut, PV_NONE,
-			    {(char_u *)4000L, (char_u *)0L}},
+			    {(char_u *)4000L, (char_u *)0L} SCRIPTID_INIT},
     {"verbose",	    "vbs",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_verbose, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"verbosefile", "vfile", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 			    (char_u *)&p_vfile, PV_NONE,
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"viewdir",     "vdir", P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
 #ifdef FEAT_SESSION
 			    (char_u *)&p_vdir, PV_NONE,
@@ -2579,7 +2600,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"viewoptions", "vop",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_SESSION
 			    (char_u *)&p_vop, PV_NONE,
@@ -2588,25 +2609,25 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"viminfo",	    "vi",   P_STRING|P_COMMA|P_NODUP|P_SECURE,
 #ifdef FEAT_VIMINFO
 			    (char_u *)&p_viminfo, PV_NONE,
 #if defined(MSDOS) || defined(MSWIN) || defined(OS2)
-			    {(char_u *)"", (char_u *)"'20,<50,s10,h,rA:,rB:"}
+			    {(char_u *)"", (char_u *)"'100,<50,s10,h,rA:,rB:"}
 #else
 # ifdef AMIGA
 			    {(char_u *)"",
-				 (char_u *)"'20,<50,s10,h,rdf0:,rdf1:,rdf2:"}
+				 (char_u *)"'100,<50,s10,h,rdf0:,rdf1:,rdf2:"}
 # else
-			    {(char_u *)"", (char_u *)"'20,<50,s10,h"}
+			    {(char_u *)"", (char_u *)"'100,<50,s10,h"}
 # endif
 #endif
 #else
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"virtualedit", "ve",   P_STRING|P_COMMA|P_NODUP|P_VI_DEF|P_VIM,
 #ifdef FEAT_VIRTUALEDIT
 			    (char_u *)&p_ve, PV_NONE,
@@ -2615,51 +2636,52 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"visualbell",  "vb",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_vb, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"w300",	    NULL,   P_NUM|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"w1200",	    NULL,   P_NUM|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"w9600",	    NULL,   P_NUM|P_VI_DEF,
 			    (char_u *)NULL, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"warn",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_warn, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"weirdinvert", "wiv",  P_BOOL|P_VI_DEF|P_RCLR,
 			    (char_u *)&p_wiv, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"whichwrap",   "ww",   P_STRING|P_VIM|P_COMMA|P_FLAGLIST,
 			    (char_u *)&p_ww, PV_NONE,
-			    {(char_u *)"", (char_u *)"b,s"}},
+			    {(char_u *)"", (char_u *)"b,s"} SCRIPTID_INIT},
     {"wildchar",    "wc",   P_NUM|P_VIM,
 			    (char_u *)&p_wc, PV_NONE,
-			    {(char_u *)(long)Ctrl_E, (char_u *)(long)TAB}},
+			    {(char_u *)(long)Ctrl_E, (char_u *)(long)TAB}
+			    SCRIPTID_INIT},
     {"wildcharm",   "wcm",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_wcm, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"wildignore",  "wig",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 #ifdef FEAT_WILDIGN
 			    (char_u *)&p_wig, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
     {"wildmenu",    "wmnu", P_BOOL|P_VI_DEF,
 #ifdef FEAT_WILDMENU
 			    (char_u *)&p_wmnu, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"wildmode",    "wim",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
 			    (char_u *)&p_wim, PV_NONE,
-			    {(char_u *)"full", (char_u *)0L}},
+			    {(char_u *)"full", (char_u *)0L} SCRIPTID_INIT},
     {"wildoptions", "wop",  P_STRING|P_VI_DEF,
 #ifdef FEAT_CMDL_COMPL
 			    (char_u *)&p_wop, PV_NONE,
@@ -2668,7 +2690,7 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"winaltkeys",  "wak",  P_STRING|P_VI_DEF,
 #ifdef FEAT_WAK
 			    (char_u *)&p_wak, PV_NONE,
@@ -2677,67 +2699,67 @@
 			    (char_u *)NULL, PV_NONE,
 			    {(char_u *)NULL, (char_u *)0L}
 #endif
-			    },
+			    SCRIPTID_INIT},
     {"window",	    "wi",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_window, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"winheight",   "wh",   P_NUM|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_wh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"winfixheight", "wfh", P_BOOL|P_VI_DEF|P_RSTAT,
 #ifdef FEAT_WINDOWS
 			    (char_u *)VAR_WIN, PV_WFH,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"winfixwidth", "wfw", P_BOOL|P_VI_DEF|P_RSTAT,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)VAR_WIN, PV_WFW,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"winminheight", "wmh", P_NUM|P_VI_DEF,
 #ifdef FEAT_WINDOWS
 			    (char_u *)&p_wmh, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"winminwidth", "wmw", P_NUM|P_VI_DEF,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)&p_wmw, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)1L, (char_u *)0L}},
+			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
     {"winwidth",   "wiw",   P_NUM|P_VI_DEF,
 #ifdef FEAT_VERTSPLIT
 			    (char_u *)&p_wiw, PV_NONE,
 #else
 			    (char_u *)NULL, PV_NONE,
 #endif
-			    {(char_u *)20L, (char_u *)0L}},
+			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
     {"wrap",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
 			    (char_u *)VAR_WIN, PV_WRAP,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"wrapmargin",  "wm",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_wm, PV_WM,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"wrapscan",    "ws",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_ws, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"write",	    NULL,   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_write, PV_NONE,
-			    {(char_u *)TRUE, (char_u *)0L}},
+			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
     {"writeany",    "wa",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_wa, PV_NONE,
-			    {(char_u *)FALSE, (char_u *)0L}},
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"writebackup", "wb",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_wb, PV_NONE,
 			    {
@@ -2746,15 +2768,15 @@
 #else
 			    (char_u *)FALSE,
 #endif
-				(char_u *)0L}},
+				(char_u *)0L} SCRIPTID_INIT},
     {"writedelay",  "wd",   P_NUM|P_VI_DEF,
 			    (char_u *)&p_wd, PV_NONE,
-			    {(char_u *)0L, (char_u *)0L}},
+			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
 
 /* terminal output codes */
 #define p_term(sss, vvv)   {sss, NULL, P_STRING|P_VI_DEF|P_RALL|P_SECURE, \
 			    (char_u *)&vvv, PV_NONE, \
-			    {(char_u *)"", (char_u *)0L}},
+			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
 
     p_term("t_AB", T_CAB)
     p_term("t_AF", T_CAF)
@@ -2815,7 +2837,8 @@
 
 /* terminal key codes are not in here */
 
-    {NULL, NULL, 0, NULL, PV_NONE, {NULL, NULL}}	/* end marker */
+    /* end marker */
+    {NULL, NULL, 0, NULL, PV_NONE, {NULL, NULL} SCRIPTID_INIT}
 };
 
 #define PARAM_COUNT (sizeof(options) / sizeof(struct vimoption))
@@ -3984,7 +4007,7 @@
 	else
 	{
 	    prefix = 1;
-	    if (STRNCMP(arg, "no", 2) == 0)
+	    if (STRNCMP(arg, "no", 2) == 0 && STRNCMP(arg, "novice", 6) != 0)
 	    {
 		prefix = 0;
 		arg += 2;
@@ -4119,11 +4142,23 @@
 					   && options[opt_idx].var == VAR_WIN)
 		goto skip;
 
-	    /* Disallow changing some options from modelines */
-	    if ((opt_flags & OPT_MODELINE) && (flags & P_SECURE))
+	    /* Disallow changing some options from modelines. */
+	    if (opt_flags & OPT_MODELINE)
 	    {
-		errmsg = (char_u *)_("E520: Not allowed in a modeline");
-		goto skip;
+		if (flags & P_SECURE)
+		{
+		    errmsg = (char_u *)_("E520: Not allowed in a modeline");
+		    goto skip;
+		}
+#ifdef FEAT_DIFF
+		/* In diff mode some options are overruled.  This avoids that
+		 * 'foldmethod' becomes "marker" instead of "diff" and that
+		 * "wrap" gets set. */
+		if (curwin->w_p_diff
+			&& (options[opt_idx].indir == PV_FDM
+			    || options[opt_idx].indir == PV_WRAP))
+		    goto skip;
+#endif
 	    }
 
 #ifdef HAVE_SANDBOX
@@ -5268,6 +5303,21 @@
 }
 #endif
 
+#ifdef FEAT_TITLE
+static void redraw_titles __ARGS((void));
+
+/*
+ * Redraw the window title and/or tab page text later.
+ */
+static void redraw_titles()
+{
+    need_maketitle = TRUE;
+# ifdef FEAT_WINDOWS
+    redraw_tabline = TRUE;
+# endif
+}
+#endif
+
 /*
  * Set a string option to a new value (without checking the effect).
  * The string is copied into allocated memory.
@@ -5275,14 +5325,13 @@
  * When "set_sid" is zero set the scriptID to current_SID.  When "set_sid" is
  * SID_NONE don't set the scriptID.  Otherwise set the scriptID to "set_sid".
  */
-/*ARGSUSED*/
     void
 set_string_option_direct(name, opt_idx, val, opt_flags, set_sid)
     char_u	*name;
     int		opt_idx;
     char_u	*val;
     int		opt_flags;	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
-    int		set_sid;
+    int		set_sid UNUSED;
 {
     char_u	*s;
     char_u	**varp;
@@ -5407,6 +5456,10 @@
     int		did_chartab = FALSE;
     char_u	**gvarp;
     long_u	free_oldval = (options[opt_idx].flags & P_ALLOCED);
+#ifdef FEAT_GUI
+    /* set when changing an option that only requires a redraw in the GUI */
+    int		redraw_gui_only = FALSE;
+#endif
 
     /* Get the global option to compare with, otherwise we would have to check
      * two values for all local options. */
@@ -5668,7 +5721,7 @@
 	    {
 # ifdef FEAT_TITLE
 		/* May show a "+" in the title now. */
-		need_maketitle = TRUE;
+		redraw_titles();
 # endif
 		/* Add 'fileencoding' to the swap file. */
 		ml_setflags(curbuf);
@@ -5687,7 +5740,7 @@
 	    {
 		errmsg = mb_init();
 # ifdef FEAT_TITLE
-		need_maketitle = TRUE;
+		redraw_titles();
 # endif
 	    }
 	}
@@ -5766,14 +5819,28 @@
 	/* load or unload key mapping tables */
 	errmsg = keymap_init();
 
-	/* When successfully installed a new keymap switch on using it. */
-	if (*curbuf->b_p_keymap != NUL && errmsg == NULL)
+	if (errmsg == NULL)
 	{
-	    curbuf->b_p_iminsert = B_IMODE_LMAP;
-	    if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)
-		curbuf->b_p_imsearch = B_IMODE_LMAP;
-	    set_iminsert_global();
-	    set_imsearch_global();
+	    if (*curbuf->b_p_keymap != NUL)
+	    {
+		/* Installed a new keymap, switch on using it. */
+		curbuf->b_p_iminsert = B_IMODE_LMAP;
+		if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)
+		    curbuf->b_p_imsearch = B_IMODE_LMAP;
+	    }
+	    else
+	    {
+		/* Cleared the keymap, may reset 'iminsert' and 'imsearch'. */
+		if (curbuf->b_p_iminsert == B_IMODE_LMAP)
+		    curbuf->b_p_iminsert = B_IMODE_NONE;
+		if (curbuf->b_p_imsearch == B_IMODE_LMAP)
+		    curbuf->b_p_imsearch = B_IMODE_USE_INSERT;
+	    }
+	    if ((opt_flags & OPT_LOCAL) == 0)
+	    {
+		set_iminsert_global();
+		set_imsearch_global();
+	    }
 # ifdef FEAT_WINDOWS
 	    status_redraw_curbuf();
 # endif
@@ -5796,7 +5863,7 @@
 	    else
 		curbuf->b_p_tx = FALSE;
 #ifdef FEAT_TITLE
-	    need_maketitle = TRUE;
+	    redraw_titles();
 #endif
 	    /* update flag in swap file */
 	    ml_setflags(curbuf);
@@ -5977,15 +6044,23 @@
 	/* ":set t_Co=0" and ":set t_Co=1" do ":set t_Co=" */
 	if (varp == &T_CCO)
 	{
-	    t_colors = atoi((char *)T_CCO);
-	    if (t_colors <= 1)
+	    int colors = atoi((char *)T_CCO);
+
+	    /* Only reinitialize colors if t_Co value has really changed to
+	     * avoid expensive reload of colorscheme if t_Co is set to the
+	     * same value multiple times. */
+	    if (colors != t_colors)
 	    {
-		if (new_value_alloced)
-		    vim_free(T_CCO);
-		T_CCO = empty_option;
+		t_colors = colors;
+		if (t_colors <= 1)
+		{
+		    if (new_value_alloced)
+			vim_free(T_CCO);
+		    T_CCO = empty_option;
+		}
+		/* We now have a different color setup, initialize it again. */
+		init_highlight(TRUE, FALSE);
 	    }
-	    /* We now have a different color setup, initialize it again. */
-	    init_highlight(TRUE, FALSE);
 	}
 	ttest(FALSE);
 	if (varp == &T_ME)
@@ -6055,6 +6130,7 @@
 		    errmsg = (char_u *)N_("E596: Invalid font(s)");
 	    }
 	}
+	redraw_gui_only = TRUE;
     }
 # ifdef FEAT_XFONTSET
     else if (varp == &p_guifontset)
@@ -6063,6 +6139,7 @@
 	    errmsg = (char_u *)N_("E597: can't select fontset");
 	else if (gui.in_use && gui_init_font(p_guifontset, TRUE) != OK)
 	    errmsg = (char_u *)N_("E598: Invalid fontset");
+	redraw_gui_only = TRUE;
     }
 # endif
 # ifdef FEAT_MBYTE
@@ -6072,6 +6149,7 @@
 	    errmsg = (char_u *)N_("E533: can't select wide font");
 	else if (gui_get_wide_font() == FAIL)
 	    errmsg = (char_u *)N_("E534: Invalid wide font");
+	redraw_gui_only = TRUE;
     }
 # endif
 #endif
@@ -6133,13 +6211,24 @@
 #ifdef FEAT_GUI
     /* 'guioptions' */
     else if (varp == &p_go)
+    {
 	gui_init_which_components(oldval);
+	redraw_gui_only = TRUE;
+    }
 #endif
 
 #if defined(FEAT_GUI_TABLINE)
     /* 'guitablabel' */
     else if (varp == &p_gtl)
+    {
 	redraw_tabline = TRUE;
+	redraw_gui_only = TRUE;
+    }
+    /* 'guitabtooltip' */
+    else if (varp == &p_gtt)
+    {
+	redraw_gui_only = TRUE;
+    }
 #endif
 
 #if defined(FEAT_MOUSE_TTY) && (defined(UNIX) || defined(VMS))
@@ -6717,7 +6806,11 @@
 
     if (curwin->w_curswant != MAXCOL)
 	curwin->w_set_curswant = TRUE;  /* in case 'showbreak' changed */
-    check_redraw(options[opt_idx].flags);
+#ifdef FEAT_GUI
+    /* check redraw when it's not a GUI option or the GUI is active. */
+    if (!redraw_gui_only || gui.in_use)
+#endif
+	check_redraw(options[opt_idx].flags);
 
     return errmsg;
 }
@@ -6932,6 +7025,7 @@
     int		new_unnamed = FALSE;
     int		new_autoselect = FALSE;
     int		new_autoselectml = FALSE;
+    int		new_html = FALSE;
     regprog_T	*new_exclude_prog = NULL;
     char_u	*errmsg = NULL;
     char_u	*p;
@@ -6955,6 +7049,11 @@
 	    new_autoselectml = TRUE;
 	    p += 12;
 	}
+	else if (STRNCMP(p, "html", 4) == 0 && (p[4] == ',' || p[4] == NUL))
+	{
+	    new_html = TRUE;
+	    p += 4;
+	}
 	else if (STRNCMP(p, "exclude:", 8) == 0 && new_exclude_prog == NULL)
 	{
 	    p += 8;
@@ -6976,6 +7075,7 @@
 	clip_unnamed = new_unnamed;
 	clip_autoselect = new_autoselect;
 	clip_autoselectml = new_autoselectml;
+	clip_html = new_html;
 	vim_free(clip_exclude_prog);
 	clip_exclude_prog = new_exclude_prog;
     }
@@ -7105,22 +7205,28 @@
 	    curbuf->b_did_warn = FALSE;
 
 #ifdef FEAT_TITLE
-	need_maketitle = TRUE;
+	redraw_titles();
 #endif
     }
 
 #ifdef FEAT_TITLE
     /* when 'modifiable' is changed, redraw the window title */
     else if ((int *)varp == &curbuf->b_p_ma)
-	need_maketitle = TRUE;
+    {
+	redraw_titles();
+    }
     /* when 'endofline' is changed, redraw the window title */
     else if ((int *)varp == &curbuf->b_p_eol)
-	need_maketitle = TRUE;
-#ifdef FEAT_MBYTE
-    /* when 'bomb' is changed, redraw the window title */
+    {
+	redraw_titles();
+    }
+# ifdef FEAT_MBYTE
+    /* when 'bomb' is changed, redraw the window title and tab page text */
     else if ((int *)varp == &curbuf->b_p_bomb)
-	need_maketitle = TRUE;
-#endif
+    {
+	redraw_titles();
+    }
+# endif
 #endif
 
     /* when 'bin' is set also set some other options */
@@ -7128,7 +7234,7 @@
     {
 	set_options_bin(old_value, curbuf->b_p_bin, opt_flags);
 #ifdef FEAT_TITLE
-	need_maketitle = TRUE;
+	redraw_titles();
 #endif
     }
 
@@ -7279,7 +7385,7 @@
 	if (!value)
 	    save_file_ff(curbuf);	/* Buffer is unchanged */
 #ifdef FEAT_TITLE
-	need_maketitle = TRUE;
+	redraw_titles();
 #endif
 #ifdef FEAT_AUTOCMD
 	modified_was_set = value;
@@ -7486,9 +7592,13 @@
 	     * set. */
 	    if (STRCMP(p_enc, "utf-8") != 0)
 	    {
+		static char *w_arabic = N_("W17: Arabic requires UTF-8, do ':set encoding=utf-8'");
+
 		msg_source(hl_attr(HLF_W));
-		MSG_ATTR(_("W17: Arabic requires UTF-8, do ':set encoding=utf-8'"),
-			hl_attr(HLF_W));
+		MSG_ATTR(_(w_arabic), hl_attr(HLF_W));
+#ifdef FEAT_EVAL
+		set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_arabic), -1);
+#endif
 	    }
 
 # ifdef FEAT_MBYTE
@@ -7714,7 +7824,7 @@
 	newFoldLevel();
     }
 
-    /* 'foldminlevel' */
+    /* 'foldminlines' */
     else if (pp == &curwin->w_p_fml)
     {
 	foldUpdateAll(curwin);
@@ -7974,6 +8084,11 @@
 	else /* curwin->w_p_scr > curwin->w_height */
 	    curwin->w_p_scr = curwin->w_height;
     }
+    if (p_hi < 0)
+    {
+	errmsg = e_positive;
+	p_hi = 0;
+    }
     if (p_report < 0)
     {
 	errmsg = e_positive;
@@ -8227,13 +8342,13 @@
 	    {
 		if (number == 0 && string != NULL)
 		{
-		    int index;
+		    int idx;
 
 		    /* Either we are given a string or we are setting option
 		     * to zero. */
-		    for (index = 0; string[index] == '0'; ++index)
+		    for (idx = 0; string[idx] == '0'; ++idx)
 			;
-		    if (string[index] != NUL || index == 0)
+		    if (string[idx] != NUL || idx == 0)
 		    {
 			/* There's another character after zeros or the string
 			 * is empty.  In both cases, we are trying to set a
@@ -8323,7 +8438,7 @@
     {
 	--arg;			    /* put arg at the '<' */
 	modifiers = 0;
-	key = find_special_key(&arg, &modifiers, TRUE);
+	key = find_special_key(&arg, &modifiers, TRUE, TRUE);
 	if (modifiers)		    /* can't handle modifiers here */
 	    key = 0;
     }
@@ -8813,6 +8928,28 @@
 }
 
 /*
+ * Free the string for one term option, if it was allocated.
+ * Set the string to empty_option and clear allocated flag.
+ * "var" points to the option value.
+ */
+    void
+free_one_termoption(var)
+    char_u *var;
+{
+    struct vimoption   *p;
+
+    for (p = &options[0]; p->fullname != NULL; p++)
+	if (p->var == var)
+	{
+	    if (p->flags & P_ALLOCED)
+		free_string_option(*(char_u **)(p->var));
+	    *(char_u **)(p->var) = empty_option;
+	    p->flags &= ~P_ALLOCED;
+	    break;
+	}
+}
+
+/*
  * Set the terminal option defaults to the current value.
  * Used after setting the terminal name.
  */
@@ -9271,10 +9408,9 @@
 /*
  * Check for NULL pointers in a winopt_T and replace them with empty_option.
  */
-/*ARGSUSED*/
     void
 check_winopt(wop)
-    winopt_T	*wop;
+    winopt_T	*wop UNUSED;
 {
 #ifdef FEAT_FOLDING
     check_string_option(&wop->wo_fdi);
@@ -9296,10 +9432,9 @@
 /*
  * Free the allocated memory inside a winopt_T.
  */
-/*ARGSUSED*/
     void
 clear_winopt(wop)
-    winopt_T	*wop;
+    winopt_T	*wop UNUSED;
 {
 #ifdef FEAT_FOLDING
     clear_string_option(&wop->wo_fdi);
@@ -9645,7 +9780,7 @@
 	}
 	--p;
     }
-    if (STRNCMP(p, "no", 2) == 0)
+    if (STRNCMP(p, "no", 2) == 0 && STRNCMP(p, "novice", 6) != 0)
     {
 	xp->xp_context = EXPAND_BOOL_SETTINGS;
 	p += 2;
@@ -9834,7 +9969,8 @@
 	regmatch->rm_ic = ic;
 	if (xp->xp_context != EXPAND_BOOL_SETTINGS)
 	{
-	    for (match = 0; match < sizeof(names) / sizeof(char *); ++match)
+	    for (match = 0; match < (int)(sizeof(names) / sizeof(char *));
+								      ++match)
 		if (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0))
 		{
 		    if (loop == 0)
@@ -10093,25 +10229,110 @@
 
 #ifdef FEAT_LANGMAP
 /*
- * Any character has an equivalent character.  This is used for keyboards that
- * have a special language mode that sends characters above 128 (although
- * other characters can be translated too).
+ * Any character has an equivalent 'langmap' character.  This is used for
+ * keyboards that have a special language mode that sends characters above
+ * 128 (although other characters can be translated too).  The "to" field is a
+ * Vim command character.  This avoids having to switch the keyboard back to
+ * ASCII mode when leaving Insert mode.
+ *
+ * langmap_mapchar[] maps any of 256 chars to an ASCII char used for Vim
+ * commands.
+ * When FEAT_MBYTE is defined langmap_mapga.ga_data is a sorted table of
+ * langmap_entry_T.  This does the same as langmap_mapchar[] for characters >=
+ * 256.
+ */
+# ifdef FEAT_MBYTE
+/*
+ * With multi-byte support use growarray for 'langmap' chars >= 256
+ */
+typedef struct
+{
+    int	    from;
+    int     to;
+} langmap_entry_T;
+
+static garray_T langmap_mapga;
+static void langmap_set_entry __ARGS((int from, int to));
+
+/*
+ * Search for an entry in "langmap_mapga" for "from".  If found set the "to"
+ * field.  If not found insert a new entry at the appropriate location.
  */
+    static void
+langmap_set_entry(from, to)
+    int    from;
+    int    to;
+{
+    langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);
+    int             a = 0;
+    int             b = langmap_mapga.ga_len;
+
+    /* Do a binary search for an existing entry. */
+    while (a != b)
+    {
+	int i = (a + b) / 2;
+	int d = entries[i].from - from;
+
+	if (d == 0)
+	{
+	    entries[i].to = to;
+	    return;
+	}
+	if (d < 0)
+	    a = i + 1;
+	else
+	    b = i;
+    }
+
+    if (ga_grow(&langmap_mapga, 1) != OK)
+	return;  /* out of memory */
+
+    /* insert new entry at position "a" */
+    entries = (langmap_entry_T *)(langmap_mapga.ga_data) + a;
+    mch_memmove(entries + 1, entries,
+			(langmap_mapga.ga_len - a) * sizeof(langmap_entry_T));
+    ++langmap_mapga.ga_len;
+    entries[0].from = from;
+    entries[0].to = to;
+}
 
 /*
- * char_u langmap_mapchar[256];
- * Normally maps each of the 128 upper chars to an <128 ascii char; used to
- * "translate" native lang chars in normal mode or some cases of
- * insert mode without having to tediously switch lang mode back&forth.
+ * Apply 'langmap' to multi-byte character "c" and return the result.
  */
+    int
+langmap_adjust_mb(c)
+    int c;
+{
+    langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);
+    int a = 0;
+    int b = langmap_mapga.ga_len;
+
+    while (a != b)
+    {
+	int i = (a + b) / 2;
+	int d = entries[i].from - c;
+
+	if (d == 0)
+	    return entries[i].to;  /* found matching entry */
+	if (d < 0)
+	    a = i + 1;
+	else
+	    b = i;
+    }
+    return c;  /* no entry found, return "c" unmodified */
+}
+# endif
 
     static void
 langmap_init()
 {
     int i;
 
-    for (i = 0; i < 256; i++)		/* we init with a-one-to one map */
-	langmap_mapchar[i] = i;
+    for (i = 0; i < 256; i++)
+	langmap_mapchar[i] = i;	 /* we init with a one-to-one map */
+# ifdef FEAT_MBYTE
+    ga_init2(&langmap_mapga, sizeof(langmap_entry_T), 8);
+# endif
 }
 
 /*
@@ -10125,7 +10346,10 @@
     char_u  *p2;
     int	    from, to;
 
-    langmap_init();			    /* back to one-to-one map first */
+#ifdef FEAT_MBYTE
+    ga_clear(&langmap_mapga);		    /* clear the previous map first */
+#endif
+    langmap_init();			    /* back to one-to-one map */
 
     for (p = p_langmap; p[0] != NUL; )
     {
@@ -10175,7 +10399,13 @@
 							     transchar(from));
 		return;
 	    }
-	    langmap_mapchar[from & 255] = to;
+
+#ifdef FEAT_MBYTE
+	    if (from >= 256)
+		langmap_set_entry(from, to);
+	    else
+#endif
+		langmap_mapchar[from & 255] = to;
 
 	    /* Advance to next pair */
 	    mb_ptr_adv(p);
diff -Naur vim72.orig/src/os_unix.c vim72/src/os_unix.c
--- vim72.orig/src/os_unix.c	2008-08-06 12:01:40.000000000 +0100
+++ vim72/src/os_unix.c	2009-07-22 22:54:24.000000000 +0100
@@ -181,7 +181,8 @@
 	&& defined(FEAT_TITLE) && !defined(FEAT_GUI_GTK)
 # define SET_SIG_ALARM
 static RETSIGTYPE sig_alarm __ARGS(SIGPROTOARG);
-static int sig_alarm_called;
+/* volatile because it is used in signal handler sig_alarm(). */
+static volatile int sig_alarm_called;
 #endif
 static RETSIGTYPE deathtrap __ARGS(SIGPROTOARG);
 
@@ -201,13 +202,16 @@
 # define SIG_ERR	((RETSIGTYPE (*)())-1)
 #endif
 
-static int	do_resize = FALSE;
+/* volatile because it is used in signal handler sig_winch(). */
+static volatile int do_resize = FALSE;
 #ifndef __EMX__
 static char_u	*extra_shell_arg = NULL;
 static int	show_shell_mess = TRUE;
 #endif
-static int	deadly_signal = 0;	    /* The signal we caught */
-static int	in_mch_delay = FALSE;	    /* sleeping in mch_delay() */
+/* volatile because it is used in signal handler deathtrap(). */
+static volatile int deadly_signal = 0;	    /* The signal we caught */
+/* volatile because it is used in signal handler deathtrap(). */
+static volatile int in_mch_delay = FALSE;    /* sleeping in mch_delay() */
 
 static int curr_tmode = TMODE_COOK;	/* contains current terminal mode */
 
@@ -315,12 +319,32 @@
     {-1,	    "Unknown!", FALSE}
 };
 
+    int
+mch_chdir(path)
+    char *path;
+{
+    if (p_verbose >= 5)
+    {
+	verbose_enter();
+	smsg((char_u *)"chdir(%s)", path);
+	verbose_leave();
+    }
+# ifdef VMS
+    return chdir(vms_fixfilename(path));
+# else
+    return chdir(path);
+# endif
+}
+
+/*
+ * Write s[len] to the screen.
+ */
     void
 mch_write(s, len)
     char_u	*s;
     int		len;
 {
-    write(1, (char *)s, len);
+    ignored = (int)write(1, (char *)s, len);
     if (p_wd)		/* Unix is too fast, slow down a bit more */
 	RealWaitForChar(read_cmd_fd, p_wd, NULL);
 }
@@ -447,10 +471,9 @@
  * Return total amount of memory available in Kbyte.
  * Doesn't change when memory has been allocated.
  */
-/* ARGSUSED */
     long_u
 mch_total_mem(special)
-    int special;
+    int special UNUSED;
 {
 # ifdef __EMX__
     return ulimit(3, 0L) >> 10;   /* always 32MB? */
@@ -799,12 +822,11 @@
 #endif
 
 /*
- * We need correct potatotypes for a signal function, otherwise mean compilers
+ * We need correct prototypes for a signal function, otherwise mean compilers
  * will barf when the second argument to signal() is ``wrong''.
  * Let me try it with a few tricky defines from my own osdef.h	(jw).
  */
 #if defined(SIGWINCH)
-/* ARGSUSED */
     static RETSIGTYPE
 sig_winch SIGDEFARG(sigarg)
 {
@@ -816,7 +838,6 @@
 #endif
 
 #if defined(SIGINT)
-/* ARGSUSED */
     static RETSIGTYPE
 catch_sigint SIGDEFARG(sigarg)
 {
@@ -828,7 +849,6 @@
 #endif
 
 #if defined(SIGPWR)
-/* ARGSUSED */
     static RETSIGTYPE
 catch_sigpwr SIGDEFARG(sigarg)
 {
@@ -848,7 +868,6 @@
 /*
  * signal function for alarm().
  */
-/* ARGSUSED */
     static RETSIGTYPE
 sig_alarm SIGDEFARG(sigarg)
 {
@@ -1065,19 +1084,23 @@
     SIGRETURN;
 }
 
-#ifdef _REENTRANT
+#if defined(_REENTRANT) && defined(SIGCONT)
 /*
  * On Solaris with multi-threading, suspending might not work immediately.
  * Catch the SIGCONT signal, which will be used as an indication whether the
  * suspending has been done or not.
+ *
+ * On Linux, signal is not always handled immediately either.
+ * See https://bugs.launchpad.net/bugs/291373
+ *
+ * volatile because it is used in in signal handler sigcont_handler().
  */
-static int sigcont_received;
+static volatile int sigcont_received;
 static RETSIGTYPE sigcont_handler __ARGS(SIGPROTOARG);
 
 /*
  * signal handler for SIGCONT
  */
-/* ARGSUSED */
     static RETSIGTYPE
 sigcont_handler SIGDEFARG(sigarg)
 {
@@ -1115,15 +1138,28 @@
     }
 # endif
 
-# ifdef _REENTRANT
+# if defined(_REENTRANT) && defined(SIGCONT)
     sigcont_received = FALSE;
 # endif
     kill(0, SIGTSTP);	    /* send ourselves a STOP signal */
-# ifdef _REENTRANT
-    /* When we didn't suspend immediately in the kill(), do it now.  Happens
-     * on multi-threaded Solaris. */
-    if (!sigcont_received)
-	pause();
+# if defined(_REENTRANT) && defined(SIGCONT)
+    /*
+     * Wait for the SIGCONT signal to be handled. It generally happens
+     * immediately, but somehow not all the time. Do not call pause()
+     * because there would be race condition which would hang Vim if
+     * signal happened in between the test of sigcont_received and the
+     * call to pause(). If signal is not yet received, call sleep(0)
+     * to just yield CPU. Signal should then be received. If somehow
+     * it's still not received, sleep 1, 2, 3 ms. Don't bother waiting
+     * further if signal is not received after 1+2+3+4 ms (not expected
+     * to happen).
+     */
+    {
+	long wait_time;
+	for (wait_time = 0; !sigcont_received && wait_time <= 3L; wait_time++)
+	    /* Loop is not entered most of the time */
+	    mch_delay(wait_time, FALSE);
+    }
 # endif
 
 # ifdef FEAT_TITLE
@@ -1172,7 +1208,7 @@
 #ifdef SIGTSTP
     signal(SIGTSTP, restricted ? SIG_IGN : SIG_DFL);
 #endif
-#ifdef _REENTRANT
+#if defined(_REENTRANT) && defined(SIGCONT)
     signal(SIGCONT, sigcont_handler);
 #endif
 
@@ -1231,7 +1267,7 @@
 reset_signals()
 {
     catch_signals(SIG_DFL, SIG_DFL);
-#ifdef _REENTRANT
+#if defined(_REENTRANT) && defined(SIGCONT)
     /* SIGCONT isn't in the list, because its default action is ignore */
     signal(SIGCONT, SIG_DFL);
 #endif
@@ -1326,11 +1362,10 @@
 /*
  * Check_win checks whether we have an interactive stdout.
  */
-/* ARGSUSED */
     int
 mch_check_win(argc, argv)
-    int	    argc;
-    char    **argv;
+    int	    argc UNUSED;
+    char    **argv UNUSED;
 {
 #ifdef OS2
     /*
@@ -1414,11 +1449,10 @@
 /*
  * Another X Error handler, just used to check for errors.
  */
-/* ARGSUSED */
     static int
 x_error_check(dpy, error_event)
-    Display *dpy;
-    XErrorEvent	*error_event;
+    Display *dpy UNUSED;
+    XErrorEvent	*error_event UNUSED;
 {
     got_x_error = TRUE;
     return 0;
@@ -1431,15 +1465,12 @@
  */
 static int x_IOerror_check __ARGS((Display *dpy));
 
-/* ARGSUSED */
     static int
 x_IOerror_check(dpy)
-    Display *dpy;
+    Display *dpy UNUSED;
 {
     /* This function should not return, it causes exit().  Longjump instead. */
     LONGJMP(lc_jump_env, 1);
-    /*NOTREACHED*/
-    return 0;
 }
 # endif
 
@@ -1448,10 +1479,9 @@
  */
 static int x_IOerror_handler __ARGS((Display *dpy));
 
-/* ARGSUSED */
     static int
 x_IOerror_handler(dpy)
-    Display *dpy;
+    Display *dpy UNUSED;
 {
     xterm_dpy = NULL;
     x11_window = 0;
@@ -1460,8 +1490,6 @@
 
     /* This function should not return, it causes exit().  Longjump instead. */
     LONGJMP(x_jump_env, 1);
-    /*NOTREACHED*/
-    return 0;
 }
 #endif
 
@@ -1706,9 +1734,9 @@
     if (oldicon == NULL && !test_only)
     {
 	if (STRNCMP(T_NAME, "builtin_", 8) == 0)
-	    oldicon = T_NAME + 8;
+	    oldicon = vim_strsave(T_NAME + 8);
 	else
-	    oldicon = T_NAME;
+	    oldicon = vim_strsave(T_NAME);
     }
 
     return retval;
@@ -1897,10 +1925,9 @@
 
 #else  /* FEAT_X11 */
 
-/*ARGSUSED*/
     static int
 get_x11_title(test_only)
-    int	    test_only;
+    int	    test_only UNUSED;
 {
     return FALSE;
 }
@@ -1912,9 +1939,9 @@
     if (!test_only)
     {
 	if (STRNCMP(T_NAME, "builtin_", 8) == 0)
-	    oldicon = T_NAME + 8;
+	    oldicon = vim_strsave(T_NAME + 8);
 	else
-	    oldicon = T_NAME;
+	    oldicon = vim_strsave(T_NAME);
     }
     return FALSE;
 }
@@ -2414,6 +2441,12 @@
 #ifdef HAVE_FCHDIR
 	    if (fd >= 0)
 	    {
+		if (p_verbose >= 5)
+		{
+		    verbose_enter();
+		    MSG("fchdir() to previous dir");
+		    verbose_leave();
+		}
 		l = fchdir(fd);
 		close(fd);
 	    }
@@ -2438,7 +2471,7 @@
     }
 
     /* Catch file names which are too long. */
-    if (retval == FAIL || STRLEN(buf) + STRLEN(fname) >= len)
+    if (retval == FAIL || (int)(STRLEN(buf) + STRLEN(fname)) >= len)
 	return FAIL;
 
     /* Do not append ".", "/dir/." is equal to "/dir". */
@@ -2475,11 +2508,10 @@
  * file name to remain exactly the same.
  * Only required for file systems where case is ignored and preserved.
  */
-/*ARGSUSED*/
     void
 fname_case(name, len)
     char_u	*name;
-    int		len;	    /* buffer size, only used when name gets longer */
+    int		len UNUSED;  /* buffer size, only used when name gets longer */
 {
     struct stat st;
     char_u	*slash, *tail;
@@ -2657,7 +2689,7 @@
  */
     vim_acl_T
 mch_get_acl(fname)
-    char_u	*fname;
+    char_u	*fname UNUSED;
 {
     vim_acl_T	ret = NULL;
 #ifdef HAVE_POSIX_ACL
@@ -2717,7 +2749,7 @@
  */
     void
 mch_set_acl(fname, aclent)
-    char_u	*fname;
+    char_u	*fname UNUSED;
     vim_acl_T	aclent;
 {
     if (aclent == NULL)
@@ -2760,10 +2792,9 @@
 /*
  * Set hidden flag for "name".
  */
-/* ARGSUSED */
     void
 mch_hide(name)
-    char_u	*name;
+    char_u	*name UNUSED;
 {
     /* can't hide a file */
 }
@@ -2905,7 +2936,7 @@
      * Ignore any errors.
      */
 #if defined(HAVE_SIGALTSTACK) || defined(HAVE_SIGSTACK)
-    signal_stack = malloc(SIGSTKSZ);
+    signal_stack = (char *)alloc(SIGSTKSZ);
     init_signal_stack();
 #endif
 }
@@ -2936,7 +2967,8 @@
     }
 #  endif
 # endif
-# ifdef FEAT_X11
+    /* Don't close the display for GTK 1, it is done in exit(). */
+# if defined(FEAT_X11) && (!defined(FEAT_GUI_GTK) || defined(HAVE_GTK2))
     if (x11_display != NULL
 #  ifdef FEAT_XCLIPBOARD
 	    && x11_display != xterm_dpy
@@ -3451,10 +3483,9 @@
 /*
  * set screen mode, always fails.
  */
-/* ARGSUSED */
     int
 mch_screenmode(arg)
-    char_u   *arg;
+    char_u   *arg UNUSED;
 {
     EMSG(_(e_screenmode));
     return FAIL;
@@ -3926,9 +3957,9 @@
 		 */
 		if (fd >= 0)
 		{
-		    dup(fd); /* To replace stdin  (file descriptor 0) */
-		    dup(fd); /* To replace stdout (file descriptor 1) */
-		    dup(fd); /* To replace stderr (file descriptor 2) */
+		    ignored = dup(fd); /* To replace stdin  (fd 0) */
+		    ignored = dup(fd); /* To replace stdout (fd 1) */
+		    ignored = dup(fd); /* To replace stderr (fd 2) */
 
 		    /* Don't need this now that we've duplicated it */
 		    close(fd);
@@ -3946,7 +3977,17 @@
 		 * children can be kill()ed.  Don't do this when using pipes,
 		 * because stdin is not a tty, we would lose /dev/tty. */
 		if (p_stmp)
+		{
 		    (void)setsid();
+#  if defined(SIGHUP)
+		    /* When doing "!xterm&" and 'shell' is bash: the shell
+		     * will exit and send SIGHUP to all processes in its
+		     * group, killing the just started process.  Ignore SIGHUP
+		     * to avoid that. (suggested by Simon Schubert)
+		     */
+		    signal(SIGHUP, SIG_IGN);
+#  endif
+		}
 # endif
 # ifdef FEAT_GUI
 		if (pty_slave_fd >= 0)
@@ -3996,13 +4037,13 @@
 
 		    /* set up stdin/stdout/stderr for the child */
 		    close(0);
-		    dup(pty_slave_fd);
+		    ignored = dup(pty_slave_fd);
 		    close(1);
-		    dup(pty_slave_fd);
+		    ignored = dup(pty_slave_fd);
 		    if (gui.in_use)
 		    {
 			close(2);
-			dup(pty_slave_fd);
+			ignored = dup(pty_slave_fd);
 		    }
 
 		    close(pty_slave_fd);    /* has been dupped, close it now */
@@ -4013,13 +4054,13 @@
 		    /* set up stdin for the child */
 		    close(fd_toshell[1]);
 		    close(0);
-		    dup(fd_toshell[0]);
+		    ignored = dup(fd_toshell[0]);
 		    close(fd_toshell[0]);
 
 		    /* set up stdout for the child */
 		    close(fd_fromshell[0]);
 		    close(1);
-		    dup(fd_fromshell[1]);
+		    ignored = dup(fd_fromshell[1]);
 		    close(fd_fromshell[1]);
 
 # ifdef FEAT_GUI
@@ -4027,7 +4068,7 @@
 		    {
 			/* set up stderr for the child */
 			close(2);
-			dup(1);
+			ignored = dup(1);
 		    }
 # endif
 		}
@@ -4078,6 +4119,9 @@
 		int	    fromshell_fd;
 		garray_T    ga;
 		int	    noread_cnt;
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+		struct timeval  start_tv;
+# endif
 
 # ifdef FEAT_GUI
 		if (pty_master_fd >= 0)
@@ -4146,9 +4190,10 @@
 			    {
 				s = vim_strchr(lp + written, NL);
 				len = write(toshell_fd, (char *)lp + written,
-					   s == NULL ? l : s - (lp + written));
+					   s == NULL ? l
+					      : (size_t)(s - (lp + written)));
 			    }
-			    if (len == l)
+			    if (len == (int)l)
 			    {
 				/* Finished a line, add a NL, unless this line
 				 * should not have one. */
@@ -4158,7 +4203,8 @@
 					    && (lnum !=
 						    curbuf->b_ml.ml_line_count
 						    || curbuf->b_p_eol)))
-				    write(toshell_fd, "\n", (size_t)1);
+				    ignored = write(toshell_fd, "\n",
+								   (size_t)1);
 				++lnum;
 				if (lnum > curbuf->b_op_end.lnum)
 				{
@@ -4186,7 +4232,9 @@
 		    ga_init2(&ga, 1, BUFLEN);
 
 		noread_cnt = 0;
-
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+		gettimeofday(&start_tv, NULL);
+# endif
 		for (;;)
 		{
 		    /*
@@ -4199,25 +4247,34 @@
 		     * that a typed password is echoed for ssh or gpg command.
 		     * Don't get characters when the child has already
 		     * finished (wait_pid == 0).
-		     * Don't get extra characters when we already have one.
 		     * Don't read characters unless we didn't get output for a
-		     * while, avoids that ":r !ls" eats typeahead.
+		     * while (noread_cnt > 4), avoids that ":r !ls" eats
+		     * typeahead.
 		     */
 		    len = 0;
 		    if (!(options & SHELL_EXPAND)
 			    && ((options &
 					 (SHELL_READ|SHELL_WRITE|SHELL_COOKED))
 				      != (SHELL_READ|SHELL_WRITE|SHELL_COOKED)
-#ifdef FEAT_GUI
+# ifdef FEAT_GUI
 						    || gui.in_use
-#endif
+# endif
 						    )
 			    && wait_pid == 0
-			    && (ta_len > 0
-				|| (noread_cnt > 4
-				    && (len = ui_inchar(ta_buf,
-						       BUFLEN, 10L, 0)) > 0)))
+			    && (ta_len > 0 || noread_cnt > 4))
 		    {
+		      if (ta_len == 0)
+		      {
+			  /* Get extra characters when we don't have any.
+			   * Reset the counter and timer. */
+			  noread_cnt = 0;
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+			  gettimeofday(&start_tv, NULL);
+# endif
+			  len = ui_inchar(ta_buf, BUFLEN, 10L, 0);
+		      }
+		      if (ta_len > 0 || len > 0)
+		      {
 			/*
 			 * For pipes:
 			 * Check for CTRL-C: send interrupt signal to child.
@@ -4271,7 +4328,8 @@
 				ta_buf[i] = '\n';
 # ifdef FEAT_MBYTE
 			    if (has_mbyte)
-				i += (*mb_ptr2len)(ta_buf + i) - 1;
+				i += (*mb_ptr2len_len)(ta_buf + i,
+							ta_len + len - i) - 1;
 # endif
 			}
 
@@ -4319,9 +4377,9 @@
 			    {
 				ta_len -= len;
 				mch_memmove(ta_buf, ta_buf + len, ta_len);
-				noread_cnt = 0;
 			    }
 			}
+		      }
 		    }
 
 		    if (got_int)
@@ -4429,6 +4487,25 @@
 			out_flush();
 			if (got_int)
 			    break;
+
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+			{
+			    struct timeval  now_tv;
+			    long	    msec;
+
+			    /* Avoid that we keep looping here without
+			     * checking for a CTRL-C for a long time.  Don't
+			     * break out too often to avoid losing typeahead. */
+			    gettimeofday(&now_tv, NULL);
+			    msec = (now_tv.tv_sec - start_tv.tv_sec) * 1000L
+				+ (now_tv.tv_usec - start_tv.tv_usec) / 1000L;
+			    if (msec > 2000)
+			    {
+				noread_cnt = 5;
+				break;
+			    }
+			}
+# endif
 		    }
 
 		    /* If we already detected the child has finished break the
@@ -4672,7 +4749,6 @@
  * Returns also, when a request from Sniff is waiting -- toni.
  * Or when a Linux GPM mouse event is waiting.
  */
-/* ARGSUSED */
 #if defined(__BEOS__)
     int
 #else
@@ -4681,7 +4757,7 @@
 RealWaitForChar(fd, msec, check_for_gpm)
     int		fd;
     long	msec;
-    int		*check_for_gpm;
+    int		*check_for_gpm UNUSED;
 {
     int		ret;
 #if defined(FEAT_XCLIPBOARD) || defined(USE_XSMP) || defined(FEAT_MZSCHEME)
@@ -5076,7 +5152,6 @@
 
 #define SHELL_SPECIAL (char_u *)"\t \"&'$;<>()\\|"
 
-/* ARGSUSED */
     int
 mch_expand_wildcards(num_pat, pat, num_file, file, flags)
     int		   num_pat;
@@ -5498,7 +5573,7 @@
     i = fread((char *)buffer, 1, len, fd);
     fclose(fd);
     mch_remove(tempname);
-    if (i != len)
+    if (i != (int)len)
     {
 	/* unexpected read error */
 	EMSG2(_(e_notread), tempname);
@@ -5559,7 +5634,7 @@
 	if (shell_style == STYLE_PRINT && !did_find_nul)
 	{
 	    /* If there is a NUL, set did_find_nul, else set check_spaces */
-	    if (len && (int)STRLEN(buffer) < len - 1)
+	    if (len && (int)STRLEN(buffer) < (int)len - 1)
 		did_find_nul = TRUE;
 	    else
 		check_spaces = TRUE;
@@ -5851,7 +5926,9 @@
 	     * we are going to suspend or starting an external process
 	     * so we shouldn't  have problem with this
 	     */
+# ifdef SIGTSTP
 	    signal(SIGTSTP, restricted ? SIG_IGN : SIG_DFL);
+# endif
 	    return 1; /* succeed */
 	}
 	if (gpm_fd == -2)
@@ -6001,7 +6078,6 @@
 /*
  * Gets info from sysmouse and adds special keys to input buf.
  */
-/* ARGSUSED */
     static RETSIGTYPE
 sig_sysmouse SIGDEFARG(sigarg)
 {
@@ -6565,11 +6641,10 @@
  * This is our chance to ask the user if they want to save,
  * or abort the logout
  */
-/*ARGSUSED*/
     static void
 xsmp_handle_interaction(smc_conn, client_data)
     SmcConn	smc_conn;
-    SmPointer	client_data;
+    SmPointer	client_data UNUSED;
 {
     cmdmod_T	save_cmdmod;
     int		cancel_shutdown = False;
@@ -6602,16 +6677,15 @@
 /*
  * Callback that starts save-yourself.
  */
-/*ARGSUSED*/
     static void
 xsmp_handle_save_yourself(smc_conn, client_data, save_type,
 					       shutdown, interact_style, fast)
     SmcConn	smc_conn;
-    SmPointer	client_data;
-    int		save_type;
+    SmPointer	client_data UNUSED;
+    int		save_type UNUSED;
     Bool	shutdown;
-    int		interact_style;
-    Bool	fast;
+    int		interact_style UNUSED;
+    Bool	fast UNUSED;
 {
     /* Handle already being in saveyourself */
     if (xsmp.save_yourself)
@@ -6645,11 +6719,10 @@
 /*
  * Callback to warn us of imminent death.
  */
-/*ARGSUSED*/
     static void
 xsmp_die(smc_conn, client_data)
-    SmcConn	smc_conn;
-    SmPointer	client_data;
+    SmcConn	smc_conn UNUSED;
+    SmPointer	client_data UNUSED;
 {
     xsmp_close();
 
@@ -6661,11 +6734,10 @@
 /*
  * Callback to tell us that save-yourself has completed.
  */
-/*ARGSUSED*/
     static void
 xsmp_save_complete(smc_conn, client_data)
-    SmcConn	smc_conn;
-    SmPointer	client_data;
+    SmcConn	smc_conn UNUSED;
+    SmPointer	client_data UNUSED;
 {
     xsmp.save_yourself = False;
 }
@@ -6675,11 +6747,10 @@
  * Callback to tell us that an instigated shutdown was cancelled
  * (maybe even by us)
  */
-/*ARGSUSED*/
     static void
 xsmp_shutdown_cancelled(smc_conn, client_data)
     SmcConn	smc_conn;
-    SmPointer	client_data;
+    SmPointer	client_data UNUSED;
 {
     if (xsmp.save_yourself)
 	SmcSaveYourselfDone(smc_conn, True);
@@ -6691,13 +6762,12 @@
 /*
  * Callback to tell us that a new ICE connection has been established.
  */
-/*ARGSUSED*/
     static void
 xsmp_ice_connection(iceConn, clientData, opening, watchData)
     IceConn	iceConn;
-    IcePointer	clientData;
+    IcePointer	clientData UNUSED;
     Bool	opening;
-    IcePointer	*watchData;
+    IcePointer	*watchData UNUSED;
 {
     /* Intercept creation of ICE connection fd */
     if (opening)
@@ -6814,7 +6884,8 @@
     if (xsmp_icefd != -1)
     {
 	SmcCloseConnection(xsmp.smcconn, 0, NULL);
-	vim_free(xsmp.clientid);
+	if (xsmp.clientid != NULL)
+	    free(xsmp.clientid);
 	xsmp.clientid = NULL;
 	xsmp_icefd = -1;
     }
diff -Naur vim72.orig/src/os_unix.h vim72/src/os_unix.h
--- vim72.orig/src/os_unix.h	2008-06-17 19:01:17.000000000 +0100
+++ vim72/src/os_unix.h	2009-07-22 22:54:23.000000000 +0100
@@ -124,7 +124,7 @@
 #  define SIGDUMMYARG	0, 0, (struct sigcontext *)0
 # else
 #  define SIGPROTOARG	(int)
-#  define SIGDEFARG(s)	(s) int s;
+#  define SIGDEFARG(s)	(s) int s UNUSED;
 #  define SIGDUMMYARG	0
 # endif
 #else
@@ -482,11 +482,6 @@
 # else
 int mch_rename __ARGS((const char *src, const char *dest));
 # endif
-# ifdef VMS
-#  define mch_chdir(s) chdir(vms_fixfilename(s))
-# else
-#  define mch_chdir(s) chdir(s)
-# endif
 # ifndef VMS
 #  ifdef __MVS__
   /* on OS390 Unix getenv() doesn't return a pointer to persistent
diff -Naur vim72.orig/src/popupmnu.c vim72/src/popupmnu.c
--- vim72.orig/src/popupmnu.c	2008-07-12 17:28:18.000000000 +0100
+++ vim72/src/popupmnu.c	2009-07-22 22:54:17.000000000 +0100
@@ -573,7 +573,7 @@
 		{
 		    /* Don't want to sync undo in the current buffer. */
 		    ++no_u_sync;
-		    res = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, 0);
+		    res = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, 0, NULL);
 		    --no_u_sync;
 		    if (res == OK)
 		    {
diff -Naur vim72.orig/src/proto/buffer.pro vim72/src/proto/buffer.pro
--- vim72.orig/src/proto/buffer.pro	2008-08-09 15:31:21.000000000 +0100
+++ vim72/src/proto/buffer.pro	2009-07-22 22:54:21.000000000 +0100
@@ -33,17 +33,16 @@
 char_u *getaltfname __ARGS((int errmsg));
 int buflist_add __ARGS((char_u *fname, int flags));
 void buflist_slash_adjust __ARGS((void));
-void buflist_altfpos __ARGS((void));
+void buflist_altfpos __ARGS((win_T *win));
 int otherfile __ARGS((char_u *ffname));
 void buf_setino __ARGS((buf_T *buf));
 void fileinfo __ARGS((int fullname, int shorthelp, int dont_truncate));
-void col_print __ARGS((char_u *buf, int col, int vcol));
+void col_print __ARGS((char_u *buf, size_t buflen, int col, int vcol));
 void maketitle __ARGS((void));
 void resettitle __ARGS((void));
 void free_titles __ARGS((void));
 int build_stl_str_hl __ARGS((win_T *wp, char_u *out, size_t outlen, char_u *fmt, int use_sandbox, int fillchar, int maxwidth, struct stl_hlrec *hltab, struct stl_hlrec *tabtab));
-void get_rel_pos __ARGS((win_T *wp, char_u *str));
-int append_arg_number __ARGS((win_T *wp, char_u *buf, int add_file, int maxlen));
+void get_rel_pos __ARGS((win_T *wp, char_u *buf, int buflen));
 char_u *fix_fname __ARGS((char_u *fname));
 void fname_expand __ARGS((buf_T *buf, char_u **ffname, char_u **sfname));
 char_u *alist_name __ARGS((aentry_T *aep));
@@ -54,8 +53,8 @@
 void write_viminfo_bufferlist __ARGS((FILE *fp));
 char *buf_spname __ARGS((buf_T *buf));
 void buf_addsign __ARGS((buf_T *buf, int id, linenr_T lnum, int typenr));
-int buf_change_sign_type __ARGS((buf_T *buf, int markId, int typenr));
-int_u buf_getsigntype __ARGS((buf_T *buf, linenr_T lnum, int type));
+linenr_T buf_change_sign_type __ARGS((buf_T *buf, int markId, int typenr));
+int buf_getsigntype __ARGS((buf_T *buf, linenr_T lnum, int type));
 linenr_T buf_delsign __ARGS((buf_T *buf, int id));
 int buf_findsign __ARGS((buf_T *buf, int id));
 int buf_findsign_id __ARGS((buf_T *buf, linenr_T lnum));
diff -Naur vim72.orig/src/proto/edit.pro vim72/src/proto/edit.pro
--- vim72.orig/src/proto/edit.pro	2008-08-09 15:31:24.000000000 +0100
+++ vim72/src/proto/edit.pro	2009-07-22 22:54:21.000000000 +0100
@@ -8,7 +8,7 @@
 void backspace_until_column __ARGS((int col));
 int vim_is_ctrl_x_key __ARGS((int c));
 int ins_compl_add_infercase __ARGS((char_u *str, int len, int icase, char_u *fname, int dir, int flags));
-void set_completion __ARGS((int startcol, list_T *list));
+void set_completion __ARGS((colnr_T startcol, list_T *list));
 void ins_compl_show_pum __ARGS((void));
 char_u *find_word_start __ARGS((char_u *ptr));
 char_u *find_word_end __ARGS((char_u *ptr));
diff -Naur vim72.orig/src/proto/eval.pro vim72/src/proto/eval.pro
--- vim72.orig/src/proto/eval.pro	2008-08-09 15:31:25.000000000 +0100
+++ vim72/src/proto/eval.pro	2009-07-22 22:54:18.000000000 +0100
@@ -17,7 +17,7 @@
 int eval_to_bool __ARGS((char_u *arg, int *error, char_u **nextcmd, int skip));
 char_u *eval_to_string_skip __ARGS((char_u *arg, char_u **nextcmd, int skip));
 int skip_expr __ARGS((char_u **pp));
-char_u *eval_to_string __ARGS((char_u *arg, char_u **nextcmd, int dolist));
+char_u *eval_to_string __ARGS((char_u *arg, char_u **nextcmd, int convert));
 char_u *eval_to_string_safe __ARGS((char_u *arg, char_u **nextcmd, int use_sandbox));
 int eval_to_number __ARGS((char_u *expr));
 list_T *eval_spell_expr __ARGS((char_u *badword, char_u *expr));
@@ -46,7 +46,9 @@
 void list_unref __ARGS((list_T *l));
 void list_free __ARGS((list_T *l, int recurse));
 dictitem_T *dict_lookup __ARGS((hashitem_T *hi));
+char_u *list_find_str __ARGS((list_T *l, long idx));
 int list_append_dict __ARGS((list_T *list, dict_T *dict));
+int list_append_string __ARGS((list_T *l, char_u *str, int len));
 int garbage_collect __ARGS((void));
 dict_T *dict_alloc __ARGS((void));
 int dict_add_nr_str __ARGS((dict_T *d, char *key, long nr, char_u *str));
@@ -58,8 +60,10 @@
 void set_vim_var_nr __ARGS((int idx, long val));
 long get_vim_var_nr __ARGS((int idx));
 char_u *get_vim_var_str __ARGS((int idx));
-void set_vcount __ARGS((long count, long count1));
+list_T *get_vim_var_list __ARGS((int idx));
+void set_vcount __ARGS((long count, long count1, int set_prevcount));
 void set_vim_var_string __ARGS((int idx, char_u *val, int len));
+void set_vim_var_list __ARGS((int idx, list_T *val));
 void set_reg_var __ARGS((int c));
 char_u *v_exception __ARGS((char_u *oldval));
 char_u *v_throwpoint __ARGS((char_u *oldval));
@@ -94,6 +98,7 @@
 void write_viminfo_varlist __ARGS((FILE *fp));
 int store_session_globals __ARGS((FILE *fd));
 void last_set_msg __ARGS((scid_T scriptID));
+void ex_oldfiles __ARGS((exarg_T *eap));
 int modify_fname __ARGS((char_u *src, int *usedlen, char_u **fnamep, char_u **bufp, int *fnamelen));
 char_u *do_string_sub __ARGS((char_u *str, char_u *pat, char_u *sub, char_u *flags));
 /* vim: set ft=c : */
diff -Naur vim72.orig/src/proto/ex_cmds.pro vim72/src/proto/ex_cmds.pro
--- vim72.orig/src/proto/ex_cmds.pro	2008-08-09 15:31:25.000000000 +0100
+++ vim72/src/proto/ex_cmds.pro	2009-07-22 22:54:21.000000000 +0100
@@ -9,9 +9,9 @@
 void do_bang __ARGS((int addr_count, exarg_T *eap, int forceit, int do_in, int do_out));
 void do_shell __ARGS((char_u *cmd, int flags));
 char_u *make_filter_cmd __ARGS((char_u *cmd, char_u *itmp, char_u *otmp));
-void append_redir __ARGS((char_u *buf, char_u *opt, char_u *fname));
+void append_redir __ARGS((char_u *buf, int buflen, char_u *opt, char_u *fname));
 int viminfo_error __ARGS((char *errnum, char *message, char_u *line));
-int read_viminfo __ARGS((char_u *file, int want_info, int want_marks, int forceit));
+int read_viminfo __ARGS((char_u *file, int flags));
 void write_viminfo __ARGS((char_u *file, int forceit));
 int viminfo_readline __ARGS((vir_T *virp));
 char_u *viminfo_readstring __ARGS((vir_T *virp, int off, int convert));
@@ -27,7 +27,7 @@
 void do_wqall __ARGS((exarg_T *eap));
 int not_writing __ARGS((void));
 int getfile __ARGS((int fnum, char_u *ffname, char_u *sfname, int setpm, linenr_T lnum, int forceit));
-int do_ecmd __ARGS((int fnum, char_u *ffname, char_u *sfname, exarg_T *eap, linenr_T newlnum, int flags));
+int do_ecmd __ARGS((int fnum, char_u *ffname, char_u *sfname, exarg_T *eap, linenr_T newlnum, int flags, win_T *oldwin));
 void ex_append __ARGS((exarg_T *eap));
 void ex_change __ARGS((exarg_T *eap));
 void ex_z __ARGS((exarg_T *eap));
@@ -55,5 +55,8 @@
 char_u *sign_get_text __ARGS((int typenr));
 void *sign_get_image __ARGS((int typenr));
 char_u *sign_typenr2name __ARGS((int typenr));
+void free_signs __ARGS((void));
+char_u *get_sign_name __ARGS((expand_T *xp, int idx));
+void set_context_in_sign_cmd __ARGS((expand_T *xp, char_u *arg));
 void ex_drop __ARGS((exarg_T *eap));
 /* vim: set ft=c : */
diff -Naur vim72.orig/src/proto/ex_getln.pro vim72/src/proto/ex_getln.pro
--- vim72.orig/src/proto/ex_getln.pro	2008-08-09 15:31:28.000000000 +0100
+++ vim72/src/proto/ex_getln.pro	2009-07-22 22:54:20.000000000 +0100
@@ -4,6 +4,7 @@
 int text_locked __ARGS((void));
 void text_locked_msg __ARGS((void));
 int curbuf_locked __ARGS((void));
+int allbuf_locked __ARGS((void));
 char_u *getexline __ARGS((int c, void *dummy, int indent));
 char_u *getexmodeline __ARGS((int promptc, void *dummy, int indent));
 int cmdline_overstrike __ARGS((void));
@@ -31,7 +32,7 @@
 void set_cmd_context __ARGS((expand_T *xp, char_u *str, int len, int col));
 int expand_cmdline __ARGS((expand_T *xp, char_u *str, int col, int *matchcount, char_u ***matches));
 int ExpandGeneric __ARGS((expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file, char_u *((*func)(expand_T *, int))));
-char_u *globpath __ARGS((char_u *path, char_u *file));
+char_u *globpath __ARGS((char_u *path, char_u *file, int expand_options));
 void init_history __ARGS((void));
 int get_histtype __ARGS((char_u *name));
 void add_to_history __ARGS((int histype, char_u *new_entry, int in_map, int sep));
diff -Naur vim72.orig/src/proto/gui.pro vim72/src/proto/gui.pro
--- vim72.orig/src/proto/gui.pro	2008-08-09 15:31:56.000000000 +0100
+++ vim72/src/proto/gui.pro	2009-07-22 22:54:23.000000000 +0100
@@ -43,6 +43,7 @@
 void gui_create_scrollbar __ARGS((scrollbar_T *sb, int type, win_T *wp));
 scrollbar_T *gui_find_scrollbar __ARGS((long ident));
 void gui_drag_scrollbar __ARGS((scrollbar_T *sb, long value, int still_dragging));
+void gui_may_update_scrollbars __ARGS((void));
 void gui_update_scrollbars __ARGS((int force));
 int gui_do_scroll __ARGS((void));
 int gui_do_horiz_scroll __ARGS((void));
diff -Naur vim72.orig/src/proto/if_cscope.pro vim72/src/proto/if_cscope.pro
--- vim72.orig/src/proto/if_cscope.pro	2008-08-09 15:31:33.000000000 +0100
+++ vim72/src/proto/if_cscope.pro	2009-07-22 22:54:21.000000000 +0100
@@ -1,4 +1,6 @@
 /* if_cscope.c */
+char_u *get_cscope_name __ARGS((expand_T *xp, int idx));
+void set_context_in_cscope_cmd __ARGS((expand_T *xp, char_u *arg, cmdidx_T cmdidx));
 void do_cscope __ARGS((exarg_T *eap));
 void do_scscope __ARGS((exarg_T *eap));
 void do_cstag __ARGS((exarg_T *eap));
diff -Naur vim72.orig/src/proto/if_mzsch.pro vim72/src/proto/if_mzsch.pro
--- vim72.orig/src/proto/if_mzsch.pro	2004-07-12 09:27:00.000000000 +0100
+++ vim72/src/proto/if_mzsch.pro	2009-07-22 22:54:22.000000000 +0100
@@ -15,10 +15,6 @@
 void *mzvim_eval_string __ARGS((char_u *str));
 struct Scheme_Object *mzvim_apply __ARGS((struct Scheme_Object *, int argc,
     struct Scheme_Object **));
-int mzthreads_allowed (void);
-#ifdef FEAT_GUI_KDE
-void timer_proc (void);
-void mzscheme_kde_start_timer (void);
-void mzscheme_kde_stop_timer (void);
-#endif
+int mzthreads_allowed __ARGS((void));
+void mzscheme_main __ARGS((void));
 /* vim: set ft=c : */
diff -Naur vim72.orig/src/proto/mark.pro vim72/src/proto/mark.pro
--- vim72.orig/src/proto/mark.pro	2008-08-09 15:31:36.000000000 +0100
+++ vim72/src/proto/mark.pro	2009-07-22 22:54:17.000000000 +0100
@@ -26,5 +26,5 @@
 void write_viminfo_filemarks __ARGS((FILE *fp));
 int removable __ARGS((char_u *name));
 int write_viminfo_marks __ARGS((FILE *fp_out));
-void copy_viminfo_marks __ARGS((vir_T *virp, FILE *fp_out, int count, int eof));
+void copy_viminfo_marks __ARGS((vir_T *virp, FILE *fp_out, int count, int eof, int flags));
 /* vim: set ft=c : */
diff -Naur vim72.orig/src/proto/mbyte.pro vim72/src/proto/mbyte.pro
--- vim72.orig/src/proto/mbyte.pro	2008-08-09 15:31:41.000000000 +0100
+++ vim72/src/proto/mbyte.pro	2009-07-22 22:54:22.000000000 +0100
@@ -7,10 +7,12 @@
 int latin_char2len __ARGS((int c));
 int latin_char2bytes __ARGS((int c, char_u *buf));
 int latin_ptr2len __ARGS((char_u *p));
+int latin_ptr2len_len __ARGS((char_u *p, int size));
 int utf_char2cells __ARGS((int c));
 int latin_ptr2cells __ARGS((char_u *p));
 int utf_ptr2cells __ARGS((char_u *p));
 int dbcs_ptr2cells __ARGS((char_u *p));
+int latin_ptr2cells_len __ARGS((char_u *p, int size));
 int latin_char2cells __ARGS((int c));
 int latin_off2cells __ARGS((unsigned off, unsigned max_off));
 int dbcs_off2cells __ARGS((unsigned off, unsigned max_off));
@@ -85,6 +87,7 @@
 int preedit_get_status __ARGS((void));
 int im_is_preediting __ARGS((void));
 int convert_setup __ARGS((vimconv_T *vcp, char_u *from, char_u *to));
+int convert_setup_ext __ARGS((vimconv_T *vcp, char_u *from, int from_unicode_is_utf8, char_u *to, int to_unicode_is_utf8));
 int convert_input __ARGS((char_u *ptr, int len, int maxlen));
 int convert_input_safe __ARGS((char_u *ptr, int len, int maxlen, char_u **restp, int *restlenp));
 char_u *string_convert __ARGS((vimconv_T *vcp, char_u *ptr, int *lenp));
diff -Naur vim72.orig/src/proto/message.pro vim72/src/proto/message.pro
--- vim72.orig/src/proto/message.pro	2008-08-09 15:31:39.000000000 +0100
+++ vim72/src/proto/message.pro	2009-07-22 22:54:21.000000000 +0100
@@ -54,6 +54,7 @@
 void msg_clr_cmdline __ARGS((void));
 int msg_end __ARGS((void));
 void msg_check __ARGS((void));
+int redirecting __ARGS((void));
 void verbose_enter __ARGS((void));
 void verbose_leave __ARGS((void));
 void verbose_enter_scroll __ARGS((void));
diff -Naur vim72.orig/src/proto/misc2.pro vim72/src/proto/misc2.pro
--- vim72.orig/src/proto/misc2.pro	2008-08-09 15:31:40.000000000 +0100
+++ vim72/src/proto/misc2.pro	2009-07-22 22:54:18.000000000 +0100
@@ -59,7 +59,7 @@
 int handle_x_keys __ARGS((int key));
 char_u *get_special_key_name __ARGS((int c, int modifiers));
 int trans_special __ARGS((char_u **srcp, char_u *dst, int keycode));
-int find_special_key __ARGS((char_u **srcp, int *modp, int keycode));
+int find_special_key __ARGS((char_u **srcp, int *modp, int keycode, int keep_x_key));
 int extract_modifiers __ARGS((int key, int *modp));
 int find_special_key_in_table __ARGS((int c));
 int get_special_key_code __ARGS((char_u *name));
diff -Naur vim72.orig/src/proto/netbeans.pro vim72/src/proto/netbeans.pro
--- vim72.orig/src/proto/netbeans.pro	2008-08-09 15:31:56.000000000 +0100
+++ vim72/src/proto/netbeans.pro	2009-07-22 22:54:19.000000000 +0100
@@ -11,7 +11,7 @@
 void netbeans_frame_moved __ARGS((int new_x, int new_y));
 void netbeans_file_activated __ARGS((buf_T *bufp));
 void netbeans_file_opened __ARGS((buf_T *bufp));
-void netbeans_file_closed __ARGS((buf_T *bufp));
+void netbeans_file_killed __ARGS((buf_T *bufp));
 void netbeans_inserted __ARGS((buf_T *bufp, linenr_T linenr, colnr_T col, char_u *txt, int newlen));
 void netbeans_removed __ARGS((buf_T *bufp, linenr_T linenr, colnr_T col, long len));
 void netbeans_unmodified __ARGS((buf_T *bufp));
diff -Naur vim72.orig/src/proto/option.pro vim72/src/proto/option.pro
--- vim72.orig/src/proto/option.pro	2008-08-09 15:31:43.000000000 +0100
+++ vim72/src/proto/option.pro	2009-07-22 22:54:24.000000000 +0100
@@ -29,6 +29,7 @@
 int makefoldset __ARGS((FILE *fd));
 void clear_termoptions __ARGS((void));
 void free_termoptions __ARGS((void));
+void free_one_termoption __ARGS((char_u *var));
 void set_term_defaults __ARGS((void));
 void comp_col __ARGS((void));
 char_u *get_equalprg __ARGS((void));
@@ -44,6 +45,7 @@
 void set_context_in_set_cmd __ARGS((expand_T *xp, char_u *arg, int opt_flags));
 int ExpandSettings __ARGS((expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file));
 int ExpandOldSetting __ARGS((int *num_file, char_u ***file));
+int langmap_adjust_mb __ARGS((int c));
 int has_format_option __ARGS((int x));
 int shortmess __ARGS((int x));
 void vimrc_found __ARGS((char_u *fname, char_u *envname));
diff -Naur vim72.orig/src/proto/os_unix.pro vim72/src/proto/os_unix.pro
--- vim72.orig/src/proto/os_unix.pro	2008-08-09 15:31:44.000000000 +0100
+++ vim72/src/proto/os_unix.pro	2009-07-22 22:54:23.000000000 +0100
@@ -1,4 +1,5 @@
 /* os_unix.c */
+int mch_chdir __ARGS((char *path));
 void mch_write __ARGS((char_u *s, int len));
 int mch_inchar __ARGS((char_u *buf, int maxlen, long wtime, int tb_change_cnt));
 int mch_char_avail __ARGS((void));
diff -Naur vim72.orig/src/proto/spell.pro vim72/src/proto/spell.pro
--- vim72.orig/src/proto/spell.pro	2008-08-09 15:31:48.000000000 +0100
+++ vim72/src/proto/spell.pro	2009-07-22 22:54:21.000000000 +0100
@@ -22,5 +22,5 @@
 char_u *spell_to_word_end __ARGS((char_u *start, buf_T *buf));
 int spell_word_start __ARGS((int startcol));
 void spell_expand_check_cap __ARGS((colnr_T col));
-int expand_spelling __ARGS((linenr_T lnum, int col, char_u *pat, char_u ***matchp));
+int expand_spelling __ARGS((linenr_T lnum, char_u *pat, char_u ***matchp));
 /* vim: set ft=c : */
diff -Naur vim72.orig/src/proto/ui.pro vim72/src/proto/ui.pro
--- vim72.orig/src/proto/ui.pro	2008-08-09 15:31:52.000000000 +0100
+++ vim72/src/proto/ui.pro	2009-07-22 22:54:23.000000000 +0100
@@ -48,6 +48,7 @@
 void open_app_context __ARGS((void));
 void x11_setup_atoms __ARGS((Display *dpy));
 void clip_x11_request_selection __ARGS((Widget myShell, Display *dpy, VimClipboard *cbd));
+void yank_cut_buffer0 __ARGS((Display *dpy, VimClipboard *cbd));
 void clip_x11_lose_selection __ARGS((Widget myShell, VimClipboard *cbd));
 int clip_x11_own_selection __ARGS((Widget myShell, VimClipboard *cbd));
 void clip_x11_set_selection __ARGS((VimClipboard *cbd));
diff -Naur vim72.orig/src/proto/window.pro vim72/src/proto/window.pro
--- vim72.orig/src/proto/window.pro	2008-08-09 15:31:54.000000000 +0100
+++ vim72/src/proto/window.pro	2009-07-22 22:54:23.000000000 +0100
@@ -1,6 +1,7 @@
 /* window.c */
 void do_window __ARGS((int nchar, long Prenum, int xchar));
 int win_split __ARGS((int size, int flags));
+int win_split_ins __ARGS((int size, int flags, win_T *newwin, int dir));
 int win_valid __ARGS((win_T *win));
 int win_count __ARGS((void));
 int make_windows __ARGS((int count, int vertical));
@@ -10,9 +11,12 @@
 void win_close __ARGS((win_T *win, int free_buf));
 void win_close_othertab __ARGS((win_T *win, int free_buf, tabpage_T *tp));
 void win_free_all __ARGS((void));
+win_T *winframe_remove __ARGS((win_T *win, int *dirp, tabpage_T *tp));
 void close_others __ARGS((int message, int forceit));
 void curwin_init __ARGS((void));
+void win_init_empty __ARGS((win_T *wp));
 int win_alloc_first __ARGS((void));
+void win_alloc_aucmd_win __ARGS((void));
 void win_init_size __ARGS((void));
 void free_tabpage __ARGS((tabpage_T *tp));
 int win_new_tabpage __ARGS((int after));
@@ -30,6 +34,8 @@
 void win_enter __ARGS((win_T *wp, int undo_sync));
 win_T *buf_jump_open_win __ARGS((buf_T *buf));
 win_T *buf_jump_open_tab __ARGS((buf_T *buf));
+void win_append __ARGS((win_T *after, win_T *wp));
+void win_remove __ARGS((win_T *wp, tabpage_T *tp));
 int win_alloc_lines __ARGS((win_T *wp));
 void win_free_lsize __ARGS((win_T *wp));
 void shell_new_rows __ARGS((void));
@@ -58,6 +64,8 @@
 int min_rows __ARGS((void));
 int only_one_window __ARGS((void));
 void check_lnums __ARGS((int do_curwin));
+void make_snapshot __ARGS((int idx));
+void restore_snapshot __ARGS((int idx, int close_curwin));
 int win_hasvertsplit __ARGS((void));
 int match_add __ARGS((win_T *wp, char_u *grp, char_u *pat, int prio, int id));
 int match_delete __ARGS((win_T *wp, int id, int perr));
diff -Naur vim72.orig/src/pty.c vim72/src/pty.c
--- vim72.orig/src/pty.c	2008-06-21 19:52:58.000000000 +0100
+++ vim72/src/pty.c	2009-07-22 22:54:16.000000000 +0100
@@ -270,9 +270,10 @@
 }
 #endif
 
-#if defined(HAVE_SVR4_PTYS) && !defined(PTY_DONE) && !defined(hpux)
+#if defined(HAVE_SVR4_PTYS) && !defined(PTY_DONE) && !defined(hpux) && !defined(MACOS_X)
 
-/* NOTE: Even though HPUX can have /dev/ptmx, the code below doesn't work! */
+/* NOTE: Even though HPUX can have /dev/ptmx, the code below doesn't work!
+ * Same for Mac OS X Leopard. */
 #define PTY_DONE
     int
 OpenPTY(ttyn)
diff -Naur vim72.orig/src/quickfix.c vim72/src/quickfix.c
--- vim72.orig/src/quickfix.c	2008-07-18 13:53:02.000000000 +0100
+++ vim72/src/quickfix.c	2009-07-22 22:54:23.000000000 +0100
@@ -1419,7 +1419,9 @@
     int			opened_window = FALSE;
     win_T		*win;
     win_T		*altwin;
+    int			flags;
 #endif
+    win_T		*oldwin = curwin;
     int			print_message = TRUE;
     int			len;
 #ifdef FEAT_FOLDING
@@ -1530,7 +1532,6 @@
     if (qf_ptr->qf_type == 1 && (!curwin->w_buffer->b_help || cmdmod.tab != 0))
     {
 	win_T	*wp;
-	int	n;
 
 	if (cmdmod.tab != 0)
 	    wp = NULL;
@@ -1546,13 +1547,16 @@
 	     * Split off help window; put it at far top if no position
 	     * specified, the current window is vertically split and narrow.
 	     */
-	    n = WSP_HELP;
+	    flags = WSP_HELP;
 # ifdef FEAT_VERTSPLIT
 	    if (cmdmod.split == 0 && curwin->w_width != Columns
 						      && curwin->w_width < 80)
-		n |= WSP_TOP;
+		flags |= WSP_TOP;
 # endif
-	    if (win_split(0, n) == FAIL)
+	    if (qi != &ql_info)
+		flags |= WSP_NEWLOC;  /* don't copy the location list */
+
+	    if (win_split(0, flags) == FAIL)
 		goto theend;
 	    opened_window = TRUE;	/* close it when fail */
 
@@ -1562,7 +1566,6 @@
 	    if (qi != &ql_info)	    /* not a quickfix list */
 	    {
 		/* The new window should use the supplied location list */
-		qf_free_all(curwin);
 		curwin->w_llist = qi;
 		qi->qf_refcount++;
 	    }
@@ -1609,10 +1612,11 @@
 		{
 		    goto_tabpage_win(tp, wp);
 		    usable_win = 1;
-		    break;
+		    goto win_found;
 		}
 	    }
 	}
+win_found:
 
 	/*
 	 * If there is only one window and it is the quickfix window, create a
@@ -1622,7 +1626,10 @@
 	{
 	    ll_ref = curwin->w_llist_ref;
 
-	    if (win_split(0, WSP_ABOVE) == FAIL)
+	    flags = WSP_ABOVE;
+	    if (ll_ref != NULL)
+		flags |= WSP_NEWLOC;
+	    if (win_split(0, flags) == FAIL)
 		goto failed;		/* not enough room for window */
 	    opened_window = TRUE;	/* close it when fail */
 	    p_swb = empty_option;	/* don't split again */
@@ -1634,7 +1641,6 @@
 	    {
 		/* The new window should use the location list from the
 		 * location list window */
-		qf_free_all(curwin);
 		curwin->w_llist = ll_ref;
 		ll_ref->qf_refcount++;
 	    }
@@ -1744,7 +1750,8 @@
 	    }
 	    else
 		ok = do_ecmd(qf_ptr->qf_fnum, NULL, NULL, NULL, (linenr_T)1,
-						   ECMD_HIDE + ECMD_SET_HELP);
+					   ECMD_HIDE + ECMD_SET_HELP,
+					   oldwin == curwin ? curwin : NULL);
 	}
 	else
 	    ok = buflist_getfile(qf_ptr->qf_fnum,
@@ -2233,7 +2240,6 @@
  * ":cclose": close the window showing the list of errors.
  * ":lclose": close the window showing the location list
  */
-/*ARGSUSED*/
     void
 ex_cclose(eap)
     exarg_T	*eap;
@@ -2267,6 +2273,7 @@
     win_T	*win;
     tabpage_T	*prevtab = curtab;
     buf_T	*qf_buf;
+    win_T	*oldwin = curwin;
 
     if (eap->cmdidx == CMD_lopen || eap->cmdidx == CMD_lwindow)
     {
@@ -2307,15 +2314,12 @@
 	if (eap->cmdidx == CMD_copen || eap->cmdidx == CMD_cwindow)
 	    /* Create the new window at the very bottom. */
 	    win_goto(lastwin);
-	if (win_split(height, WSP_BELOW) == FAIL)
+	if (win_split(height, WSP_BELOW | WSP_NEWLOC) == FAIL)
 	    return;		/* not enough room for window */
 #ifdef FEAT_SCROLLBIND
 	curwin->w_p_scb = FALSE;
 #endif
 
-	/* Remove the location list for the quickfix window */
-	qf_free_all(curwin);
-
 	if (eap->cmdidx == CMD_lopen || eap->cmdidx == CMD_lwindow)
 	{
 	    /*
@@ -2326,20 +2330,28 @@
 	    win->w_llist->qf_refcount++;
 	}
 
+	if (oldwin != curwin)
+	    oldwin = NULL;  /* don't store info when in another window */
 	if (qf_buf != NULL)
 	    /* Use the existing quickfix buffer */
 	    (void)do_ecmd(qf_buf->b_fnum, NULL, NULL, NULL, ECMD_ONE,
-						     ECMD_HIDE + ECMD_OLDBUF);
+					     ECMD_HIDE + ECMD_OLDBUF, oldwin);
 	else
 	{
 	    /* Create a new quickfix buffer */
-	    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE);
+	    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, oldwin);
 	    /* switch off 'swapfile' */
 	    set_option_value((char_u *)"swf", 0L, NULL, OPT_LOCAL);
 	    set_option_value((char_u *)"bt", 0L, (char_u *)"quickfix",
 								   OPT_LOCAL);
 	    set_option_value((char_u *)"bh", 0L, (char_u *)"wipe", OPT_LOCAL);
-	    set_option_value((char_u *)"diff", 0L, NULL, OPT_LOCAL);
+#ifdef FEAT_DIFF
+	    curwin->w_p_diff = FALSE;
+#endif
+#ifdef FEAT_FOLDING
+	    set_option_value((char_u *)"fdm", 0L, (char_u *)"manual",
+								   OPT_LOCAL);
+#endif
 	}
 
 	/* Only set the height when still in the same tab page and there is no
@@ -2600,10 +2612,12 @@
     curbuf->b_p_ma = FALSE;
 
 #ifdef FEAT_AUTOCMD
+    keep_filetype = TRUE;		/* don't detect 'filetype' */
     apply_autocmds(EVENT_BUFREADPOST, (char_u *)"quickfix", NULL,
 							       FALSE, curbuf);
     apply_autocmds(EVENT_BUFWINENTER, (char_u *)"quickfix", NULL,
 							       FALSE, curbuf);
+    keep_filetype = FALSE;
 #endif
 
     /* make sure it will be redrawn */
@@ -2759,7 +2773,7 @@
     sprintf((char *)cmd, "%s%s%s", (char *)p_shq, (char *)eap->arg,
 							       (char *)p_shq);
     if (*p_sp != NUL)
-	append_redir(cmd, p_sp, fname);
+	append_redir(cmd, len, p_sp, fname);
     /*
      * Output a newline if there's something else than the :make command that
      * was typed (in which case the cursor is in column 0).
@@ -3196,7 +3210,7 @@
 			break;
 		    col = regmatch.endpos[0].col
 					    + (col == regmatch.endpos[0].col);
-		    if (col > STRLEN(ml_get_buf(buf, lnum, FALSE)))
+		    if (col > (colnr_T)STRLEN(ml_get_buf(buf, lnum, FALSE)))
 			break;
 		}
 		line_breakcheck();
@@ -3397,14 +3411,15 @@
     /* Init the options. */
     buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);
 
-    /* set curwin/curbuf to buf and save a few things */
-    aucmd_prepbuf(&aco, newbuf);
+    /* need to open the memfile before putting the buffer in a window */
+    if (ml_open(newbuf) == OK)
+    {
+	/* set curwin/curbuf to buf and save a few things */
+	aucmd_prepbuf(&aco, newbuf);
 
-    /* Need to set the filename for autocommands. */
-    (void)setfname(curbuf, fname, NULL, FALSE);
+	/* Need to set the filename for autocommands. */
+	(void)setfname(curbuf, fname, NULL, FALSE);
 
-    if (ml_open(curbuf) == OK)
-    {
 	/* Create swap file now to avoid the ATTENTION message. */
 	check_need_swap(TRUE);
 
@@ -3427,10 +3442,10 @@
 		newbuf = curbuf;
 	    }
 	}
-    }
 
-    /* restore curwin/curbuf and a few other things */
-    aucmd_restbuf(&aco);
+	/* restore curwin/curbuf and a few other things */
+	aucmd_restbuf(&aco);
+    }
 
     if (!buf_valid(newbuf))
 	return NULL;
diff -Naur vim72.orig/src/regexp.c vim72/src/regexp.c
--- vim72.orig/src/regexp.c	2008-08-07 20:58:50.000000000 +0100
+++ vim72/src/regexp.c	2009-07-22 22:54:21.000000000 +0100
@@ -471,7 +471,7 @@
 
     if ((*pp)[1] == ':')
     {
-	for (i = 0; i < sizeof(class_names) / sizeof(*class_names); ++i)
+	for (i = 0; i < (int)(sizeof(class_names) / sizeof(*class_names)); ++i)
 	    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)
 	    {
 		*pp += STRLEN(class_names[i]) + 2;
@@ -3362,12 +3362,11 @@
  * Match a regexp against a string ("line" points to the string) or multiple
  * lines ("line" is NULL, use reg_getline()).
  */
-/*ARGSUSED*/
     static long
 vim_regexec_both(line, col, tm)
     char_u	*line;
     colnr_T	col;		/* column to start looking for match */
-    proftime_T	*tm;		/* timeout limit or NULL */
+    proftime_T	*tm UNUSED;	/* timeout limit or NULL */
 {
     regprog_T	*prog;
     char_u	*s;
@@ -4532,7 +4531,7 @@
 		cleanup_subexpr();
 		if (!REG_MULTI)		/* Single-line regexp */
 		{
-		    if (reg_endp[no] == NULL)
+		    if (reg_startp[no] == NULL || reg_endp[no] == NULL)
 		    {
 			/* Backref was not set: Match an empty string. */
 			len = 0;
@@ -4548,7 +4547,7 @@
 		}
 		else				/* Multi-line regexp */
 		{
-		    if (reg_endpos[no].lnum < 0)
+		    if (reg_startpos[no].lnum < 0 || reg_endpos[no].lnum < 0)
 		    {
 			/* Backref was not set: Match an empty string. */
 			len = 0;
@@ -7279,13 +7278,11 @@
     }
     else
     {
-	if (submatch_match->endp[no] == NULL)
+	s = submatch_match->startp[no];
+	if (s == NULL || submatch_match->endp[no] == NULL)
 	    retval = NULL;
 	else
-	{
-	    s = submatch_match->startp[no];
 	    retval = vim_strnsave(s, (int)(submatch_match->endp[no] - s));
-	}
     }
 
     return retval;
diff -Naur vim72.orig/src/screen.c vim72/src/screen.c
--- vim72.orig/src/screen.c	2008-07-24 15:45:07.000000000 +0100
+++ vim72/src/screen.c	2009-07-22 22:54:23.000000000 +0100
@@ -270,11 +270,10 @@
  * Note that when also inserting/deleting lines w_redraw_top and w_redraw_bot
  * may become invalid and the whole window will have to be redrawn.
  */
-/*ARGSUSED*/
     void
 redrawWinline(lnum, invalid)
     linenr_T	lnum;
-    int		invalid;	/* window line height is invalid now */
+    int		invalid UNUSED;	/* window line height is invalid now */
 {
 #ifdef FEAT_FOLDING
     int		i;
@@ -2413,7 +2412,7 @@
 			&& (lnume < bot->lnum
 			    || (lnume == bot->lnum
 				&& (bot->col - (*p_sel == 'e'))
-		>= STRLEN(ml_get_buf(wp->w_buffer, lnume, FALSE)))))))
+		>= (colnr_T)STRLEN(ml_get_buf(wp->w_buffer, lnume, FALSE)))))))
 	{
 	    if (VIsual_mode == Ctrl_V)
 	    {
@@ -2439,9 +2438,17 @@
 
 #ifdef FEAT_SYN_HL
     /* Show 'cursorcolumn' in the fold line. */
-    if (wp->w_p_cuc && (int)wp->w_virtcol + txtcol < W_WIDTH(wp))
-	ScreenAttrs[off + wp->w_virtcol + txtcol] = hl_combine_attr(
-		 ScreenAttrs[off + wp->w_virtcol + txtcol], hl_attr(HLF_CUC));
+    if (wp->w_p_cuc)
+    {
+	txtcol += wp->w_virtcol;
+	if (wp->w_p_wrap)
+	    txtcol -= wp->w_skipcol;
+	else
+	    txtcol -= wp->w_leftcol;
+	if (txtcol >= 0 && txtcol < W_WIDTH(wp))
+	    ScreenAttrs[off + txtcol] = hl_combine_attr(
+				 ScreenAttrs[off + txtcol], hl_attr(HLF_CUC));
+    }
 #endif
 
     SCREEN_LINE(row + W_WINROW(wp), W_WINCOL(wp), (int)W_WIDTH(wp),
@@ -2541,14 +2548,13 @@
  *
  * Return the number of last row the line occupies.
  */
-/* ARGSUSED */
     static int
 win_line(wp, lnum, startrow, endrow, nochange)
     win_T	*wp;
     linenr_T	lnum;
     int		startrow;
     int		endrow;
-    int		nochange;		/* not updating for changed text */
+    int		nochange UNUSED;	/* not updating for changed text */
 {
     int		col;			/* visual column on screen */
     unsigned	off;			/* offset in ScreenLines/ScreenAttrs */
@@ -2588,6 +2594,7 @@
     int		noinvcur = FALSE;	/* don't invert the cursor */
 #ifdef FEAT_VISUAL
     pos_T	*top, *bot;
+    int		lnum_in_visual_area = FALSE;
 #endif
     pos_T	pos;
     long	v;
@@ -2784,9 +2791,10 @@
 	    top = &VIsual;
 	    bot = &curwin->w_cursor;
 	}
+	lnum_in_visual_area = (lnum >= top->lnum && lnum <= bot->lnum);
 	if (VIsual_mode == Ctrl_V)	/* block mode */
 	{
-	    if (lnum >= top->lnum && lnum <= bot->lnum)
+	    if (lnum_in_visual_area)
 	    {
 		fromcol = wp->w_old_cursor_fcol;
 		tocol = wp->w_old_cursor_lcol;
@@ -2879,8 +2887,9 @@
 	}
 	else
 	    tocol = MAXCOL;
-	if (fromcol == tocol)		/* do at least one character */
-	    tocol = fromcol + 1;	/* happens when past end of line */
+	/* do at least one character; happens when past end of line */
+	if (fromcol == tocol)
+	    tocol = fromcol + 1;
 	area_highlighting = TRUE;
 	attr = hl_attr(HLF_I);
     }
@@ -3412,6 +3421,7 @@
 			&& (*mb_ptr2cells)(ptr) > 1)
 #endif
 		    || ((int)vcol_prev == fromcol_prev
+			&& vcol_prev < vcol	/* not at margin */
 			&& vcol < tocol))
 		area_attr = attr;		/* start highlighting */
 	    else if (area_attr != 0
@@ -3544,7 +3554,8 @@
 		/* Use line_attr when not in the Visual or 'incsearch' area
 		 * (area_attr may be 0 when "noinvcur" is set). */
 	    else if (line_attr != 0 && ((fromcol == -10 && tocol == MAXCOL)
-					|| (vcol < fromcol || vcol >= tocol)))
+				|| vcol < fromcol || vcol_prev < fromcol_prev
+				|| vcol >= tocol))
 		char_attr = line_attr;
 #endif
 	    else
@@ -4106,6 +4117,7 @@
 # endif
 				    (col < W_WIDTH(wp)))
 				&& !(noinvcur
+				    && lnum == wp->w_cursor.lnum
 				    && (colnr_T)vcol == wp->w_virtcol)))
 			&& lcs_eol_one >= 0)
 		{
@@ -4247,7 +4259,7 @@
 	 * preedit_changed and commit.  Thus Vim can't set "im_is_active", use
 	 * im_is_preediting() here. */
 	if (xic != NULL
-		&& lnum == curwin->w_cursor.lnum
+		&& lnum == wp->w_cursor.lnum
 		&& (State & INSERT)
 		&& !p_imdisable
 		&& im_is_preediting()
@@ -4256,7 +4268,7 @@
 	    colnr_T tcol;
 
 	    if (preedit_end_col == MAXCOL)
-		getvcol(curwin, &(curwin->w_cursor), &tcol, NULL, NULL);
+		getvcol(curwin, &(wp->w_cursor), &tcol, NULL, NULL);
 	    else
 		tcol = preedit_end_col;
 	    if ((long)preedit_start_col <= vcol && vcol < (long)tcol)
@@ -4353,7 +4365,13 @@
 	    }
 #endif
 	    if (lcs_eol == lcs_eol_one
-		    && ((area_attr != 0 && vcol == fromcol && c == NUL)
+		    && ((area_attr != 0 && vcol == fromcol
+#ifdef FEAT_VISUAL
+			    && (VIsual_mode != Ctrl_V
+				|| lnum == VIsual.lnum
+				|| lnum == curwin->w_cursor.lnum)
+#endif
+			    && c == NUL)
 #ifdef FEAT_SEARCH_EXTRA
 			/* highlight 'hlsearch' match at end of line */
 			|| (prevcol_hl_flag == TRUE
@@ -4447,7 +4465,8 @@
 	if (c == NUL)
 	{
 #ifdef FEAT_SYN_HL
-	    if (eol_hl_off > 0 && vcol - eol_hl_off == (long)wp->w_virtcol)
+	    if (eol_hl_off > 0 && vcol - eol_hl_off == (long)wp->w_virtcol
+		    && lnum == wp->w_cursor.lnum)
 	    {
 		/* highlight last char after line */
 		--col;
@@ -4549,7 +4568,8 @@
 	 * highlight the cursor position itself. */
 	if (wp->w_p_cuc && vcol == (long)wp->w_virtcol
 		&& lnum != wp->w_cursor.lnum
-		&& draw_state == WL_LINE)
+		&& draw_state == WL_LINE
+		&& !lnum_in_visual_area)
 	{
 	    vcol_save_attr = char_attr;
 	    char_attr = hl_combine_attr(char_attr, hl_attr(HLF_CUC));
@@ -4652,7 +4672,7 @@
 	    --n_skip;
 
 	/* Only advance the "vcol" when after the 'number' column. */
-	if (draw_state >= WL_SBR
+	if (draw_state > WL_NR
 #ifdef FEAT_DIFF
 		&& filler_todo <= 0
 #endif
@@ -5119,8 +5139,8 @@
 #endif
 
 #if defined(FEAT_GUI) || defined(UNIX)
-	    /* The bold trick makes a single row of pixels appear in the next
-	     * character.  When a bold character is removed, the next
+	    /* The bold trick makes a single column of pixels appear in the
+	     * next character.  When a bold character is removed, the next
 	     * character should be redrawn too.  This happens for our own GUI
 	     * and for some xterms. */
 	    if (
@@ -5723,6 +5743,13 @@
     int		fillchar;
     int		attr;
     int		this_ru_col;
+    static int  busy = FALSE;
+
+    /* It's possible to get here recursively when 'statusline' (indirectly)
+     * invokes ":redrawstatus".  Simply ignore the call then. */
+    if (busy)
+	return;
+    busy = TRUE;
 
     wp->w_redr_status = FALSE;
     if (wp->w_status_height == 0)
@@ -5861,6 +5888,7 @@
 									attr);
     }
 #endif
+    busy = FALSE;
 }
 
 #ifdef FEAT_STL_OPT
@@ -6076,7 +6104,7 @@
 				fillchar, maxwidth, hltab, tabtab);
     len = (int)STRLEN(buf);
 
-    while (width < maxwidth && len < sizeof(buf) - 1)
+    while (width < maxwidth && len < (int)sizeof(buf) - 1)
     {
 #ifdef FEAT_MBYTE
 	len += (*mb_char2bytes)(fillchar, buf + len);
@@ -6263,9 +6291,15 @@
     int		pcc[MAX_MCO];
 # endif
 #endif
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+    int		force_redraw_this;
+    int		force_redraw_next = FALSE;
+#endif
+    int		need_redraw;
 
     if (ScreenLines == NULL || row >= screen_Rows)	/* safety check */
 	return;
+    off = LineOffset[row] + col;
 
 #ifdef FEAT_MBYTE
     /* When drawing over the right halve of a double-wide char clear out the
@@ -6275,10 +6309,21 @@
 	    && !gui.in_use
 # endif
 	    && mb_fix_col(col, row) != col)
-	screen_puts_len((char_u *)" ", 1, row, col - 1, 0);
+    {
+	ScreenLines[off - 1] = ' ';
+	ScreenAttrs[off - 1] = 0;
+	if (enc_utf8)
+	{
+	    ScreenLinesUC[off - 1] = 0;
+	    ScreenLinesC[0][off - 1] = 0;
+	}
+	/* redraw the previous cell, make it empty */
+	screen_char(off - 1, row, col - 1);
+	/* force the cell at "col" to be redrawn */
+	force_redraw_next = TRUE;
+    }
 #endif
 
-    off = LineOffset[row] + col;
 #ifdef FEAT_MBYTE
     max_off = LineOffset[row] + screen_Columns;
 #endif
@@ -6342,7 +6387,12 @@
 	}
 #endif
 
-	if (ScreenLines[off] != c
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+	force_redraw_this = force_redraw_next;
+	force_redraw_next = FALSE;
+#endif
+
+	need_redraw = ScreenLines[off] != c
 #ifdef FEAT_MBYTE
 		|| (mbyte_cells == 2
 		    && ScreenLines[off + 1] != (enc_dbcs ? ptr[1] : 0))
@@ -6350,24 +6400,24 @@
 		    && c == 0x8e
 		    && ScreenLines2[off] != ptr[1])
 		|| (enc_utf8
-		    && (ScreenLinesUC[off] != (u8char_T)u8c
+		    && (ScreenLinesUC[off] != (u8char_T)(c >= 0x80 ? u8c : 0)
 			|| screen_comp_differs(off, u8cc)))
 #endif
 		|| ScreenAttrs[off] != attr
-		|| exmode_active
+		|| exmode_active;
+
+	if (need_redraw
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+		|| force_redraw_this
+#endif
 		)
 	{
 #if defined(FEAT_GUI) || defined(UNIX)
 	    /* The bold trick makes a single row of pixels appear in the next
 	     * character.  When a bold character is removed, the next
 	     * character should be redrawn too.  This happens for our own GUI
-	     * and for some xterms.
-	     * Force the redraw by setting the attribute to a different value
-	     * than "attr", the contents of ScreenLines[] may be needed by
-	     * mb_off2cells() further on.
-	     * Don't do this for the last drawn character, because the next
-	     * character may not be redrawn. */
-	    if (
+	     * and for some xterms. */
+	    if (need_redraw && ScreenLines[off] != ' ' && (
 # ifdef FEAT_GUI
 		    gui.in_use
 # endif
@@ -6377,23 +6427,14 @@
 # ifdef UNIX
 		    term_is_xterm
 # endif
-	       )
+		    ))
 	    {
-		int		n;
+		int	n = ScreenAttrs[off];
 
-		n = ScreenAttrs[off];
-# ifdef FEAT_MBYTE
-		if (col + mbyte_cells < screen_Columns
-			&& (n > HL_ALL || (n & HL_BOLD))
-			&& (len < 0 ? ptr[mbyte_blen] != NUL
-					     : ptr + mbyte_blen < text + len))
-		    ScreenAttrs[off + mbyte_cells] = attr + 1;
-# else
-		if (col + 1 < screen_Columns
-			&& (n > HL_ALL || (n & HL_BOLD))
-			&& (len < 0 ? ptr[1] != NUL : ptr + 1 < text + len))
-		    ScreenLines[off + 1] = 0;
-# endif
+		if (n > HL_ALL)
+		    n = syn_attr2attr(n);
+		if (n & HL_BOLD)
+		    force_redraw_next = TRUE;
 	    }
 #endif
 #ifdef FEAT_MBYTE
@@ -6480,6 +6521,20 @@
 	    ++ptr;
 	}
     }
+
+#if defined(FEAT_MBYTE) || defined(FEAT_GUI) || defined(UNIX)
+    /* If we detected the next character needs to be redrawn, but the text
+     * doesn't extend up to there, update the character here. */
+    if (force_redraw_next && col < screen_Columns)
+    {
+# ifdef FEAT_MBYTE
+	if (enc_dbcs != 0 && dbcs_off2cells(off, max_off) > 1)
+	    screen_char_2(off, row, col);
+	else
+# endif
+	    screen_char(off, row, col);
+    }
+#endif
 }
 
 #ifdef FEAT_SEARCH_EXTRA
@@ -7356,7 +7411,11 @@
 #endif
     static int	    entered = FALSE;		/* avoid recursiveness */
     static int	    done_outofmem_msg = FALSE;	/* did outofmem message */
+#ifdef FEAT_AUTOCMD
+    int		    retry_count = 0;
 
+retry:
+#endif
     /*
      * Allocation of the screen buffers is done only when the size changes and
      * when Rows and Columns have been set and we have started doing full
@@ -7440,10 +7499,17 @@
 	{
 	    outofmem = TRUE;
 #ifdef FEAT_WINDOWS
-	    break;
+	    goto give_up;
 #endif
 	}
     }
+#ifdef FEAT_AUTOCMD
+    if (aucmd_win != NULL && win_alloc_lines(aucmd_win) == FAIL)
+	outofmem = TRUE;
+#endif
+#ifdef FEAT_WINDOWS
+give_up:
+#endif
 
 #ifdef FEAT_MBYTE
     for (i = 0; i < p_mco; ++i)
@@ -7628,8 +7694,17 @@
     --RedrawingDisabled;
 
 #ifdef FEAT_AUTOCMD
-    if (starting == 0)
+    /*
+     * Do not apply autocommands more than 3 times to avoid an endless loop
+     * in case applying autocommands always changes Rows or Columns.
+     */
+    if (starting == 0 && ++retry_count <= 3)
+    {
 	apply_autocmds(EVENT_VIMRESIZED, NULL, NULL, FALSE, curbuf);
+	/* In rare cases, autocommands may have altered Rows or Columns,
+	 * jump back to check if we need to allocate the screen again. */
+	goto retry;
+    }
 #endif
 }
 
@@ -8590,7 +8665,6 @@
  *
  * Return OK for success, FAIL if the lines are not deleted.
  */
-/*ARGSUSED*/
     int
 screen_del_lines(off, row, line_count, end, force, wp)
     int		off;
@@ -8598,7 +8672,7 @@
     int		line_count;
     int		end;
     int		force;		/* even when line_count > p_ttyscroll */
-    win_T	*wp;		/* NULL or window to use width from */
+    win_T	*wp UNUSED;	/* NULL or window to use width from */
 {
     int		j;
     int		i;
@@ -9416,13 +9490,15 @@
     win_T	*wp;
     int		always;
 {
-    char_u	buffer[70];
+#define RULER_BUF_LEN 70
+    char_u	buffer[RULER_BUF_LEN];
     int		row;
     int		fillchar;
     int		attr;
     int		empty_line = FALSE;
     colnr_T	virtcol;
     int		i;
+    size_t	len;
     int		o;
 #ifdef FEAT_VERTSPLIT
     int		this_ru_col;
@@ -9537,11 +9613,12 @@
 	 * Some sprintfs return the length, some return a pointer.
 	 * To avoid portability problems we use strlen() here.
 	 */
-	sprintf((char *)buffer, "%ld,",
+	vim_snprintf((char *)buffer, RULER_BUF_LEN, "%ld,",
 		(wp->w_buffer->b_ml.ml_flags & ML_EMPTY)
 		    ? 0L
 		    : (long)(wp->w_cursor.lnum));
-	col_print(buffer + STRLEN(buffer),
+	len = STRLEN(buffer);
+	col_print(buffer + len, RULER_BUF_LEN - len,
 			empty_line ? 0 : (int)wp->w_cursor.col + 1,
 			(int)virtcol + 1);
 
@@ -9551,7 +9628,7 @@
 	 * screen up on some terminals).
 	 */
 	i = (int)STRLEN(buffer);
-	get_rel_pos(wp, buffer + i + 1);
+	get_rel_pos(wp, buffer + i + 1, RULER_BUF_LEN - i - 1);
 	o = i + vim_strsize(buffer + i + 1);
 #ifdef FEAT_WINDOWS
 	if (wp->w_status_height == 0)	/* can't use last char of screen */
@@ -9578,7 +9655,7 @@
 		    buffer[i++] = fillchar;
 		++o;
 	    }
-	    get_rel_pos(wp, buffer + i);
+	    get_rel_pos(wp, buffer + i, RULER_BUF_LEN - i);
 	}
 	/* Truncate at window boundary. */
 #ifdef FEAT_MBYTE
diff -Naur vim72.orig/src/search.c vim72/src/search.c
--- vim72.orig/src/search.c	2008-07-13 19:18:27.000000000 +0100
+++ vim72/src/search.c	2009-07-22 22:54:22.000000000 +0100
@@ -345,6 +345,15 @@
 {
     vim_free(spats[0].pat);
     vim_free(spats[1].pat);
+
+# ifdef FEAT_RIGHTLEFT
+    if (mr_pattern_alloced)
+    {
+        vim_free(mr_pattern);
+        mr_pattern_alloced = FALSE;
+        mr_pattern = NULL;
+    }
+# endif
 }
 #endif
 
@@ -513,7 +522,6 @@
  * When FEAT_EVAL is defined, returns the index of the first matching
  * subpattern plus one; one if there was none.
  */
-/*ARGSUSED*/
     int
 searchit(win, buf, pos, dir, pat, count, options, pat_use, stop_lnum, tm)
     win_T	*win;		/* window to search in; can be NULL for a
@@ -526,7 +534,7 @@
     int		options;
     int		pat_use;	/* which pattern to use when "pat" is empty */
     linenr_T	stop_lnum;	/* stop after this line number when != 0 */
-    proftime_T	*tm;		/* timeout limit or NULL */
+    proftime_T	*tm UNUSED;	/* timeout limit or NULL */
 {
     int		found;
     linenr_T	lnum;		/* no init to shut up Apollo cc */
@@ -545,8 +553,6 @@
     int		save_called_emsg = called_emsg;
 #ifdef FEAT_SEARCH_EXTRA
     int		break_loop = FALSE;
-#else
-# define break_loop FALSE
 #endif
 
     if (search_regcomp(pat, RE_SEARCH, pat_use,
@@ -931,7 +937,10 @@
 	     * twice.
 	     */
 	    if (!p_ws || stop_lnum != 0 || got_int || called_emsg
-					       || break_loop || found || loop)
+#ifdef FEAT_SEARCH_EXTRA
+					       || break_loop
+#endif
+					       || found || loop)
 		break;
 
 	    /*
@@ -949,7 +958,11 @@
 		give_warning((char_u *)_(dir == BACKWARD
 					  ? top_bot_msg : bot_top_msg), TRUE);
 	}
-	if (got_int || called_emsg || break_loop)
+	if (got_int || called_emsg
+#ifdef FEAT_SEARCH_EXTRA
+		|| break_loop
+#endif
+		)
 	    break;
     }
     while (--count > 0 && found);   /* stop after count matches or no match */
@@ -2327,8 +2340,8 @@
 		    for (col = pos.col; check_prevcol(linep, col, '\\', &col);)
 			bslcnt++;
 		}
-		/* Only accept a match when 'M' is in 'cpo' or when ecaping is
-		 * what we expect. */
+		/* Only accept a match when 'M' is in 'cpo' or when escaping
+		 * is what we expect. */
 		if (cpo_bsl || (bslcnt & 1) == match_escaped)
 		{
 		    if (c == initc)
@@ -4514,12 +4527,11 @@
  * Find identifiers or defines in included files.
  * if p_ic && (compl_cont_status & CONT_SOL) then ptr must be in lowercase.
  */
-/*ARGSUSED*/
     void
 find_pattern_in_path(ptr, dir, len, whole, skip_comments,
 				    type, count, action, start_lnum, end_lnum)
     char_u	*ptr;		/* pointer to search pattern */
-    int		dir;		/* direction of expansion */
+    int		dir UNUSED;	/* direction of expansion */
     int		len;		/* length of search pattern */
     int		whole;		/* match whole words only */
     int		skip_comments;	/* don't match inside comments */
@@ -4663,7 +4675,7 @@
 			    msg_putchar('\n');	    /* cursor below last one */
 			    if (!got_int)	    /* don't display if 'q'
 						       typed at "--more--"
-						       mesage */
+						       message */
 			    {
 				msg_home_replace_hl(new_fname);
 				MSG_PUTS(_(" (includes previously listed match)"));
@@ -4975,7 +4987,7 @@
 					    || IObuff[i-2] == '!'))))
 				IObuff[i++] = ' ';
 			}
-			/* copy as much as posible of the new word */
+			/* copy as much as possible of the new word */
 			if (p - aux >= IOSIZE - i)
 			    p = aux + IOSIZE - i - 1;
 			STRNCPY(IObuff + i, aux, p - aux);
@@ -5010,7 +5022,7 @@
 		    if (did_show)
 			msg_putchar('\n');	/* cursor below last one */
 		    if (!got_int)		/* don't display if 'q' typed
-						    at "--more--" mesage */
+						    at "--more--" message */
 			msg_home_replace_hl(curr_fname);
 		    prev_fname = curr_fname;
 		}
@@ -5092,7 +5104,7 @@
 		}
 		if (action != ACTION_SHOW)
 		{
-		    curwin->w_cursor.col = (colnr_T) (startp - line);
+		    curwin->w_cursor.col = (colnr_T)(startp - line);
 		    curwin->w_set_curswant = TRUE;
 		}
 
@@ -5119,7 +5131,8 @@
 		    && action == ACTION_EXPAND
 		    && !(compl_cont_status & CONT_SOL)
 #endif
-		    && *(p = startp + 1))
+		    && *startp != NUL
+		    && *(p = startp + 1) != NUL)
 		goto search_line;
 	}
 	line_breakcheck();
diff -Naur vim72.orig/src/spell.c vim72/src/spell.c
--- vim72.orig/src/spell.c	2008-07-12 20:20:55.000000000 +0100
+++ vim72/src/spell.c	2009-07-22 22:54:23.000000000 +0100
@@ -77,7 +77,7 @@
 
 /*
  * Do the opposite: based on a maximum end score and a known sound score,
- * compute the the maximum word score that can be used.
+ * compute the maximum word score that can be used.
  */
 #define MAXSCORE(word_score, sound_score) ((4 * word_score - sound_score) / 3)
 
@@ -469,6 +469,7 @@
     garray_T	sl_comppat;	/* CHECKCOMPOUNDPATTERN items */
     regprog_T	*sl_compprog;	/* COMPOUNDRULE turned into a regexp progrm
 				 * (NULL when no compounding) */
+    char_u	*sl_comprules;	/* all COMPOUNDRULE concatenated (or NULL) */
     char_u	*sl_compstartflags; /* flags for first compound word */
     char_u	*sl_compallflags; /* all flags for compound words */
     char_u	sl_nobreak;	/* When TRUE: no spaces between words */
@@ -625,7 +626,7 @@
 /* TRUE if a word appears in the list of banned words.  */
 #define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&su->su_banned, word)))
 
-/* Number of suggestions kept when cleaning up.  we need to keep more than
+/* Number of suggestions kept when cleaning up.  We need to keep more than
  * what is displayed, because when rescore_suggestions() is called the score
  * may change and wrong suggestions may be removed later. */
 #define SUG_CLEAN_COUNT(su)    ((su)->su_maxcount < 130 ? 150 : (su)->su_maxcount + 20)
@@ -839,7 +840,10 @@
 static void slang_clear __ARGS((slang_T *lp));
 static void slang_clear_sug __ARGS((slang_T *lp));
 static void find_word __ARGS((matchinf_T *mip, int mode));
+static int match_checkcompoundpattern __ARGS((char_u *ptr, int wlen, garray_T *gap));
 static int can_compound __ARGS((slang_T *slang, char_u *word, char_u *flags));
+static int can_be_compound __ARGS((trystate_T *sp, slang_T *slang, char_u *compflags, int flag));
+static int match_compoundrule __ARGS((slang_T *slang, char_u *compflags));
 static int valid_word_prefix __ARGS((int totprefcnt, int arridx, int flags, char_u *word, slang_T *slang, int cond_req));
 static void find_prefix __ARGS((matchinf_T *mip, int mode));
 static int fold_more __ARGS((matchinf_T *mip));
@@ -946,8 +950,8 @@
  */
 #ifndef FEAT_MBYTE
 /* Non-multi-byte implementation. */
-# define SPELL_TOFOLD(c) ((c) < 256 ? spelltab.st_fold[c] : (c))
-# define SPELL_TOUPPER(c) ((c) < 256 ? spelltab.st_upper[c] : (c))
+# define SPELL_TOFOLD(c) ((c) < 256 ? (int)spelltab.st_fold[c] : (c))
+# define SPELL_TOUPPER(c) ((c) < 256 ? (int)spelltab.st_upper[c] : (c))
 # define SPELL_ISUPPER(c) ((c) < 256 ? spelltab.st_isu[c] : FALSE)
 #else
 # if defined(HAVE_WCHAR_H)
@@ -958,18 +962,18 @@
  * the "w" library function for characters above 255 if available. */
 # ifdef HAVE_TOWLOWER
 #  define SPELL_TOFOLD(c) (enc_utf8 && (c) >= 128 ? utf_fold(c) \
-	    : (c) < 256 ? spelltab.st_fold[c] : towlower(c))
+	    : (c) < 256 ? (int)spelltab.st_fold[c] : (int)towlower(c))
 # else
 #  define SPELL_TOFOLD(c) (enc_utf8 && (c) >= 128 ? utf_fold(c) \
-	    : (c) < 256 ? spelltab.st_fold[c] : (c))
+	    : (c) < 256 ? (int)spelltab.st_fold[c] : (c))
 # endif
 
 # ifdef HAVE_TOWUPPER
 #  define SPELL_TOUPPER(c) (enc_utf8 && (c) >= 128 ? utf_toupper(c) \
-	    : (c) < 256 ? spelltab.st_upper[c] : towupper(c))
+	    : (c) < 256 ? (int)spelltab.st_upper[c] : (int)towupper(c))
 # else
 #  define SPELL_TOUPPER(c) (enc_utf8 && (c) >= 128 ? utf_toupper(c) \
-	    : (c) < 256 ? spelltab.st_upper[c] : (c))
+	    : (c) < 256 ? (int)spelltab.st_upper[c] : (c))
 # endif
 
 # ifdef HAVE_ISWUPPER
@@ -1519,6 +1523,11 @@
 					    ((unsigned)flags >> 24)))
 		    continue;
 
+		/* If there is a match with a CHECKCOMPOUNDPATTERN rule
+		 * discard the compound word. */
+		if (match_checkcompoundpattern(ptr, wlen, &slang->sl_comppat))
+		    continue;
+
 		if (mode == FIND_COMPOUND)
 		{
 		    int	    capflags;
@@ -1577,6 +1586,11 @@
 		    if (!can_compound(slang, fword, mip->mi_compflags))
 			continue;
 		}
+		else if (slang->sl_comprules != NULL
+			     && !match_compoundrule(slang, mip->mi_compflags))
+		    /* The compound flags collected so far do not match any
+		     * COMPOUNDRULE, discard the compounded word. */
+		    continue;
 	    }
 
 	    /* Check NEEDCOMPOUND: can't use word without compounding. */
@@ -1727,6 +1741,39 @@
 }
 
 /*
+ * Return TRUE if there is a match between the word ptr[wlen] and
+ * CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another
+ * word.
+ * A match means that the first part of CHECKCOMPOUNDPATTERN matches at the
+ * end of ptr[wlen] and the second part matches after it.
+ */
+    static int
+match_checkcompoundpattern(ptr, wlen, gap)
+    char_u	*ptr;
+    int		wlen;
+    garray_T	*gap;  /* &sl_comppat */
+{
+    int		i;
+    char_u	*p;
+    int		len;
+
+    for (i = 0; i + 1 < gap->ga_len; i += 2)
+    {
+	p = ((char_u **)gap->ga_data)[i + 1];
+	if (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0)
+	{
+	    /* Second part matches at start of following compound word, now
+	     * check if first part matches at end of previous word. */
+	    p = ((char_u **)gap->ga_data)[i];
+	    len = (int)STRLEN(p);
+	    if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)
+		return TRUE;
+	}
+    }
+    return FALSE;
+}
+
+/*
  * Return TRUE if "flags" is a valid sequence of compound flags and "word"
  * does not have too many syllables.
  */
@@ -1773,6 +1820,98 @@
 }
 
 /*
+ * Return TRUE when the sequence of flags in "compflags" plus "flag" can
+ * possibly form a valid compounded word.  This also checks the COMPOUNDRULE
+ * lines if they don't contain wildcards.
+ */
+    static int
+can_be_compound(sp, slang, compflags, flag)
+    trystate_T	*sp;
+    slang_T	*slang;
+    char_u	*compflags;
+    int		flag;
+{
+    /* If the flag doesn't appear in sl_compstartflags or sl_compallflags
+     * then it can't possibly compound. */
+    if (!byte_in_str(sp->ts_complen == sp->ts_compsplit
+		? slang->sl_compstartflags : slang->sl_compallflags, flag))
+	return FALSE;
+
+    /* If there are no wildcards, we can check if the flags collected so far
+     * possibly can form a match with COMPOUNDRULE patterns.  This only
+     * makes sense when we have two or more words. */
+    if (slang->sl_comprules != NULL && sp->ts_complen > sp->ts_compsplit)
+    {
+	int v;
+
+	compflags[sp->ts_complen] = flag;
+	compflags[sp->ts_complen + 1] = NUL;
+	v = match_compoundrule(slang, compflags + sp->ts_compsplit);
+	compflags[sp->ts_complen] = NUL;
+	return v;
+    }
+
+    return TRUE;
+}
+
+
+/*
+ * Return TRUE if the compound flags in compflags[] match the start of any
+ * compound rule.  This is used to stop trying a compound if the flags
+ * collected so far can't possibly match any compound rule.
+ * Caller must check that slang->sl_comprules is not NULL.
+ */
+    static int
+match_compoundrule(slang, compflags)
+    slang_T	*slang;
+    char_u	*compflags;
+{
+    char_u	*p;
+    int		i;
+    int		c;
+
+    /* loop over all the COMPOUNDRULE entries */
+    for (p = slang->sl_comprules; *p != NUL; ++p)
+    {
+	/* loop over the flags in the compound word we have made, match
+	 * them against the current rule entry */
+	for (i = 0; ; ++i)
+	{
+	    c = compflags[i];
+	    if (c == NUL)
+		/* found a rule that matches for the flags we have so far */
+		return TRUE;
+	    if (*p == '/' || *p == NUL)
+		break;  /* end of rule, it's too short */
+	    if (*p == '[')
+	    {
+		int match = FALSE;
+
+		/* compare against all the flags in [] */
+		++p;
+		while (*p != ']' && *p != NUL)
+		    if (*p++ == c)
+			match = TRUE;
+		if (!match)
+		    break;  /* none matches */
+	    }
+	    else if (*p != c)
+		break;  /* flag of word doesn't match flag in pattern */
+	    ++p;
+	}
+
+	/* Skip to the next "/", where the next pattern starts. */
+	p = vim_strchr(p, '/');
+	if (p == NULL)
+	    break;
+    }
+
+    /* Checked all the rules and none of them match the flags, so there
+     * can't possibly be a compound starting with these flags. */
+    return FALSE;
+}
+
+/*
  * Return non-zero if the prefix indicated by "arridx" matches with the prefix
  * ID in "flags" for the word "word".
  * The WF_RAREPFX flag is included in the return value for a rare prefix.
@@ -2237,7 +2376,7 @@
 
 	    /* If we are back at the starting line and there is no match then
 	     * give up. */
-	    if (lnum == wp->w_cursor.lnum && !found_one)
+	    if (lnum == wp->w_cursor.lnum && (!found_one || wrapped))
 		break;
 
 	    /* Skip the characters at the start of the next line that were
@@ -2513,9 +2652,11 @@
     lp->sl_midword = NULL;
 
     vim_free(lp->sl_compprog);
+    vim_free(lp->sl_comprules);
     vim_free(lp->sl_compstartflags);
     vim_free(lp->sl_compallflags);
     lp->sl_compprog = NULL;
+    lp->sl_comprules = NULL;
     lp->sl_compstartflags = NULL;
     lp->sl_compallflags = NULL;
 
@@ -3460,6 +3601,7 @@
     char_u	*pp;
     char_u	*cp;
     char_u	*ap;
+    char_u	*crp;
     int		cnt;
     garray_T	*gap;
 
@@ -3545,6 +3687,12 @@
     slang->sl_compallflags = ap;
     *ap = NUL;
 
+    /* And a list of all patterns in their original form, for checking whether
+     * compounding may work in match_compoundrule().  This is freed when we
+     * encounter a wildcard, the check doesn't work then. */
+    crp = alloc(todo + 1);
+    slang->sl_comprules = crp;
+
     pp = pat;
     *pp++ = '^';
     *pp++ = '\\';
@@ -3587,6 +3735,20 @@
 		    atstart = 0;
 	    }
 	}
+
+	/* Copy flag to "sl_comprules", unless we run into a wildcard. */
+	if (crp != NULL)
+	{
+	    if (c == '+' || c == '*')
+	    {
+		vim_free(slang->sl_comprules);
+		slang->sl_comprules = NULL;
+		crp = NULL;
+	    }
+	    else
+		*crp++ = c;
+	}
+
 	if (c == '/')	    /* slash separates two items */
 	{
 	    *pp++ = '\\';
@@ -3611,6 +3773,9 @@
     *pp++ = '$';
     *pp = NUL;
 
+    if (crp != NULL)
+	*crp = NUL;
+
     slang->sl_compprog = vim_regcomp(pat, RE_MAGIC + RE_STRING + RE_STRICT);
     vim_free(pat);
     if (slang->sl_compprog == NULL)
@@ -4791,13 +4956,16 @@
  * Structure that is used to store the items in the word tree.  This avoids
  * the need to keep track of each allocated thing, everything is freed all at
  * once after ":mkspell" is done.
+ * Note: "sb_next" must be just before "sb_data" to make sure the alignment of
+ * "sb_data" is correct for systems where pointers must be aligned on
+ * pointer-size boundaries and sizeof(pointer) > sizeof(int) (e.g., Sparc).
  */
 #define  SBLOCKSIZE 16000	/* size of sb_data */
 typedef struct sblock_S sblock_T;
 struct sblock_S
 {
-    sblock_T	*sb_next;	/* next block in list */
     int		sb_used;	/* nr of bytes already in use */
+    sblock_T	*sb_next;	/* next block in list */
     char_u	sb_data[1];	/* data, actually longer */
 };
 
@@ -4915,6 +5083,7 @@
 } spellinfo_T;
 
 static afffile_T *spell_read_aff __ARGS((spellinfo_T *spin, char_u *fname));
+static int is_aff_rule __ARGS((char_u **items, int itemcnt, char *rulename, int	 mincount));
 static void aff_process_flags __ARGS((afffile_T *affile, affentry_T *entry));
 static int spell_info_item __ARGS((char_u *s));
 static unsigned affitem2flag __ARGS((int flagtype, char_u *item, char_u	*fname, int lnum));
@@ -4950,7 +5119,7 @@
 static void put_sugtime __ARGS((spellinfo_T *spin, FILE *fd));
 static int write_vim_spell __ARGS((spellinfo_T *spin, char_u *fname));
 static void clear_node __ARGS((wordnode_T *node));
-static int put_node __ARGS((FILE *fd, wordnode_T *node, int index, int regionmask, int prefixtree));
+static int put_node __ARGS((FILE *fd, wordnode_T *node, int idx, int regionmask, int prefixtree));
 static void spell_make_sugfile __ARGS((spellinfo_T *spin, char_u *wfname));
 static int sug_filltree __ARGS((spellinfo_T *spin, slang_T *slang));
 static int sug_maketable __ARGS((spellinfo_T *spin));
@@ -5223,8 +5392,7 @@
 	/* Handle non-empty lines. */
 	if (itemcnt > 0)
 	{
-	    if (STRCMP(items[0], "SET") == 0 && itemcnt == 2
-						       && aff->af_enc == NULL)
+	    if (is_aff_rule(items, itemcnt, "SET", 2) && aff->af_enc == NULL)
 	    {
 #ifdef FEAT_MBYTE
 		/* Setup for conversion from "ENC" to 'encoding'. */
@@ -5239,7 +5407,7 @@
 		    smsg((char_u *)_("Conversion in %s not supported"), fname);
 #endif
 	    }
-	    else if (STRCMP(items[0], "FLAG") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "FLAG", 2)
 					      && aff->af_flagtype == AFT_CHAR)
 	    {
 		if (STRCMP(items[1], "long") == 0)
@@ -5284,69 +5452,71 @@
 			spin->si_info = p;
 		    }
 	    }
-	    else if (STRCMP(items[0], "MIDWORD") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "MIDWORD", 2)
 							   && midword == NULL)
 	    {
 		midword = getroom_save(spin, items[1]);
 	    }
-	    else if (STRCMP(items[0], "TRY") == 0 && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "TRY", 2))
 	    {
 		/* ignored, we look in the tree for what chars may appear */
 	    }
 	    /* TODO: remove "RAR" later */
-	    else if ((STRCMP(items[0], "RAR") == 0
-			|| STRCMP(items[0], "RARE") == 0) && itemcnt == 2
-						       && aff->af_rare == 0)
+	    else if ((is_aff_rule(items, itemcnt, "RAR", 2)
+			|| is_aff_rule(items, itemcnt, "RARE", 2))
+							 && aff->af_rare == 0)
 	    {
 		aff->af_rare = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
 	    /* TODO: remove "KEP" later */
-	    else if ((STRCMP(items[0], "KEP") == 0
-		    || STRCMP(items[0], "KEEPCASE") == 0) && itemcnt == 2
+	    else if ((is_aff_rule(items, itemcnt, "KEP", 2)
+			|| is_aff_rule(items, itemcnt, "KEEPCASE", 2))
 						     && aff->af_keepcase == 0)
 	    {
 		aff->af_keepcase = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "BAD") == 0 && itemcnt == 2
-						       && aff->af_bad == 0)
+	    else if ((is_aff_rule(items, itemcnt, "BAD", 2)
+			|| is_aff_rule(items, itemcnt, "FORBIDDENWORD", 2))
+							  && aff->af_bad == 0)
 	    {
 		aff->af_bad = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "NEEDAFFIX") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "NEEDAFFIX", 2)
 						    && aff->af_needaffix == 0)
 	    {
 		aff->af_needaffix = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "CIRCUMFIX") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "CIRCUMFIX", 2)
 						    && aff->af_circumfix == 0)
 	    {
 		aff->af_circumfix = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "NOSUGGEST") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "NOSUGGEST", 2)
 						    && aff->af_nosuggest == 0)
 	    {
 		aff->af_nosuggest = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "NEEDCOMPOUND") == 0 && itemcnt == 2
+	    else if ((is_aff_rule(items, itemcnt, "NEEDCOMPOUND", 2)
+			|| is_aff_rule(items, itemcnt, "ONLYINCOMPOUND", 2))
 						     && aff->af_needcomp == 0)
 	    {
 		aff->af_needcomp = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDROOT") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDROOT", 2)
 						     && aff->af_comproot == 0)
 	    {
 		aff->af_comproot = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDFORBIDFLAG") == 0
-				   && itemcnt == 2 && aff->af_compforbid == 0)
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDFORBIDFLAG", 2)
+						   && aff->af_compforbid == 0)
 	    {
 		aff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
@@ -5354,8 +5524,8 @@
 		    smsg((char_u *)_("Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d"),
 			    fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDPERMITFLAG") == 0
-				   && itemcnt == 2 && aff->af_comppermit == 0)
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDPERMITFLAG", 2)
+						   && aff->af_comppermit == 0)
 	    {
 		aff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],
 								 fname, lnum);
@@ -5363,7 +5533,7 @@
 		    smsg((char_u *)_("Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d"),
 			    fname, lnum);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDFLAG") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDFLAG", 2)
 							 && compflags == NULL)
 	    {
 		/* Turn flag "c" into COMPOUNDRULE compatible string "c+",
@@ -5376,7 +5546,15 @@
 		    compflags = p;
 		}
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDRULE") == 0 && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDRULES", 2))
+	    {
+		/* We don't use the count, but do check that it's a number and
+		 * not COMPOUNDRULE mistyped. */
+		if (atoi((char *)items[1]) == 0)
+		    smsg((char_u *)_("Wrong COMPOUNDRULES value in %s line %d: %s"),
+						       fname, lnum, items[1]);
+	    }
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDRULE", 2))
 	    {
 		/* Concatenate this string to previously defined ones, using a
 		 * slash to separate them. */
@@ -5395,7 +5573,7 @@
 		    compflags = p;
 		}
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDWORDMAX") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDWORDMAX", 2)
 							      && compmax == 0)
 	    {
 		compmax = atoi((char *)items[1]);
@@ -5403,7 +5581,7 @@
 		    smsg((char_u *)_("Wrong COMPOUNDWORDMAX value in %s line %d: %s"),
 						       fname, lnum, items[1]);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDMIN") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDMIN", 2)
 							   && compminlen == 0)
 	    {
 		compminlen = atoi((char *)items[1]);
@@ -5411,7 +5589,7 @@
 		    smsg((char_u *)_("Wrong COMPOUNDMIN value in %s line %d: %s"),
 						       fname, lnum, items[1]);
 	    }
-	    else if (STRCMP(items[0], "COMPOUNDSYLMAX") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "COMPOUNDSYLMAX", 2)
 							   && compsylmax == 0)
 	    {
 		compsylmax = atoi((char *)items[1]);
@@ -5419,32 +5597,29 @@
 		    smsg((char_u *)_("Wrong COMPOUNDSYLMAX value in %s line %d: %s"),
 						       fname, lnum, items[1]);
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDDUP") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDDUP", 1))
 	    {
 		compoptions |= COMP_CHECKDUP;
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDREP") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDREP", 1))
 	    {
 		compoptions |= COMP_CHECKREP;
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDCASE") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDCASE", 1))
 	    {
 		compoptions |= COMP_CHECKCASE;
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDTRIPLE") == 0
-							      && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDTRIPLE", 1))
 	    {
 		compoptions |= COMP_CHECKTRIPLE;
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDPATTERN") == 0
-							      && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDPATTERN", 2))
 	    {
 		if (atoi((char *)items[1]) == 0)
 		    smsg((char_u *)_("Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s"),
 						       fname, lnum, items[1]);
 	    }
-	    else if (STRCMP(items[0], "CHECKCOMPOUNDPATTERN") == 0
-							      && itemcnt == 3)
+	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDPATTERN", 3))
 	    {
 		garray_T    *gap = &spin->si_comppat;
 		int	    i;
@@ -5463,24 +5638,24 @@
 					       = getroom_save(spin, items[2]);
 		}
 	    }
-	    else if (STRCMP(items[0], "SYLLABLE") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "SYLLABLE", 2)
 							  && syllable == NULL)
 	    {
 		syllable = getroom_save(spin, items[1]);
 	    }
-	    else if (STRCMP(items[0], "NOBREAK") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "NOBREAK", 1))
 	    {
 		spin->si_nobreak = TRUE;
 	    }
-	    else if (STRCMP(items[0], "NOSPLITSUGS") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "NOSPLITSUGS", 1))
 	    {
 		spin->si_nosplitsugs = TRUE;
 	    }
-	    else if (STRCMP(items[0], "NOSUGFILE") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "NOSUGFILE", 1))
 	    {
 		spin->si_nosugfile = TRUE;
 	    }
-	    else if (STRCMP(items[0], "PFXPOSTPONE") == 0 && itemcnt == 1)
+	    else if (is_aff_rule(items, itemcnt, "PFXPOSTPONE", 1))
 	    {
 		aff->af_pfxpostpone = TRUE;
 	    }
@@ -5771,24 +5946,20 @@
 		    }
 		}
 	    }
-	    else if (STRCMP(items[0], "FOL") == 0 && itemcnt == 2
-							       && fol == NULL)
+	    else if (is_aff_rule(items, itemcnt, "FOL", 2) && fol == NULL)
 	    {
 		fol = vim_strsave(items[1]);
 	    }
-	    else if (STRCMP(items[0], "LOW") == 0 && itemcnt == 2
-							       && low == NULL)
+	    else if (is_aff_rule(items, itemcnt, "LOW", 2) && low == NULL)
 	    {
 		low = vim_strsave(items[1]);
 	    }
-	    else if (STRCMP(items[0], "UPP") == 0 && itemcnt == 2
-							       && upp == NULL)
+	    else if (is_aff_rule(items, itemcnt, "UPP", 2) && upp == NULL)
 	    {
 		upp = vim_strsave(items[1]);
 	    }
-	    else if ((STRCMP(items[0], "REP") == 0
-			|| STRCMP(items[0], "REPSAL") == 0)
-		    && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "REP", 2)
+		     || is_aff_rule(items, itemcnt, "REPSAL", 2))
 	    {
 		/* Ignore REP/REPSAL count */;
 		if (!isdigit(*items[1]))
@@ -5819,7 +5990,7 @@
 					 : &spin->si_rep, items[1], items[2]);
 		}
 	    }
-	    else if (STRCMP(items[0], "MAP") == 0 && itemcnt == 2)
+	    else if (is_aff_rule(items, itemcnt, "MAP", 2))
 	    {
 		/* MAP item or count */
 		if (!found_map)
@@ -5856,9 +6027,8 @@
 		    ga_append(&spin->si_map, '/');
 		}
 	    }
-	    /* Accept "SAL from to" and "SAL from to # comment". */
-	    else if (STRCMP(items[0], "SAL") == 0
-		    && (itemcnt == 3 || (itemcnt > 3 && items[3][0] == '#')))
+	    /* Accept "SAL from to" and "SAL from to  #comment". */
+	    else if (is_aff_rule(items, itemcnt, "SAL", 3))
 	    {
 		if (do_sal)
 		{
@@ -5877,12 +6047,12 @@
 								: items[2]);
 		}
 	    }
-	    else if (STRCMP(items[0], "SOFOFROM") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "SOFOFROM", 2)
 							  && sofofrom == NULL)
 	    {
 		sofofrom = getroom_save(spin, items[1]);
 	    }
-	    else if (STRCMP(items[0], "SOFOTO") == 0 && itemcnt == 2
+	    else if (is_aff_rule(items, itemcnt, "SOFOTO", 2)
 							    && sofoto == NULL)
 	    {
 		sofoto = getroom_save(spin, items[1]);
@@ -5980,7 +6150,7 @@
 	else if (spin->si_newprefID == 0 || spin->si_newprefID == 127)
 	    MSG(_("Too many compound flags"));
 	else
-	    MSG(_("Too many posponed prefixes and/or compound flags"));
+	    MSG(_("Too many postponed prefixes and/or compound flags"));
     }
 
     if (syllable != NULL)
@@ -6017,6 +6187,22 @@
 }
 
 /*
+ * Return TRUE when items[0] equals "rulename", there are "mincount" items or
+ * a comment is following after item "mincount".
+ */
+    static int
+is_aff_rule(items, itemcnt, rulename, mincount)
+    char_u	**items;
+    int		itemcnt;
+    char	*rulename;
+    int		mincount;
+{
+    return (STRCMP(items[0], rulename) == 0
+	    && (itemcnt == mincount
+		|| (itemcnt > mincount && items[mincount][0] == '#')));
+}
+
+/*
  * For affix "entry" move COMPOUNDFORBIDFLAG and COMPOUNDPERMITFLAG from
  * ae_flags to ae_comppermit and ae_compforbid.
  */
@@ -7866,7 +8052,7 @@
     /* time_t can be up to 8 bytes in size, more than long_u, thus we
      * can't use put_bytes() here. */
     for (i = 7; i >= 0; --i)
-	if (i + 1 > sizeof(time_t))
+	if (i + 1 > (int)sizeof(time_t))
 	    /* ">>" doesn't work well when shifting more bits than avail */
 	    putc(0, fd);
 	else
@@ -7926,6 +8112,8 @@
     char_u	*p;
     int		rr;
     int		retval = OK;
+    size_t	fwv = 1;  /* collect return value of fwrite() to avoid
+			     warnings from picky compiler */
 
     fd = mch_fopen((char *)fname, "w");
     if (fd == NULL)
@@ -7936,11 +8124,11 @@
 
     /* <HEADER>: <fileID> <versionnr> */
 							    /* <fileID> */
-    if (fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, (size_t)1, fd) != 1)
-    {
-	EMSG(_(e_write));
-	retval = FAIL;
-    }
+    fwv &= fwrite(VIMSPELLMAGIC, VIMSPELLMAGICL, (size_t)1, fd);
+    if (fwv != (size_t)1)
+	/* Catch first write error, don't try writing more. */
+	goto theend;
+
     putc(VIMSPELLVERSION, fd);				    /* <versionnr> */
 
     /*
@@ -7955,7 +8143,7 @@
 
 	i = (int)STRLEN(spin->si_info);
 	put_bytes(fd, (long_u)i, 4);			/* <sectionlen> */
-	fwrite(spin->si_info, (size_t)i, (size_t)1, fd); /* <infotext> */
+	fwv &= fwrite(spin->si_info, (size_t)i, (size_t)1, fd); /* <infotext> */
     }
 
     /* SN_REGION: <regionname> ...
@@ -7966,7 +8154,7 @@
 	putc(SNF_REQUIRED, fd);				/* <sectionflags> */
 	l = spin->si_region_count * 2;
 	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
-	fwrite(spin->si_region_name, (size_t)l, (size_t)1, fd);
+	fwv &= fwrite(spin->si_region_name, (size_t)l, (size_t)1, fd);
 							/* <regionname> ... */
 	regionmask = (1 << spin->si_region_count) - 1;
     }
@@ -8016,7 +8204,7 @@
 	}
 
 	put_bytes(fd, (long_u)l, 2);			/* <folcharslen> */
-	fwrite(folchars, (size_t)l, (size_t)1, fd);	/* <folchars> */
+	fwv &= fwrite(folchars, (size_t)l, (size_t)1, fd); /* <folchars> */
     }
 
     /* SN_MIDWORD: <midword> */
@@ -8027,7 +8215,8 @@
 
 	i = (int)STRLEN(spin->si_midword);
 	put_bytes(fd, (long_u)i, 4);			/* <sectionlen> */
-	fwrite(spin->si_midword, (size_t)i, (size_t)1, fd); /* <midword> */
+	fwv &= fwrite(spin->si_midword, (size_t)i, (size_t)1, fd);
+							/* <midword> */
     }
 
     /* SN_PREFCOND: <prefcondcnt> <prefcond> ... */
@@ -8113,7 +8302,8 @@
 		p = rr == 1 ? ftp->ft_from : ftp->ft_to;
 		l = (int)STRLEN(p);
 		putc(l, fd);
-		fwrite(p, l, (size_t)1, fd);
+		if (l > 0)
+		    fwv &= fwrite(p, l, (size_t)1, fd);
 	    }
 	}
 
@@ -8131,11 +8321,11 @@
 							/* <sectionlen> */
 
 	put_bytes(fd, (long_u)l, 2);			/* <sofofromlen> */
-	fwrite(spin->si_sofofr, l, (size_t)1, fd);	/* <sofofrom> */
+	fwv &= fwrite(spin->si_sofofr, l, (size_t)1, fd); /* <sofofrom> */
 
 	l = (int)STRLEN(spin->si_sofoto);
 	put_bytes(fd, (long_u)l, 2);			/* <sofotolen> */
-	fwrite(spin->si_sofoto, l, (size_t)1, fd);	/* <sofoto> */
+	fwv &= fwrite(spin->si_sofoto, l, (size_t)1, fd); /* <sofoto> */
     }
 
     /* SN_WORDS: <word> ...
@@ -8160,7 +8350,7 @@
 		    l = (int)STRLEN(hi->hi_key) + 1;
 		    len += l;
 		    if (round == 2)			/* <word> */
-			fwrite(hi->hi_key, (size_t)l, (size_t)1, fd);
+			fwv &= fwrite(hi->hi_key, (size_t)l, (size_t)1, fd);
 		    --todo;
 		}
 	    if (round == 1)
@@ -8176,7 +8366,7 @@
 	putc(0, fd);					/* <sectionflags> */
 	l = spin->si_map.ga_len;
 	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
-	fwrite(spin->si_map.ga_data, (size_t)l, (size_t)1, fd);
+	fwv &= fwrite(spin->si_map.ga_data, (size_t)l, (size_t)1, fd);
 							/* <mapstr> */
     }
 
@@ -8232,10 +8422,11 @@
 	{
 	    p = ((char_u **)(spin->si_comppat.ga_data))[i];
 	    putc((int)STRLEN(p), fd);			/* <comppatlen> */
-	    fwrite(p, (size_t)STRLEN(p), (size_t)1, fd);/* <comppattext> */
+	    fwv &= fwrite(p, (size_t)STRLEN(p), (size_t)1, fd);
+							/* <comppattext> */
 	}
 							/* <compflags> */
-	fwrite(spin->si_compflags, (size_t)STRLEN(spin->si_compflags),
+	fwv &= fwrite(spin->si_compflags, (size_t)STRLEN(spin->si_compflags),
 							       (size_t)1, fd);
     }
 
@@ -8259,7 +8450,8 @@
 
 	l = (int)STRLEN(spin->si_syllable);
 	put_bytes(fd, (long_u)l, 4);			/* <sectionlen> */
-	fwrite(spin->si_syllable, (size_t)l, (size_t)1, fd); /* <syllable> */
+	fwv &= fwrite(spin->si_syllable, (size_t)l, (size_t)1, fd);
+							/* <syllable> */
     }
 
     /* end of <SECTIONS> */
@@ -8295,13 +8487,18 @@
 	(void)put_node(fd, tree, 0, regionmask, round == 3);
     }
 
-    /* Write another byte to check for errors. */
+    /* Write another byte to check for errors (file system full). */
     if (putc(0, fd) == EOF)
 	retval = FAIL;
-
+theend:
     if (fclose(fd) == EOF)
 	retval = FAIL;
 
+    if (fwv != (size_t)1)
+	retval = FAIL;
+    if (retval == FAIL)
+	EMSG(_(e_write));
+
     return retval;
 }
 
@@ -9890,6 +10087,7 @@
     char_u	*p;
     int		len;
     int		totlen;
+    size_t	x = 1;  /* collect return value of fwrite() */
 
     if (fd != NULL)
 	put_bytes(fd, (long_u)gap->ga_len, 2);	    /* <prefcondcnt> */
@@ -9906,7 +10104,7 @@
 	    if (fd != NULL)
 	    {
 		fputc(len, fd);
-		fwrite(p, (size_t)len, (size_t)1, fd);
+		x &= fwrite(p, (size_t)len, (size_t)1, fd);
 	    }
 	    totlen += len;
 	}
@@ -10054,6 +10252,7 @@
     int		limit;
     int		selected = count;
     int		badlen = 0;
+    int		msg_scroll_save = msg_scroll;
 
     if (no_spell_checking(curwin))
 	return;
@@ -10218,7 +10417,9 @@
 	selected = prompt_for_number(&mouse_used);
 	if (mouse_used)
 	    selected -= lines_left;
-	lines_left = Rows;	/* avoid more prompt */
+	lines_left = Rows;		/* avoid more prompt */
+	/* don't delay for 'smd' in normal_cmd() */
+	msg_scroll = msg_scroll_save;
     }
 
     if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)
@@ -10243,7 +10444,8 @@
 	}
 
 	/* Replace the word. */
-	p = alloc((unsigned)STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);
+	p = alloc((unsigned)STRLEN(line) - stp->st_orglen
+						       + stp->st_wordlen + 1);
 	if (p != NULL)
 	{
 	    c = (int)(sug.su_badptr - line);
@@ -10343,10 +10545,9 @@
 /*
  * ":spellrepall"
  */
-/*ARGSUSED*/
     void
 ex_spellrepall(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     pos_T	pos = curwin->w_cursor;
     char_u	*frompat;
@@ -11480,15 +11681,24 @@
 		    vim_strncpy(preword + sp->ts_prewordlen,
 			    tword + sp->ts_splitoff,
 			    sp->ts_twordlen - sp->ts_splitoff);
-		    p = preword;
-		    while (*skiptowhite(p) != NUL)
-			p = skipwhite(skiptowhite(p));
-		    if (fword_ends && !can_compound(slang, p,
-						compflags + sp->ts_compsplit))
-			/* Compound is not allowed.  But it may still be
-			 * possible if we add another (short) word. */
+
+		    /* Verify CHECKCOMPOUNDPATTERN  rules. */
+		    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,
+							  &slang->sl_comppat))
 			compound_ok = FALSE;
 
+		    if (compound_ok)
+		    {
+			p = preword;
+			while (*skiptowhite(p) != NUL)
+			    p = skipwhite(skiptowhite(p));
+			if (fword_ends && !can_compound(slang, p,
+						compflags + sp->ts_compsplit))
+			    /* Compound is not allowed.  But it may still be
+			     * possible if we add another (short) word. */
+			    compound_ok = FALSE;
+		    }
+
 		    /* Get pointer to last char of previous word. */
 		    p = preword + sp->ts_prewordlen;
 		    mb_ptr_back(preword, p);
@@ -11685,10 +11895,9 @@
 			&& (slang->sl_compsylmax < MAXWLEN
 			    || sp->ts_complen + 1 - sp->ts_compsplit
 							  < slang->sl_compmax)
-			&& (byte_in_str(sp->ts_complen == sp->ts_compsplit
-					    ? slang->sl_compstartflags
-					    : slang->sl_compallflags,
-						    ((unsigned)flags >> 24))))
+			&& (can_be_compound(sp, slang,
+					 compflags, ((unsigned)flags >> 24))))
+
 		{
 		    try_compound = TRUE;
 		    compflags[sp->ts_complen] = ((unsigned)flags >> 24);
@@ -14808,7 +15017,7 @@
 
 	case 0:
 	    /*
-	     * Lenghts are equal, thus changes must result in same length: An
+	     * Lengths are equal, thus changes must result in same length: An
 	     * insert is only possible in combination with a delete.
 	     * 1: check if for identical strings
 	     */
@@ -15398,10 +15607,9 @@
 /*
  * ":spellinfo"
  */
-/*ARGSUSED*/
     void
 ex_spellinfo(eap)
-    exarg_T *eap;
+    exarg_T *eap UNUSED;
 {
     int		lpi;
     langp_T	*lp;
@@ -15945,11 +16153,9 @@
  * Returns the number of matches.  The matches are in "matchp[]", array of
  * allocated strings.
  */
-/*ARGSUSED*/
     int
-expand_spelling(lnum, col, pat, matchp)
-    linenr_T	lnum;
-    int		col;
+expand_spelling(lnum, pat, matchp)
+    linenr_T	lnum UNUSED;
     char_u	*pat;
     char_u	***matchp;
 {
diff -Naur vim72.orig/src/structs.h vim72/src/structs.h
--- vim72.orig/src/structs.h	2008-07-30 21:02:50.000000000 +0100
+++ vim72/src/structs.h	2009-07-22 22:54:23.000000000 +0100
@@ -16,7 +16,7 @@
  */
 #if defined(SASC) && SASC < 658
 typedef long		linenr_T;
-typedef unsigned	colnr_T;
+typedef int		colnr_T;
 typedef unsigned short	short_u;
 #endif
 
@@ -33,9 +33,9 @@
 } pos_T;
 
 #ifdef FEAT_VIRTUALEDIT
-# define INIT_POS_T {0, 0, 0}
+# define INIT_POS_T(l, c, ca) {l, c, ca}
 #else
-# define INIT_POS_T {0, 0}
+# define INIT_POS_T(l, c, ca) {l, c}
 #endif
 
 /*
@@ -459,7 +459,7 @@
 typedef struct
 {
     int		hide;			/* TRUE when ":hide" was used */
-# ifdef FEAT_BROWSE
+# ifdef FEAT_BROWSE_CMD
     int		browse;			/* TRUE to invoke file dialog */
 # endif
 # ifdef FEAT_WINDOWS
@@ -882,6 +882,8 @@
 {
     typebuf_T		save_typebuf;
     int			typebuf_valid;	    /* TRUE when save_typebuf valid */
+    int			old_char;
+    int			old_mod_mask;
     struct buffheader	save_stuffbuff;
 #ifdef USE_INPUT_BUF
     char_u		*save_inputbuf;
@@ -1166,7 +1168,8 @@
     char_u	*b_fname;	/* current file name */
 
 #ifdef UNIX
-    int		b_dev;		/* device number (-1 if not set) */
+    int		b_dev_valid;	/* TRUE when b_dev has a valid number */
+    dev_t	b_dev;		/* device number */
     ino_t	b_ino;		/* inode number */
 #endif
 #ifdef FEAT_CW_EDITOR
@@ -1620,6 +1623,14 @@
 };
 #endif
 
+#define SNAP_HELP_IDX	0
+#ifdef FEAT_AUTOCMD
+# define SNAP_AUCMD_IDX 1
+# define SNAP_COUNT	2
+#else
+# define SNAP_COUNT	1
+#endif
+
 /*
  * Tab pages point to the top frame of each tab page.
  * Note: Most values are NOT valid for the current tab page!  Use "curwin",
@@ -1648,7 +1659,7 @@
     buf_T	    *(tp_diffbuf[DB_COUNT]);
     int		    tp_diff_invalid;	/* list of diffs is outdated */
 #endif
-    frame_T	    *tp_snapshot;    /* window layout snapshot */
+    frame_T	    *(tp_snapshot[SNAP_COUNT]);  /* window layout snapshots */
 #ifdef FEAT_EVAL
     dictitem_T	    tp_winvar;	    /* variable for "t:" Dictionary */
     dict_T	    tp_vars;	    /* internal variables, local to tab page */
@@ -1784,10 +1795,15 @@
 #endif
 
     /*
-     * The next three specify the offsets for displaying the buffer:
+     * "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for
+     * displaying the buffer.
      */
     linenr_T	w_topline;	    /* buffer line number of the line at the
 				       top of the window */
+#ifdef FEAT_AUTOCMD
+    char	w_topline_was_set;  /* flag set to TRUE when topline is set,
+				       e.g. by winrestview() */
+#endif
 #ifdef FEAT_DIFF
     int		w_topfill;	    /* number of filler lines above w_topline */
     int		w_old_topfill;	    /* w_topfill at last redraw */
@@ -2270,16 +2286,11 @@
  */
 typedef struct
 {
-    buf_T	*save_buf;	/* saved curbuf */
+    buf_T	*save_curbuf;	/* saved curbuf */
 #ifdef FEAT_AUTOCMD
-    buf_T	*new_curbuf;	/* buffer to be used */
-    win_T	*save_curwin;	/* saved curwin, NULL if it didn't change */
-    win_T	*new_curwin;	/* new curwin if save_curwin != NULL */
-    pos_T	save_cursor;	/* saved cursor pos of save_curwin */
-    linenr_T	save_topline;	/* saved topline of save_curwin */
-# ifdef FEAT_DIFF
-    int		save_topfill;	/* saved topfill of save_curwin */
-# endif
+    win_T	*save_curwin;	/* saved curwin */
+    win_T	*new_curwin;	/* new curwin */
+    buf_T	*new_curbuf;	/* new curbuf */
 #endif
 } aco_save_T;
 
diff -Naur vim72.orig/src/syntax.c vim72/src/syntax.c
--- vim72.orig/src/syntax.c	2008-08-08 22:47:48.000000000 +0100
+++ vim72/src/syntax.c	2009-07-22 22:54:22.000000000 +0100
@@ -3224,11 +3224,10 @@
 /*
  * Handle ":syntax case" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_case(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     char_u	*next;
@@ -3249,11 +3248,10 @@
 /*
  * Handle ":syntax spell" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_spell(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     char_u	*next;
@@ -3517,11 +3515,10 @@
 /*
  * Handle ":syntax on" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_on(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     syn_cmd_onoff(eap, "syntax");
 }
@@ -3529,11 +3526,10 @@
 /*
  * Handle ":syntax enable" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_enable(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     set_internal_string_var((char_u *)"syntax_cmd", (char_u *)"enable");
     syn_cmd_onoff(eap, "syntax");
@@ -3543,11 +3539,10 @@
 /*
  * Handle ":syntax reset" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_reset(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     eap->nextcmd = check_nextcmd(eap->arg);
     if (!eap->skip)
@@ -3561,11 +3556,10 @@
 /*
  * Handle ":syntax manual" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_manual(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     syn_cmd_onoff(eap, "manual");
 }
@@ -3573,11 +3567,10 @@
 /*
  * Handle ":syntax off" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_off(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	/* not used */
+    int		syncing UNUSED;
 {
     syn_cmd_onoff(eap, "nosyntax");
 }
@@ -4461,11 +4454,10 @@
 /*
  * Handle ":syntax include [@{group-name}] filename" command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_include(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     int		sgl_id = 1;
@@ -4532,11 +4524,10 @@
 /*
  * Handle ":syntax keyword {group-name} [{option}] keyword .." command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_keyword(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     char_u	*group_name_end;
@@ -5275,11 +5266,10 @@
  * Handle ":syntax cluster {cluster-name} [contains={groupname},..]
  *		[add={groupname},..] [remove={groupname},..]".
  */
-/* ARGSUSED */
     static void
 syn_cmd_cluster(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg = eap->arg;
     char_u	*group_name_end;
@@ -5464,11 +5454,10 @@
 /*
  * Handle ":syntax sync .." command.
  */
-/* ARGSUSED */
     static void
 syn_cmd_sync(eap, syncing)
     exarg_T	*eap;
-    int		syncing;	    /* not used */
+    int		syncing UNUSED;
 {
     char_u	*arg_start = eap->arg;
     char_u	*arg_end;
@@ -6099,10 +6088,9 @@
  * Function given to ExpandGeneric() to obtain the list syntax names for
  * expansion.
  */
-/*ARGSUSED*/
     char_u *
 get_syntax_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
     if (expand_what == EXP_SUBCMD)
@@ -7744,14 +7732,13 @@
 /*
  * Get the font or fontset for one highlight group.
  */
-/*ARGSUSED*/
     static void
 hl_do_font(idx, arg, do_normal, do_menu, do_tooltip)
     int		idx;
     char_u	*arg;
-    int		do_normal;	/* set normal font */
-    int		do_menu;	/* set menu font */
-    int		do_tooltip;	/* set tooltip font */
+    int		do_normal;		/* set normal font */
+    int		do_menu UNUSED;		/* set menu font */
+    int		do_tooltip UNUSED;	/* set tooltip font */
 {
 # ifdef FEAT_XFONTSET
     /* If 'guifontset' is not empty, first try using the name as a
@@ -9150,10 +9137,9 @@
  * Function given to ExpandGeneric() to obtain the list of group names.
  * Also used for synIDattr() function.
  */
-/*ARGSUSED*/
     char_u *
 get_highlight_name(xp, idx)
-    expand_T	*xp;
+    expand_T	*xp UNUSED;
     int		idx;
 {
 #ifdef FEAT_CMDL_COMPL
diff -Naur vim72.orig/src/tag.c vim72/src/tag.c
--- vim72.orig/src/tag.c	2008-07-16 22:31:30.000000000 +0100
+++ vim72/src/tag.c	2009-07-22 22:54:22.000000000 +0100
@@ -100,7 +100,7 @@
  * Tag for preview window is remembered separately, to avoid messing up the
  * normal tagstack.
  */
-static taggy_T ptag_entry = {NULL};
+static taggy_T ptag_entry = {NULL, {INIT_POS_T(0, 0, 0), 0}, 0, 0};
 #endif
 
 /*
@@ -515,7 +515,7 @@
 	     * If a count is supplied to the ":tag <name>" command, then
 	     * jump to count'th matching tag.
 	     */
-	    if (type == DT_TAG && count > 0)
+	    if (type == DT_TAG && *tag != NUL && count > 0)
 		cur_match = count - 1;
 
 	    if (type == DT_SELECT || type == DT_JUMP
@@ -618,7 +618,7 @@
 		taglen_advance(taglen);
 		MSG_PUTS_ATTR(_("file\n"), hl_attr(HLF_T));
 
-		for (i = 0; i < num_matches; ++i)
+		for (i = 0; i < num_matches && !got_int; ++i)
 		{
 		    parse_match(matches[i], &tagp);
 		    if (!new_tag && (
@@ -655,6 +655,8 @@
 		    }
 		    if (msg_col > 0)
 			msg_putchar('\n');
+		    if (got_int)
+			break;
 		    msg_advance(15);
 
 		    /* print any extra fields */
@@ -689,6 +691,8 @@
 				if (msg_col + ptr2cells(p) >= Columns)
 				{
 				    msg_putchar('\n');
+				    if (got_int)
+					break;
 				    msg_advance(15);
 				}
 				p = msg_outtrans_one(p, attr);
@@ -704,6 +708,8 @@
 			if (msg_col > 15)
 			{
 			    msg_putchar('\n');
+			    if (got_int)
+				break;
 			    msg_advance(15);
 			}
 		    }
@@ -734,6 +740,8 @@
 		    {
 			if (msg_col + (*p == TAB ? 1 : ptr2cells(p)) > Columns)
 			    msg_putchar('\n');
+			if (got_int)
+			    break;
 			msg_advance(15);
 
 			/* skip backslash used for escaping command char */
@@ -760,12 +768,9 @@
 		    if (msg_col)
 			msg_putchar('\n');
 		    ui_breakcheck();
-		    if (got_int)
-		    {
-			got_int = FALSE;	/* only stop the listing */
-			break;
-		    }
 		}
+		if (got_int)
+		    got_int = FALSE;	/* only stop the listing */
 		ask_for_selection = TRUE;
 	    }
 #if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)
@@ -1100,10 +1105,9 @@
 /*
  * Print the tag stack
  */
-/*ARGSUSED*/
     void
 do_tags(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     int		i;
     char_u	*name;
@@ -2525,11 +2529,10 @@
  * Callback function for finding all "tags" and "tags-??" files in
  * 'runtimepath' doc directories.
  */
-/*ARGSUSED*/
     static void
 found_tagfile_cb(fname, cookie)
     char_u	*fname;
-    void	*cookie;
+    void	*cookie UNUSED;
 {
     if (ga_grow(&tag_fnames, 1) == OK)
 	((char_u **)(tag_fnames.ga_data))[tag_fnames.ga_len++] =
@@ -2542,6 +2545,15 @@
 {
     ga_clear_strings(&tag_fnames);
     do_tag(NULL, DT_FREE, 0, 0, 0);
+    tag_freematch();
+
+# if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
+    if (ptag_entry.tagname)
+    {
+        vim_free(ptag_entry.tagname);
+        ptag_entry.tagname = NULL;
+    }
+# endif
 }
 #endif
 
@@ -2725,7 +2737,24 @@
 	 */
 	p_7f = vim_strchr(lbuf, 0x7f);
 	if (p_7f == NULL)
+	{
+etag_fail:
+	    if (vim_strchr(lbuf, '\n') == NULL)
+	    {
+		/* Truncated line.  Ignore it. */
+		if (p_verbose >= 5)
+		{
+		    verbose_enter();
+		    MSG(_("Ignoring long line in tags file"));
+		    verbose_leave();
+		}
+		tagp->command = lbuf;
+		tagp->tagname = lbuf;
+		tagp->tagname_end = lbuf;
+		return OK;
+	    }
 	    return FAIL;
+	}
 
 	/* Find ^A.  If not found the line number is after the 0x7f */
 	p = vim_strchr(p_7f, Ctrl_A);
@@ -2735,7 +2764,7 @@
 	    ++p;
 
 	if (!VIM_ISDIGIT(*p))	    /* check for start of line number */
-	    return FAIL;
+	    goto etag_fail;
 	tagp->command = p;
 
 
@@ -2749,7 +2778,7 @@
 	    /* find end of tagname */
 	    for (p = p_7f - 1; !vim_iswordc(*p); --p)
 		if (p == lbuf)
-		    return FAIL;
+		    goto etag_fail;
 	    tagp->tagname_end = p + 1;
 	    while (p >= lbuf && vim_iswordc(*p))
 		--p;
@@ -3762,7 +3791,7 @@
 		--end;
 	}
 	len = (int)(end - start);
-	if (len > sizeof(buf) - 1)
+	if (len > (int)sizeof(buf) - 1)
 	    len = sizeof(buf) - 1;
 	vim_strncpy(buf, start, len);
     }
diff -Naur vim72.orig/src/term.c vim72/src/term.c
--- vim72.orig/src/term.c	2008-07-27 12:48:06.000000000 +0100
+++ vim72/src/term.c	2009-07-22 22:54:24.000000000 +0100
@@ -2881,7 +2881,7 @@
 
 	/* if 'Sb' and 'AB' are not defined, reset "Co" */
 	if (*T_CSB == NUL && *T_CAB == NUL)
-	    T_CCO = empty_option;
+	    free_one_termoption(T_CCO);
 
 	/* Set 'weirdinvert' according to value of 't_xs' */
 	p_wiv = (*T_XS != NUL);
@@ -2906,7 +2906,7 @@
     int	    i;
     int	    shift;
 
-    for (i = 1; i <= sizeof(long_u); i++)
+    for (i = 1; i <= (int)sizeof(long_u); i++)
     {
 	shift = 8 * (sizeof(long_u) - i);
 	dst[i - 1] = (char_u) ((val >> shift) & 0xff);
@@ -2937,7 +2937,7 @@
     len = get_bytes_from_buf(buf, bytes, (int)sizeof(long_u));
     if (len != -1)
     {
-	for (i = 0; i < sizeof(long_u); i++)
+	for (i = 0; i < (int)sizeof(long_u); i++)
 	{
 	    shift = 8 * (sizeof(long_u) - 1 - i);
 	    *val += (long_u)bytes[i] << shift;
@@ -4920,7 +4920,15 @@
 	key_name[0] = KEY2TERMCAP0(key);
 	key_name[1] = KEY2TERMCAP1(key);
 	if (key_name[0] == KS_KEY)
-	    string[new_slen++] = key_name[1];	/* from ":set <M-b>=xx" */
+	{
+	    /* from ":set <M-b>=xx" */
+#ifdef FEAT_MBYTE
+	    if (has_mbyte)
+		new_slen += (*mb_char2bytes)(key_name[1], string + new_slen);
+	    else
+#endif
+		string[new_slen++] = key_name[1];
+	}
 	else
 	{
 	    string[new_slen++] = K_SPECIAL;
@@ -5547,7 +5555,7 @@
  * respects the current B/k/< settings of 'cpoption'.
  *
  * This function is called when expanding mappings/abbreviations on the
- * command-line, and for building the "Ambiguous mapping..." error messæge.
+ * command-line, and for building the "Ambiguous mapping..." error message.
  *
  * It uses a growarray to build the translation string since the
  * latter can be wider than the original description. The caller has to
diff -Naur vim72.orig/src/testdir/Makefile vim72/src/testdir/Makefile
--- vim72.orig/src/testdir/Makefile	2008-06-19 21:29:46.000000000 +0100
+++ vim72/src/testdir/Makefile	2009-07-22 22:54:23.000000000 +0100
@@ -4,9 +4,11 @@
 
 VIMPROG = ../vim
 
-# Uncomment this line for using valgrind.
-# The output goes into a file "valgrind.$PID" (sorry, no test number).
-# VALGRIND = valgrind --tool=memcheck --leak-check=yes --num-callers=15 --logfile=valgrind
+# Uncomment this line to use valgrind for memory leaks and extra warnings.
+#   The output goes into a file "valgrind.testN"
+#   Vim should be compiled with EXITFREE to avoid false warnings.
+#   This will make testing about 10 times as slow.
+# VALGRIND = valgrind --tool=memcheck --leak-check=yes --num-callers=15 --log-file=valgrind.$*
 
 SCRIPTS = test1.out test2.out test3.out test4.out test5.out test6.out \
 		test7.out test8.out test9.out test10.out test11.out \
@@ -20,21 +22,23 @@
 		test48.out test49.out test51.out test52.out test53.out \
 		test54.out test55.out test56.out test57.out test58.out \
 		test59.out test60.out test61.out test62.out test63.out \
-		test64.out test65.out
+		test64.out test65.out test66.out
 
 SCRIPTS_GUI = test16.out
 
 .SUFFIXES: .in .out
 
-nongui:	nolog $(SCRIPTS)
-	@echo
-	@cat test.log
-	@echo ALL DONE
+nongui:	nolog $(SCRIPTS) report
+
+gui:	nolog $(SCRIPTS) $(SCRIPTS_GUI) report
 
-gui:	nolog $(SCRIPTS) $(SCRIPTS_GUI)
+report:
 	@echo
-	@cat test.log
-	@echo ALL DONE
+	@echo 'Test results:'
+	@/bin/sh -c "if test -f test.log; \
+		then cat test.log; echo TEST FAILURE; exit 1; \
+		else echo ALL DONE; \
+		fi"
 
 $(SCRIPTS) $(SCRIPTS_GUI): $(VIMPROG)
 
@@ -71,4 +75,4 @@
 test60.out: test60.vim
 
 nolog:
-	-echo Test results: >test.log
+	-rm -f test.log
diff -Naur vim72.orig/src/testdir/Make_ming.mak vim72/src/testdir/Make_ming.mak
--- vim72.orig/src/testdir/Make_ming.mak	1970-01-01 01:00:00.000000000 +0100
+++ vim72/src/testdir/Make_ming.mak	2009-07-22 22:54:20.000000000 +0100
@@ -0,0 +1,91 @@
+# Makefile to run tests for Vim, on Dos-like machines
+# with sh.exe or zsh.exe in the path or not.
+#
+# Author: Bill McCarthy
+#
+# Note that test54 has been removed until it is fixed.
+#
+# Requires a set of Unix tools: echo, diff, etc.
+
+ifneq (sh.exe, $(SHELL))
+DEL = rm -f
+MV = mv
+CP = cp
+DIRSLASH = /
+else
+DEL = del
+MV = rename
+CP = copy
+DIRSLASH = \\
+endif
+
+VIMPROG = ..$(DIRSLASH)vim
+
+# Omitted:
+# test2		"\\tmp" doesn't work.
+# test10	'errorformat' is different
+# test12	can't unlink a swap file
+# test25	uses symbolic link
+# test27	can't edit file with "*" in file name
+# test31	16 bit version runs out of memory...
+
+SCRIPTS16 =	test1.out test19.out test20.out test22.out \
+		test23.out test24.out test28.out test29.out \
+		test35.out test36.out test43.out \
+		test44.out test45.out test46.out test47.out \
+		test48.out test51.out test53.out            \
+		test55.out test56.out test57.out test58.out test59.out \
+		test60.out test61.out test62.out test63.out test64.out
+
+# Had to remove test54 which doesn't work yet.
+#		                                 test54.out
+
+SCRIPTS =	test3.out test4.out test5.out test6.out test7.out \
+		test8.out test9.out test11.out test13.out test14.out \
+		test15.out test17.out test18.out test21.out test26.out \
+		test30.out test31.out test32.out test33.out test34.out \
+		test37.out test38.out test39.out test40.out test41.out \
+		test42.out test52.out test65.out test66.out
+
+SCRIPTS32 =	test50.out
+
+SCRIPTS_GUI = test16.out
+
+.SUFFIXES: .in .out
+
+vimall:	fixff $(SCRIPTS16) $(SCRIPTS) $(SCRIPTS_GUI) $(SCRIPTS32)
+	echo ALL DONE
+
+nongui:	fixff $(SCRIPTS16) $(SCRIPTS)
+	echo ALL DONE
+
+small:
+	echo ALL DONE
+
+gui:	fixff $(SCRIPTS16) $(SCRIPTS) $(SCRIPTS_GUI)
+	echo ALL DONE
+
+win32:	fixff $(SCRIPTS16) $(SCRIPTS) $(SCRIPTS32)
+	echo ALL DONE
+
+fixff:
+	-$(VIMPROG) -u dos.vim --noplugin "+argdo set ff=dos|upd" +q *.in *.ok
+
+clean:
+	-$(DEL) *.out
+	-$(DEL) test.ok
+	-$(DEL) small.vim
+	-$(DEL) tiny.vim
+	-$(DEL) mbyte.vim
+	-$(DEL) X*
+	-$(DEL) viminfo
+
+.in.out:
+	$(CP) $*.ok test.ok
+	$(VIMPROG) -u dos.vim -U NONE --noplugin -s dotest.in $*.in
+	diff test.out $*.ok
+	-$(DEL) $*.out
+	$(MV) test.out $*.out
+	-$(DEL) X*
+	-$(DEL) test.ok
+	-$(DEL) viminfo
diff -Naur vim72.orig/src/testdir/test30.in vim72/src/testdir/test30.in
--- vim72.orig/src/testdir/test30.in	2008-06-25 22:33:01.000000000 +0100
+++ vim72/src/testdir/test30.in	2009-07-22 22:54:16.000000000 +0100
@@ -24,10 +24,17 @@
 :set nobin eol
 :bwipe XXUnix XXDos XXMac
 :" create mixed format files
-:!cat XXUnix XXDos >XXUxDs
-:!cat XXUnix XXMac >XXUxMac
-:!cat XXDos XXMac >XXDosMac
-:!cat XXUnix XXDos XXMac >XXUxDsMc
+:if has("vms")
+: !copy XXUnix,XXDos XXUxDs.
+: !copy XXUnix,XXMac XXUxMac.
+: !copy XXDos,XXMac  XXDosMac.
+: !copy XXUnix,XXDos,XXMac XXUxDsMc.
+:else
+: !cat XXUnix XXDos >XXUxDs
+: !cat XXUnix XXMac >XXUxMac
+: !cat XXDos XXMac >XXDosMac
+: !cat XXUnix XXDos XXMac >XXUxDsMc
+:endif
 :"
 :" try reading and writing with 'fileformats' empty
 :set fileformat=unix
diff -Naur vim72.orig/src/testdir/test42.ok vim72/src/testdir/test42.ok
--- vim72.orig/src/testdir/test42.ok	2008-02-20 12:27:37.000000000 +0000
+++ vim72/src/testdir/test42.ok	2009-07-22 22:54:17.000000000 +0100
@@ -20,7 +20,7 @@
 ucs-2
 
 
-  fileencoding=ucs-2le
+  fileencoding=utf-16le
   bomb
 ucs-2le
 
diff -Naur vim72.orig/src/testdir/test54.in vim72/src/testdir/test54.in
--- vim72.orig/src/testdir/test54.in	2005-01-01 11:21:16.000000000 +0000
+++ vim72/src/testdir/test54.in	2009-07-22 22:54:16.000000000 +0100
@@ -3,8 +3,13 @@
 STARTTEST
 :so small.vim
 :e xx
-:!rm -f test.out
-:au BufLeave <buffer> :!echo buffer-local autommand in %>> test.out
+:if has("vms")
+: !del test.out.*
+: au BufLeave <buffer> :!write sys$output "buffer-local autommand in %" > test.out
+:else
+: !rm -f test.out
+: au BufLeave <buffer> :!echo buffer-local autommand in %>> test.out
+:endif
 :e somefile           " here, autocommand for xx shall write test.out 
 :                     " but autocommand shall not apply to buffer named <buffer>
 :bwipe xx             " here, autocommand shall be auto-deleted
diff -Naur vim72.orig/src/testdir/test66.in vim72/src/testdir/test66.in
--- vim72.orig/src/testdir/test66.in	1970-01-01 01:00:00.000000000 +0100
+++ vim72/src/testdir/test66.in	2009-07-22 22:54:20.000000000 +0100
@@ -0,0 +1,25 @@
+
+Test for visual block shift and tab characters.
+
+STARTTEST
+:so small.vim
+/^abcdefgh
+4jI    j<<11|D
+7|a		
+7|a		   
+7|a	       	4k13|4j<
+:$-4,$w! test.out
+:$-4,$s/\s\+//g
+4kI    j<<
+7|a		
+7|a					
+7|a	       		4k13|4j3<
+:$-4,$w >> test.out
+:qa!
+ENDTEST
+
+abcdefghijklmnopqrstuvwxyz
+abcdefghijklmnopqrstuvwxyz
+abcdefghijklmnopqrstuvwxyz
+abcdefghijklmnopqrstuvwxyz
+abcdefghijklmnopqrstuvwxyz
diff -Naur vim72.orig/src/testdir/test66.ok vim72/src/testdir/test66.ok
--- vim72.orig/src/testdir/test66.ok	1970-01-01 01:00:00.000000000 +0100
+++ vim72/src/testdir/test66.ok	2009-07-22 22:54:20.000000000 +0100
@@ -0,0 +1,10 @@
+    abcdefghijklmnopqrstuvwxyz
+abcdefghij
+    abc	    defghijklmnopqrstuvwxyz
+    abc	    defghijklmnopqrstuvwxyz
+    abc	    defghijklmnopqrstuvwxyz
+    abcdefghijklmnopqrstuvwxyz
+abcdefghij
+    abc	    defghijklmnopqrstuvwxyz
+    abc		defghijklmnopqrstuvwxyz
+    abc	    defghijklmnopqrstuvwxyz
diff -Naur vim72.orig/src/ui.c vim72/src/ui.c
--- vim72.orig/src/ui.c	2008-07-14 19:14:56.000000000 +0100
+++ vim72/src/ui.c	2009-07-22 22:54:23.000000000 +0100
@@ -320,10 +320,9 @@
  * The gui_set_shellsize() or mch_set_shellsize() function will try to set the
  * new size.  If this is not possible, it will adjust Rows and Columns.
  */
-/*ARGSUSED*/
     void
 ui_set_shellsize(mustset)
-    int		mustset;	/* set by the user */
+    int		mustset UNUSED;	/* set by the user */
 {
 #ifdef FEAT_GUI
     if (gui.in_use)
@@ -1127,10 +1126,9 @@
  * available for pasting.
  * When "both" is TRUE also copy to the '+' register.
  */
-/*ARGSUSED*/
     void
 clip_copy_modeless_selection(both)
-    int		both;
+    int		both UNUSED;
 {
     char_u	*buffer;
     char_u	*bufp;
@@ -1701,10 +1699,9 @@
     return (int)maxlen;
 }
 
-/*ARGSUSED*/
     void
 fill_input_buf(exit_on_error)
-    int	exit_on_error;
+    int	exit_on_error UNUSED;
 {
 #if defined(UNIX) || defined(OS2) || defined(VMS) || defined(MACOS_X_UNIX)
     int		len;
@@ -1820,7 +1817,7 @@
 #ifdef HAVE_DUP
 	    /* Use stderr for stdin, also works for shell commands. */
 	    close(0);
-	    dup(2);
+	    ignored = dup(2);
 #else
 	    read_cmd_fd = 2;	/* read from stderr instead of stdin */
 #endif
@@ -1992,11 +1989,10 @@
 
 static void  clip_x11_request_selection_cb __ARGS((Widget, XtPointer, Atom *, Atom *, XtPointer, long_u *, int *));
 
-/* ARGSUSED */
     static void
 clip_x11_request_selection_cb(w, success, sel_atom, type, value, length,
 			      format)
-    Widget	w;
+    Widget	w UNUSED;
     XtPointer	success;
     Atom	*sel_atom;
     Atom	*type;
@@ -2020,7 +2016,7 @@
 
     if (value == NULL || *length == 0)
     {
-	clip_free_selection(cbd);	/* ???  [what's the query?] */
+	clip_free_selection(cbd);	/* nothing received, clear register */
 	*(int *)success = FALSE;
 	return;
     }
@@ -2076,7 +2072,7 @@
 	text_prop.value = (unsigned char *)value;
 	text_prop.encoding = *type;
 	text_prop.format = *format;
-	text_prop.nitems = STRLEN(value);
+	text_prop.nitems = len;
 	status = XmbTextPropertyToTextList(X_DISPLAY, &text_prop,
 							 &text_list, &n_text);
 	if (status != Success || n_text < 1)
@@ -2108,8 +2104,8 @@
     Atom	type;
     static int	success;
     int		i;
-    int		nbytes = 0;
-    char_u	*buffer;
+    time_t	start_time;
+    int		timed_out = FALSE;
 
     for (i =
 #ifdef FEAT_MBYTE
@@ -2129,6 +2125,7 @@
 	    case 3:  type = text_atom;		break;
 	    default: type = XA_STRING;
 	}
+	success = MAYBE;
 	XtGetSelectionValue(myShell, cbd->sel_atom, type,
 	    clip_x11_request_selection_cb, (XtPointer)&success, CurrentTime);
 
@@ -2141,47 +2138,59 @@
 	 * characters, then they will appear before the one that requested the
 	 * paste!  Don't worry, we will catch up with any other events later.
 	 */
-	for (;;)
+	start_time = time(NULL);
+	while (success == MAYBE)
 	{
-	    if (XCheckTypedEvent(dpy, SelectionNotify, &event))
-		break;
-	    if (XCheckTypedEvent(dpy, SelectionRequest, &event))
-		/* We may get a SelectionRequest here and if we don't handle
-		 * it we hang.  KDE klipper does this, for example. */
+	    if (XCheckTypedEvent(dpy, SelectionNotify, &event)
+		    || XCheckTypedEvent(dpy, SelectionRequest, &event)
+		    || XCheckTypedEvent(dpy, PropertyNotify, &event))
+	    {
+		/* This is where clip_x11_request_selection_cb() should be
+		 * called.  It may actually happen a bit later, so we loop
+		 * until "success" changes.
+		 * We may get a SelectionRequest here and if we don't handle
+		 * it we hang.  KDE klipper does this, for example.
+		 * We need to handle a PropertyNotify for large selections. */
 		XtDispatchEvent(&event);
+		continue;
+	    }
+
+	    /* Time out after 2 to 3 seconds to avoid that we hang when the
+	     * other process doesn't respond.  Note that the SelectionNotify
+	     * event may still come later when the selection owner comes back
+	     * to life and the text gets inserted unexpectedly.  Don't know
+	     * why that happens or how to avoid that :-(. */
+	    if (time(NULL) > start_time + 2)
+	    {
+		timed_out = TRUE;
+		break;
+	    }
 
 	    /* Do we need this?  Probably not. */
 	    XSync(dpy, False);
 
-	    /* Bernhard Walle solved a slow paste response in an X terminal by
-	     * adding: usleep(10000); here. */
+	    /* Wait for 1 msec to avoid that we eat up all CPU time. */
+	    ui_delay(1L, TRUE);
 	}
 
-	/* this is where clip_x11_request_selection_cb() is actually called */
-	XtDispatchEvent(&event);
-
-	if (success)
+	if (success == TRUE)
 	    return;
+
+	/* don't do a retry with another type after timing out, otherwise we
+	 * hang for 15 seconds. */
+	if (timed_out)
+	    break;
     }
 
     /* Final fallback position - use the X CUT_BUFFER0 store */
-    buffer = (char_u *)XFetchBuffer(dpy, &nbytes, 0);
-    if (nbytes > 0)
-    {
-	/* Got something */
-	clip_yank_selection(MCHAR, buffer, (long)nbytes, cbd);
-	XFree((void *)buffer);
-	if (p_verbose > 0)
-	    verb_msg((char_u *)_("Used CUT_BUFFER0 instead of empty selection"));
-    }
+    yank_cut_buffer0(dpy, cbd);
 }
 
 static Boolean	clip_x11_convert_selection_cb __ARGS((Widget, Atom *, Atom *, Atom *, XtPointer *, long_u *, int *));
 
-/* ARGSUSED */
     static Boolean
 clip_x11_convert_selection_cb(w, sel_atom, target, type, value, length, format)
-    Widget	w;
+    Widget	w UNUSED;
     Atom	*sel_atom;
     Atom	*target;
     Atom	*type;
@@ -2308,10 +2317,9 @@
 
 static void  clip_x11_lose_ownership_cb __ARGS((Widget, Atom *));
 
-/* ARGSUSED */
     static void
 clip_x11_lose_ownership_cb(w, sel_atom)
-    Widget  w;
+    Widget  w UNUSED;
     Atom    *sel_atom;
 {
     if (*sel_atom == clip_plus.sel_atom)
@@ -2344,14 +2352,67 @@
  * Send the current selection to the clipboard.  Do nothing for X because we
  * will fill in the selection only when requested by another app.
  */
-/*ARGSUSED*/
     void
 clip_x11_set_selection(cbd)
-    VimClipboard *cbd;
+    VimClipboard *cbd UNUSED;
 {
 }
 #endif
 
+#if defined(FEAT_XCLIPBOARD) || defined(FEAT_GUI_X11) \
+    || defined(FEAT_GUI_GTK) || defined(PROTO)
+/*
+ * Get the contents of the X CUT_BUFFER0 and put it in "cbd".
+ */
+    void
+yank_cut_buffer0(dpy, cbd)
+    Display		*dpy;
+    VimClipboard	*cbd;
+{
+    int		nbytes = 0;
+    char_u	*buffer = (char_u *)XFetchBuffer(dpy, &nbytes, 0);
+
+    if (nbytes > 0)
+    {
+#ifdef FEAT_MBYTE
+	int  done = FALSE;
+
+	/* CUT_BUFFER0 is supposed to be always latin1.  Convert to 'enc' when
+	 * using a multi-byte encoding.  Conversion between two 8-bit
+	 * character sets usually fails and the text might actually be in
+	 * 'enc' anyway. */
+	if (has_mbyte)
+	{
+	    char_u	*conv_buf = buffer;
+	    vimconv_T	vc;
+
+	    vc.vc_type = CONV_NONE;
+	    if (convert_setup(&vc, (char_u *)"latin1", p_enc) == OK)
+	    {
+		conv_buf = string_convert(&vc, buffer, &nbytes);
+		if (conv_buf != NULL)
+		{
+		    clip_yank_selection(MCHAR, conv_buf, (long)nbytes, cbd);
+		    vim_free(conv_buf);
+		    done = TRUE;
+		}
+		convert_setup(&vc, NULL, NULL);
+	    }
+	}
+	if (!done)  /* use the text without conversion */
+#endif
+	    clip_yank_selection(MCHAR, buffer, (long)nbytes, cbd);
+	XFree((void *)buffer);
+	if (p_verbose > 0)
+	{
+	    verbose_enter();
+	    verb_msg((char_u *)_("Used CUT_BUFFER0 instead of empty selection"));
+	    verbose_leave();
+	}
+    }
+}
+#endif
+
 #if defined(FEAT_MOUSE) || defined(PROTO)
 
 /*
@@ -2898,11 +2959,10 @@
  * Find the window at screen position "*rowp" and "*colp".  The positions are
  * updated to become relative to the top-left of the window.
  */
-/*ARGSUSED*/
     win_T *
 mouse_find_win(rowp, colp)
     int		*rowp;
-    int		*colp;
+    int		*colp UNUSED;
 {
     frame_T	*fp;
 
diff -Naur vim72.orig/src/version.c vim72/src/version.c
--- vim72.orig/src/version.c	2008-08-09 15:24:52.000000000 +0100
+++ vim72/src/version.c	2009-07-22 22:54:24.000000000 +0100
@@ -677,9 +677,500 @@
 static int included_patches[] =
 {   /* Add new patch number below this line */
 /**/
+    239,
+/**/
+    238,
+/**/
+    237,
+/**/
+    236,
+/**/
+    235,
+/**/
+    234,
+/**/
+    233,
+/**/
+    232,
+/**/
+    231,
+/**/
+    230,
+/**/
+    229,
+/**/
+    228,
+/**/
+    227,
+/**/
+    226,
+/**/
+    225,
+/**/
+    224,
+/**/
+    223,
+/**/
+    222,
+/**/
+    221,
+/**/
+    220,
+/**/
+    219,
+/**/
+    218,
+/**/
+    217,
+/**/
+    216,
+/**/
+    215,
+/**/
+    214,
+/**/
+    213,
+/**/
+    212,
+/**/
+    211,
+/**/
+    210,
+/**/
+    209,
+/**/
+    208,
+/**/
+    207,
+/**/
+    206,
+/**/
+    205,
+/**/
+    204,
+/**/
+    203,
+/**/
+    202,
+/**/
+    201,
+/**/
+    200,
+/**/
+    199,
+/**/
+    198,
+/**/
+    197,
+/**/
+    196,
+/**/
+    195,
+/**/
+    194,
+/**/
+    193,
+/**/
+    192,
+/**/
+    191,
+/**/
+    190,
+/**/
+    189,
+/**/
+    188,
+/**/
+    187,
+/**/
+    186,
+/**/
+    185,
+/**/
+    184,
+/**/
+    183,
+/**/
+    182,
+/**/
+    181,
+/**/
+    180,
+/**/
+    179,
+/**/
+    178,
+/**/
+    177,
+/**/
+    176,
+/**/
+    175,
+/**/
+    174,
+/**/
+    173,
+/**/
+    172,
+/**/
+    171,
+/**/
+    170,
+/**/
+    169,
+/**/
+    168,
+/**/
+    167,
+/**/
+    166,
+/**/
+    165,
+/**/
+    164,
+/**/
+    163,
+/**/
+    162,
+/**/
+    161,
+/**/
+    160,
+/**/
+    159,
+/**/
+    158,
+/**/
+    157,
+/**/
+    156,
+/**/
+    155,
+/**/
+    154,
+/**/
+    153,
+/**/
+    152,
+/**/
+    151,
+/**/
+    150,
+/**/
+    149,
+/**/
+    148,
+/**/
+    147,
+/**/
+    146,
+/**/
+    145,
+/**/
+    144,
+/**/
+    143,
+/**/
+    142,
+/**/
+    141,
+/**/
+    140,
+/**/
+    139,
+/**/
+    138,
+/**/
+    137,
+/**/
+    136,
+/**/
+    135,
+/**/
+    134,
+/**/
+    133,
+/**/
+    132,
+/**/
+    131,
+/**/
+    130,
+/**/
+    129,
+/**/
+    128,
+/**/
+    127,
+/**/
+    126,
+/**/
+    125,
+/**/
+    124,
+/**/
+    123,
+/**/
+    122,
+/**/
+    121,
+/**/
+    120,
+/**/
+    119,
+/**/
+    118,
+/**/
+    117,
+/**/
+    116,
+/**/
+    115,
+/**/
+    114,
+/**/
+    113,
+/**/
+    112,
+/**/
+    111,
+/**/
+    110,
+/**/
+    109,
+/**/
+    108,
+/**/
+    107,
+/**/
+    106,
+/**/
+    105,
+/**/
+    104,
+/**/
+    103,
+/**/
+    102,
+/**/
+    101,
+/**/
+    100,
+/**/
+    99,
+/**/
+    98,
+/**/
+    97,
+/**/
+    96,
+/**/
+    95,
+/**/
+    94,
+/**/
+    93,
+/**/
+    92,
+/**/
+    91,
+/**/
+    90,
+/**/
+    89,
+/**/
+    88,
+/**/
+    87,
+/**/
+    86,
+/**/
+    85,
+/**/
+    84,
+/**/
+    83,
+/**/
+    82,
+/**/
+    81,
+/**/
+    80,
+/**/
+    79,
+/**/
+    78,
+/**/
+    77,
+/**/
+    76,
+/**/
+    75,
+/**/
+    74,
+/**/
+    73,
+/**/
+    72,
+/**/
+    71,
+/**/
+    70,
+/**/
+    69,
+/**/
+    68,
+/**/
+    67,
+/**/
+    66,
+/**/
+    65,
+/**/
+    64,
+/**/
+    63,
+/**/
+    62,
+/**/
+    61,
+/**/
+    60,
+/**/
+    59,
+/**/
+    58,
+/**/
+    57,
+/**/
+    56,
+/**/
+    55,
+/**/
+    54,
+/**/
+    53,
+/**/
+    52,
+/**/
+    51,
+/**/
+    50,
+/**/
+    49,
+/**/
+    48,
+/**/
+    47,
+/**/
+    46,
+/**/
+    45,
+/**/
+    44,
+/**/
+    43,
+/**/
+    42,
+/**/
+    41,
+/**/
+    40,
+/**/
+    39,
+/**/
+    38,
+/**/
+    37,
+/**/
+    36,
+/**/
+    35,
+/**/
+    34,
+/**/
+    33,
+/**/
+    32,
+/**/
+    31,
+/**/
+    30,
+/**/
+    29,
+/**/
+    28,
+/**/
+    27,
+/**/
+    26,
+/**/
+    25,
+/**/
+    24,
+/**/
+    23,
+/**/
+    22,
+/**/
+    21,
+/**/
+    20,
+/**/
+    19,
+/**/
+    18,
+/**/
+    17,
+/**/
+    16,
+/**/
+    15,
+/**/
+    14,
+/**/
+    13,
+/**/
+    12,
+/**/
+    11,
+/**/
+    10,
+/**/
+    9,
+/**/
+    8,
+/**/
+    7,
+/**/
+    6,
+/**/
+    5,
+/**/
+    4,
+/**/
+    3,
+/**/
+    2,
+/**/
+    1,
+/**/
     0
 };
 
+/*
+ * Place to put a short description when adding a feature with a patch.
+ * Keep it short, e.g.,: "relative numbers", "persistent undo".
+ * Also add a comment marker to separate the lines.
+ * See the official Vim patches for the diff format: It must use a context of
+ * one line only.  Create it by hand or use "diff -C2" and edit the patch.
+ */
+static char *(extra_patches[]) =
+{   /* Add your patch description below this line */
+/**/
+    NULL
+};
+
     int
 highest_patch()
 {
@@ -786,7 +1277,7 @@
     MSG_PUTS(_("\nRISC OS version"));
 #endif
 #ifdef VMS
-    MSG_PUTS("\nOpenVMS version");
+    MSG_PUTS(_("\nOpenVMS version"));
 # ifdef HAVE_PATHDEF
     if (*compiled_arch != NUL)
     {
@@ -825,6 +1316,19 @@
 	}
     }
 
+    /* Print the list of extra patch descriptions if there is at least one. */
+    if (extra_patches[0] != NULL)
+    {
+	MSG_PUTS(_("\nExtra patches: "));
+	s = "";
+	for (i = 0; extra_patches[i] != NULL; ++i)
+	{
+	    MSG_PUTS(s);
+	    s = ", ";
+	    MSG_PUTS(extra_patches[i]);
+	}
+    }
+
 #ifdef MODIFIED_BY
     MSG_PUTS("\n");
     MSG_PUTS(_("Modified by "));
@@ -1253,10 +1757,9 @@
 /*
  * ":intro": clear screen, display intro screen and wait for return.
  */
-/*ARGSUSED*/
     void
 ex_intro(eap)
-    exarg_T	*eap;
+    exarg_T	*eap UNUSED;
 {
     screenclear();
     intro_message(TRUE);
diff -Naur vim72.orig/src/vim.h vim72/src/vim.h
--- vim72.orig/src/vim.h	2008-08-09 17:03:38.000000000 +0100
+++ vim72/src/vim.h	2009-07-22 22:54:22.000000000 +0100
@@ -262,6 +262,14 @@
 # define __PARMS(x) __ARGS(x)
 #endif
 
+/* Mark unused function arguments with UNUSED, so that gcc -Wunused-parameter
+ * can be used to check for mistakes. */
+#ifdef HAVE_ATTRIBUTE_UNUSED
+# define UNUSED __attribute__((unused))
+#else
+# define UNUSED
+#endif
+
 /* if we're compiling in C++ (currently only KVim), the system
  * headers must have the correct prototypes or nothing will build.
  * conversely, our prototypes might clash due to throw() specifiers and
@@ -341,8 +349,14 @@
 #ifdef BACKSLASH_IN_FILENAME
 # define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`%#'\"|!<")
 #else
-# define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<")
-# define SHELL_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<>();&")
+# ifdef VMS
+    /* VMS allows a lot of characters in the file name */
+#  define PATH_ESC_CHARS ((char_u *)" \t\n*?{`\\%#'\"|!")
+#  define SHELL_ESC_CHARS ((char_u *)" \t\n*?{`\\%#'|!()&")
+# else
+#  define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<")
+#  define SHELL_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<>();&")
+# endif
 #endif
 
 #define NUMBUFLEN 30	    /* length of a buffer to store a number in ASCII */
@@ -370,7 +384,7 @@
    * Define __w64 as an empty token for everything but MSVC 7.x or later.
    */
 # if !defined(_MSC_VER)	|| (_MSC_VER < 1300)
-#  define __w64 
+#  define __w64
 # endif
 typedef unsigned long __w64	long_u;
 typedef		 long __w64     long_i;
@@ -702,6 +716,8 @@
 #define EXPAND_USER_DEFINED	30
 #define EXPAND_USER_LIST	31
 #define EXPAND_SHELLCMD		32
+#define EXPAND_CSCOPE		33
+#define EXPAND_SIGN		34
 
 /* Values for exmode_active (0 is no exmode) */
 #define EXMODE_NORMAL		1
@@ -1051,6 +1067,7 @@
 #define WSP_HELP	16	/* creating the help window */
 #define WSP_BELOW	32	/* put new window below/right */
 #define WSP_ABOVE	64	/* put new window above/left */
+#define WSP_NEWLOC	128	/* don't copy location list */
 
 /*
  * arguments for gui_set_shellsize()
@@ -1328,11 +1345,11 @@
 # define MSG_BUF_CLEN  MSG_BUF_LEN	    /* cell length */
 #endif
 
-#if defined(AMIGA) || defined(__linux__) || defined(__QNX__) || defined(__CYGWIN32__) || defined(_AIX)
-# define TBUFSZ 2048		/* buffer size for termcap entry */
-#else
-# define TBUFSZ 1024		/* buffer size for termcap entry */
-#endif
+/* Size of the buffer used for tgetent().  Unfortunately this is largely
+ * undocumented, some systems use 1024.  Using a buffer that is too small
+ * causes a buffer overrun and a crash.  Use the maximum known value to stay
+ * on the safe side. */
+#define TBUFSZ 2048		/* buffer size for termcap entry */
 
 /*
  * Maximum length of key sequence to be mapped.
@@ -1451,8 +1468,8 @@
 # define PERROR(msg)		    perror(msg)
 #endif
 
-typedef long	    linenr_T;		/* line number type */
-typedef unsigned    colnr_T;		/* column number type */
+typedef long	linenr_T;		/* line number type */
+typedef int	colnr_T;		/* column number type */
 typedef unsigned short disptick_T;	/* display tick type */
 
 #define MAXLNUM (0x7fffffffL)		/* maximum (invalid) line number */
@@ -1728,7 +1745,8 @@
 #define VV_MOUSE_COL	51
 #define VV_OP		52
 #define VV_SEARCHFORWARD 53
-#define VV_LEN		54	/* number of v: vars */
+#define VV_OLDFILES	54
+#define VV_LEN		55	/* number of v: vars */
 
 #ifdef FEAT_CLIPBOARD
 
@@ -1979,6 +1997,9 @@
 # endif
 #endif
 
+#ifndef FEAT_NETBEANS_INTG
+# undef NBDEBUG
+#endif
 #ifdef NBDEBUG /* Netbeans debugging. */
 # include "nbdebug.h"
 #else
@@ -2054,4 +2075,10 @@
 #define DOSO_VIMRC	1	/* loading vimrc file */
 #define DOSO_GVIMRC	2	/* loading gvimrc file */
 
+/* flags for read_viminfo() and children */
+#define VIF_WANT_INFO		1	/* load non-mark info */
+#define VIF_WANT_MARKS		2	/* load file marks */
+#define VIF_FORCEIT		4	/* overwrite info already read */
+#define VIF_GET_OLDFILES	8	/* load v:oldfiles */
+
 #endif /* VIM__H */
diff -Naur vim72.orig/src/window.c vim72/src/window.c
--- vim72.orig/src/window.c	2008-08-06 12:00:30.000000000 +0100
+++ vim72/src/window.c	2009-07-22 22:54:23.000000000 +0100
@@ -11,8 +11,8 @@
 
 static int path_is_url __ARGS((char_u *p));
 #if defined(FEAT_WINDOWS) || defined(PROTO)
-static int win_split_ins __ARGS((int size, int flags, win_T *newwin, int dir));
-static void win_init __ARGS((win_T *newp, win_T *oldp));
+static void win_init __ARGS((win_T *newp, win_T *oldp, int flags));
+static void win_init_some __ARGS((win_T *newp, win_T *oldp));
 static void frame_comp_pos __ARGS((frame_T *topfrp, int *row, int *col));
 static void frame_setheight __ARGS((frame_T *curfrp, int height));
 #ifdef FEAT_VERTSPLIT
@@ -23,8 +23,8 @@
 static void win_totop __ARGS((int size, int flags));
 static void win_equal_rec __ARGS((win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height));
 static int last_window __ARGS((void));
+static int one_window __ARGS((void));
 static win_T *win_free_mem __ARGS((win_T *win, int *dirp, tabpage_T *tp));
-static win_T *winframe_remove __ARGS((win_T *win, int *dirp, tabpage_T *tp));
 static frame_T *win_altframe __ARGS((win_T *win, tabpage_T *tp));
 static tabpage_T *alt_tabpage __ARGS((void));
 static win_T *frame2win __ARGS((frame_T *frp));
@@ -41,6 +41,7 @@
 #endif
 #endif
 static int win_alloc_firstwin __ARGS((win_T *oldwin));
+static void new_frame __ARGS((win_T *wp));
 #if defined(FEAT_WINDOWS) || defined(PROTO)
 static tabpage_T *alloc_tabpage __ARGS((void));
 static int leave_tabpage __ARGS((buf_T *new_curbuf));
@@ -49,8 +50,6 @@
 static int frame_minheight __ARGS((frame_T *topfrp, win_T *next_curwin));
 static void win_enter_ext __ARGS((win_T *wp, int undo_sync, int no_curwin));
 static void win_free __ARGS((win_T *wp, tabpage_T *tp));
-static void win_append __ARGS((win_T *, win_T *));
-static void win_remove __ARGS((win_T *, tabpage_T *tp));
 static void frame_append __ARGS((frame_T *after, frame_T *frp));
 static void frame_insert __ARGS((frame_T *before, frame_T *frp));
 static void frame_remove __ARGS((frame_T *frp));
@@ -62,17 +61,15 @@
 static void frame_add_height __ARGS((frame_T *frp, int n));
 static void last_status_rec __ARGS((frame_T *fr, int statusline));
 
-static void make_snapshot __ARGS((void));
 static void make_snapshot_rec __ARGS((frame_T *fr, frame_T **frp));
-static void clear_snapshot __ARGS((tabpage_T *tp));
+static void clear_snapshot __ARGS((tabpage_T *tp, int idx));
 static void clear_snapshot_rec __ARGS((frame_T *fr));
-static void restore_snapshot __ARGS((int close_curwin));
 static int check_snapshot_rec __ARGS((frame_T *sn, frame_T *fr));
 static win_T *restore_snapshot_rec __ARGS((frame_T *sn, frame_T *fr));
 
 #endif /* FEAT_WINDOWS */
 
-static win_T *win_alloc __ARGS((win_T *after));
+static win_T *win_alloc __ARGS((win_T *after, int hidden));
 static void win_new_height __ARGS((win_T *, int));
 
 #define URL_SLASH	1		/* path_is_url() has found "://" */
@@ -259,7 +256,7 @@
 /* cursor to previous window with wrap around */
     case 'W':
 		CHECK_CMDWIN
-		if (lastwin == firstwin && Prenum != 1)	/* just one window */
+		if (firstwin == lastwin && Prenum != 1)	/* just one window */
 		    beep_flush();
 		else
 		{
@@ -343,7 +340,7 @@
 
 /* move window to new tab page */
     case 'T':
-		if (firstwin == lastwin)
+		if (one_window())
 		    MSG(_(m_onlyone));
 		else
 		{
@@ -531,7 +528,8 @@
 # ifdef FEAT_SCROLLBIND
 			curwin->w_p_scb = FALSE;
 # endif
-			(void)do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL, ECMD_HIDE);
+			(void)do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,
+							   ECMD_HIDE, NULL);
 			if (nchar == 'F' && lnum >= 0)
 			{
 			    curwin->w_cursor.lnum = lnum;
@@ -593,9 +591,7 @@
 		++allow_keys;   /* no mapping for xchar, but allow key codes */
 		if (xchar == NUL)
 		    xchar = plain_vgetc();
-#ifdef FEAT_LANGMAP
 		LANGMAP_ADJUST(xchar, TRUE);
-#endif
 		--no_mapping;
 		--allow_keys;
 #ifdef FEAT_CMDL_INFO
@@ -680,9 +676,9 @@
     /* When creating the help window make a snapshot of the window layout.
      * Otherwise clear the snapshot, it's now invalid. */
     if (flags & WSP_HELP)
-	make_snapshot();
+	make_snapshot(SNAP_HELP_IDX);
     else
-	clear_snapshot(curtab);
+	clear_snapshot(curtab, SNAP_HELP_IDX);
 
     return win_split_ins(size, flags, NULL, 0);
 }
@@ -693,7 +689,7 @@
  * top/left/right/bottom.
  * return FAIL for failure, OK otherwise
  */
-    static int
+    int
 win_split_ins(size, flags, newwin, dir)
     int		size;
     int		flags;
@@ -894,14 +890,14 @@
     {
 	/* new window below/right of current one */
 	if (newwin == NULL)
-	    wp = win_alloc(oldwin);
+	    wp = win_alloc(oldwin, FALSE);
 	else
 	    win_append(oldwin, wp);
     }
     else
     {
 	if (newwin == NULL)
-	    wp = win_alloc(oldwin->w_prev);
+	    wp = win_alloc(oldwin->w_prev, FALSE);
 	else
 	    win_append(oldwin->w_prev, wp);
     }
@@ -911,8 +907,15 @@
 	if (wp == NULL)
 	    return FAIL;
 
+	new_frame(wp);
+	if (wp->w_frame == NULL)
+	{
+	    win_free(wp, NULL);
+	    return FAIL;
+	}
+
 	/* make the contents of the new window the same as the current one */
-	win_init(wp, curwin);
+	win_init(wp, curwin, flags);
     }
 
     /*
@@ -971,13 +974,7 @@
     }
 
     if (newwin == NULL)
-    {
-	/* Create a frame for the new window. */
-	frp = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
-	frp->fr_layout = FR_LEAF;
-	frp->fr_win = wp;
-	wp->w_frame = frp;
-    }
+	frp = wp->w_frame;
     else
 	frp = newwin->w_frame;
     frp->fr_parent = curfrp->fr_parent;
@@ -1157,15 +1154,19 @@
     return OK;
 }
 
+
 /*
  * Initialize window "newp" from window "oldp".
  * Used when splitting a window and when creating a new tab page.
  * The windows will both edit the same buffer.
+ * WSP_NEWLOC may be specified in flags to prevent the location list from
+ * being copied.
  */
     static void
-win_init(newp, oldp)
+win_init(newp, oldp, flags)
     win_T	*newp;
     win_T	*oldp;
+    int		 flags UNUSED;
 {
     int		i;
 
@@ -1190,19 +1191,19 @@
     copy_jumplist(oldp, newp);
 #endif
 #ifdef FEAT_QUICKFIX
-    copy_loclist(oldp, newp);
+    if (flags & WSP_NEWLOC)
+    {
+	/* Don't copy the location list.  */
+	newp->w_llist = NULL;
+	newp->w_llist_ref = NULL;
+    }
+    else
+	copy_loclist(oldp, newp);
 #endif
     if (oldp->w_localdir != NULL)
 	newp->w_localdir = vim_strsave(oldp->w_localdir);
 
-    /* Use the same argument list. */
-    newp->w_alist = oldp->w_alist;
-    ++newp->w_alist->al_refcount;
-    newp->w_arg_idx = oldp->w_arg_idx;
-
-    /*
-     * copy tagstack and options from existing window
-     */
+    /* copy tagstack and folds */
     for (i = 0; i < oldp->w_tagstacklen; i++)
     {
 	newp->w_tagstack[i] = oldp->w_tagstack[i];
@@ -1212,10 +1213,29 @@
     }
     newp->w_tagstackidx = oldp->w_tagstackidx;
     newp->w_tagstacklen = oldp->w_tagstacklen;
-    win_copy_options(oldp, newp);
 # ifdef FEAT_FOLDING
     copyFoldingState(oldp, newp);
 # endif
+
+    win_init_some(newp, oldp);
+}
+
+/*
+ * Initialize window "newp" from window"old".
+ * Only the essential things are copied.
+ */
+    static void
+win_init_some(newp, oldp)
+    win_T	*newp;
+    win_T	*oldp;
+{
+    /* Use the same argument list. */
+    newp->w_alist = oldp->w_alist;
+    ++newp->w_alist->al_refcount;
+    newp->w_arg_idx = oldp->w_arg_idx;
+
+    /* copy options from existing window */
+    win_copy_options(oldp, newp);
 }
 
 #endif /* FEAT_WINDOWS */
@@ -1258,11 +1278,10 @@
  * Must be called when there is just one window, filling the whole screen
  * (excluding the command line).
  */
-/*ARGSUSED*/
     int
 make_windows(count, vertical)
     int		count;
-    int		vertical;	/* split windows vertically if TRUE */
+    int		vertical UNUSED;  /* split windows vertically if TRUE */
 {
     int		maxcount;
     int		todo;
@@ -1557,15 +1576,8 @@
 #if defined(FEAT_GUI) && defined(FEAT_VERTSPLIT)
     /* When 'guioptions' includes 'L' or 'R' may have to remove or add
      * scrollbars.  Have to update them anyway. */
-    if (gui.in_use)
-    {
-	out_flush();
-	gui_init_which_components(NULL);
-	gui_update_scrollbars(TRUE);
-    }
-    need_mouse_correct = TRUE;
+    gui_may_update_scrollbars();
 #endif
-
 }
 
 /*
@@ -2040,13 +2052,40 @@
 }
 
 /*
- * Return TRUE if the current window is the only window that exists.
+ * Return TRUE if the current window is the only window that exists (ignoring
+ * "aucmd_win").
  * Returns FALSE if there is a window, possibly in another tab page.
  */
     static int
 last_window()
 {
-    return (lastwin == firstwin && first_tabpage->tp_next == NULL);
+    return (one_window() && first_tabpage->tp_next == NULL);
+}
+
+/*
+ * Return TRUE if there is only one window other than "aucmd_win" in the
+ * current tab page.
+ */
+    static int
+one_window()
+{
+#ifdef FEAT_AUTOCMD
+    win_T	*wp;
+    int		seen_one = FALSE;
+
+    FOR_ALL_WINDOWS(wp)
+    {
+	if (wp != aucmd_win)
+	{
+	    if (seen_one)
+		return FALSE;
+	    seen_one = TRUE;
+	}
+    }
+    return TRUE;
+#else
+    return firstwin == lastwin;
+#endif
 }
 
 /*
@@ -2075,6 +2114,19 @@
 	return;
     }
 
+#ifdef FEAT_AUTOCMD
+    if (win == aucmd_win)
+    {
+	EMSG(_("E813: Cannot close autocmd window"));
+	return;
+    }
+    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())
+    {
+	EMSG(_("E814: Cannot close window, only autocmd window would remain"));
+	return;
+    }
+#endif
+
     /*
      * When closing the last window in a tab page first go to another tab
      * page and then close the window and the tab page.  This avoids that
@@ -2104,7 +2156,7 @@
     if (win->w_buffer->b_help)
 	help_window = TRUE;
     else
-	clear_snapshot(curtab);
+	clear_snapshot(curtab, SNAP_HELP_IDX);
 
 #ifdef FEAT_AUTOCMD
     if (win == curwin)
@@ -2221,7 +2273,7 @@
     /* After closing the help window, try restoring the window layout from
      * before it was opened. */
     if (help_window)
-	restore_snapshot(close_curwin);
+	restore_snapshot(SNAP_HELP_IDX, close_curwin);
 
 #if defined(FEAT_GUI) && defined(FEAT_VERTSPLIT)
     /* When 'guioptions' includes 'L' or 'R' may have to remove scrollbars. */
@@ -2302,13 +2354,6 @@
     frame_T	*frp;
     win_T	*wp;
 
-#ifdef FEAT_FOLDING
-    clearFolding(win);
-#endif
-
-    /* reduce the reference count to the argument list. */
-    alist_unlink(win->w_alist);
-
     /* Remove the window and its frame from the tree of frames. */
     frp = win->w_frame;
     wp = winframe_remove(win, dirp, tp);
@@ -2334,6 +2379,14 @@
 	tabpage_close(TRUE);
 # endif
 
+# ifdef FEAT_AUTOCMD
+    if (aucmd_win != NULL)
+    {
+	(void)win_free_mem(aucmd_win, &dummy, NULL);
+	aucmd_win = NULL;
+    }
+# endif
+
     while (firstwin != NULL)
 	(void)win_free_mem(firstwin, &dummy, NULL);
 }
@@ -2343,11 +2396,10 @@
  * Remove a window and its frame from the tree of frames.
  * Returns a pointer to the window that got the freed up space.
  */
-/*ARGSUSED*/
-    static win_T *
+    win_T *
 winframe_remove(win, dirp, tp)
     win_T	*win;
-    int		*dirp;		/* set to 'v' or 'h' for direction if 'ea' */
+    int		*dirp UNUSED;	/* set to 'v' or 'h' for direction if 'ea' */
     tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
 {
     frame_T	*frp, *frp2, *frp3;
@@ -3083,7 +3135,7 @@
     win_T	*nextwp;
     int		r;
 
-    if (lastwin == firstwin)
+    if (one_window())
     {
 	if (message
 #ifdef FEAT_AUTOCMD
@@ -3145,27 +3197,34 @@
     void
 curwin_init()
 {
-    redraw_win_later(curwin, NOT_VALID);
-    curwin->w_lines_valid = 0;
-    curwin->w_cursor.lnum = 1;
-    curwin->w_curswant = curwin->w_cursor.col = 0;
+    win_init_empty(curwin);
+}
+
+    void
+win_init_empty(wp)
+    win_T *wp;
+{
+    redraw_win_later(wp, NOT_VALID);
+    wp->w_lines_valid = 0;
+    wp->w_cursor.lnum = 1;
+    wp->w_curswant = wp->w_cursor.col = 0;
 #ifdef FEAT_VIRTUALEDIT
-    curwin->w_cursor.coladd = 0;
+    wp->w_cursor.coladd = 0;
 #endif
-    curwin->w_pcmark.lnum = 1;	/* pcmark not cleared but set to line 1 */
-    curwin->w_pcmark.col = 0;
-    curwin->w_prev_pcmark.lnum = 0;
-    curwin->w_prev_pcmark.col = 0;
-    curwin->w_topline = 1;
+    wp->w_pcmark.lnum = 1;	/* pcmark not cleared but set to line 1 */
+    wp->w_pcmark.col = 0;
+    wp->w_prev_pcmark.lnum = 0;
+    wp->w_prev_pcmark.col = 0;
+    wp->w_topline = 1;
 #ifdef FEAT_DIFF
-    curwin->w_topfill = 0;
+    wp->w_topfill = 0;
 #endif
-    curwin->w_botline = 2;
+    wp->w_botline = 2;
 #ifdef FEAT_FKMAP
-    if (curwin->w_p_rl)
-	curwin->w_farsi = W_CONV + W_R_L;
+    if (wp->w_p_rl)
+	wp->w_farsi = W_CONV + W_R_L;
     else
-	curwin->w_farsi = W_CONV;
+	wp->w_farsi = W_CONV;
 #endif
 }
 
@@ -3187,9 +3246,30 @@
     first_tabpage->tp_topframe = topframe;
     curtab = first_tabpage;
 #endif
+
     return OK;
 }
 
+#if defined(FEAT_AUTOCMD) || defined(PROTO)
+/*
+ * Init "aucmd_win".  This can only be done after the first
+ * window is fully initialized, thus it can't be in win_alloc_first().
+ */
+    void
+win_alloc_aucmd_win()
+{
+    aucmd_win = win_alloc(NULL, TRUE);
+    if (aucmd_win != NULL)
+    {
+	win_init_some(aucmd_win, curwin);
+# ifdef FEAT_SCROLLBIND
+	aucmd_win->w_p_scb = FALSE;
+# endif
+	new_frame(aucmd_win);
+    }
+}
+#endif
+
 /*
  * Allocate the first window or the first window in a new tab page.
  * When "oldwin" is NULL create an empty buffer for it.
@@ -3201,7 +3281,7 @@
 win_alloc_firstwin(oldwin)
     win_T	*oldwin;
 {
-    curwin = win_alloc(NULL);
+    curwin = win_alloc(NULL, FALSE);
     if (oldwin == NULL)
     {
 	/* Very first window, need to create an empty buffer for it and
@@ -3220,7 +3300,7 @@
     else
     {
 	/* First window in new tab page, initialize it from "oldwin". */
-	win_init(curwin, oldwin);
+	win_init(curwin, oldwin, 0);
 
 # ifdef FEAT_SCROLLBIND
 	/* We don't want scroll-binding in the first window. */
@@ -3229,21 +3309,36 @@
     }
 #endif
 
-    topframe = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
-    if (topframe == NULL)
+    new_frame(curwin);
+    if (curwin->w_frame == NULL)
 	return FAIL;
-    topframe->fr_layout = FR_LEAF;
+    topframe = curwin->w_frame;
 #ifdef FEAT_VERTSPLIT
     topframe->fr_width = Columns;
 #endif
     topframe->fr_height = Rows - p_ch;
     topframe->fr_win = curwin;
-    curwin->w_frame = topframe;
 
     return OK;
 }
 
 /*
+ * Create a frame for window "wp".
+ */
+    static void
+new_frame(win_T *wp)
+{
+    frame_T *frp = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
+
+    wp->w_frame = frp;
+    if (frp != NULL)
+    {
+	frp->fr_layout = FR_LEAF;
+	frp->fr_win = wp;
+    }
+}
+
+/*
  * Initialize the window and frame size to the maximum.
  */
     void
@@ -3293,10 +3388,13 @@
 free_tabpage(tp)
     tabpage_T	*tp;
 {
+    int idx;
+
 # ifdef FEAT_DIFF
     diff_clear(tp);
 # endif
-    clear_snapshot(tp);
+    for (idx = 0; idx < SNAP_COUNT; ++idx)
+	clear_snapshot(tp, idx);
 #ifdef FEAT_EVAL
     vars_clear(&tp->tp_vars.dv_hashtab);	/* free all t: variables */
 #endif
@@ -3363,12 +3461,7 @@
 #if defined(FEAT_GUI)
 	/* When 'guioptions' includes 'L' or 'R' may have to remove or add
 	 * scrollbars.  Have to update them anyway. */
-	if (gui.in_use && starting == 0)
-	{
-	    gui_init_which_components(NULL);
-	    gui_update_scrollbars(TRUE);
-	}
-	need_mouse_correct = TRUE;
+	gui_may_update_scrollbars();
 #endif
 
 	redraw_all_later(CLEAR);
@@ -3490,10 +3583,9 @@
  * FAIL.
  * Careful: When OK is returned need to get a new tab page very very soon!
  */
-/*ARGSUSED*/
     static int
 leave_tabpage(new_curbuf)
-    buf_T	*new_curbuf;	    /* what is going to be the new curbuf,
+    buf_T	*new_curbuf UNUSED;    /* what is going to be the new curbuf,
 				       NULL if unknown */
 {
     tabpage_T	*tp = curtab;
@@ -3535,11 +3627,10 @@
  * Start using tab page "tp".
  * Only to be used after leave_tabpage() or freeing the current tab page.
  */
-/*ARGSUSED*/
     static void
 enter_tabpage(tp, old_curbuf)
     tabpage_T	*tp;
-    buf_T	*old_curbuf;
+    buf_T	*old_curbuf UNUSED;
 {
     int		old_off = tp->tp_firstwin->w_winrow;
     win_T	*next_prevwin = tp->tp_prevwin;
@@ -3588,12 +3679,7 @@
 #if defined(FEAT_GUI)
     /* When 'guioptions' includes 'L' or 'R' may have to remove or add
      * scrollbars.  Have to update them anyway. */
-    if (gui.in_use && starting == 0)
-    {
-	gui_init_which_components(NULL);
-	gui_update_scrollbars(TRUE);
-    }
-    need_mouse_correct = TRUE;
+    gui_may_update_scrollbars();
 #endif
 
     redraw_all_later(CLEAR);
@@ -4028,14 +4114,14 @@
 	    if (mch_dirname(cwd, MAXPATHL) == OK)
 		globaldir = vim_strsave(cwd);
 	}
-	mch_chdir((char *)curwin->w_localdir);
-	shorten_fnames(TRUE);
+	if (mch_chdir((char *)curwin->w_localdir) == 0)
+	    shorten_fnames(TRUE);
     }
     else if (globaldir != NULL)
     {
 	/* Window doesn't have a local directory and we are not in the global
 	 * directory: Change to the global directory. */
-	mch_chdir((char *)globaldir);
+	ignored = mch_chdir((char *)globaldir);
 	vim_free(globaldir);
 	globaldir = NULL;
 	shorten_fnames(TRUE);
@@ -4145,12 +4231,13 @@
 #endif
 
 /*
- * allocate a window structure and link it in the window list
+ * Allocate a window structure and link it in the window list when "hidden" is
+ * FALSE.
  */
-/*ARGSUSED*/
     static win_T *
-win_alloc(after)
-    win_T	*after;
+win_alloc(after, hidden)
+    win_T	*after UNUSED;
+    int		hidden UNUSED;
 {
     win_T	*newwin;
 
@@ -4176,7 +4263,8 @@
 	 * link the window in the window list
 	 */
 #ifdef FEAT_WINDOWS
-	win_append(after, newwin);
+	if (!hidden)
+	    win_append(after, newwin);
 #endif
 #ifdef FEAT_VERTSPLIT
 	newwin->w_wincol = 0;
@@ -4237,6 +4325,13 @@
 {
     int		i;
 
+#ifdef FEAT_FOLDING
+    clearFolding(wp);
+#endif
+
+    /* reduce the reference count to the argument list. */
+    alist_unlink(wp->w_alist);
+
 #ifdef FEAT_AUTOCMD
     /* Don't execute autocommands while the window is halfway being deleted.
      * gui_mch_destroy_scrollbar() may trigger a FocusGained event. */
@@ -4299,7 +4394,10 @@
     }
 #endif /* FEAT_GUI */
 
-    win_remove(wp, tp);
+#ifdef FEAT_AUTOCMD
+    if (wp != aucmd_win)
+#endif
+	win_remove(wp, tp);
     vim_free(wp);
 
 #ifdef FEAT_AUTOCMD
@@ -4310,7 +4408,7 @@
 /*
  * Append window "wp" in the window list after window "after".
  */
-    static void
+    void
 win_append(after, wp)
     win_T	*after, *wp;
 {
@@ -4336,7 +4434,7 @@
 /*
  * Remove a window from the window list.
  */
-    static void
+    void
 win_remove(wp, tp)
     win_T	*wp;
     tabpage_T	*tp;		/* tab page "win" is in, NULL for current */
@@ -6036,6 +6134,7 @@
 /*
  * Return TRUE if there is only one window (in the current tab page), not
  * counting a help or preview window, unless it is the current window.
+ * Does not count "aucmd_win".
  */
     int
 only_one_window()
@@ -6049,11 +6148,15 @@
 	return FALSE;
 
     for (wp = firstwin; wp != NULL; wp = wp->w_next)
-	if (!((wp->w_buffer->b_help && !curbuf->b_help)
+	if ((!((wp->w_buffer->b_help && !curbuf->b_help)
 # ifdef FEAT_QUICKFIX
 		    || wp->w_p_pvw
 # endif
 	     ) || wp == curwin)
+# ifdef FEAT_AUTOCMD
+		&& wp != aucmd_win
+# endif
+	   )
 	    ++count;
     return (count <= 1);
 #else
@@ -6108,11 +6211,12 @@
 /*
  * Create a snapshot of the current frame sizes.
  */
-    static void
-make_snapshot()
+    void
+make_snapshot(idx)
+    int idx;
 {
-    clear_snapshot(curtab);
-    make_snapshot_rec(topframe, &curtab->tp_snapshot);
+    clear_snapshot(curtab, idx);
+    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);
 }
 
     static void
@@ -6140,11 +6244,12 @@
  * Remove any existing snapshot.
  */
     static void
-clear_snapshot(tp)
+clear_snapshot(tp, idx)
     tabpage_T	*tp;
+    int		idx;
 {
-    clear_snapshot_rec(tp->tp_snapshot);
-    tp->tp_snapshot = NULL;
+    clear_snapshot_rec(tp->tp_snapshot[idx]);
+    tp->tp_snapshot[idx] = NULL;
 }
 
     static void
@@ -6164,26 +6269,27 @@
  * This is only done if the screen size didn't change and the window layout is
  * still the same.
  */
-    static void
-restore_snapshot(close_curwin)
+    void
+restore_snapshot(idx, close_curwin)
+    int		idx;
     int		close_curwin;	    /* closing current window */
 {
     win_T	*wp;
 
-    if (curtab->tp_snapshot != NULL
+    if (curtab->tp_snapshot[idx] != NULL
 # ifdef FEAT_VERTSPLIT
-	    && curtab->tp_snapshot->fr_width == topframe->fr_width
+	    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width
 # endif
-	    && curtab->tp_snapshot->fr_height == topframe->fr_height
-	    && check_snapshot_rec(curtab->tp_snapshot, topframe) == OK)
+	    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height
+	    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)
     {
-	wp = restore_snapshot_rec(curtab->tp_snapshot, topframe);
+	wp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);
 	win_comp_pos();
 	if (wp != NULL && close_curwin)
 	    win_goto(wp);
 	redraw_all_later(CLEAR);
     }
-    clear_snapshot(curtab);
+    clear_snapshot(curtab, idx);
 }
 
 /*
diff -Naur vim72.orig/src/workshop.c vim72/src/workshop.c
--- vim72.orig/src/workshop.c	2008-06-21 19:53:26.000000000 +0100
+++ vim72/src/workshop.c	2009-07-22 22:54:22.000000000 +0100
@@ -204,12 +204,11 @@
  * Function:
  *	Load a given file into the WorkShop buffer.
  */
-/*ARGSUSED*/
     void
 workshop_load_file(
 	char	*filename,		/* the file to load */
 	int	 line,			/* an optional line number (or 0) */
-	char	*frameid)		/* used for multi-frame support */
+	char	*frameid UNUSED)	/* used for multi-frame support */
 {
 #ifdef WSDEBUG_TRACE
     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
@@ -263,10 +262,9 @@
     load_window(filename, lineno);
 }
 
-/*ARGSUSED*/
     void
 workshop_front_file(
-	char	*filename)
+	char	*filename UNUSED)
 {
 #ifdef WSDEBUG_TRACE
     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
@@ -538,9 +536,8 @@
  * breakpoints have moved when a program has been recompiled and
  * reloaded into dbx.
  */
-/*ARGSUSED*/
     void
-workshop_moved_marks(char *filename)
+workshop_moved_marks(char *filename UNUSED)
 {
 #ifdef WSDEBUG_TRACE
     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
@@ -575,11 +572,10 @@
     return (int)h;
 }
 
-/*ARGSUSED*/
     void
 workshop_footer_message(
-	char		*message,
-	int		 severity)	/* severity is currently unused */
+	char	*message,
+	int	severity UNUSED)	/* severity is currently unused */
 {
 #ifdef WSDEBUG_TRACE
     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
@@ -687,15 +683,14 @@
  * command. The globals curMenuName and curMenuPriority contain the name and
  * priority of the parent menu tree.
  */
-/*ARGSUSED*/
     void
 workshop_menu_item(
 	char		*label,
 	char		*verb,
-	char		*accelerator,
+	char		*accelerator UNUSED,
 	char		*acceleratorText,
-	char		*name,
-	char		*filepos,
+	char		*name UNUSED,
+	char		*filepos UNUSED,
 	char		*sensitive)
 {
     char		 cbuf[BUFSIZ];
@@ -810,13 +805,12 @@
     workshopInitDone = True;
 }
 
-/*ARGSUSED*/
     void
 workshop_toolbar_button(
 	char	*label,
 	char	*verb,
-	char	*senseVerb,
-	char	*filepos,
+	char	*senseVerb UNUSED,
+	char	*filepos UNUSED,
 	char	*help,
 	char	*sense,
 	char	*file,
@@ -968,7 +962,9 @@
 	    if (strcmp(option, "syntax") == 0)
 		vim_snprintf(cbuf, sizeof(cbuf), "syntax %s", value);
 	    else if (strcmp(option, "savefiles") == 0)
-		; /* XXX - Not yet implemented */
+	    {
+		/* XXX - Not yet implemented */
+	    }
 	    break;
 
 	case 'l':
@@ -1098,10 +1094,9 @@
 /*
  * A button in the toolbar has been pushed.
  */
-/*ARGSUSED*/
     int
 workshop_get_positions(
-	void		*clientData,	/* unused */
+	void		*clientData UNUSED,
 	char	       **filename,	/* output data */
 	int		*curLine,	/* output data */
 	int		*curCol,	/* output data */
@@ -1121,8 +1116,12 @@
 				      ? (char *)curbuf->b_sfname : "<None>");
 #endif
 
-    strcpy(ffname, (char *) curbuf->b_ffname);
-    *filename = ffname;		/* copy so nobody can change b_ffname */
+    if (curbuf->b_ffname == NULL)
+	ffname[0] = NUL;
+    else
+	/* copy so nobody can change b_ffname */
+	strcpy(ffname, (char *) curbuf->b_ffname);
+    *filename = ffname;
     *curLine = curwin->w_cursor.lnum;
     *curCol = curwin->w_cursor.col;
 
@@ -1522,9 +1521,8 @@
 	return NULL;
 }
 
-/*ARGSUSED*/
     void
-workshop_save_sensitivity(char *filename)
+workshop_save_sensitivity(char *filename UNUSED)
 {
 }
 
diff -Naur vim72.orig/src/xxd/xxd.c vim72/src/xxd/xxd.c
--- vim72.orig/src/xxd/xxd.c	2007-11-29 20:05:16.000000000 +0000
+++ vim72/src/xxd/xxd.c	2009-07-22 22:54:23.000000000 +0100
@@ -64,6 +64,9 @@
 # define _CRT_SECURE_NO_DEPRECATE
 # define _CRT_NONSTDC_NO_DEPRECATE
 #endif
+#if !defined(CYGWIN) && (defined(CYGWIN32) || defined(__CYGWIN__) || defined(__CYGWIN32__))
+# define CYGWIN
+#endif
 
 #include <stdio.h>
 #ifdef VAXC
@@ -77,7 +80,8 @@
 #if !defined(OS2) && defined(__EMX__)
 # define OS2
 #endif
-#if defined(MSDOS) || defined(WIN32) || defined(OS2) || defined(__BORLANDC__)
+#if defined(MSDOS) || defined(WIN32) || defined(OS2) || defined(__BORLANDC__) \
+  || defined(CYGWIN)
 # include <io.h>	/* for setmode() */
 #else
 # ifdef UNIX
@@ -150,9 +154,6 @@
 # endif
 #endif
 
-#if !defined(CYGWIN) && (defined(CYGWIN32) || defined(__CYGWIN__) || defined(__CYGWIN32__))
-# define CYGWIN
-#endif
 #if defined(MSDOS) || defined(WIN32) || defined(OS2)
 # define BIN_READ(yes)  ((yes) ? "rb" : "rt")
 # define BIN_WRITE(yes) ((yes) ? "wb" : "wt")
