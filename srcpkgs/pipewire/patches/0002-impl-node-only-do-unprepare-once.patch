From 24ab601201223e05950bb8133be5d77526de1997 Mon Sep 17 00:00:00 2001
From: Wim Taymans <wtaymans@redhat.com>
Date: Mon, 15 Sep 2025 10:22:16 +0200
Subject: [PATCH 2/4] impl-node: only do unprepare once

There is not reason to do the unprepare logic twice and it might
actually interfere with the actions of the client.

See #4840
Fixes #4893
---
 src/pipewire/impl-node.c | 18 +++++++++++-------
 1 file changed, 11 insertions(+), 7 deletions(-)

diff --git a/src/pipewire/impl-node.c b/src/pipewire/impl-node.c
index e5636d561..59a34475c 100644
--- a/src/pipewire/impl-node.c
+++ b/src/pipewire/impl-node.c
@@ -225,17 +225,21 @@ do_node_unprepare(struct spa_loop *loop, bool async, uint32_t seq,
 	pw_log_trace("%p: unprepare %d remote:%d exported:%d", this, this->rt.prepared,
 			this->remote, this->exported);
 
-	/* We mark ourself as finished now, this will avoid going further into the process loop
-	 * in case our fd was ready (removing ourselfs from the loop should avoid that as well).
-	 * If we were supposed to be scheduled make sure we continue the graph for the peers we
-	 * were supposed to trigger */
+	if (!this->rt.prepared)
+		return 0;
+
+	/* The remote client will INACTIVE itself and remove itself from the loop to avoid
+	 * being scheduled.
+	 * The server will mark remote nodes as FINISHED and trigger the peers. This will
+	 * make sure the remote node will not trigger the peers anymore when it will
+	 * stop (it only triggers peers when it has PENDING_TRIGGER (<= AWAKE)). We have
+	 * to trigger the peers on the server because the client might simply be dead and
+	 * not able to trigger anything.
+	 */
 	old_state = SPA_ATOMIC_XCHG(this->rt.target.activation->status, PW_NODE_ACTIVATION_INACTIVE);
 	if (PW_NODE_ACTIVATION_PENDING_TRIGGER(old_state))
 		trigger = get_time_ns(this->rt.target.system);
 
-	if (!this->rt.prepared)
-		return 0;
-
 	if (!this->remote)
 		spa_loop_remove_source(loop, &this->source);
 
-- 
2.51.0

