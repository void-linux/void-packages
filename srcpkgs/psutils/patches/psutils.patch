diff -rupN psutils/Makefile.unix psutils-new/Makefile.unix
--- psutils/Makefile.unix	1997-03-11 23:52:59.000000000 +0100
+++ psutils-new/Makefile.unix	2014-04-11 15:51:34.758134445 +0200
@@ -5,6 +5,14 @@
 #
 # updated AJCD 3/1/96
 #
+# patched by some patches from debian
+# conditional patch for libpaper by
+# Dormeletti Carlo <carlo.dormeletti[at]email.it>
+#
+# if you want compile it with libpaper support 
+# uncomment the LIBPAPER line, any value will make the test true
+# and compile it with libpaper support 
+#
 # Multiple makefiles for different OSes are generated from a single master
 # now.
 #
@@ -19,16 +27,19 @@
 # psnup puts multiple logical pages on one physical page
 # psresize scales and moves pages to fit on different paper sizes
 
+# LIBPAPER = true
+
 PAPER=a4
 
 # Makefile for PSUtils under Unix
 
 OS = UNIX
-
-BINDIR = /usr/local/bin
+prefix=/usr
+ 
+BINDIR = $(prefix)/bin
 SCRIPTDIR = $(BINDIR)
-INCLUDEDIR = /usr/local/share/psutils
-PERL = /usr/local/bin/perl
+INCLUDEDIR = $(prefix)/share/psutils
+PERL = /usr/bin/perl
 
 BINMODE = 0755
 MANMODE = 0644
@@ -36,61 +47,79 @@
 INSTALL = install -c -m $(BINMODE)
 INSTALLMAN = install -c -m $(MANMODE)
 MANEXT = 1
-MANDIR = /usr/local/share/man/man$(MANEXT)
+MANDIR = $(prefix)/share/man/man$(MANEXT)
 
 CC = gcc
-CFLAGS = -DPAPER=\"$(PAPER)\" -DUNIX -O -Wall
+CFLAGS = @CFLAGS@
+LDFLAGS = @LDFLAGS@
+
+ifdef LIBPAPER
+	CFLAGS += -DDEBIAN -DUNIX -O2 -g -Wall -Werror
+	LIBS = -lpaper
+else
+	CFLAGS += -DPAPER=\"$(PAPER)\" -DUNIX -O2 -g -Wall -Werror
+	LIBS = 
+endif
 
-BIN = psbook psselect pstops epsffit psnup \
-	psresize
-SHELLSCRIPTS = getafm showchar
-PERLSCRIPTS = fixfmps fixmacps fixpsditps fixpspps \
+
+BIN = psbook psselect pstops epsffit psnup psresize
+SHELLSCRIPTS = getafm showchar psjoin
+PERLSCRIPTS = fixfmps fixpsditps fixpspps \
 	fixtpps fixwfwps fixwpps fixscribeps fixwwps \
 	fixdlsrps extractres includeres psmerge
 MANPAGES = psbook.$(MANEXT) psselect.$(MANEXT) pstops.$(MANEXT) epsffit.$(MANEXT) psnup.$(MANEXT) \
-	psresize.$(MANEXT) psmerge.$(MANEXT) fixscribeps.$(MANEXT) getafm.$(MANEXT) \
-	fixdlsrps.$(MANEXT) fixfmps.$(MANEXT) fixmacps.$(MANEXT) fixpsditps.$(MANEXT) \
+	psresize.$(MANEXT) psmerge.$(MANEXT) psjoin.$(MANEXT) fixscribeps.$(MANEXT) getafm.$(MANEXT) \
+	fixdlsrps.$(MANEXT) fixfmps.$(MANEXT) fixpsditps.$(MANEXT) \
 	fixpspps.$(MANEXT) fixtpps.$(MANEXT) fixwfwps.$(MANEXT) fixwpps.$(MANEXT) \
-	fixwwps.$(MANEXT) extractres.$(MANEXT) includeres.$(MANEXT)
-INCLUDES = md68_0.ps md71_0.ps
+	fixwwps.$(MANEXT) extractres.$(MANEXT) includeres.$(MANEXT) \
+	showchar.$(MANEXT)
 
 all: $(BIN) $(PERLSCRIPTS) $(MANPAGES) $(SHELLSCRIPTS)
 
 psutil.o: psutil.h patchlev.h pserror.h psutil.c
+	$(CC) $(CFLAGS) -o $@ -c psutil.c
 
 psspec.o: psutil.h patchlev.h psspec.h pserror.h psspec.c
+	$(CC) $(CFLAGS) -o $@ -c psspec.c
 
 pserror.o: psutil.h patchlev.h pserror.h pserror.c
+	$(CC) $(CFLAGS) -o $@ -c pserror.c
 
 epsffit.o: epsffit.c pserror.h patchlev.h
+	$(CC) $(CFLAGS) -o $@ -c epsffit.c
 
 epsffit: epsffit.o pserror.o
-	$(CC) $(CCFLAGS) -o epsffit pserror.o epsffit.o
+	$(CC) $(LDFLAGS) -o epsffit pserror.o epsffit.o
 
 psnup: psnup.o psutil.o psspec.o pserror.o
-	$(CC) $(CCFLAGS) -o psnup psutil.o psspec.o pserror.o psnup.o
+	$(CC) $(LDFLAGS) -o psnup psutil.o psspec.o pserror.o psnup.o $(LIBS)
 
 psnup.o: psutil.h patchlev.h psspec.h pserror.h psnup.c
+	$(CC) $(CFLAGS) -o $@ -c psnup.c
 
 psresize: psresize.o psutil.o pserror.o psspec.o
-	$(CC) $(CCFLAGS) -o psresize psutil.o psspec.o pserror.o psresize.o
+	$(CC) $(LDFLAGS) -o psresize psutil.o psspec.o pserror.o psresize.o \
+          $(LIBS)
 
 psresize.o: psutil.h patchlev.h psspec.h pserror.h psresize.c
+	$(CC) $(CFLAGS) -o $@ -c psresize.c
 
 psbook: psbook.o psutil.o pserror.o
-	$(CC) $(CCFLAGS) -o psbook psutil.o pserror.o psbook.o
+	$(CC) $(LDFLAGS) -o psbook psutil.o pserror.o psbook.o
 
 psbook.o: psutil.h patchlev.h pserror.h psbook.c
+	$(CC) $(CFLAGS) -o $@ -c psbook.c
 
 psselect: psselect.o psutil.o pserror.o
-	$(CC) $(CCFLAGS) -o psselect psutil.o pserror.o psselect.o
+	$(CC) $(LDFLAGS) -o psselect psutil.o pserror.o psselect.o
 
 psselect.o: psutil.h patchlev.h pserror.h psselect.c
 
 pstops: pstops.o psutil.o psspec.o pserror.o
-	$(CC) $(CCFLAGS) -o pstops psutil.o psspec.o pserror.o pstops.o
+	$(CC) $(LDFLAGS) -o pstops psutil.o psspec.o pserror.o pstops.o $(LIBS)
 
 pstops.o: psutil.h patchlev.h psspec.h pserror.h pstops.c
+	$(CC) $(CFLAGS) -o $@ -c pstops.c
 
 getafm:	getafm.sh
 	cp $? $@
@@ -106,10 +135,6 @@
 	$(PERL) maketext OS=$(OS) PERL=$(PERL) $? > $@
 	$(CHMOD) $(BINMODE) $@
 
-fixmacps: fixmacps.pl
-	$(PERL) maketext OS=$(OS) PERL=$(PERL) INCLUDE=$(INCLUDEDIR) $? > $@
-	$(CHMOD) $(BINMODE) $@
-
 fixpsditps: fixpsditps.pl
 	$(PERL) maketext OS=$(OS) PERL=$(PERL) $? > $@
 	$(CHMOD) $(BINMODE) $@
@@ -171,11 +196,11 @@
 psmerge.$(MANEXT): psmerge.man
 	$(PERL) maketext "MAN=$(MANPAGES)" $? > $@
 
-fixfmps.$(MANEXT): fixfmps.man
+psjoin.$(MANEXT): psjoin.man
 	$(PERL) maketext "MAN=$(MANPAGES)" $? > $@
 
-fixmacps.$(MANEXT): fixmacps.man
-	$(PERL) maketext "MAN=$(MANPAGES)" INCLUDE=$(INCLUDEDIR) $? > $@
+fixfmps.$(MANEXT): fixfmps.man
+	$(PERL) maketext "MAN=$(MANPAGES)" $? > $@
 
 fixpsditps.$(MANEXT): fixpsditps.man
 	$(PERL) maketext "MAN=$(MANPAGES)" $? > $@
@@ -210,39 +235,35 @@
 getafm.$(MANEXT): getafm.man
 	$(PERL) maketext "MAN=$(MANPAGES)" $? > $@
 
+showchar.$(MANEXT): showchar.man
+	$(PERL) maketext "MAN=$(MANPAGES)" $? > $@
+
 clean:
 	rm -f *.o
 
 veryclean realclean: clean
 	rm -f $(BIN) $(PERLSCRIPTS) $(MANPAGES)
 
-install: install.bin install.script install.man install.include
+install: install.bin install.script install.man
 
 install.bin: $(BIN)
-	-mkdir $(BINDIR)
+	-mkdir -p $(DESTDIR)$(BINDIR)
 	@for i in $(BIN); do \
 		echo Installing $$i; \
-		$(INSTALL) $$i $(BINDIR); \
+		$(INSTALL) $$i $(DESTDIR)$(BINDIR); \
 	done
 
 install.script: $(PERLSCRIPTS) $(SHELLSCRIPTS)
-	-mkdir $(SCRIPTDIR)
+	-mkdir -p $(DESTDIR)$(SCRIPTDIR)
 	@for i in $(PERLSCRIPTS) $(SHELLSCRIPTS); do \
 		echo Installing $$i; \
-		$(INSTALL) $$i $(SCRIPTDIR); \
-	done
-
-install.include: $(INCLUDES)
-	-mkdir $(INCLUDEDIR)
-	@for i in $(INCLUDES); do \
-		echo Installing $$i; \
-		$(INSTALLMAN) $$i $(INCLUDEDIR); \
+		$(INSTALL) $$i $(DESTDIR)$(SCRIPTDIR); \
 	done
 
 install.man: $(MANPAGES)
-	-mkdir $(MANDIR)
+	-mkdir -p $(DESTDIR)$(MANDIR)
 	@for i in $(MANPAGES); do \
 		echo Installing manual page for $$i; \
-		$(INSTALLMAN) $$i $(MANDIR)/$$i; \
+		$(INSTALLMAN) $$i $(DESTDIR)$(MANDIR)/$$i; \
 	done
 
diff -rupN psutils/README psutils-new/README
--- psutils/README	1997-03-11 23:53:05.000000000 +0100
+++ psutils-new/README	2014-04-09 21:23:02.237996540 +0200
@@ -181,6 +181,7 @@ people, including:
 	Mike Coleman
 	Dale Scheetz		dwarf@polaris.net
 	Yves Arrouye		arrouye@marin.fdn.fr
+	Stanislav Brabec	utx@penguin.cz
 
 (Apologies to anyone who I have left out, it was not intentional.)
 
diff -rupN psutils/README.voidlinux psutils-new/README.voidlinux
--- psutils/README.voidlinux	1970-01-01 01:00:00.000000000 +0100
+++ psutils-new/README.voidlinux	2014-04-11 16:34:36.488067584 +0200
@@ -0,0 +1,56 @@
+This version of psutils is patched from debian sources and has a patched Makefile to 
+build and install in voidlinux.
+
+Please report any error to voidlinux maintainer and not upstrean or to debian maintainer
+
+It install only theese files:
+
+epsffit
+extractres
+fixdlsrps
+fixfmps
+fixpsditps
+fixpspps
+fixscribeps
+fixtpps
+fixwfwps
+fixwpps
+fixwwps
+getafm
+includeres
+psbook
+psjoin
+psmerge
+psnup
+psresize
+psselect
+pstops
+showchar
+
+and theese man pages:
+
+epsffit.1
+extractres.1
+fixdlsrps.1
+fixfmps.1
+fixpsditps.1
+fixpspps.1
+fixscribeps.1
+fixtpps.1
+fixwfwps.1
+fixwpps.1
+fixwwps.1
+getafm.1
+includeres.1
+psbook.1
+psjoin.1
+psmerge.1
+psnup.1
+psresize.1
+psselect.1
+pstops.1
+showchar.1
+
+It retain the original LICENSE file in /usr/share/licenses/psutils
+The lacks of copyrighted files from Apple cited in the LICENSE make the copyright part in 
+the original LICENSE file useless.
\ No newline at end of file
diff -rupN psutils/epsffit.c psutils-new/epsffit.c
--- psutils/epsffit.c	1997-03-11 23:52:52.000000000 +0100
+++ psutils-new/epsffit.c	2014-04-09 19:55:19.698132829 +0200
@@ -8,6 +8,7 @@
  *               -c centres the image in the bounding box given
  *               -r rotates the image by 90 degrees anti-clockwise
  *               -a alters the aspect ratio to fit the bounding box
+ *               -m rotate to maximise the size within specified bounding
  *               -s adds a showpage at the end of the image
  *
  * Added filename spec (from Larry Weissman) 5 Feb 93
@@ -20,6 +21,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
+#include <unistd.h>
 
 #include "pserror.h"
 #include "patchlev.h"
@@ -34,66 +36,76 @@ static void usage(void)
 {
    fprintf(stderr, "%s release %d patchlevel %d\n", program, RELEASE, PATCHLEVEL);
    fprintf(stderr, "Copyright (C) Angus J. C. Duggan, 1991-1995. See file LICENSE for details.\n");
-   fprintf(stderr, "Usage: %s [-c] [-r] [-a] [-s] llx lly urx ury [infile [outfile]]\n",
+   fprintf(stderr, "Usage: %s [-c] [-r] [-a] [-m] [-s] llx lly urx ury [infile [outfile]]\n",
 	   program);
    exit(1);
 }
 
-void main(int argc, char **argv)
+int
+main(int argc, char **argv)
 {
    int bbfound = 0;              /* %%BoundingBox: found */
-   int urx, ury, llx, lly;
+   int urx = 0, ury = 0, llx = 0, lly = 0;
    int furx, fury, fllx, flly;
    int showpage = 0, centre = 0, rotate = 0, aspect = 0, maximise = 0;
    char buf[BUFSIZ];
-   FILE *input;
-   FILE *output;
+   FILE *input = stdin;
+   FILE *output = stdout;
+   int opt;
+
+   program = *argv;
+
+   while((opt = getopt(argc, argv, "csramv")) != EOF) {
+     switch(opt) {
+     case 'c': centre = 1; break;
+     case 's': showpage = 1; break;
+     case 'r': rotate = 1; break;
+     case 'a': aspect = 1; break;
+     case 'm': maximise = 1; break;
+     case 'v':
+     default:
+       usage();
+       break;
+     }
+   }
 
-   program = *argv++; argc--;
+   if ((argc - optind) < 4 || (argc - optind) > 6) usage();
 
-   while (argc > 0 && argv[0][0] == '-') {
-      switch (argv[0][1]) {
-      case 'c': centre = 1; break;
-      case 's': showpage = 1; break;
-      case 'r': rotate = 1; break;
-      case 'a': aspect = 1; break;
-      case 'm': maximise = 1; break;
-      case 'v':
-      default:  usage();
-      }
-      argc--;
-      argv++;
+   fllx = atoi(argv[optind++]);
+   flly = atoi(argv[optind++]);
+   furx = atoi(argv[optind++]);
+   fury = atoi(argv[optind++]);
+
+   /* Be defensive */
+   if((argc - optind) < 0 || (argc - optind) > 2) usage();
+
+   if ((argc - optind) > 0) {
+      if(!(input = fopen(argv[optind], OPEN_READ)))
+	 message(FATAL, "can't open input file %s\n", argv[optind]);
+      optind++;
    }
-
-   if (argc < 4 || argc > 6) usage();
-   fllx = atoi(argv[0]);
-   flly = atoi(argv[1]);
-   furx = atoi(argv[2]);
-   fury = atoi(argv[3]);
-
-   if (argc > 4) {
-      if(!(input = fopen(argv[4], OPEN_READ)))
-	 message(FATAL, "can't open input file %s\n", argv[4]);
-   } else {
 #if defined(MSDOS) || defined(WINNT)
+   else {
       int fd = fileno(stdin) ;
       if ( setmode(fd, O_BINARY) < 0 )
          message(FATAL, "can't reset stdin to binary mode\n");
-#endif
       input = stdin ;
     }
+#endif
 
-   if (argc > 5) {
-      if(!(output = fopen(argv[5], OPEN_WRITE)))
-	 message(FATAL, "can't open output file %s\n", argv[5]);
-   } else {
+   if ((argc - optind) > 0) {
+      if(!(output = fopen(argv[optind], OPEN_WRITE)))
+	 message(FATAL, "can't open output file %s\n", argv[optind]);
+      optind++;
+   }
 #if defined(MSDOS) || defined(WINNT)
+   else {
       int fd = fileno(stdout) ;
       if ( setmode(fd, O_BINARY) < 0 )
          message(FATAL, "can't reset stdout to binary mode\n");
-#endif
       output = stdout ;
     }
+#endif
 
    while (fgets(buf, BUFSIZ, input)) {
       if (buf[0] == '%' && (buf[1] == '%' || buf[1] == '!')) {
diff -rupN psutils/getafm.sh psutils-new/getafm.sh
--- psutils/getafm.sh	1997-03-11 23:52:57.000000000 +0100
+++ psutils-new/getafm.sh	2014-04-09 19:55:19.696132829 +0200
@@ -1,7 +1,7 @@
 #!/bin/sh
 
 if [ $# -ne 1 ]; then
-  echo "usage: $0 font-name | gsnd - >font-name.afm" >&2
+  echo "usage: $0 font-name | gsnd -q - >font-name.afm" >&2
   exit 1
 fi
 
@@ -13,6 +13,11 @@ cat << EOF
 %	getafm 1.00 (c) AJCD
 % and getafm.ps by an unknown author,
 %	modified by J. Daniel Smith <dsmith@mailhost.aa.cad.slb.com>
+%
+% modified by Joachim H. Kaiser <jhk@cmpnetmail.com>:
+% - suggest a quiet gs run in usage
+% - get font version info (from 'version', not 'Version')
+% - add copyright field to output
 
 % Metrics dictionary code added by AJCD, 7/6/93
 
@@ -66,8 +71,9 @@ cat << EOF
 	(isFixedPitch)(IsFixedPitch) prany
 	(UnderlinePosition)dup prany
 	(UnderlineThickness)dup prany
-	(Version)(version) prany
+	(version)(Version) prany
 	(Notice)dup prany
+	(Copyright)dup prany
       pop
     }
     {
diff -rupN psutils/psbook.c psutils-new/psbook.c
--- psutils/psbook.c	1997-03-11 23:53:01.000000000 +0100
+++ psutils-new/psbook.c	2014-04-09 20:01:32.285123179 +0200
@@ -8,6 +8,8 @@
  *       psbook [-q] [-s<signature>] [infile [outfile]]
  */
 
+#include <unistd.h>
+
 #include "psutil.h"
 #include "pserror.h"
 #include "patchlev.h"
@@ -32,36 +34,54 @@ static void usage(void)
 }
 
 
-void main(int argc, char *argv[])
+int
+main(int argc, char *argv[])
 {
    int signature = 0;
    int currentpg, maxpage;
+   int opt;
+
+   verbose = 1;
+   program = *argv;
+
+   while((opt = getopt(argc, argv, "vqs:")) != EOF) {
+     switch(opt) {
+     case 's':	/* signature size */
+       signature = atoi(optarg);
+       if (signature < 1 || signature % 4) usage();
+       break;
+     case 'q':	/* quiet */
+       verbose = 0;
+       break;
+     case 'v':	/* version */
+     default:
+       usage();
+       break;
+     }
+   }
 
    infile = stdin;
    outfile = stdout;
-   verbose = 1;
-   for (program = *argv++; --argc; argv++) {
-      if (argv[0][0] == '-') {
-	 switch (argv[0][1]) {
-	 case 's':	/* signature size */
-	    signature = atoi(*argv+2);
-	    if (signature < 1 || signature % 4) usage();
-	    break;
-	 case 'q':	/* quiet */
-	    verbose = 0;
-	    break;
-	 case 'v':	/* version */
-	 default:
-	    usage();
-	 }
-      } else if (infile == stdin) {
-	 if ((infile = fopen(*argv, OPEN_READ)) == NULL)
-	    message(FATAL, "can't open input file %s\n", *argv);
-      } else if (outfile == stdout) {
-	 if ((outfile = fopen(*argv, OPEN_WRITE)) == NULL)
-	    message(FATAL, "can't open output file %s\n", *argv);
-      } else usage();
+
+   /* Be defensive */
+   if((argc - optind) < 0 || (argc - optind) > 2) usage();
+
+   if (optind != argc) {
+     /* User specified an input file */
+     if ((infile = fopen(argv[optind], OPEN_READ)) == NULL)
+       message(FATAL, "can't open input file %s\n", argv[optind]);
+     optind++;
+   }
+
+   if (optind != argc) {
+     /* User specified an output file */
+     if ((outfile = fopen(argv[optind], OPEN_WRITE)) == NULL)
+       message(FATAL, "can't open output file %s\n", argv[optind]);
+     optind++;
    }
+
+   if(optind != argc) usage();
+
 #if defined(MSDOS) || defined(WINNT)
    if ( infile == stdin ) {
       int fd = fileno(stdin) ;
@@ -77,7 +97,7 @@ void main(int argc, char *argv[])
    if ((infile=seekable(infile))==NULL)
       message(FATAL, "can't seek input\n");
 
-   scanpages();
+   scanpages(NULL);
 
    if (!signature)
       signature = maxpage = pages+(4-pages%4)%4;
@@ -85,7 +105,7 @@ void main(int argc, char *argv[])
       maxpage = pages+(signature-pages%signature)%signature;
 
    /* rearrange pages */
-   writeheader(maxpage);
+   writeheader(maxpage, NULL);
    writeprolog();
    writesetup();
    for (currentpg = 0; currentpg < maxpage; currentpg++) {
diff -rupN psutils/pserror.c psutils-new/pserror.c
--- psutils/pserror.c	1997-03-11 23:53:01.000000000 +0100
+++ psutils-new/pserror.c	2014-04-09 19:55:19.691132829 +0200
@@ -24,7 +24,7 @@ extern char *program ;	/* Defined by mai
 void message(int flags, char *format, ...)
 {
   va_list args ;
-  static column = 0 ;		/* current screen column for message wrap */
+  static int column = 0 ;	/* current screen column for message wrap */
   char msgbuf[MAX_MESSAGE] ;	/* buffer in which to put the message */
   char *bufptr = msgbuf ;	/* message buffer pointer */
 
diff -rupN psutils/psjoin psutils-new/psjoin
--- psutils/psjoin	1970-01-01 01:00:00.000000000 +0100
+++ psutils-new/psjoin	2014-04-09 21:24:18.122994574 +0200
@@ -0,0 +1,208 @@
+#!/usr/bin/perl
+#
+# psjoin - concatenate PostScript files
+#
+# version 0.2, 2002-07-18
+# version 0.3, 2003-11-30
+#
+# by Tom Sato <VEF00200@nifty.ne.jp>, http://homepage3.nifty.com/tsato/
+
+$force_even = 0;
+$force_save = 0;
+$dont_strip = 0;
+$save = "save %psjoin\n";
+$restore = "restore %psjoin\n";
+while ($ARGV[0] =~ /^-[a-z]/i) {
+    if ($ARGV[0] eq "-a") {
+	$force_even = 1;
+	shift;
+    } elsif ($ARGV[0] eq "-s") {
+	$force_save = 1;
+	$save = "/#psjoin-save# save def %psjoin\n";
+	$restore = "#psjoin-save# restore %psjoin\n";
+	shift;
+    } elsif ($ARGV[0] eq "-p") {
+	$dont_strip = 1;
+	shift;
+    } elsif ($ARGV[0] eq "-h") {
+	print STDERR "psjoin - concatenate PostScript files (version 0.3)\n";
+	print STDERR "by Tom Sato <VEF00200\@nifty.ne.jp>,";
+	print STDERR " http://member.nifty.ne.jp/tsato/\n\n";
+	print STDERR "Usage: psjoin [ options... ] filenames...\n\n";
+	print STDERR "Option:\n";
+	print STDERR "  -a: align first page of each documents to odd page\n";
+	print STDERR "  -s: try to close unclosed save operators\n";
+	print STDERR "  -p: not strip prolog/trailer of the input files\n";
+	print STDERR "  -h: display this\n";
+	exit 0;
+    } else {
+	print STDERR "$0: unknown option: $ARGV[0]\n";
+	print STDERR "(\"$0 -h\" for short description)\n";
+	exit 2;
+    }
+}
+shift if $ARGV[0] eq "--";
+
+if ($dont_strip) {
+    $prolog_inx = 9999;
+    $prolog[$prolog_inx] = "% [ psjoin: don't strip ]\n";
+    $trailer[$prolog_inx] = "% [ psjoin: don't strip ]\n";
+} else {
+    for ($i = 0; $i <= $#ARGV; $i++) {
+	open(IN, $ARGV[$i]) || die "$0: can't open \"$ARGV[$i]\" ($!)";
+
+	$in_comment = 1;
+	$in_prolog = 1;
+	$in_trailer = 0;
+	$comments[$i] = "";
+	$prolog[$i] = "";
+	$trailer[$i] = "";
+	$pages[$i] = 0;
+	while (<IN>) {
+	    next if /^%%BeginDocument/ .. /^%%EndDocument/;
+
+	    if ($in_comment) {
+		next if /^%!PS-Adobe-/; 
+		next if /^%%Title/;
+		next if /^%%Pages/;
+		next if /^%%Creator/;
+		$in_comment = 0 if /^%%EndComments/;
+		$comments[$i] .= $_;
+		next;
+	    } elsif ($in_prolog) {
+		if (/^%%Page:/) {
+		    $in_prolog = 0;
+		} else {
+		    $prolog[$i] .= $_;
+		    next;
+		}
+	    }
+
+	    $in_trailer = 1 if /^%%Trailer/;
+	    if ($in_trailer) {
+		$trailer[$i] .= $_;
+		next;
+	    }
+
+	    $pages[$i]++ if /^%%Page:/;
+	}
+	close(IN);
+
+	if ($prolog[$i]) {
+	    for ($j = 0; $j < $i; $j++) {
+		if ($prolog[$j] eq $prolog[$i]) {
+		    $pages[$j] += $pages[$i];
+		    break;
+		}
+	    }
+	}
+    }
+
+    $largest = 0;
+    $prolog_inx = 0;
+    for ($i = 0; $i <= $#ARGV; $i++) {
+	$size = length($prolog[$i]) * $pages[$i];
+	if ($largest < $size) {
+	    $largest = $size;
+	    $prolog_inx = $i;
+	}
+    }
+}
+
+print "%!PS-Adobe-3.0\n";
+print "%%Title: @ARGV\n";
+print "%%Creator: psjoin 0.2\n";
+print "%%Pages: (atend)\n";
+print $comments[$prolog_inx];
+
+print "\n";
+print $prolog[$prolog_inx];
+for ($i = 0; $i <= $#ARGV; $i++) {
+    $prolog[$i] =~ s/^%%/% %%/;
+    $prolog[$i] =~ s/\n%%/\n% %%/g;
+    $trailer[$i] =~ s/^%%/% %%/;
+    $trailer[$i] =~ s/\n%%/\n% %%/g;
+}
+
+$total_pages = 0;
+for ($i = 0; $i <= $#ARGV; $i++) {
+    print "\n";
+    print "% [ psjoin: file = $ARGV[$i] ]\n";
+    if ($prolog[$i] ne $prolog[$prolog_inx]) {
+        print "% [ psjoin: Prolog/Trailer will be inserted to every page ]\n";
+    } else {
+        print "% [ psjoin: common Prolog/Trailer will be used ]\n";
+    }
+
+    $in_comment = 1 if !$dont_strip;
+    $in_prolog = 1 if !$dont_strip;
+    $in_trailer = 0;
+    $saved = 0;
+    $pages = 0;
+
+    open(IN, $ARGV[$i]) || die "$0: can't open \"$ARGV[$i]\" ($!)";
+    while (<IN>) {
+        if (/^%%BeginDocument/ .. /^%%EndDocument/) {
+            # s/^(%[%!])/% \1/;
+            print $_;
+        } else {
+            if ($in_comment) {
+                $in_comment = 0 if /^%%EndComments/;
+            } elsif ($in_prolog) {
+                if (/^%%Page:/) {
+                    $in_prolog = 0;
+                } else {
+                    next;
+                }
+            }
+            $in_trailer = 1 if !$dont_strip && /^%%Trailer/;
+            next if $in_trailer;
+
+            if (/^%%Page:/) {
+                if ($saved) {
+                    print $trailer[$i];
+		    print $restore;
+                    $saved = 0;
+                }
+
+                $pages++;
+                $total_pages++;
+                print "\n";
+                print "%%Page: ($i-$pages) $total_pages\n";
+                if ($prolog[$i] ne $prolog[$prolog_inx]) {
+		    print $save;
+                    print $prolog[$i];
+                    $saved = 1;
+                } elsif ($force_save) {
+		    print $save;
+		}
+            } else {
+                s/^(%[%!])/% \1/;
+                print $_;
+            }
+        }
+    }
+    close(IN);
+
+    if ($force_even && $pages % 2 != 0) {
+	$pages++;
+	$total_pages++;
+	print "\n";
+	print "%%Page: ($i-E) $total_pages\n";
+	print "% [ psjoin: empty page inserted to force even pages ]\n";
+	print "showpage\n";
+    }
+
+    if ($saved) {
+        print $trailer[$i];
+        print $restore;
+    } elsif ($force_save) {
+        print $restore;
+    }
+}
+
+print "\n";
+print "%%Trailer\n";
+print $trailer[$prolog_inx];
+print "%%Pages: $total_pages\n";
+print "%%EOF\n";
diff -rupN psutils/psjoin.man psutils-new/psjoin.man
--- psutils/psjoin.man	1970-01-01 01:00:00.000000000 +0100
+++ psutils-new/psjoin.man	2014-04-09 21:24:18.123994574 +0200
@@ -0,0 +1,18 @@
+.TH PSJOIN "1" "November 2003" "psjoin 0.3" "User Commands"
+.SH NAME
+psjoin \- psjoin
+.SH SYNOPSIS
+.B psjoin
+[ \fIoptions\fR... ] \fIfilenames\fR...
+.SH DESCRIPTION
+psjoin \- concatenate PostScript files (version 0.3)
+by Tom Sato <VEF00200@nifty.ne.jp>, http://member.nifty.ne.jp/tsato/
+.SS "Option:"
+.HP
+\fB\-a\fR: align first page of each documents to odd page
+.HP
+\fB\-s\fR: try to close unclosed save operators
+.HP
+\fB\-p\fR: not strip prolog/trailer of the input files
+.HP
+\fB\-h\fR: display help
diff -rupN psutils/psmerge.man psutils-new/psmerge.man
--- psutils/psmerge.man	1997-03-11 23:53:02.000000000 +0100
+++ psutils-new/psmerge.man	2014-04-09 19:58:34.492127784 +0200
@@ -6,9 +6,7 @@ psmerge \- filter to merge several PostS
 [
 .B \-o\fIout.ps\fB
 ]
-[
 .I file.ps ...
-]
 .SH DESCRIPTION
 .I Psmerge
 merges PostScript documents into a single document. It only works in the
diff -rupN psutils/psmerge.pl psutils-new/psmerge.pl
--- psutils/psmerge.pl	1997-03-11 23:53:02.000000000 +0100
+++ psutils-new/psmerge.pl	2014-04-09 21:17:17.098005478 +0200
@@ -1,42 +1,66 @@
 @PERL@
 # psmerge: merge PostScript files produced by same application and setup
-# usage: psmerge [-oout.ps] [-thorough] file1.ps file2.ps ...
+# usage: psmerge [-oout.ps] file1.ps file2.ps ...
 #
 # Copyright (C) Angus J. C. Duggan 1991-1995
 # See file LICENSE for details.
 
-$prog = ($0 =~ s=.*/==);
+use strict;
+$^W = 1;
+my $prog = ($0 =~ m,([^/\\]*)$,) ? $1 : $0;
+my $outfile = undef;
+
+usage() unless @ARGV;
 
 while ($ARGV[0] =~ /^-/) {
    $_ = shift;
    if (/^-o(.+)/) {
-      if (!close(STDOUT) || !open(STDOUT, ">$1")) {
-	 print STDERR "$prog: can't open $1 for output\n";
-	 exit 1;
-      }
+      $outfile = $1;
    } elsif (/^-t(horough)?$/) {
-      $thorough = 1;
+      # This doesn't do anything, but we leave it for backward compatibility.
    } else {
-      print STDERR "Usage: $prog [-oout] [-thorough] file...\n";
+      usage();
+   }
+}
+
+my $gs = find_gs();
+if (defined $gs)
+{
+   # Just invoke gs
+   $outfile = '/dev/stdout' unless defined $outfile;
+   exec +(qw(gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite),
+	  "-sOutputFile=$outfile", '-f', @ARGV);
+   die "$prog: exec /usr/bin/gs failed\n";
+}
+else
+{
+   warn +("$prog: /usr/bin/gs not found; falling back to old," .
+	  " less functional behavior\n");
+}
+
+if (defined $outfile)
+{
+   if (!close(STDOUT) || !open(STDOUT, ">$outfile")) {
+      print STDERR "$prog: can't open $1 for output\n";
       exit 1;
    }
 }
 
-$page = 0;
-$first = 1;
-$nesting = 0;
+my $page = 0;
+my $first = 1;
+my $nesting = 0;
 
-@header = ();
-$header = 1;
+my @header = ();
+my $header = 1;
 
-@trailer = ();
-$trailer = 0;
+my @trailer = ();
+my $trailer = 0;
 
-@pages = ();
-@body = ();
+my @pages = ();
+my @body = ();
 
-@resources = ();
-$inresource = 0;
+my @resources = ();
+my $inresource = 0;
 
 while (<>) {
    if (/^%%BeginFont:/ || /^%%BeginResource:/ || /^%%BeginProcSet:/) {
@@ -45,41 +69,55 @@ while (<>) {
    } elsif ($inresource) {
       push(@resources, $_);
       $inresource = 0 if /^%%EndFont/ || /^%%EndResource/ || /^%%EndProcSet/;
-   } elsif (/^%%Page:/ && $nesting == 0) {
-      $header = $trailer = 0;
-      push(@pages, join("", @body)) if @body;
-      $page++;
-      @body = ("%%Page: ($page) $page\n");
-   } elsif (/^%%Trailer/ && $nesting == 0) {
-      push(@trailer, $_);
-      push(@pages, join("", @body)) if @body;
-      @body = ();
-      $trailer = 1;
-      $header = 0;
-   } elsif ($header) {
-      push(@trailer, $_);
-      push(@pages, join("", @body)) if @body;
-      @body = ();
-      $trailer = 1;
-      $header = 0;
-   } elsif ($trailer) {
-      if (/^%!/ || /%%EOF/) {
-	 $trailer = $first = 0;
-      } elsif ($first) {
-	 push(@trailer, $_);
-      }
-   } elsif (/^%%BeginDocument/ || /^%%BeginBinary/ || /^%%BeginFile/) {
-      push(@body, $_);
-      $nesting++;
-   } elsif (/^%%EndDocument/ || /^%%EndBinary/ || /^%%EndFile/) {
-      push(@body, $_);
-      $nesting--;
-   } else {
-      print $_ if $print;
-   }
+       } elsif (/^%%Page:/ && $nesting == 0) {
+	  $header = $trailer = 0;
+	  push(@pages, join("", @body)) if @body;
+	  $page++;
+	  @body = ("%%Page: ($page) $page\n");
+       } elsif (/^%%Trailer/ && $nesting == 0) {
+	  push(@trailer, $_);
+	  push(@pages, join("", @body)) if @body;
+	  @body = ();
+	  $trailer = 1;
+	  $header = 0;
+       } elsif ($header) {
+	  push(@trailer, $_);
+	  push(@pages, join("", @body)) if @body;
+	  @body = ();
+	  $trailer = 1;
+	  $header = 0;
+       } elsif ($trailer) {
+	  if (/^%!/ || /%%EOF/) {
+	     $trailer = $first = 0;
+	  } elsif ($first) {
+	     push(@trailer, $_);
+	  }
+       } elsif (/^%%BeginDocument/ || /^%%BeginBinary/ || /^%%BeginFile/) {
+	  push(@body, $_);
+	  $nesting++;
+       } elsif (/^%%EndDocument/ || /^%%EndBinary/ || /^%%EndFile/) {
+	  push(@body, $_);
+	  $nesting--;
+       }
 }
 
 print @trailer;
 
-exit 0;
+sub find_gs
+{
+   my $path = $ENV{'PATH'} || "";
+   my @path = split(':', $path);
+   foreach my $dir (@path)
+   {
+      return "$dir/gs" if -x "$dir/gs";
+   }
+   undef;
+}
+
+sub usage
+{
+   print STDERR "Usage: $prog [-oout] file...\n";
+   exit 1;
+}
+
 @END@
diff -rupN psutils/psnup.c psutils-new/psnup.c
--- psutils/psnup.c	1997-03-11 23:53:02.000000000 +0100
+++ psutils-new/psnup.c	2014-04-09 21:19:57.068001335 +0200
@@ -23,11 +23,18 @@
  * 		-d<wid>	to draw the page boundaries
  */
 
+#include <unistd.h>
+#include <string.h>
+
 #include "psutil.h"
 #include "psspec.h"
 #include "pserror.h"
 #include "patchlev.h"
 
+#ifdef DEBIAN
+#include <paper.h>
+#endif
+
 char *program ;
 int pages ;
 int verbose ;
@@ -66,21 +73,37 @@ static int nextdiv(int n, int m)
    return (0);
 }
 
-void main(int argc, char *argv[])
+int
+main(int argc, char *argv[])
 {
-   int horiz, vert, rotate, column, flip, leftright, topbottom;
+   int horiz = 0, vert = 0, rotate = 0, column = 0;
+   int flip = 0, leftright = 0, topbottom = 0;
    int nup = 1;
    double draw = 0;				/* draw page borders */
-   double scale;				/* page scale */
+   double scale = 1.0;				/* page scale */
    double uscale = 0;				/* user supplied scale */
    double ppwid, pphgt;				/* paper dimensions */
    double margin, border;			/* paper & page margins */
    double vshift, hshift;			/* page centring shifts */
    double iwidth, iheight ;			/* input paper size */
    double tolerance = 100000;			/* layout tolerance */
-   Paper *paper;
+   Paper *paper = NULL;
+   off_t sizeheaders[20];			/* headers to remove */
+   int opt;
 
-#ifdef PAPER
+#ifdef DEBIAN
+   paperinit();
+   {
+     const char *default_size = systempapername();
+     if (!default_size) default_size = defaultpapername ();
+     if (default_size) paper = findpaper(default_size);
+     if (paper) {
+       width = (double)PaperWidth(paper);
+       height = (double)PaperHeight(paper);
+     }
+   }
+   paperdone();
+#elif defined(PAPER)
    if ( (paper = findpaper(PAPER)) != (Paper *)0 ) {
       width = (double)PaperWidth(paper);
       height = (double)PaperHeight(paper);
@@ -91,105 +114,129 @@ void main(int argc, char *argv[])
    leftright = topbottom = 1;
    iwidth = iheight = -1 ;
 
+   verbose = 1;
+   program = *argv;
+
+   while((opt =
+          getopt(argc, argv,
+                 "qd::lrfcw:W:h:H:m:b:t:s:p:P:n:1::2::3::4::5::6::7::8::9::"))
+         != EOF) {
+     switch(opt) {
+     case 'q':	/* quiet */
+       verbose = 0;
+       break;
+     case 'd':	/* draw borders */
+       if (optarg)
+         draw = singledimen(optarg, argerror, usage);
+       else
+         draw = 1;
+       break;
+     case 'l':	/* landscape (rotated left) */
+       column = !column;
+       topbottom = !topbottom;
+       break;
+     case 'r':	/* seascape (rotated right) */
+       column = !column;
+       leftright = !leftright;
+       break;
+     case 'f':	/* flipped */
+       flip = 1;
+       break;
+     case 'c':	/* column major layout */
+       column = !column;
+       break;
+     case 'w':	/* page width */
+       width = singledimen(optarg, argerror, usage);
+       break;
+     case 'W':	/* input page width */
+       iwidth = singledimen(optarg, argerror, usage);
+       break;
+     case 'h':	/* page height */
+       height = singledimen(optarg, argerror, usage);
+       break;
+     case 'H':	/* input page height */
+       iheight = singledimen(optarg, argerror, usage);
+       break;
+     case 'm':	/* margins around whole page */
+       margin = singledimen(optarg, argerror, usage);
+       break;
+     case 'b':	/* border around individual pages */
+       border = singledimen(optarg, argerror, usage);
+       break;
+     case 't':	/* layout tolerance */
+       tolerance = atof(optarg);
+       break;
+     case 's':	/* override scale */
+       uscale = atof(optarg);
+       break;
+     case 'p':	/* output (and by default input) paper type */
+       if ( (paper = findpaper(optarg)) != (Paper *)0 ) {
+         width = (double)PaperWidth(paper);
+         height = (double)PaperHeight(paper);
+       } else
+         message(FATAL, "paper size '%s' not recognised\n", optarg);
+       break;
+     case 'P':	/* paper type */
+       if ( (paper = findpaper(optarg)) != (Paper *)0 ) {
+         iwidth = (double)PaperWidth(paper);
+         iheight = (double)PaperHeight(paper);
+       } else
+         message(FATAL, "paper size '%s' not recognised\n", optarg);
+       break;
+     case 'n':	/* n-up, for compatibility with other psnups */
+       if ((nup = atoi(optarg)) < 1)
+         message(FATAL, "-n %d too small\n", nup);
+       break;
+     case '1':
+     case '2':
+     case '3':
+     case '4':
+     case '5':
+     case '6':
+     case '7':
+     case '8':
+     case '9':
+       if(optarg) {
+         char *valuestr = (char *) malloc(strlen(optarg) + 2);
+         valuestr[0] = opt;
+         strcpy(&(valuestr[1]), optarg);
+
+         /* really should check that valuestr is only digits here...*/
+         if ((nup = atoi(valuestr)) < 1)
+           message(FATAL, "-n %d too small\n", nup);
+         free(valuestr);
+       } else {
+         nup = (opt - '0');
+       }
+       break;
+     case 'v':	/* version */
+     default:
+       usage();
+     }
+   }
+
    infile = stdin;
    outfile = stdout;
-   verbose = 1;
-   for (program = *argv++; --argc; argv++) {
-      if (argv[0][0] == '-') {
-	 switch (argv[0][1]) {
-	 case 'q':	/* quiet */
-	    verbose = 0;
-	    break;
-	 case 'd':	/* draw borders */
-	    if (argv[0][2])
-	       draw = singledimen(*argv+2, argerror, usage);
-	    else
-	       draw = 1;
-	    break;
-	 case 'l':	/* landscape (rotated left) */
-	    column = !column;
-	    topbottom = !topbottom;
-	    break;
-	 case 'r':	/* seascape (rotated right) */
-	    column = !column;
-	    leftright = !leftright;
-	    break;
-	 case 'f':	/* flipped */
-	    flip = 1;
-	    break;
-	 case 'c':	/* column major layout */
-	    column = !column;
-	    break;
-	 case 'w':	/* page width */
-	    width = singledimen(*argv+2, argerror, usage);
-	    break;
-	 case 'W':	/* input page width */
-	    iwidth = singledimen(*argv+2, argerror, usage);
-	    break;
-	 case 'h':	/* page height */
-	    height = singledimen(*argv+2, argerror, usage);
-	    break;
-	 case 'H':	/* input page height */
-	    iheight = singledimen(*argv+2, argerror, usage);
-	    break;
-	 case 'm':	/* margins around whole page */
-	    margin = singledimen(*argv+2, argerror, usage);
-	    break;
-	 case 'b':	/* border around individual pages */
-	    border = singledimen(*argv+2, argerror, usage);
-	    break;
-	 case 't':	/* layout tolerance */
-	    tolerance = atof(*argv+2);
-	    break;
-	 case 's':	/* override scale */
-	    uscale = atof(*argv+2);
-	    break;
-	 case 'p':	/* output (and by default input) paper type */
-	    if ( (paper = findpaper(*argv+2)) != (Paper *)0 ) {
-	       width = (double)PaperWidth(paper);
-	       height = (double)PaperHeight(paper);
-	    } else
-	       message(FATAL, "paper size '%s' not recognised\n", *argv+2);
-	    break;
-	 case 'P':	/* paper type */
-	    if ( (paper = findpaper(*argv+2)) != (Paper *)0 ) {
-	       iwidth = (double)PaperWidth(paper);
-	       iheight = (double)PaperHeight(paper);
-	    } else
-	       message(FATAL, "paper size '%s' not recognised\n", *argv+2);
-	    break;
-	 case 'n':	/* n-up, for compatibility with other psnups */
-	    if (argc >= 2) {
-	       argv++;
-	       argc--;
-	       if ((nup = atoi(*argv)) < 1)
-		  message(FATAL, "-n %d too small\n", nup);
-	    } else
-	       message(FATAL, "argument expected for -n\n");
-	    break;
-	 case '1':
-	 case '2':
-	 case '3':
-	 case '4':
-	 case '5':
-	 case '6':
-	 case '7':
-	 case '8':
-	 case '9':
-	    nup = atoi(*argv+1);
-	    break;
-	 case 'v':	/* version */
-	 default:
-	    usage();
-	 }
-      } else if (infile == stdin) {
-	 if ((infile = fopen(*argv, OPEN_READ)) == NULL)
-	    message(FATAL, "can't open input file %s\n", *argv);
-      } else if (outfile == stdout) {
-	 if ((outfile = fopen(*argv, OPEN_WRITE)) == NULL)
-	    message(FATAL, "can't open output file %s\n", *argv);
-      } else usage();
+
+   /* Be defensive */
+   if((argc - optind) < 0 || (argc - optind) > 2) usage();
+
+   if (optind != argc) {
+     /* User specified an input file */
+     if ((infile = fopen(argv[optind], OPEN_READ)) == NULL)
+       message(FATAL, "can't open input file %s\n", argv[optind]);
+     optind++;
    }
+
+   if (optind != argc) {
+     /* User specified an output file */
+     if ((outfile = fopen(argv[optind], OPEN_WRITE)) == NULL)
+       message(FATAL, "can't open output file %s\n", argv[optind]);
+     optind++;
+   }
+
+   if (optind != argc) usage();
+
 #if defined(MSDOS) || defined(WINNT)
    if ( infile == stdin ) {
       int fd = fileno(stdin) ;
@@ -215,6 +262,8 @@ void main(int argc, char *argv[])
    if (ppwid <= 0 || pphgt <= 0)
       message(FATAL, "paper margins are too large\n");
 
+   scanpages(sizeheaders);
+
    /* set default values of input height & width */
    if ( iwidth > 0 )
      width = iwidth ;
@@ -328,7 +377,7 @@ void main(int argc, char *argv[])
 	 }
       }
       
-      pstops(nup, 1, 0, specs, draw);		/* do page rearrangement */
+      pstops_write(nup, 1, 0, specs, draw, sizeheaders); /* do page rearrangement */
    }
 
    exit(0);
diff -rupN psutils/psnup.man psutils-new/psnup.man
--- psutils/psnup.man	1997-03-11 23:53:02.000000000 +0100
+++ psutils-new/psnup.man	2014-04-09 19:55:19.695132829 +0200
@@ -61,11 +61,12 @@ to centimeters or inches.
 The 
 .I \-p
 option can be used as an alternative, to set the paper size to
-.B a3, a4, a5, b5, letter, legal, tabloid, statement, executive, folio, quarto
-or
+.B a0, a1, a2, a3, a4, a5, b5, letter, legal, tabloid, statement,
+executive, folio, quarto or
 .B 10x14.
-The default paper size is
-.B @PAPER@.
+The default paper size is normally
+.B @PAPER@,
+but on a Debian system, /etc/papersize is consulted.
 The
 .I \-W, \-H,
 and
diff -rupN psutils/psresize.c psutils-new/psresize.c
--- psutils/psresize.c	1997-03-11 23:53:03.000000000 +0100
+++ psutils-new/psresize.c	2014-04-09 21:19:57.069001335 +0200
@@ -15,11 +15,17 @@
  *              -Ppaper sets the input paper size (width and height) by name
  */
 
+#include <unistd.h>
+
 #include "psutil.h"
 #include "psspec.h"
 #include "pserror.h"
 #include "patchlev.h"
 
+#ifdef DEBIAN
+#include <paper.h>
+#endif
+
 char *program ;
 int pages ;
 int verbose ;
@@ -46,7 +52,8 @@ static void argerror(void)
 #define MIN(x,y) ((x) > (y) ? (y) : (x))
 #define MAX(x,y) ((x) > (y) ? (x) : (y))
 
-void main(int argc, char *argv[])
+int
+main(int argc, char *argv[])
 {
    double scale, rscale;			/* page scale */
    double waste, rwaste;			/* amount wasted */
@@ -54,10 +61,24 @@ void main(int argc, char *argv[])
    int rotate;
    double inwidth = -1;
    double inheight = -1;
-   Paper *paper;
+   off_t sizeheaders[20];			/* headers to remove */
+   Paper *paper = NULL;
    PageSpec *specs;
+   int opt;
 
-#ifdef PAPER
+#ifdef DEBIAN
+   paperinit();
+   {
+     const char *default_size = systempapername();
+     if (!default_size) default_size = defaultpapername ();
+     if (default_size) paper = findpaper(default_size);
+     if (paper) {
+       inwidth = width = (double)PaperWidth(paper);
+       inheight = height = (double)PaperHeight(paper);
+     }
+   }
+   paperdone();
+#elif defined(PAPER)
    if ( (paper = findpaper(PAPER)) != (Paper *)0 ) {
       inwidth = width = (double)PaperWidth(paper);
       inheight = height = (double)PaperHeight(paper);
@@ -67,53 +88,72 @@ void main(int argc, char *argv[])
    vshift = hshift = 0;
    rotate = 0;
 
+   verbose = 1;
+
+
+   program = *argv;
+
+   while((opt = getopt(argc, argv,
+                       "qw:h:p:W:H:P:")) != EOF) {
+     switch(opt) {
+
+     case 'q':	/* quiet */
+       verbose = 0;
+       break;
+     case 'w':	/* page width */
+       width = singledimen(optarg, argerror, usage);
+       break;
+     case 'h':	/* page height */
+       height = singledimen(optarg, argerror, usage);
+       break;
+     case 'p':	/* paper type */
+       if ( (paper = findpaper(optarg)) != (Paper *)0 ) {
+         width = (double)PaperWidth(paper);
+         height = (double)PaperHeight(paper);
+       } else
+         message(FATAL, "paper size '%s' not recognised\n", optarg);
+       break;
+     case 'W':	/* input page width */
+       inwidth = singledimen(optarg, argerror, usage);
+       break;
+     case 'H':	/* input page height */
+       inheight = singledimen(optarg, argerror, usage);
+       break;
+     case 'P':	/* input paper type */
+       if ( (paper = findpaper(optarg)) != (Paper *)0 ) {
+         inwidth = (double)PaperWidth(paper);
+         inheight = (double)PaperHeight(paper);
+       } else
+         message(FATAL, "paper size '%s' not recognised\n", optarg);
+       break;
+     case 'v':	/* version */
+     default:
+       usage();
+     }
+   }
+
    infile = stdin;
    outfile = stdout;
-   verbose = 1;
-   for (program = *argv++; --argc; argv++) {
-      if (argv[0][0] == '-') {
-	 switch (argv[0][1]) {
-	 case 'q':	/* quiet */
-	    verbose = 0;
-	    break;
-	 case 'w':	/* page width */
-	    width = singledimen(*argv+2, argerror, usage);
-	    break;
-	 case 'h':	/* page height */
-	    height = singledimen(*argv+2, argerror, usage);
-	    break;
-	 case 'p':	/* paper type */
-	    if ( (paper = findpaper(*argv+2)) != (Paper *)0 ) {
-	       width = (double)PaperWidth(paper);
-	       height = (double)PaperHeight(paper);
-	    } else
-	       message(FATAL, "paper size '%s' not recognised\n", *argv+2);
-	    break;
-	 case 'W':	/* input page width */
-	    inwidth = singledimen(*argv+2, argerror, usage);
-	    break;
-	 case 'H':	/* input page height */
-	    inheight = singledimen(*argv+2, argerror, usage);
-	    break;
-	 case 'P':	/* input paper type */
-	    if ( (paper = findpaper(*argv+2)) != (Paper *)0 ) {
-	       inwidth = (double)PaperWidth(paper);
-	       inheight = (double)PaperHeight(paper);
-	    } else
-	       message(FATAL, "paper size '%s' not recognised\n", *argv+2);
-	    break;
-	 case 'v':	/* version */
-	 default:
-	    usage();
-	 }
-      } else if (infile == stdin) {
-	 if ((infile = fopen(*argv, OPEN_READ)) == NULL)
-	    message(FATAL, "can't open input file %s\n", *argv);
-      } else if (outfile == stdout) {
-	 if ((outfile = fopen(*argv, OPEN_WRITE)) == NULL)
-	    message(FATAL, "can't open output file %s\n", *argv);
-      } else usage();
+
+   /* Be defensive */
+   if((argc - optind) < 0 || (argc - optind) > 2) usage();
+
+   if (optind != argc) {
+     /* User specified an input file */
+     if ((infile = fopen(argv[optind], OPEN_READ)) == NULL)
+       message(FATAL, "can't open input file %s\n", argv[optind]);
+     optind++;
    }
+
+   if (optind != argc) {
+     /* User specified an output file */
+     if ((outfile = fopen(argv[optind], OPEN_WRITE)) == NULL)
+       message(FATAL, "can't open output file %s\n", argv[optind]);
+     optind++;
+   }
+
+   if (optind != argc) usage();
+
 #if defined(MSDOS) || defined(WINNT)
    if ( infile == stdin ) {
       int fd = fileno(stdin) ;
@@ -132,6 +172,8 @@ void main(int argc, char *argv[])
    if (width <= 0 || height <= 0)
       message(FATAL, "output page width and height must be set\n");
 
+   scanpages(sizeheaders);
+
    if (inwidth <= 0 || inheight <= 0)
       message(FATAL, "input page width and height must be set\n");
 
@@ -173,7 +215,7 @@ void main(int argc, char *argv[])
    specs->yoff = vshift;
    specs->flags |= OFFSET;
       
-   pstops(1, 1, 0, specs, 0.0);		/* do page rearrangement */
+   pstops_write(1, 1, 0, specs, 0.0, sizeheaders); /* do page rearrangement */
 
    exit(0);
 }
diff -rupN psutils/psresize.man psutils-new/psresize.man
--- psutils/psresize.man	1997-03-11 23:53:03.000000000 +0100
+++ psutils-new/psresize.man	2014-04-09 19:55:19.699132829 +0200
@@ -1,6 +1,6 @@
 .TH PSRESIZE 1 "PSUtils Release @RELEASE@ Patchlevel @PATCHLEVEL@"
 .SH NAME
-psresize \- multiple pages per sheet
+psresize \- rescales and centers a document for new output paper size
 .SH SYNOPSIS
 .B psresize
 [
@@ -42,8 +42,8 @@ to centimeters or inches.
 The 
 .I \-p
 option can be used as an alternative, to set the output paper size to
-.B a3, a4, a5, b5, letter, legal, tabloid, statement, executive, folio, quarto
-or
+.B a0, a1, a2, a3, a4, a5, b5, letter, legal, tabloid, statement,
+executive, folio, quarto or
 .B 10x14.
 The default output paper size is
 .B @PAPER@.
diff -rupN psutils/psselect.c psutils-new/psselect.c
--- psutils/psselect.c	1997-03-11 23:53:03.000000000 +0100
+++ psutils-new/psselect.c	2014-04-09 20:01:32.286123179 +0200
@@ -11,12 +11,13 @@
 #include "psutil.h"
 #include "pserror.h"
 #include "patchlev.h"
+#include <unistd.h>
 
 char *program ;
 int pages ;
 int verbose ;
-FILE *infile ;
-FILE *outfile ;
+FILE *infile;
+FILE *outfile;
 char pagelabel[BUFSIZ] ;
 int pageno ;
 
@@ -52,6 +53,9 @@ static PageRange *addrange(char *str, Pa
 {
    int first=0;
    int sign;
+
+   if(!str) return NULL;
+
    sign = (*str == '_' && ++str) ? -1 : 1;
    if (isdigit(*str)) {
       first = sign*atoi(str);
@@ -91,48 +95,70 @@ static PageRange *addrange(char *str, Pa
 }
 
 
-void main(int argc, char *argv[])
+int
+main(int argc, char *argv[])
 {
+   int opt;
    int currentpg, maxpage = 0;
    int even = 0, odd = 0, reverse = 0;
    int pass, all;
    PageRange *pagerange = NULL;
 
+   verbose = 1;
+   program = *argv;
+
+   while((opt = getopt(argc, argv, "eorqvp:")) != EOF) {
+     switch(opt) {
+     case 'e':	/* even pages */
+       even = 1;
+       break;
+     case 'o':	/* odd pages */
+       odd = 1;
+       break;
+     case 'r':	/* reverse */
+       reverse = 1;
+       break;
+     case 'p':	/* page spec */
+       pagerange = addrange(optarg, pagerange);
+       break;
+     case 'q':	/* quiet */
+       verbose = 0;
+       break;
+     case 'v':	/* version */
+     default:
+       usage();
+       break;
+     }
+   }
+
    infile = stdin;
    outfile = stdout;
-   verbose = 1;
-   for (program = *argv++; --argc; argv++) {
-      if (argv[0][0] == '-') {
-	 switch (argv[0][1]) {
-	 case 'e':	/* even pages */
-	    even = 1;
-	    break;
-	 case 'o':	/* odd pages */
-	    odd = 1;
-	    break;
-	 case 'r':	/* reverse */
-	    reverse = 1;
-	    break;
-	 case 'p':	/* page spec */
-	    pagerange = addrange(*argv+2, pagerange);
-	    break;
-	 case 'q':	/* quiet */
-	    verbose = 0;
-	    break;
-	 case 'v':	/* version */
-	 default:
-	    usage();
-	 }
-      } else if (pagerange == NULL && !reverse && !even && !odd) {
-	 pagerange = addrange(*argv, NULL);
-      } else if (infile == stdin) {
-	 if ((infile = fopen(*argv, OPEN_READ)) == NULL)
-	    message(FATAL, "can't open input file %s\n", *argv);
-      } else if (outfile == stdout) {
-	 if ((outfile = fopen(*argv, OPEN_WRITE)) == NULL)
-	    message(FATAL, "can't open output file %s\n", *argv);
-      } else usage();
+
+   /* If we haven't gotten a page range yet, we better get one now */
+   if (pagerange == NULL && !reverse && !even && !odd) {
+     pagerange = addrange(argv[optind], NULL);
+     optind++;
    }
+
+   /* Be defensive */
+   if((argc - optind) < 0 || (argc - optind) > 2) usage();
+
+   if (optind != argc) {
+     /* User specified an input file */
+     if ((infile = fopen(argv[optind], OPEN_READ)) == NULL)
+       message(FATAL, "can't open input file %s\n", argv[optind]);
+     optind++;
+   }
+
+   if (optind != argc) {
+     /* User specified an output file */
+     if ((outfile = fopen(argv[optind], OPEN_WRITE)) == NULL)
+       message(FATAL, "can't open output file %s\n", argv[optind]);
+     optind++;
+   }
+
+   if(optind != argc) usage();
+
 #if defined(MSDOS) || defined(WINNT)
    if ( infile == stdin ) {
       int fd = fileno(stdin) ;
@@ -145,10 +171,11 @@ void main(int argc, char *argv[])
          message(FATAL, "can't reset stdout to binary mode\n");
     }
 #endif
+
    if ((infile=seekable(infile))==NULL)
       message(FATAL, "can't seek input\n");
 
-   scanpages();
+   scanpages(NULL);
 
    /* select all pages or all in range if odd or even not set */
    all = !(odd || even);
@@ -197,7 +224,7 @@ void main(int argc, char *argv[])
    for (pass = 0; pass < 2; pass++) {
       PageRange *r;
       if (pass) {                           /* write header on second pass */
-	 writeheader(maxpage);
+	 writeheader(maxpage, NULL);
 	 writeprolog();
 	 writesetup();
       }
diff -rupN psutils/psspec.c psutils-new/psspec.c
--- psutils/psspec.c	1997-03-11 23:53:04.000000000 +0100
+++ psutils-new/psspec.c	2014-04-09 21:23:02.236996540 +0200
@@ -22,6 +22,8 @@ PageSpec *newspec(void)
    if (temp == NULL)
       message(FATAL, "out of memory\n");
    temp->reversed = temp->pageno = temp->flags = temp->rotate = 0;
+   temp->hflip = 0;
+   temp->vflip = 0;
    temp->scale = 1;
    temp->xoff = temp->yoff = 0;
    temp->next = NULL;
@@ -93,10 +95,13 @@ double singledimen(char *str, void (*err
 
 static char *prologue[] = { /* PStoPS procset */
 #ifndef SHOWPAGE_LOAD
+   /* Wrap these up with our own versions.  We have to  */
    "userdict begin",
-   "[/showpage/erasepage/copypage]{dup where{pop dup load",	/* prevent */
-   " type/operatortype eq{1 array cvx dup 0 3 index cvx put",	/* binding */
-   " bind def}{pop}ifelse}{pop}ifelse}forall",			/* in prolog */
+   "[/showpage/erasepage/copypage]{dup where{pop dup load",
+   " type/operatortype eq{ /PStoPSenablepage cvx 1 index"
+   " load 1 array astore cvx {} bind /ifelse cvx 4 array"
+   " astore cvx def}{pop}ifelse}{pop}ifelse}forall"
+   " /PStoPSenablepage true def",
 #else
    "userdict begin",
    "[/showpage/copypage/erasepage]{dup 10 string cvs dup",
@@ -134,18 +139,22 @@ static char *prologue[] = { /* PStoPS pr
    NULL
    };
 
-void pstops(int modulo, int pps, int nobind, PageSpec *specs, double draw)
+void pstops(int modulo, int pps, int nobind, PageSpec *specs, double draw) {
+
+  scanpages(NULL);
+  pstops_write(modulo, pps, nobind, specs, draw, NULL);
+}
+
+void pstops_write(int modulo, int pps, int nobind, PageSpec *specs, double draw, off_t *ignorelist)
 {
    int thispg, maxpage;
    int pageindex = 0;
    char **pro;
 
-   scanpages();
-
    maxpage = ((pages+modulo-1)/modulo)*modulo;
 
    /* rearrange pages: doesn't cope properly with loaded definitions */
-   writeheader((maxpage/modulo)*pps);
+   writeheadermedia((maxpage/modulo)*pps, ignorelist, width, height);
 #ifndef SHOWPAGE_LOAD
    writestring("%%BeginProcSet: PStoPS");
 #else
@@ -208,6 +217,14 @@ void pstops(int modulo, int pps, int nob
 	       sprintf(buffer, "%d rotate\n", ps->rotate);
 	       writestring(buffer);
 	    }
+	    if ((ps->flags & HFLIP) && (ps->hflip%2)) {
+	       sprintf(buffer, "[ -1 0 0 1 %f 0 ] concat\n", width*ps->scale);
+	       writestring(buffer);
+	    }
+	    if ((ps->flags & VFLIP) && (ps->vflip%2)) {
+	       sprintf(buffer, "[ 1 0 0 -1 0 %f ] concat\n", height*ps->scale);
+	       writestring(buffer);
+	    }
 	    if (ps->flags & SCALE) {
 	       sprintf(buffer, "%f dup scale\n", ps->scale);
 	       writestring(buffer);
@@ -228,7 +245,7 @@ void pstops(int modulo, int pps, int nob
 	 }
 	 if (add_next) {
 #ifndef SHOWPAGE_LOAD
-	    writestring("/showpage{}def/copypage{}def/erasepage{}def\n");
+	    writestring("/PStoPSenablepage false def\n");
 #else
 	    writestring("/PStoPSshowpage{}store/PStoPScopypage{}store/PStoPSerasepage{}store\n");
 #endif
diff -rupN psutils/psspec.h psutils-new/psspec.h
--- psutils/psspec.h	1997-03-11 23:53:04.000000000 +0100
+++ psutils-new/psspec.h	2014-04-09 21:23:02.235996540 +0200
@@ -8,12 +8,14 @@
 /* pagespec flags */
 #define ADD_NEXT (0x01)
 #define ROTATE   (0x02)
-#define SCALE    (0x04)
-#define OFFSET   (0x08)
-#define GSAVE    (ROTATE|SCALE|OFFSET)
+#define HFLIP    (0x04)
+#define VFLIP    (0x08)
+#define SCALE    (0x10)
+#define OFFSET   (0x20)
+#define GSAVE    (ROTATE|HFLIP|VFLIP|SCALE|OFFSET)
 
 typedef struct pagespec {
-   int reversed, pageno, flags, rotate;
+   int reversed, pageno, flags, rotate, hflip, vflip;
    double xoff, yoff, scale;
    struct pagespec *next;
 } PageSpec ;
@@ -28,3 +30,5 @@ extern double singledimen(char *str, voi
 			  void (*usagefn)(void));
 extern void pstops(int modulo, int pps, int nobind, PageSpec *specs,
 		   double draw);
+extern void pstops_write(int modulo, int pps, int nobind, PageSpec *specs,
+                         double draw, off_t *ignorelist);
diff -rupN psutils/pstops.c psutils-new/pstops.c
--- psutils/pstops.c	1997-03-11 23:53:04.000000000 +0100
+++ psutils-new/pstops.c	2014-04-09 21:23:02.234996540 +0200
@@ -8,11 +8,18 @@
  *       pstops [-q] [-b] [-d] [-w<dim>] [-h<dim>] [-ppaper] <pagespecs> [infile [outfile]]
  */
 
+#include <unistd.h>
+#include <string.h>
+
 #include "psutil.h"
 #include "psspec.h"
 #include "pserror.h"
 #include "patchlev.h"
 
+#ifdef DEBIAN
+#include <paper.h>
+#endif
+
 char *program ;
 int pages ;
 int verbose ;
@@ -35,7 +42,7 @@ static void argerror(void)
 {
    fprintf(stderr, "%s: page specification error:\n", program);
    fprintf(stderr, "  <pagespecs> = [modulo:]<spec>\n");
-   fprintf(stderr, "  <spec>      = [-]pageno[@scale][L|R|U][(xoff,yoff)][,spec|+spec]\n");
+   fprintf(stderr, "  <spec>      = [-]pageno[@scale][L|R|U|H|V][(xoff,yoff)][,spec|+spec]\n");
    fprintf(stderr, "                modulo>=1, 0<=pageno<modulo\n");
    fflush(stderr);
    exit(1);
@@ -47,8 +54,8 @@ static int pagesperspec = 1;
 static PageSpec *parsespecs(char *str)
 {
    PageSpec *head, *tail;
-   int other = 0;
-   int num = -1;
+   unsigned long spec_count = 0;
+   long num = -1;
 
    head = tail = newspec();
    while (*str) {
@@ -57,7 +64,7 @@ static PageSpec *parsespecs(char *str)
       } else {
 	 switch (*str++) {
 	 case ':':
-	    if (other || head != tail || num < 1) argerror();
+	    if (spec_count || head != tail || num < 1) argerror();
 	    modulo = num;
 	    num = -1;
 	    break;
@@ -65,10 +72,9 @@ static PageSpec *parsespecs(char *str)
 	    tail->reversed = !tail->reversed;
 	    break;
 	 case '@':
-	    if (num < 0) argerror();
-	    tail->scale *= parsedouble(&str, argerror);
-	    tail->flags |= SCALE;
-	    break;
+            tail->scale *= parsedouble(&str, argerror);
+            tail->flags |= SCALE;
+           break;
 	 case 'l': case 'L':
 	    tail->rotate += 90;
 	    tail->flags |= ROTATE;
@@ -81,6 +87,14 @@ static PageSpec *parsespecs(char *str)
 	    tail->rotate += 180;
 	    tail->flags |= ROTATE;
 	    break;
+	 case 'h': case 'H':
+	    tail->hflip += 1;
+	    tail->flags |= HFLIP;
+	    break;
+	 case 'v': case 'V':
+	    tail->vflip += 1;
+	    tail->flags |= VFLIP;
+	    break;
 	 case '(':
 	    tail->xoff += parsedimen(&str, argerror);
 	    if (*str++ != ',') argerror();
@@ -102,7 +116,7 @@ static PageSpec *parsespecs(char *str)
 	 default:
 	    argerror();
 	 }
-	 other = 1;
+	 spec_count++;
       }
    }
    if (num >= modulo)
@@ -112,71 +126,124 @@ static PageSpec *parsespecs(char *str)
    return (head);
 }
 
-void main(int argc, char *argv[])
+int
+main(int argc, char *argv[])
 {
    PageSpec *specs = NULL;
    int nobinding = 0;
    double draw = 0;
-   Paper *paper;
+   Paper *paper = NULL;
+   int opt;
 
-#ifdef PAPER
+#ifdef DEBIAN
+   paperinit();
+   {
+     const char *default_size = systempapername();
+     if (!default_size) default_size = defaultpapername ();
+     if (default_size) paper = findpaper(default_size);
+     if (paper) {
+       width = (double)PaperWidth(paper);
+       height = (double)PaperHeight(paper);
+     }
+   }
+   paperdone();
+#elif defined(PAPER)
    if ( (paper = findpaper(PAPER)) != (Paper *)0 ) {
       width = (double)PaperWidth(paper);
       height = (double)PaperHeight(paper);
    }
 #endif
 
+   verbose = 1;
+
+   program = *argv;
+
+   while((opt = getopt(argc, argv, "qd::bw:h:p:v0123456789")) != EOF) {
+     switch(opt) {
+     case 'q':	/* quiet */
+       verbose = 0;
+       break;
+     case 'd':	/* draw borders */
+       if(optarg)
+         draw = singledimen(optarg, argerror, usage);
+       else
+         draw = 1;
+       break;
+     case 'b':	/* no bind operator */
+       nobinding = 1;
+       break;
+     case 'w':	/* page width */
+       width = singledimen(optarg, argerror, usage);
+       break;
+     case 'h':	/* page height */
+       height = singledimen(optarg, argerror, usage);
+       break;
+     case 'p':	/* paper type */
+       if ( (paper = findpaper(optarg)) != (Paper *)0 ) {
+         width = (double)PaperWidth(paper);
+         height = (double)PaperHeight(paper);
+       } else
+         message(FATAL, "paper size '%s' not recognised\n", optarg);
+       break;
+     case 'v':	/* version */
+       usage();
+     case '0':
+     case '1':
+     case '2':
+     case '3':
+     case '4':
+     case '5':
+     case '6':
+     case '7':
+     case '8':
+     case '9':
+       if (specs == NULL) {
+         char *spec_txt = alloca((optarg ? strlen(optarg) : 0) + 3);
+         if(!spec_txt) message(FATAL, "no memory for spec allocation\n");
+         spec_txt[0] = '-';
+         spec_txt[1] = opt;
+         spec_txt[2] = 0;
+         if (optarg) strcat(spec_txt, optarg);
+         specs = parsespecs(spec_txt);
+       } else {
+         usage();
+       }
+       break;
+     default:
+       usage();
+       break;
+     }
+   }
+
+   if (specs == NULL) {
+     if(optind == argc) usage();
+     specs = parsespecs(argv[optind]);
+     optind++;
+   }
+
    infile = stdin;
    outfile = stdout;
-   verbose = 1;
-   for (program = *argv++; --argc; argv++) {
-      if (argv[0][0] == '-') {
-	 switch (argv[0][1]) {
-	 case 'q':	/* quiet */
-	    verbose = 0;
-	    break;
-	 case 'd':	/* draw borders */
-	    if (argv[0][2])
-	       draw = singledimen(*argv+2, argerror, usage);
-	    else
-	       draw = 1;
-	    break;
-	 case 'b':	/* no bind operator */
-	    nobinding = 1;
-	    break;
-	 case 'w':	/* page width */
-	    width = singledimen(*argv+2, argerror, usage);
-	    break;
-	 case 'h':	/* page height */
-	    height = singledimen(*argv+2, argerror, usage);
-	    break;
-	 case 'p':	/* paper type */
-	    if ( (paper = findpaper(*argv+2)) != (Paper *)0 ) {
-	       width = (double)PaperWidth(paper);
-	       height = (double)PaperHeight(paper);
-	    } else
-	      message(FATAL, "paper size '%s' not recognised\n", *argv+2);
-	    break;
-	 case 'v':	/* version */
-	    usage();
-	 default:
-	    if (specs == NULL)
-	       specs = parsespecs(*argv);
-	    else
-	       usage();
-	 }
-      } else if (specs == NULL)
-	 specs = parsespecs(*argv);
-      else if (infile == stdin) {
-	 if ((infile = fopen(*argv, OPEN_READ)) == NULL)
-	    message(FATAL, "can't open input file %s\n", *argv);
-      } else if (outfile == stdout) {
-	 if ((outfile = fopen(*argv, OPEN_WRITE)) == NULL)
-	    message(FATAL, "can't open output file %s\n", *argv);
-      } else usage();
+
+   /* Be defensive */
+   if((argc - optind) < 0 || (argc - optind) > 2) usage();
+
+   if (optind != argc) {
+     /* User specified an input file */
+     if ((infile = fopen(argv[optind], OPEN_READ)) == NULL)
+       message(FATAL, "can't open input file %s\n", argv[optind]);
+     optind++;
+   }
+
+   if (optind != argc) {
+     /* User specified an output file */
+     if ((outfile = fopen(argv[optind], OPEN_WRITE)) == NULL)
+       message(FATAL, "can't open output file %s\n", argv[optind]);
+     optind++;
    }
-   if (specs == NULL)
-      usage();
+
+   if (optind != argc) usage();
+   if (specs == NULL) usage();
+
 #if defined(MSDOS) || defined(WINNT)
    if ( infile == stdin ) {
       int fd = fileno(stdin) ;
diff -rupN psutils/pstops.man psutils-new/pstops.man
--- psutils/pstops.man	1997-03-11 23:53:04.000000000 +0100
+++ psutils-new/pstops.man	2014-04-09 21:23:02.236996540 +0200
@@ -43,7 +43,7 @@ follow the syntax:
 .I = spec[+specs][,specs]
 .TP
 .I spec
-.I = [-]pageno[L][R][U][@scale][(xoff,yoff)]
+.I = [-]pageno[L][R][U][H][V][@scale][(xoff,yoff)]
 .RE
 .sp
 .I modulo
@@ -74,8 +74,9 @@ to convert to centimetres or inches, or
 or
 .B "h"
 to specify as a multiple of the width or height.
-The optional parameters \fIL\fR, \fIR\fR, and \fIU\fR rotate the page left,
-right, or upside-down.
+The optional parameters \fIL\fR, \fIR\fR, \fIU\fR, \fIH\fR and \fIV\fR
+rotate the page left, right, or upside-down, and flip (mirror) page
+horizontally or vertically.
 The optional
 .I scale
 parameter scales the page by the fraction specified.
@@ -85,15 +86,20 @@ the document, instead of the start.
 If page \fIspec\fRs are separated by
 .B \+
 the pages will be merged into one page; if they are separated by
-.B \,
+.B ,
 they will be on separate pages.
 If there is only one page specification, with
 .I pageno
 zero, the \fIpageno\fR may be omitted.
 
-The shift, rotation, and scaling are performed
+The shift, rotation, and scaling are applied
+to the PostScript transformation matrix
 in that order regardless of which order
 they appear on the command line.
+The matrix accumulates the individual transformations.
+The effect on the image is to first scale with respect to an origin
+at the lower left corner, then rotate about the same origin, and
+finally shift.
 .PP
 The
 .I \-w
@@ -108,8 +114,8 @@ clipping path for each page.
 The 
 .I \-p
 option can be used as an alternative, to set the paper size to
-.B a3, a4, a5, b5, letter, legal, tabloid, statement, executive, folio, quarto
-or
+.B a0, a1, a2, a3, a4, a5, b5, letter, legal, tabloid, statement,
+executive, folio, quarto or
 .B 10x14.
 The default paper size is
 .B @PAPER@.
@@ -136,7 +142,7 @@ This section contains some sample re-arr
 sheet (of A4 paper), the pagespec to use is:
 .sp
 .ce
-2:0L@.7(21cm,0)+1L@.7(21cm,14.85cm)
+"2:0L@.7(21cm,0)+1L@.7(21cm,14.85cm)"
 .sp
 To select all of the odd pages in reverse order, use:
 .sp
@@ -146,12 +152,12 @@ To select all of the odd pages in revers
 To re-arrange pages for printing 2-up booklets, use
 .sp
 .ce
-4:-3L@.7(21cm,0)+0L@.7(21cm,14.85cm)
+"4:-3L@.7(21cm,0)+0L@.7(21cm,14.85cm)"
 .sp
 for the front sides, and
 .sp
 .ce
-4:1L@.7(21cm,0)+-2L@.7(21cm,14.85cm)
+"4:1L@.7(21cm,0)+-2L@.7(21cm,14.85cm)"
 .sp
 for the reverse sides (or join them with a comma for duplex printing).
 .SH AUTHOR
diff -rupN psutils/psutil.c psutils-new/psutil.c
--- psutils/psutil.c	1997-03-11 23:53:04.000000000 +0100
+++ psutils-new/psutil.c	2014-04-09 21:19:57.065001335 +0200
@@ -5,7 +5,10 @@
  * utilities for PS programs
  */
 
+
 /*
+ *  Daniele Giacomini appunti2@gmail.com 2010-09-02
+ *    Changed to using ftello() and fseeko()
  *  AJCD 6/4/93
  *    Changed to using ftell() and fseek() only (no length calculations)
  *  Hunter Goatley    31-MAY-1993 23:33
@@ -13,6 +16,9 @@
  *  Hunter Goatley     2-MAR-1993 14:41
  *    Added VMS support.
  */
+
+#define _FILE_OFFSET_BITS 64
+
 #include "psutil.h"
 #include "pserror.h"
 #include "patchlev.h"
@@ -20,6 +26,7 @@
 #include <string.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <stdio.h>
 
 #define iscomment(x,y) (strncmp(x,y,strlen(y)) == 0)
 
@@ -33,21 +40,27 @@ extern int pageno;
 
 static char buffer[BUFSIZ];
 static long bytes = 0;
-static long pagescmt = 0;
-static long headerpos = 0;
-static long endsetup = 0;
-static long beginprocset = 0;		/* start of pstops procset */
-static long endprocset = 0;
+static off_t pagescmt = 0;
+static off_t headerpos = 0;
+static off_t endsetup = 0;
+static off_t beginprocset = 0;		/* start of pstops procset */
+static off_t endprocset = 0;
 static int outputpage = 0;
 static int maxpages = 100;
-static long *pageptr;
+static off_t *pageptr;
 
 /* list of paper sizes supported */
 static Paper papersizes[] = {
+   { "a0", 2382, 3369 },	/* 84cm * 118.8cm */
+   { "a1", 1684, 2382 },	/* 59.4cm * 84cm */
+   { "a2", 1191, 1684 },	/* 42cm * 59.4cm */
    { "a3", 842, 1191 },		/* 29.7cm * 42cm */
    { "a4", 595, 842 },		/* 21cm * 29.7cm */
    { "a5", 421, 595 },		/* 14.85cm * 21cm */
    { "b5", 516, 729 },		/* 18.2cm * 25.72cm */
+   { "A0", 2382, 3369 },	/* 84cm * 118.8cm */
+   { "A1", 1684, 2382 },	/* 59.4cm * 84cm */
+   { "A2", 1191, 1684 },	/* 42cm * 59.4cm */
    { "A3", 842, 1191 },		/* 29.7cm * 42cm */
    { "A4", 595, 842 },		/* 21cm * 29.7cm */
    { "A5", 421, 595 },		/* 14.85cm * 21cm */
@@ -65,7 +78,7 @@ static Paper papersizes[] = {
 };
 
 /* return pointer to paper size struct or NULL */
-Paper* findpaper(char *name)
+Paper* findpaper(const char *name)
 {
    Paper *pp;
    for (pp = papersizes; PaperName(pp); pp++) {
@@ -88,15 +101,15 @@ FILE *seekable(FILE *fp)
 #if defined(WINNT)
   struct _stat fs ;
 #else
-  long fpos;
+  off_t fpos;
 #endif
 
 #if defined(WINNT)
   if (_fstat(fileno(fp), &fs) == 0 && (fs.st_mode&_S_IFREG) != 0)
     return (fp);
 #else
-  if ((fpos = ftell(fp)) >= 0)
-    if (!fseek(fp, 0L, SEEK_END) && !fseek(fp, fpos, SEEK_SET))
+  if ((fpos = ftello(fp)) >= 0)
+    if (!fseeko(fp, (off_t) 0, SEEK_END) && !fseeko(fp, fpos, SEEK_SET))
       return (fp);
 #endif
 
@@ -121,7 +134,7 @@ FILE *seekable(FILE *fp)
 
   /* discard the input file, and rewind the temporary */
   (void) fclose(fp);
-  if (fseek(ft, 0L, SEEK_SET) != 0)
+  if (fseeko(ft, (off_t) 0, SEEK_SET) != 0)
     return (NULL) ;
 
   return (ft);
@@ -129,46 +142,91 @@ FILE *seekable(FILE *fp)
 }
 
 
-/* copy input file from current position upto new position to output file */
-static int fcopy(long upto)
-{
-   long here = ftell(infile);
-   while (here < upto) {
-      if ((fgets(buffer, BUFSIZ, infile) == NULL) ||
-	  (fputs(buffer, outfile) == EOF))
-	 return(0);
-      here = ftell(infile);
-      bytes += strlen(buffer);
-   }
-   return (1);
+/* copy input file from current position upto new position to output file,
+ * ignoring the lines starting at something ignorelist points to */
+static int fcopy(off_t upto, off_t *ignorelist)
+{
+  off_t here = ftello(infile);
+  off_t bytes_left;
+
+  if (ignorelist != NULL) {
+    while (*ignorelist > 0 && *ignorelist < here)
+      ignorelist++;
+
+    while (*ignorelist > 0 && *ignorelist < upto) {
+      int r = fcopy(*ignorelist, NULL);
+      if (!r || fgets(buffer, BUFSIZ, infile) == NULL)
+	return 0;
+      ignorelist++;
+      here = ftello(infile);
+      while (*ignorelist > 0 && *ignorelist < here)
+	ignorelist++;
+    }
+  }
+  bytes_left = upto - here;
+
+  while (bytes_left > 0) {
+    size_t rw_result;
+    const size_t numtocopy = (bytes_left > BUFSIZ) ? BUFSIZ : bytes_left;
+    rw_result = fread(buffer, 1, numtocopy, infile);
+    if (rw_result < numtocopy) return (0);
+    rw_result = fwrite(buffer, 1, numtocopy, outfile);
+    if (rw_result < numtocopy) return (0);
+    bytes_left -= numtocopy;
+    bytes += numtocopy;
+  }
+  return (1);
 }
 
 /* build array of pointers to start/end of pages */
-void scanpages(void)
+void scanpages(off_t *sizeheaders)
 {
    register char *comment = buffer+2;
    register int nesting = 0;
-   register long int record;
+   register off_t record;
+
+   if (sizeheaders)
+     *sizeheaders = 0;
 
-   if ((pageptr = (long *)malloc(sizeof(long)*maxpages)) == NULL)
+   if ((pageptr = (off_t *)malloc(sizeof(off_t)*maxpages)) == NULL)
       message(FATAL, "out of memory\n");
    pages = 0;
-   fseek(infile, 0L, SEEK_SET);
-   while (record = ftell(infile), fgets(buffer, BUFSIZ, infile) != NULL)
+   fseeko(infile, (off_t) 0, SEEK_SET);
+   while (record = ftello(infile), fgets(buffer, BUFSIZ, infile) != NULL)
       if (*buffer == '%') {
 	 if (buffer[1] == '%') {
 	    if (nesting == 0 && iscomment(comment, "Page:")) {
 	       if (pages >= maxpages-1) {
 		  maxpages *= 2;
-		  if ((pageptr = (long *)realloc((char *)pageptr,
-					     sizeof(long)*maxpages)) == NULL)
+		  if ((pageptr = (off_t *)realloc((char *)pageptr,
+					     sizeof(off_t)*maxpages)) == NULL)
 		     message(FATAL, "out of memory\n");
 	       }
 	       pageptr[pages++] = record;
+	    } else if (headerpos == 0 && iscomment(comment, "BoundingBox:")) {
+	       if (sizeheaders) {
+		  *(sizeheaders++) = record;
+		  *sizeheaders = 0;
+	       }
+	    } else if (headerpos == 0 && iscomment(comment, "HiResBoundingBox:")) {
+	       if (sizeheaders) {
+		  *(sizeheaders++) = record;
+		  *sizeheaders = 0;
+	       }
+	    } else if (headerpos == 0 && iscomment(comment,"DocumentPaperSizes:")) {
+	       if (sizeheaders) {
+		  *(sizeheaders++) = record;
+		  *sizeheaders = 0;
+	       }
+	    } else if (headerpos == 0 && iscomment(comment,"DocumentMedia:")) {
+	       if (sizeheaders) {
+		  *(sizeheaders++) = record;
+		  *sizeheaders = 0;
+	       }
 	    } else if (headerpos == 0 && iscomment(comment, "Pages:"))
 	       pagescmt = record;
 	    else if (headerpos == 0 && iscomment(comment, "EndComments"))
-	       headerpos = ftell(infile);
+	       headerpos = ftello(infile);
 	    else if (iscomment(comment, "BeginDocument") ||
 		     iscomment(comment, "BeginBinary") ||
 		     iscomment(comment, "BeginFile"))
@@ -180,23 +238,23 @@ void scanpages(void)
 	    else if (nesting == 0 && iscomment(comment, "EndSetup"))
 	       endsetup = record;
 	    else if (nesting == 0 && iscomment(comment, "BeginProlog"))
-	       headerpos = ftell(infile);
+	       headerpos = ftello(infile);
 	    else if (nesting == 0 &&
 		       iscomment(comment, "BeginProcSet: PStoPS"))
 	       beginprocset = record;
 	    else if (beginprocset && !endprocset &&
 		     iscomment(comment, "EndProcSet"))
-	       endprocset = ftell(infile);
+	       endprocset = ftello(infile);
 	    else if (nesting == 0 && (iscomment(comment, "Trailer") ||
 				      iscomment(comment, "EOF"))) {
-	       fseek(infile, record, SEEK_SET);
+	       fseeko(infile, record, SEEK_SET);
 	       break;
 	    }
 	 } else if (headerpos == 0 && buffer[1] != '!')
 	    headerpos = record;
       } else if (headerpos == 0)
 	 headerpos = record;
-   pageptr[pages] = ftell(infile);
+   pageptr[pages] = ftello(infile);
    if (endsetup == 0 || endsetup > pageptr[0])
       endsetup = pageptr[0];
 }
@@ -204,7 +262,7 @@ void scanpages(void)
 /* seek a particular page */
 void seekpage(int p)
 {
-   fseek(infile, pageptr[p], SEEK_SET);
+   fseeko(infile, pageptr[p], SEEK_SET);
    if (fgets(buffer, BUFSIZ, infile) != NULL &&
        iscomment(buffer, "%%Page:")) {
       char *start, *end;
@@ -268,7 +326,7 @@ void writepagesetup(void)
 /* write the body of a page */
 void writepagebody(int p)
 {
-   if (!fcopy(pageptr[p+1]))
+   if (!fcopy(pageptr[p+1], NULL))
       message(FATAL, "I/O error writing page %d\n", outputpage);
 }
 
@@ -281,26 +339,37 @@ void writepage(int p)
 }
 
 /* write from start of file to end of header comments */
-void writeheader(int p)
+void writeheader(int p, off_t *ignore)
 {
-   fseek(infile, 0L, SEEK_SET);
+   writeheadermedia(p, ignore, -1, -1);
+}
+
+void writeheadermedia(int p, off_t *ignore, double width, double height)
+{
+    fseeko(infile, (off_t) 0, SEEK_SET);
    if (pagescmt) {
-      if (!fcopy(pagescmt) || fgets(buffer, BUFSIZ, infile) == NULL)
+      if (!fcopy(pagescmt, ignore) || fgets(buffer, BUFSIZ, infile) == NULL)
 	 message(FATAL, "I/O error in header\n");
+      if (width > -1 && height > -1) {
+         sprintf(buffer, "%%%%DocumentMedia: plain %d %d 0 () ()\n", (int) width, (int) height);
+         writestring(buffer);
+         sprintf(buffer, "%%%%BoundingBox: 0 0 %d %d\n", (int) width, (int) height);
+         writestring(buffer);
+      }
       sprintf(buffer, "%%%%Pages: %d 0\n", p);
       writestring(buffer);
    }
-   if (!fcopy(headerpos))
+   if (!fcopy(headerpos, ignore))
       message(FATAL, "I/O error in header\n");
 }
 
 /* write prologue to end of setup section excluding PStoPS procset */
 int writepartprolog(void)
 {
-   if (beginprocset && !fcopy(beginprocset))
+   if (beginprocset && !fcopy(beginprocset, NULL))
       message(FATAL, "I/O error in prologue\n");
    if (endprocset)
-      fseek(infile, endprocset, SEEK_SET);
+      fseeko(infile, endprocset, SEEK_SET);
    writeprolog();
    return !beginprocset;
 }
@@ -308,21 +377,21 @@ int writepartprolog(void)
 /* write prologue up to end of setup section */
 void writeprolog(void)
 {
-   if (!fcopy(endsetup))
+   if (!fcopy(endsetup, NULL))
       message(FATAL, "I/O error in prologue\n");
 }
 
 /* write from end of setup to start of pages */
 void writesetup(void)
 {
-   if (!fcopy(pageptr[0]))
+   if (!fcopy(pageptr[0], NULL))
       message(FATAL, "I/O error in prologue\n");
 }
 
 /* write trailer */
 void writetrailer(void)
 {
-   fseek(infile, pageptr[pages], SEEK_SET);
+   fseeko(infile, pageptr[pages], SEEK_SET);
    while (fgets(buffer, BUFSIZ, infile) != NULL) {
       writestring(buffer);
    }
diff -rupN psutils/psutil.h psutils-new/psutil.h
--- psutils/psutil.h	1997-03-11 23:53:04.000000000 +0100
+++ psutils-new/psutil.h	2014-04-09 21:19:57.066001335 +0200
@@ -4,7 +4,7 @@
  *
  * utilities for PS programs
  */
-
+#define _FILE_OFFSET_BITS 64
 #include <stdio.h>
 #include <stdlib.h>
 #include <ctype.h>
@@ -25,20 +25,21 @@ typedef struct papersize {
 #define PaperHeight(p) ((p)->height)
 
 /* Definitions for functions found in psutil.c */
-extern Paper *findpaper(char *name);
+extern Paper *findpaper(const char *name);
 extern FILE *seekable(FILE *fp);
 extern void writepage(int p);
 extern void seekpage(int p);
 extern void writepageheader(char *label, int p);
 extern void writepagesetup(void);
 extern void writepagebody(int p);
-extern void writeheader(int p);
+extern void writeheader(int p, off_t *ignorelist);
+extern void writeheadermedia(int p, off_t *ignorelist, double width, double height);
 extern int writepartprolog(void);
 extern void writeprolog(void);
 extern void writesetup(void);
 extern void writetrailer(void);
 extern void writeemptypage(void);
-extern void scanpages(void);
+extern void scanpages(off_t *sizeheaders);
 extern void writestring(char *s);
 
 /* These variables are imported from the client program (e.g. psbook, psnup,
diff -rupN psutils/showchar.man psutils-new/showchar.man
--- psutils/showchar.man	1970-01-01 01:00:00.000000000 +0100
+++ psutils-new/showchar.man	2014-04-09 21:18:34.694003468 +0200
@@ -0,0 +1,26 @@
+.TH SHOWCHAR 1 "PSUtils Release @RELEASE@ Patchlevel @PATCHLEVEL@"
+.SH NAME
+showchar \- show character with information
+.SH SYNOPSIS
+.B showchar
+[
+.B fontname
+] [
+.B charname
+]
+.SH DESCRIPTION
+This manual page was written for the Debian GNU/Linux distribution
+because the original program does not have a manual page.
+.PP
+.B showchar
+outputs PostScript to draw a character with metric info.
+.SH AUTHOR
+Copyright (C) Angus J. C. Duggan 1991-1995
+.PP
+This manual page was written by Uwe Hermann <uh1763@hermann-uwe.de>,
+for the Debian GNU/Linux system (but may be used by others).
+.SH TRADEMARKS
+.B PostScript
+is a trademark of Adobe Systems Incorporated.
+.SH "SEE ALSO"
+@MAN@
