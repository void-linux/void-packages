Description: new source included in lazarus-1.8~rc2
Index: Qt5Pas.pro
===================================================================
--- a/Qt5Pas.pro
+++ b/Qt5Pas.pro
@@ -121,7 +121,10 @@ HEADERS +=  \
            qsize_c.h \
            qstring_c.h \
            qstringlist_c.h \
+           qsurface_c.h \           
+           qsurfaceformat_c.h \
            qrect_c.h \
+           qmargins_c.h \                      
            qdatetime_c.h \
            qbytearray_c.h \
            qlocale_c.h \
@@ -153,6 +156,10 @@ HEADERS +=  \
            qapplication_hook.h \
            qwhatsthis_c.h \
            qsizepolicy_c.h \
+           qscreen_c.h \
+           qscreen_hook.h \
+           qwindow_c.h \
+           qwindow_hook.h \           
            qwidget_c.h \
            qwidget_hook.h \
            qlayoutitem_c.h \
@@ -179,6 +186,7 @@ HEADERS +=  \
            qbrush_c.h \
            qpen_c.h \
            qpolygon_c.h \
+           qbackingstore_c.h \
            qpainter_c.h \
            qpaintengine_c.h \
            qpaintdevice_c.h \
@@ -375,6 +383,8 @@ HEADERS +=  \
            qdrag_hook_c.h \
            qguiapplication_hook_c.h \
            qapplication_hook_c.h \
+           qscreen_hook_c.h \           
+           qwindow_hook_c.h \
            qwidget_hook_c.h \
            qlayout_hook_c.h \
            qstackedlayout_hook_c.h \
@@ -468,7 +478,10 @@ SOURCES +=  \
            qsize_c.cpp \
            qstring_c.cpp \
            qstringlist_c.cpp \
+           qsurface_c.cpp \
+           qsurfaceformat_c.cpp \
            qrect_c.cpp \
+           qmargins_c.cpp \           
            qdatetime_c.cpp \
            qbytearray_c.cpp \
            qlocale_c.cpp \
@@ -493,6 +506,8 @@ SOURCES +=  \
            qapplication_c.cpp \
            qwhatsthis_c.cpp \
            qsizepolicy_c.cpp \
+           qscreen_c.cpp \
+           qwindow_c.cpp \           
            qwidget_c.cpp \
            qlayoutitem_c.cpp \
            qlayout_c.cpp \
@@ -512,6 +527,7 @@ SOURCES +=  \
            qbrush_c.cpp \
            qpen_c.cpp \
            qpolygon_c.cpp \
+           qbackingstore_c.cpp \
            qpainter_c.cpp \
            qpaintengine_c.cpp \
            qpaintdevice_c.cpp \
@@ -646,6 +662,8 @@ SOURCES +=  \
            qdrag_hook_c.cpp \
            qguiapplication_hook_c.cpp \
            qapplication_hook_c.cpp \
+           qscreen_hook_c.cpp \           
+           qwindow_hook_c.cpp \
            qwidget_hook_c.cpp \
            qlayout_hook_c.cpp \
            qstackedlayout_hook_c.cpp \
Index: src/chandles.h
===================================================================
--- a/src/chandles.h
+++ b/src/chandles.h
@@ -23,6 +23,8 @@ typedef unsigned int PTRUINT;
 
 typedef struct QAbstractButton__ { PTRINT dummy; } *QAbstractButtonH;
 typedef struct QSizePolicy__ { PTRINT dummy; } *QSizePolicyH;
+typedef struct QSurface__ { PTRINT dummy; } *QSurfaceH;
+typedef struct QSurfaceFormat__ { PTRINT dummy; } *QSurfaceFormatH;
 /* typedef struct QWebHistoryItem_hook__ { PTRINT dummy; } *QWebHistoryItem_hookH; */
 typedef struct QSlider_hook__ { PTRINT dummy; } *QSlider_hookH;
 typedef struct QGraphicsScene_hook__ { PTRINT dummy; } *QGraphicsScene_hookH;
@@ -446,6 +448,8 @@ typedef struct QButtonGroup_hook__ { PTR
 typedef struct QInputMethodEvent__ { PTRINT dummy; } *QInputMethodEventH;
 typedef struct QDate__ { PTRINT dummy; } *QDateH;
 typedef struct QStyleOptionTitleBar__ { PTRINT dummy; } *QStyleOptionTitleBarH;
+typedef struct QScreen_hook__ { PTRINT dummy; } *QScreen_hookH;
+typedef struct QWindow_hook__ { PTRINT dummy; } *QWindow_hookH;
 typedef struct QWidget_hook__ { PTRINT dummy; } *QWidget_hookH;
 typedef struct QDockWidget__ { PTRINT dummy; } *QDockWidgetH;
 typedef struct QLine__ { PTRINT dummy; } *QLineH;
Index: src/qbackingstore_c.cpp
===================================================================
--- /dev/null
+++ b/src/qbackingstore_c.cpp
@@ -0,0 +1,78 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#include "qbackingstore_c.h"
+
+QBackingStoreH QBackingStore_Create(QWindowH window)
+{
+  return (QBackingStoreH) new QBackingStore((QWindow*)window);
+}
+
+void QBackingStore_Destroy(QBackingStoreH handle)
+{
+  delete (QBackingStore *)handle;
+}
+
+QWindowH QBackingStore_window(QBackingStoreH handle)
+{
+  return (QWindowH) ((QBackingStore *)handle)->window();
+}
+
+QPaintDeviceH QBackingStore_paintDevice(QBackingStoreH handle)
+{
+  return (QPaintDeviceH) ((QBackingStore *)handle)->paintDevice();
+}
+
+void QBackingStore_flush(QBackingStoreH handle, const QRegionH region, QWindowH window, const QPointH offset)
+{
+  ((QBackingStore *)handle)->flush(*(const QRegion*) region, (QWindow *)window, *(const QPoint*) offset);
+}
+
+void QBackingStore_resize(QBackingStoreH handle, const QSizeH AnonParam1)
+{
+  ((QBackingStore *)handle)->resize(*(const QSize*)AnonParam1);
+}
+
+void QBackingStore_size(QBackingStoreH handle, PSize retval)
+{
+  *(QSize *)retval = ((QBackingStore *)handle)->size();
+}
+
+bool QBackingStore_scroll(QBackingStoreH handle, const QRegionH area, int dx, int dy)
+{
+  return ((QBackingStore *)handle)->scroll(*(const QRegion*)area, dx, dy);
+}
+
+void QBackingStore_beginPaint(QBackingStoreH handle, const QRegionH AnonParam1)
+{
+  ((QBackingStore *)handle)->beginPaint(*(const QRegion*)AnonParam1);
+}
+
+void QBackingStore_endPaint(QBackingStoreH handle)
+{
+  ((QBackingStore *)handle)->endPaint();
+}
+
+void QBackingStore_setStaticContents(QBackingStoreH handle, const QRegionH AnonParam1)
+{
+  ((QBackingStore *)handle)->setStaticContents(*(const QRegion*)AnonParam1);
+}
+
+void QBackingStore_staticContents(QBackingStoreH handle, QRegionH retval)
+{
+	*(QRegion *)retval = ((QBackingStore *)handle)->staticContents();
+}
+
+bool QBackingStore_hasStaticContents(QBackingStoreH handle)
+{
+  return (bool) ((QBackingStore *)handle)->hasStaticContents();
+}
+
Index: src/qbackingstore_c.h
===================================================================
--- /dev/null
+++ b/src/qbackingstore_c.h
@@ -0,0 +1,32 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#ifndef QBACKINGSTORE_C_H
+#define QBACKINGSTORE_C_H
+
+#include <QtGui>
+#include "pascalbind.h"
+
+C_EXPORT QBackingStoreH QBackingStore_Create(QWindowH window);
+C_EXPORT void QBackingStore_Destroy(QBackingStoreH handle);
+C_EXPORT QWindowH QBackingStore_window(QBackingStoreH handle);
+C_EXPORT QPaintDeviceH QBackingStore_paintDevice(QBackingStoreH handle);
+C_EXPORT void QBackingStore_flush(QBackingStoreH handle, const QRegionH region, QWindowH window, const QPointH offset);
+C_EXPORT void QBackingStore_resize(QBackingStoreH handle, const QSizeH AnonParam1);
+C_EXPORT void QBackingStore_size(QBackingStoreH handle, PSize retval);
+C_EXPORT bool QBackingStore_scroll(QBackingStoreH handle, const QRegionH area, int dx, int dy);
+C_EXPORT void QBackingStore_beginPaint(QBackingStoreH handle, const QRegionH AnonParam1);
+C_EXPORT void QBackingStore_endPaint(QBackingStoreH handle);
+C_EXPORT void QBackingStore_setStaticContents(QBackingStoreH handle, const QRegionH AnonParam1);
+C_EXPORT void QBackingStore_staticContents(QBackingStoreH handle, QRegionH retval);
+C_EXPORT bool QBackingStore_hasStaticContents(QBackingStoreH handle);
+
+#endif
Index: src/qmargins_c.cpp
===================================================================
--- /dev/null
+++ b/src/qmargins_c.cpp
@@ -0,0 +1,73 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#include "qmargins_c.h"
+
+QMarginsH QMargins_Create()
+{
+	return (QMarginsH) new QMargins();
+}
+
+QMarginsH QMargins_Create2(int left, int top, int right, int bottom)
+{
+  return (QMarginsH) new QMargins(left, top, right, bottom);
+}
+
+void QMargins_Destroy(QMarginsH handle)
+{
+	delete (QMargins *)handle;
+}
+
+bool QMargins_isNull(QMarginsH handle)
+{
+  return (bool) ((QMargins *)handle)->isNull();
+}
+
+int QMargins_left(QMarginsH handle)
+{
+  return (int) ((QMargins *)handle)->left();
+}
+
+int QMargins_top(QMarginsH handle)
+{
+  return (int) ((QMargins *)handle)->top();
+}
+
+int QMargins_right(QMarginsH handle)
+{
+  return (int) ((QMargins *)handle)->right();
+}
+
+int QMargins_bottom(QMarginsH handle)
+{
+  return (int) ((QMargins *)handle)->bottom();
+}
+
+void QMargins_setLeft(QMarginsH handle, int left)
+{
+  ((QMargins *)handle)->setLeft(left);
+}
+
+void QMargins_setTop(QMarginsH handle, int top)
+{
+  ((QMargins *)handle)->setTop(top);
+}
+
+void QMargins_setRight(QMarginsH handle, int right)
+{
+  ((QMargins *)handle)->setRight(right);
+}
+
+void QMargins_setBottom(QMarginsH handle, int bottom)
+{
+  ((QMargins *)handle)->setBottom(bottom);
+}
+
Index: src/qmargins_c.h
===================================================================
--- /dev/null
+++ b/src/qmargins_c.h
@@ -0,0 +1,31 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#ifndef QMARGINS_C_H
+#define QMARGINS_C_H
+
+#include <QtCore>
+#include "pascalbind.h"
+
+C_EXPORT QMarginsH QMargins_Create();
+C_EXPORT QMarginsH QMargins_Create2(int left, int top, int right, int bottom);
+C_EXPORT void QMargins_Destroy(QMarginsH handle);
+C_EXPORT bool QMargins_isNull(QMarginsH handle);
+C_EXPORT int QMargins_left(QMarginsH handle);
+C_EXPORT int QMargins_top(QMarginsH handle);
+C_EXPORT int QMargins_right(QMarginsH handle);
+C_EXPORT int QMargins_bottom(QMarginsH handle);
+C_EXPORT void QMargins_setLeft(QMarginsH handle, int left);
+C_EXPORT void QMargins_setTop(QMarginsH handle, int top);
+C_EXPORT void QMargins_setRight(QMarginsH handle, int right);
+C_EXPORT void QMargins_setBottom(QMarginsH handle, int bottom);
+
+#endif
Index: src/qobject_c.cpp
===================================================================
--- a/src/qobject_c.cpp
+++ b/src/qobject_c.cpp
@@ -177,3 +177,10 @@ void QObject_deleteLater(QObjectH handle
 	((QObject *)handle)->deleteLater();
 }
 
+const QMetaObjectH QObject_metaObject(QObjectH handle)
+{
+  const QMetaObject *meta = ((QObject *)handle)->metaObject();
+  if (!meta)
+    return NULL;
+  return (const QMetaObjectH) meta;
+}
Index: src/qobject_c.h
===================================================================
--- a/src/qobject_c.h
+++ b/src/qobject_c.h
@@ -47,5 +47,6 @@ C_EXPORT uint QObject_registerUserData()
 C_EXPORT QObjectH QObject_parent(QObjectH handle);
 C_EXPORT bool QObject_inherits(QObjectH handle, const char* classname);
 C_EXPORT void QObject_deleteLater(QObjectH handle);
+C_EXPORT const QMetaObjectH QObject_metaObject(QObjectH handle);
 
 #endif
Index: src/qscreen_c.cpp
===================================================================
--- /dev/null
+++ b/src/qscreen_c.cpp
@@ -0,0 +1,178 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#include "qscreen_c.h"
+
+void QScreen_Destroy(QScreenH handle)
+{
+  delete (QScreen *)handle;
+}
+
+void QScreen_name(QScreenH handle, PWideString retval)
+{
+	QString t_retval;
+	t_retval = ((QScreen *)handle)->name();
+	copyQStringToPWideString(t_retval, retval);
+}
+
+int QScreen_depth(QScreenH handle)
+{
+  return (int) ((QScreen *)handle)->depth();
+}
+
+void QScreen_size(QScreenH handle, PSize retval)
+{
+	*(QSize *)retval = ((QScreen *)handle)->size();
+}
+
+void QScreen_geometry(QScreenH handle, PRect retval)
+{
+	QRect t_retval;
+	t_retval = ((QScreen *)handle)->geometry();
+	copyQRectToPRect(t_retval, retval);
+}
+
+void QScreen_physicalSize(QScreenH handle, QSizeFH retval)
+{
+	*(QSizeF *)retval = ((QScreen *)handle)->physicalSize();
+}
+
+qreal QScreen_physicalDotsPerInchX(QScreenH handle)
+{
+  return (qreal) ((QScreen *)handle)->physicalDotsPerInchX();
+}
+
+qreal QScreen_physicalDotsPerInchY(QScreenH handle)
+{
+  return (qreal) ((QScreen *)handle)->physicalDotsPerInchY();
+}
+
+qreal QScreen_physicalDotsPerInch(QScreenH handle)
+{
+  return (qreal) ((QScreen *)handle)->physicalDotsPerInch();
+}
+
+qreal QScreen_logicalDotsPerInchX(QScreenH handle)
+{
+  return (qreal) ((QScreen *)handle)->logicalDotsPerInchX();
+}
+
+qreal QScreen_logicalDotsPerInchY(QScreenH handle)
+{
+  return (qreal) ((QScreen *)handle)->logicalDotsPerInchY();
+}
+
+qreal QScreen_logicalDotsPerInch(QScreenH handle)
+{
+  return (qreal) ((QScreen *)handle)->logicalDotsPerInch();
+}
+
+qreal QScreen_devicePixelRatio(QScreenH handle)
+{
+  return (qreal) ((QScreen *)handle)->devicePixelRatio();
+}
+
+void QScreen_availableSize(QScreenH handle, PSize retval)
+{
+	*(QSize *)retval = ((QScreen *)handle)->availableSize();
+}
+
+void QScreen_availableGeometry(QScreenH handle, PRect retval)
+{
+	QRect t_retval;
+	t_retval = ((QScreen *)handle)->availableGeometry();
+	copyQRectToPRect(t_retval, retval);
+}
+
+void QScreen_virtualSize(QScreenH handle, PSize retval)
+{
+	*(QSize *)retval = ((QScreen *)handle)->virtualSize();
+}
+
+void QScreen_virtualGeometry(QScreenH handle, PRect retval)
+{
+	QRect t_retval;
+	t_retval = ((QScreen *)handle)->virtualGeometry();
+	copyQRectToPRect(t_retval, retval);
+}
+
+Qt::ScreenOrientation QScreen_primaryOrientation(QScreenH handle)
+{
+  return (Qt::ScreenOrientation) ((QScreen *)handle)->primaryOrientation();
+}
+
+Qt::ScreenOrientation QScreen_orientation(QScreenH handle)
+{
+  return (Qt::ScreenOrientation) ((QScreen *)handle)->orientation();
+}
+
+Qt::ScreenOrientation QScreen_nativeOrientation(QScreenH handle)
+{
+  return (Qt::ScreenOrientation) ((QScreen *)handle)->nativeOrientation();
+}
+
+Qt::ScreenOrientations QScreen_orientationUpdateMask(QScreenH handle)
+{
+  return (Qt::ScreenOrientations) ((QScreen *)handle)->orientationUpdateMask();
+}
+
+void QScreen_setOrientationUpdateMask(QScreenH handle, Qt::ScreenOrientations mask)
+{
+  ((QScreen *)handle)->setOrientationUpdateMask((Qt::ScreenOrientations) mask);
+}
+
+int QScreen_angleBetween(QScreenH handle, Qt::ScreenOrientation a, Qt::ScreenOrientation b)
+{
+  return (int) ((QScreen *)handle)->angleBetween((Qt::ScreenOrientation) a, (Qt::ScreenOrientation) b);
+}
+
+void QScreen_virtualSiblings(QScreenH handle, PPtrIntArray retval)
+{
+	QList<QScreen*> t_retval;
+	t_retval = ((QScreen *)handle)->virtualSiblings();
+	copyQListTemplateToPtrIntArray(t_retval, retval);
+}
+
+void QScreen_transformBetween(QScreenH handle, QTransformH retval, Qt::ScreenOrientation a, Qt::ScreenOrientation b, PRect AnonParam1)
+{
+	QRect t_AnonParam1;
+	copyPRectToQRect(AnonParam1, t_AnonParam1);
+	*(QTransform *)retval = ((QScreen *)handle)->transformBetween((Qt::ScreenOrientation) a, (Qt::ScreenOrientation) b, t_AnonParam1);
+}
+
+void QScreen_mapBetween(QScreenH handle, PRect retval, Qt::ScreenOrientation a, Qt::ScreenOrientation b, PRect AnonParam1)
+{
+	QRect t_AnonParam1;
+  QRect t_retval;
+	copyPRectToQRect(AnonParam1, t_AnonParam1);
+  t_retval = ((QScreen *)handle)->mapBetween((Qt::ScreenOrientation) a, (Qt::ScreenOrientation) b, t_AnonParam1);
+  copyQRectToPRect(t_retval, retval);
+}
+
+bool QScreen_isPortrait(QScreenH handle, Qt::ScreenOrientation orientation)
+{
+  return (bool) ((QScreen *)handle)->isPortrait((Qt::ScreenOrientation) orientation);
+}
+
+bool QScreen_isLandscape(QScreenH handle, Qt::ScreenOrientation orientation)
+{
+  return (bool) ((QScreen *)handle)->isLandscape((Qt::ScreenOrientation) orientation);
+}
+
+void QScreen_grabWindow(QScreenH handle, QPixmapH retval,unsigned int window, int x,int y,int w, int h)
+{
+  *(QPixmap *)retval = ((QScreen *)handle)->grabWindow((WId) window, x, y, w, h);
+}
+
+qreal QScreen_refreshRate(QScreenH handle)
+{
+  return (qreal) ((QScreen *)handle)->refreshRate();
+}
Index: src/qscreen_c.h
===================================================================
--- /dev/null
+++ b/src/qscreen_c.h
@@ -0,0 +1,49 @@
+//******************************************************************************
+//  Copyright (c) 2007 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#ifndef QSCREEN_C_H
+#define QSCREEN_C_H
+
+#include <QtGui>
+#include "pascalbind.h"
+
+C_EXPORT void QScreen_Destroy(QScreenH handle);
+C_EXPORT void QScreen_name(QScreenH handle, PWideString retval);
+C_EXPORT int QScreen_depth(QScreenH handle);
+C_EXPORT void QScreen_size(QScreenH handle, PSize retval);
+C_EXPORT void QScreen_geometry(QScreenH handle, PRect retval);
+C_EXPORT void QScreen_physicalSize(QScreenH handle, QSizeFH retval);
+C_EXPORT qreal QScreen_physicalDotsPerInchX(QScreenH handle);
+C_EXPORT qreal QScreen_physicalDotsPerInchY(QScreenH handle);
+C_EXPORT qreal QScreen_physicalDotsPerInch(QScreenH handle);
+C_EXPORT qreal QScreen_logicalDotsPerInchX(QScreenH handle);
+C_EXPORT qreal QScreen_logicalDotsPerInchY(QScreenH handle);
+C_EXPORT qreal QScreen_logicalDotsPerInch(QScreenH handle);
+C_EXPORT qreal QScreen_devicePixelRatio(QScreenH handle);
+C_EXPORT void QScreen_availableSize(QScreenH handle, PSize retval);
+C_EXPORT void QScreen_availableGeometry(QScreenH handle, PRect retval);
+C_EXPORT void QScreen_virtualSize(QScreenH handle, PSize retval);
+C_EXPORT void QScreen_virtualGeometry(QScreenH handle, PRect retval);
+C_EXPORT Qt::ScreenOrientation QScreen_primaryOrientation(QScreenH handle);
+C_EXPORT Qt::ScreenOrientation QScreen_orientation(QScreenH handle);
+C_EXPORT Qt::ScreenOrientation QScreen_nativeOrientation(QScreenH handle);
+C_EXPORT Qt::ScreenOrientations QScreen_orientationUpdateMask(QScreenH handle);
+C_EXPORT void QScreen_setOrientationUpdateMask(QScreenH handle, Qt::ScreenOrientations mask);
+C_EXPORT int QScreen_angleBetween(QScreenH handle, Qt::ScreenOrientation a, Qt::ScreenOrientation b);
+C_EXPORT void QScreen_virtualSiblings(QScreenH handle, PPtrIntArray retval);
+C_EXPORT void QScreen_transformBetween(QScreenH handle, QTransformH retval, Qt::ScreenOrientation a, Qt::ScreenOrientation b, PRect AnonParam1);
+C_EXPORT void QScreen_mapBetween(QScreenH handle, PRect retval, Qt::ScreenOrientation a, Qt::ScreenOrientation b, PRect AnonParam1);
+C_EXPORT bool QScreen_isPortrait(QScreenH handle, Qt::ScreenOrientation orientation);
+C_EXPORT bool QScreen_isLandscape(QScreenH handle, Qt::ScreenOrientation orientation);
+C_EXPORT void QScreen_grabWindow(QScreenH handle, QPixmapH retval,unsigned int window, int x = 0,int y = 0,int w = -1, int h = -1);
+C_EXPORT qreal QScreen_refreshRate(QScreenH handle);
+
+#endif
Index: src/qscreen_hook_c.cpp
===================================================================
--- /dev/null
+++ b/src/qscreen_hook_c.cpp
@@ -0,0 +1,68 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#include "qscreen_hook_c.h"
+
+QScreen_hookH QScreen_hook_Create(QObjectH handle)
+{
+	return (QScreen_hookH) new QScreen_hook((QObject*)handle);
+}
+
+void QScreen_hook_Destroy(QScreen_hookH handle)
+{
+	delete (QScreen_hook *)handle;
+}
+
+void QScreen_hook_hook_geometryChanged(QScreen_hookH handle, QHookH hook)
+{
+  ((QScreen_hook *)handle)->hook_geometryChanged(hook);
+}
+
+void QScreen_hook_hook_availableGeometryChanged(QScreen_hookH handle, QHookH hook)
+{
+  ((QScreen_hook *)handle)->hook_availableGeometryChanged(hook);
+}
+
+void QScreen_hook_hook_physicalSizeChanged(QScreen_hookH handle, QHookH hook)
+{
+  ((QScreen_hook *)handle)->hook_physicalSizeChanged(hook);
+}
+
+void QScreen_hook_hook_physicalDotsPerInchChanged(QScreen_hookH handle, QHookH hook)
+{
+  ((QScreen_hook *)handle)->hook_physicalDotsPerInchChanged(hook);
+}
+
+void QScreen_hook_hook_logicalDotsPerInchChanged(QScreen_hookH handle, QHookH hook)
+{
+  ((QScreen_hook *)handle)->hook_logicalDotsPerInchChanged(hook);
+}
+
+void QScreen_hook_hook_virtualGeometryChanged(QScreen_hookH handle, QHookH hook)
+{
+  ((QScreen_hook *)handle)->hook_virtualGeometryChanged(hook);
+}
+
+void QScreen_hook_hook_primaryOrientationChanged(QScreen_hookH handle, QHookH hook)
+{
+  ((QScreen_hook *)handle)->hook_primaryOrientationChanged(hook);
+}
+
+void QScreen_hook_hook_orientationChanged(QScreen_hookH handle, QHookH hook)
+{
+  ((QScreen_hook *)handle)->hook_orientationChanged(hook);
+}
+
+void QScreen_hook_hook_refreshRateChanged(QScreen_hookH handle, QHookH hook)
+{
+  ((QScreen_hook *)handle)->hook_refreshRateChanged(hook);
+}
+
Index: src/qscreen_hook_c.h
===================================================================
--- /dev/null
+++ b/src/qscreen_hook_c.h
@@ -0,0 +1,30 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#ifndef QSCREEN_HOOK_C_H
+#define QSCREEN_HOOK_C_H
+
+#include "qscreen_hook.h"
+
+C_EXPORT QScreen_hookH QScreen_hook_Create(QObjectH handle);
+C_EXPORT void QScreen_hook_Destroy(QScreen_hookH handle);
+C_EXPORT void QScreen_hook_hook_geometryChanged(QScreen_hookH handle, QHookH hook);
+C_EXPORT void QScreen_hook_hook_availableGeometryChanged(QScreen_hookH handle, QHookH hook);
+C_EXPORT void QScreen_hook_hook_physicalSizeChanged(QScreen_hookH handle, QHookH hook);
+C_EXPORT void QScreen_hook_hook_physicalDotsPerInchChanged(QScreen_hookH handle, QHookH hook);
+C_EXPORT void QScreen_hook_hook_logicalDotsPerInchChanged(QScreen_hookH handle, QHookH hook);
+C_EXPORT void QScreen_hook_hook_virtualGeometryChanged(QScreen_hookH handle, QHookH hook);
+C_EXPORT void QScreen_hook_hook_primaryOrientationChanged(QScreen_hookH handle, QHookH hook);
+C_EXPORT void QScreen_hook_hook_orientationChanged(QScreen_hookH handle, QHookH hook);
+C_EXPORT void QScreen_hook_hook_refreshRateChanged(QScreen_hookH handle, QHookH hook);
+
+#endif
+
Index: src/qscreen_hook.h
===================================================================
--- /dev/null
+++ b/src/qscreen_hook.h
@@ -0,0 +1,190 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#ifndef QSCREEN_HOOK_H
+#define QSCREEN_HOOK_H
+
+#include <qscreen.h>
+
+#include "qobject_hook.h"
+
+class QScreen_hook : public QObject_hook {
+  Q_OBJECT
+  public:
+    QScreen_hook(QObject *handle) : QObject_hook(handle) {
+      geometryChanged_event.func = NULL;
+      availableGeometryChanged_event.func = NULL;
+      physicalSizeChanged_event.func = NULL;
+      physicalDotsPerInchChanged_event.func = NULL;
+      logicalDotsPerInchChanged_event.func = NULL;
+      virtualGeometryChanged_event.func = NULL;
+      primaryOrientationChanged_event.func = NULL;
+      orientationChanged_event.func = NULL;
+      refreshRateChanged_event.func = NULL;
+
+    }
+
+    void hook_geometryChanged(QHook &hook) {
+      if ( !geometryChanged_event.func )
+        connect(handle, SIGNAL(geometryChanged(const QRect&)), this, SLOT(geometryChanged_hook(const QRect&)));
+      geometryChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(geometryChanged(const QRect&)), this, SLOT(geometryChanged_hook(const QRect&)));
+    }
+
+    void hook_availableGeometryChanged(QHook &hook) {
+      if ( !availableGeometryChanged_event.func )
+        connect(handle, SIGNAL(availableGeometryChanged(const QRect&)), this, SLOT(availableGeometryChanged_hook(const QRect&)));
+      availableGeometryChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(availableGeometryChanged(const QRect&)), this, SLOT(availableGeometryChanged_hook(const QRect&)));
+    }
+
+    void hook_physicalSizeChanged(QHook &hook) {
+      if ( !physicalSizeChanged_event.func )
+        connect(handle, SIGNAL(physicalSizeChanged(const QSizeF&)), this, SLOT(physicalSizeChanged_hook(const QSizeF&)));
+      physicalSizeChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(physicalSizeChanged(const QSizeF&)), this, SLOT(physicalSizeChanged_hook(const QSizeF&)));
+    }
+
+    void hook_physicalDotsPerInchChanged(QHook &hook) {
+      if ( !physicalDotsPerInchChanged_event.func )
+        connect(handle, SIGNAL(physicalDotsPerInchChanged(qreal)), this, SLOT(physicalDotsPerInchChanged_hook(qreal)));
+      physicalDotsPerInchChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(physicalDotsPerInchChanged(qreal)), this, SLOT(physicalDotsPerInchChanged_hook(qreal)));
+    }
+
+    void hook_logicalDotsPerInchChanged(QHook &hook) {
+      if ( !logicalDotsPerInchChanged_event.func )
+        connect(handle, SIGNAL(logicalDotsPerInchChanged(qreal)), this, SLOT(logicalDotsPerInchChanged_hook(qreal)));
+      logicalDotsPerInchChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(logicalDotsPerInchChanged(qreal)), this, SLOT(logicalDotsPerInchChanged_hook(qreal)));
+    }
+
+    void hook_virtualGeometryChanged(QHook &hook) {
+      if ( !virtualGeometryChanged_event.func )
+        connect(handle, SIGNAL(virtualGeometryChanged(const QRect&)), this, SLOT(virtualGeometryChanged_hook(const QRect&)));
+      virtualGeometryChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(virtualGeometryChanged(const QRect&)), this, SLOT(virtualGeometryChanged_hook(const QRect&)));
+    }
+
+    void hook_primaryOrientationChanged(QHook &hook) {
+      if ( !primaryOrientationChanged_event.func )
+        connect(handle, SIGNAL(primaryOrientationChanged(Qt::ScreenOrientation)), this, SLOT(primaryOrientationChanged_hook(Qt::ScreenOrientation)));
+      primaryOrientationChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(primaryOrientationChanged(Qt::ScreenOrientation)), this, SLOT(primaryOrientationChanged_hook(Qt::ScreenOrientation)));
+    }
+
+    void hook_orientationChanged(QHook &hook) {
+      if ( !orientationChanged_event.func )
+        connect(handle, SIGNAL(orientationChanged(Qt::ScreenOrientation)), this, SLOT(orientationChanged_hook(Qt::ScreenOrientation)));
+      orientationChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(orientationChanged(Qt::ScreenOrientation)), this, SLOT(orientationChanged_hook(Qt::ScreenOrientation)));
+    }
+
+    void hook_refreshRateChanged(QHook &hook) {
+      if ( !refreshRateChanged_event.func )
+        connect(handle, SIGNAL(refreshRateChanged(qreal)), this, SLOT(refreshRateChanged_hook(qreal)));
+      refreshRateChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(refreshRateChanged(qreal)), this, SLOT(refreshRateChanged_hook(qreal)));
+    }
+
+  private slots:
+    void geometryChanged_hook(const QRect& geom) {
+      if ( geometryChanged_event.func ) {
+        typedef void (*func_type)(void *data, PRect geom);
+	PRect t_geom;
+	copyQRectToPRect(geom, t_geom);
+	(*(func_type)geometryChanged_event.func)(geometryChanged_event.data, t_geom);
+      }
+    }
+
+    void availableGeometryChanged_hook(const QRect& geom) {
+      if ( availableGeometryChanged_event.func ) {
+        typedef void (*func_type)(void *data, PRect geom);
+	PRect t_geom;
+	copyQRectToPRect(geom, t_geom);
+	(*(func_type)availableGeometryChanged_event.func)(availableGeometryChanged_event.data, t_geom);
+      }
+    }
+
+    void physicalSizeChanged_hook(const QSizeF& pos) {
+      if ( physicalSizeChanged_event.func ) {
+        typedef void (*func_type)(void *data, const QSizeFH pos);
+	(*(func_type)physicalSizeChanged_event.func)(physicalSizeChanged_event.data, (const QSizeFH)&pos);
+      }
+    }
+
+    void physicalDotsPerInchChanged_hook(qreal dpi) {
+      if ( physicalDotsPerInchChanged_event.func ) {
+        typedef void (*func_type)(void *data, qreal dpi);
+	(*(func_type)physicalDotsPerInchChanged_event.func)(physicalDotsPerInchChanged_event.data, dpi);
+      }
+    }
+
+    void logicalDotsPerInchChanged_hook(qreal dpi) {
+      if ( logicalDotsPerInchChanged_event.func ) {
+        typedef void (*func_type)(void *data, qreal dpi);
+	(*(func_type)logicalDotsPerInchChanged_event.func)(logicalDotsPerInchChanged_event.data, dpi);
+      }
+    }
+
+    void virtualGeometryChanged_hook(const QRect& geom) {
+      if ( virtualGeometryChanged_event.func ) {
+        typedef void (*func_type)(void *data, PRect geom);
+	PRect t_geom;
+	copyQRectToPRect(geom, t_geom);
+	(*(func_type)virtualGeometryChanged_event.func)(virtualGeometryChanged_event.data, t_geom);
+      }
+    }
+
+    void primaryOrientationChanged_hook(Qt::ScreenOrientation orientation) {
+      if ( primaryOrientationChanged_event.func ) {
+        typedef void (*func_type)(void *data, Qt::ScreenOrientation orientation);
+	(*(func_type)primaryOrientationChanged_event.func)(primaryOrientationChanged_event.data, orientation);
+      }
+    }
+
+    void orientationChanged_hook(Qt::ScreenOrientation orientation) {
+      if ( orientationChanged_event.func ) {
+        typedef void (*func_type)(void *data, Qt::ScreenOrientation orientation);
+	(*(func_type)orientationChanged_event.func)(orientationChanged_event.data, orientation);
+      }
+    }
+
+    void refreshRateChanged_hook(qreal refreshRate) {
+      if ( refreshRateChanged_event.func ) {
+        typedef void (*func_type)(void *data, qreal refreshRate);
+	(*(func_type)refreshRateChanged_event.func)(refreshRateChanged_event.data, refreshRate);
+      }
+    }
+
+  private:
+    QHook geometryChanged_event;
+    QHook availableGeometryChanged_event;
+    QHook physicalSizeChanged_event;
+    QHook physicalDotsPerInchChanged_event;
+    QHook logicalDotsPerInchChanged_event;
+    QHook virtualGeometryChanged_event;
+    QHook primaryOrientationChanged_event;
+    QHook orientationChanged_event;
+    QHook refreshRateChanged_event;
+};
+
+#endif
+
Index: src/qsurface_c.cpp
===================================================================
--- /dev/null
+++ b/src/qsurface_c.cpp
@@ -0,0 +1,45 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#include "qsurface_c.h"
+
+void QSurface_Destroy(QSurfaceH handle)
+{
+	delete (QSurface *)handle;
+}
+
+void QSurface_size(QSurfaceH handle, PSize retval)
+{
+	*(QSize *)retval = ((QSurface *)handle)->size();
+}
+
+
+bool QSurface_supportsOpenGL(QSurfaceH handle)
+{
+  return (bool) ((QSurface *)handle)->supportsOpenGL();
+}
+
+QSurface::SurfaceClass QSurface_surfaceClass(QSurfaceH handle)
+{
+  return (QSurface::SurfaceClass) ((QSurface *)handle)->surfaceClass();
+}
+
+QSurface::SurfaceType QSurface_surfaceType(QSurfaceH handle)
+{
+  return (QSurface::SurfaceType) ((QSurface *)handle)->surfaceType();
+}
+
+
+void QSurface_format(QSurfaceH handle, QSurfaceFormatH areturn)
+{
+  *(QSurfaceFormat *)areturn = ((QSurface *)handle)->format();
+}
+
Index: src/qsurface_c.h
===================================================================
--- /dev/null
+++ b/src/qsurface_c.h
@@ -0,0 +1,25 @@
+//******************************************************************************
+//  Copyright (c) 2007 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#ifndef QSURFACE_C_H
+#define QSURFACE_C_H
+
+#include <QtGui>
+#include "pascalbind.h"
+
+C_EXPORT void QSurface_Destroy(QSurfaceH handle);
+C_EXPORT void QSurface_size(QSurfaceH handle, PSize retval);
+C_EXPORT bool QSurface_supportsOpenGL(QSurfaceH handle);
+C_EXPORT QSurface::SurfaceClass QSurface_surfaceClass(QSurfaceH handle);
+C_EXPORT QSurface::SurfaceType QSurface_surfaceType(QSurfaceH handle);
+C_EXPORT void QSurface_format(QSurfaceH handle, QSurfaceFormatH areturn);
+
+#endif
Index: src/qsurfaceformat_c.cpp
===================================================================
--- /dev/null
+++ b/src/qsurfaceformat_c.cpp
@@ -0,0 +1,202 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#include "qsurfaceformat_c.h"
+
+QSurfaceFormatH QSurfaceFormat_Create()
+{
+  return (QSurfaceFormatH) new QSurfaceFormat();
+}
+
+QSurfaceFormatH QSurfaceFormat_Create2(QSurfaceFormat::FormatOptions options)
+{
+  return (QSurfaceFormatH) new QSurfaceFormat((QSurfaceFormat::FormatOptions) options);
+}
+
+void QSurfaceFormat_Destroy(QSurfaceFormatH handle)
+{
+	delete (QSurfaceFormat *)handle;
+}
+
+void QSurfaceFormat_setDepthBufferSize(QSurfaceFormatH handle, int size)
+{
+  ((QSurfaceFormat*)handle)->setDepthBufferSize(size);
+}
+
+int QSurfaceFormat_depthBufferSize(QSurfaceFormatH handle)
+{
+  return (int) ((QSurfaceFormat*)handle)->depthBufferSize();
+}
+
+void QSurfaceFormat_setStencilBufferSize(QSurfaceFormatH handle, int size)
+{
+  ((QSurfaceFormat*)handle)->setStencilBufferSize(size);
+}
+
+int QSurfaceFormat_stencilBufferSize(QSurfaceFormatH handle)
+{
+  return (int) ((QSurfaceFormat*)handle)->stencilBufferSize();
+}
+
+void QSurfaceFormat_setRedBufferSize(QSurfaceFormatH handle, int size)
+{
+  ((QSurfaceFormat*)handle)->setRedBufferSize(size);
+}
+
+int QSurfaceFormat_redBufferSize(QSurfaceFormatH handle)
+{
+  return (int) ((QSurfaceFormat*)handle)->redBufferSize();
+}
+
+void QSurfaceFormat_setGreenBufferSize(QSurfaceFormatH handle, int size)
+{
+  ((QSurfaceFormat*)handle)->setGreenBufferSize(size);
+}
+
+int QSurfaceFormat_greenBufferSize(QSurfaceFormatH handle)
+{
+  return (int) ((QSurfaceFormat*)handle)->greenBufferSize();
+}
+
+void QSurfaceFormat_setBlueBufferSize(QSurfaceFormatH handle, int size)
+{
+  ((QSurfaceFormat*)handle)->setBlueBufferSize(size);
+}
+
+int QSurfaceFormat_blueBufferSize(QSurfaceFormatH handle)
+{
+  return (int) ((QSurfaceFormat*)handle)->blueBufferSize();
+}
+
+void QSurfaceFormat_setAlphaBufferSize(QSurfaceFormatH handle, int size)
+{
+  ((QSurfaceFormat*)handle)->setAlphaBufferSize(size);
+}
+
+int QSurfaceFormat_alphaBufferSize(QSurfaceFormatH handle)
+{
+  return (int) ((QSurfaceFormat*)handle)->alphaBufferSize();
+}
+
+void QSurfaceFormat_setSamples(QSurfaceFormatH handle, int numSamples)
+{
+  ((QSurfaceFormat*)handle)->setSamples(numSamples);
+}
+
+int QSurfaceFormat_samples(QSurfaceFormatH handle)
+{
+  return (int) ((QSurfaceFormat*)handle)->samples();
+}
+
+void QSurfaceFormat_setSwapBehavior(QSurfaceFormatH handle, QSurfaceFormat::SwapBehavior behavior)
+{
+  ((QSurfaceFormat*)handle)->setSwapBehavior((QSurfaceFormat::SwapBehavior) behavior);
+}
+
+QSurfaceFormat::SwapBehavior QSurfaceFormat_swapBehavior(QSurfaceFormatH handle)
+{
+  return (QSurfaceFormat::SwapBehavior) ((QSurfaceFormat*)handle)->swapBehavior();
+}
+
+bool QSurfaceFormat_hasAlpha(QSurfaceFormatH handle)
+{
+  return (bool) ((QSurfaceFormat*)handle)->hasAlpha();
+}
+
+void QSurfaceFormat_setProfile(QSurfaceFormatH handle, QSurfaceFormat::OpenGLContextProfile profile)
+{
+  ((QSurfaceFormat*)handle)->setProfile((QSurfaceFormat::OpenGLContextProfile) profile);
+}
+
+QSurfaceFormat::OpenGLContextProfile QSurfaceFormat_profile(QSurfaceFormatH handle)
+{
+  return (QSurfaceFormat::OpenGLContextProfile) ((QSurfaceFormat*)handle)->profile();
+}
+
+void QSurfaceFormat_setRenderableType(QSurfaceFormatH handle, QSurfaceFormat::RenderableType type)
+{
+  ((QSurfaceFormat*)handle)->setRenderableType((QSurfaceFormat::RenderableType) type);
+}
+
+QSurfaceFormat::RenderableType QSurfaceFormat_renderableType(QSurfaceFormatH handle)
+{
+  return (QSurfaceFormat::RenderableType) ((QSurfaceFormat*)handle)->renderableType();
+}
+
+void QSurfaceFormat_setMajorVersion(QSurfaceFormatH handle, int majorVersion)
+{
+  ((QSurfaceFormat*)handle)->setMajorVersion(majorVersion);
+}
+
+int QSurfaceFormat_majorVersion(QSurfaceFormatH handle)
+{
+  return (int) ((QSurfaceFormat*)handle)->majorVersion();
+}
+
+void QSurfaceFormat_setMinorVersion(QSurfaceFormatH handle, int minorVersion)
+{
+  ((QSurfaceFormat*)handle)->setMinorVersion(minorVersion);
+}
+
+int QSurfaceFormat_minorVersion(QSurfaceFormatH handle)
+{
+  return (int) ((QSurfaceFormat*)handle)->minorVersion();
+}
+
+bool QSurfaceFormat_stereo(QSurfaceFormatH handle)
+{
+  return (bool) ((QSurfaceFormat*)handle)->stereo();
+}
+
+void QSurfaceFormat_setStereo(QSurfaceFormatH handle, bool enable)
+{
+  ((QSurfaceFormat*)handle)->setStereo(enable);
+}
+
+void QSurfaceFormat_setOptions(QSurfaceFormatH handle, QSurfaceFormat::FormatOptions options)
+{
+  ((QSurfaceFormat*)handle)->setOptions((QSurfaceFormat::FormatOptions) options);
+}
+
+void QSurfaceFormat_setOption(QSurfaceFormatH handle, QSurfaceFormat::FormatOption option, bool on)
+{
+  ((QSurfaceFormat*)handle)->setOption((QSurfaceFormat::FormatOption) option, on);
+}
+
+bool QSurfaceFormat_testOption(QSurfaceFormatH handle, QSurfaceFormat::FormatOption option)
+{
+  return (bool) ((QSurfaceFormat*)handle)->testOption((QSurfaceFormat::FormatOption) option);
+}
+
+QSurfaceFormat::FormatOptions QSurfaceFormat_options(QSurfaceFormatH handle)
+{
+  return (QSurfaceFormat::FormatOptions) ((QSurfaceFormat*)handle)->options();
+}
+
+int QSurfaceFormat_swapInterval(QSurfaceFormatH handle)
+{
+  return ((QSurfaceFormat*)handle)->swapInterval();
+}
+
+void QSurfaceFormat_setSwapInterval(QSurfaceFormatH handle, int interval)
+{
+  ((QSurfaceFormat*)handle)->setSwapInterval(interval);
+}
+
+void QSurfaceFormat_setDefaultFormat(QSurfaceFormatH format)
+{
+  QSurfaceFormat::setDefaultFormat(*(const QSurfaceFormat*) format);
+}
+
+void QSurfaceFormat_defaultFormat(QSurfaceFormatH retval)
+{
+  *(QSurfaceFormat*)retval = QSurfaceFormat::defaultFormat();
+}
Index: src/qsurfaceformat_c.h
===================================================================
--- /dev/null
+++ b/src/qsurfaceformat_c.h
@@ -0,0 +1,57 @@
+//******************************************************************************
+//  Copyright (c) 2007 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#ifndef QSURFACEFORMAT_C_H
+#define QSURFACEFORMAT_C_H
+
+#include <QtGui>
+#include "pascalbind.h"
+
+C_EXPORT QSurfaceFormatH QSurfaceFormat_Create();
+C_EXPORT QSurfaceFormatH QSurfaceFormat_Create2(QSurfaceFormat::FormatOptions options);
+C_EXPORT void QSurfaceFormat_Destroy(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setDepthBufferSize(QSurfaceFormatH handle,int size);
+C_EXPORT int QSurfaceFormat_depthBufferSize(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setStencilBufferSize(QSurfaceFormatH handle, int size);
+C_EXPORT int QSurfaceFormat_stencilBufferSize(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setRedBufferSize(QSurfaceFormatH handle, int size);
+C_EXPORT int QSurfaceFormat_redBufferSize(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setGreenBufferSize(QSurfaceFormatH handle, int size);
+C_EXPORT int QSurfaceFormat_greenBufferSize(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setBlueBufferSize(QSurfaceFormatH handle, int size);
+C_EXPORT int QSurfaceFormat_blueBufferSize(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setAlphaBufferSize(QSurfaceFormatH handle, int size);
+C_EXPORT int QSurfaceFormat_alphaBufferSize(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setSamples(QSurfaceFormatH handle, int numSamples);
+C_EXPORT int QSurfaceFormat_samples(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setSwapBehavior(QSurfaceFormatH handle, QSurfaceFormat::SwapBehavior behavior);
+C_EXPORT QSurfaceFormat::SwapBehavior QSurfaceFormat_swapBehavior(QSurfaceFormatH handle);
+C_EXPORT bool QSurfaceFormat_hasAlpha(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setProfile(QSurfaceFormatH handle, QSurfaceFormat::OpenGLContextProfile profile);
+C_EXPORT QSurfaceFormat::OpenGLContextProfile QSurfaceFormat_profile(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setRenderableType(QSurfaceFormatH handle, QSurfaceFormat::RenderableType type);
+C_EXPORT QSurfaceFormat::RenderableType QSurfaceFormat_renderableType(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setMajorVersion(QSurfaceFormatH handle, int majorVersion);
+C_EXPORT int QSurfaceFormat_majorVersion(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setMinorVersion(QSurfaceFormatH handle, int minorVersion);
+C_EXPORT int QSurfaceFormat_minorVersion(QSurfaceFormatH handle);
+C_EXPORT bool QSurfaceFormat_stereo(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setStereo(QSurfaceFormatH handle, bool enable);
+C_EXPORT void QSurfaceFormat_setOptions(QSurfaceFormatH handle, QSurfaceFormat::FormatOptions options);
+C_EXPORT void QSurfaceFormat_setOption(QSurfaceFormatH handle, QSurfaceFormat::FormatOption option, bool on = true);
+C_EXPORT bool QSurfaceFormat_testOption(QSurfaceFormatH handle, QSurfaceFormat::FormatOption option);
+C_EXPORT QSurfaceFormat::FormatOptions QSurfaceFormat_options(QSurfaceFormatH handle);
+C_EXPORT int QSurfaceFormat_swapInterval(QSurfaceFormatH handle);
+C_EXPORT void QSurfaceFormat_setSwapInterval(QSurfaceFormatH handle, int interval);
+C_EXPORT void QSurfaceFormat_setDefaultFormat(QSurfaceFormatH format);
+C_EXPORT void QSurfaceFormat_defaultFormat(QSurfaceFormatH retval);
+
+#endif
Index: src/qwindow_c.cpp
===================================================================
--- /dev/null
+++ b/src/qwindow_c.cpp
@@ -0,0 +1,548 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#include "qwindow_c.h"
+
+QWindowH QWindow_Create(QWindowH parent)
+{
+  return (QWindowH) new QWindow((QWindow*)parent);
+}
+
+QWindowH QWindow_Create2(QScreenH screen)
+{
+  return (QWindowH) new QWindow((QScreen*)screen);
+}
+
+void QWindow_Destroy(QWindowH handle)
+{
+  delete (QWindow *)handle;
+}
+
+void QWindow_setSurfaceType(QWindowH handle, QSurface::SurfaceType surfaceType)
+{
+  ((QWindow *)handle)->setSurfaceType((QSurface::SurfaceType) surfaceType);
+}
+
+QSurface::SurfaceType QWindow_surfaceType(QWindowH handle)
+{
+  return (QSurface::SurfaceType) ((QWindow *)handle)->surfaceType();
+}
+
+bool QWindow_isVisible(QWindowH handle)
+{
+  return (bool) ((QWindow *)handle)->isVisible();
+}
+
+QWindow::Visibility QWindow_visibility(QWindowH handle)
+{
+  return (QWindow::Visibility) ((QWindow *)handle)->visibility();
+}
+
+void QWindow_setVisibility(QWindowH handle, QWindow::Visibility v)
+{
+  ((QWindow *)handle)->setVisibility((QWindow::Visibility) v);
+}
+
+void QWindow_createPlatformResources(QWindowH handle) /* void create(); */
+{
+  ((QWindow *)handle)->create();
+}
+
+void QWindow_destroyPlatformResources(QWindowH handle) /* void destroy(); */
+{
+  ((QWindow *)handle)->destroy();
+}
+
+unsigned int QWindow_winId(QWindowH handle)
+{
+  return (unsigned int) ((QWindow *)handle)->winId();
+}
+
+QWindowH QWindow_parent(QWindowH handle)
+{
+  return (QWindowH) ((QWindow *)handle)->parent();
+}
+
+void QWindow_setParent(QWindowH handle, QWindowH parent)
+{
+	((QWindow *)handle)->setParent((QWindow*)parent);
+}
+
+bool QWindow_isTopLevel(QWindowH handle)
+{
+	return (bool) ((QWindow *)handle)->isTopLevel();
+}
+
+
+bool QWindow_isModal(QWindowH handle)
+{
+	return (bool) ((QWindow *)handle)->isModal();
+}
+
+Qt::WindowModality QWindow_modality(QWindowH handle)
+{
+	return (Qt::WindowModality) ((QWindow *)handle)->modality();
+}
+
+void QWindow_setModality(QWindowH handle, Qt::WindowModality windowModality)
+{
+	((QWindow *)handle)->setModality((Qt::WindowModality)windowModality);
+}
+
+void QWindow_setFormat(QWindowH handle, const QSurfaceFormatH format)
+{
+  ((QWindow *)handle)->setFormat(*(const QSurfaceFormat*) format);
+}
+
+void QWindow_format(QWindowH handle, QSurfaceFormatH retval)
+{
+  *(QSurfaceFormat*) retval = ((QWindow *)handle)->format();
+}
+
+void QWindow_requestedFormat(QWindowH handle, QSurfaceFormatH retval)
+{
+  *(QSurfaceFormat*) retval = ((QWindow *)handle)->requestedFormat();
+}
+
+void QWindow_setFlags(QWindowH handle, unsigned int flags)
+{
+  ((QWindow *)handle)->setFlags((Qt::WindowFlags)flags);
+}
+
+unsigned int QWindow_flags(QWindowH handle)
+{
+  return (unsigned int) ((QWindow *)handle)->flags();
+}
+
+Qt::WindowType QWindow_type(QWindowH handle)
+{
+  return (Qt::WindowType) ((QWindow *)handle)->type();
+}
+
+void QWindow_title(QWindowH handle, PWideString retval)
+{
+	QString t_retval;
+	t_retval = ((QWindow *)handle)->title();
+	copyQStringToPWideString(t_retval, retval);
+}
+
+void QWindow_setOpacity(QWindowH handle, qreal level)
+{
+	((QWindow *)handle)->setOpacity(level);
+}
+
+qreal QWindow_opacity(QWindowH handle)
+{
+  return (qreal) ((QWindow *)handle)->opacity();
+}
+
+void QWindow_setMask(QWindowH handle, const QRegionH AnonParam1)
+{
+	((QWindow *)handle)->setMask(*(const QRegion*)AnonParam1);
+}
+
+void QWindow_mask(QWindowH handle, QRegionH retval)
+{
+	*(QRegion *)retval = ((QWindow *)handle)->mask();
+}
+
+bool QWindow_isActiveWindow(QWindowH handle)
+{
+	return (bool) ((QWindow *)handle)->isActive();
+}
+
+void QWindow_reportContentOrientationChange(QWindowH handle, Qt::ScreenOrientation orientation)
+{
+  ((QWindow *)handle)->reportContentOrientationChange((Qt::ScreenOrientation) orientation);
+}
+
+Qt::ScreenOrientation QWindow_contentOrientation(QWindowH handle)
+{
+  return (Qt::ScreenOrientation) ((QWindow *)handle)->contentOrientation();
+}
+
+qreal QWindow_devicePixelRatio(QWindowH handle)
+{
+  return (qreal) ((QWindow *)handle)->devicePixelRatio();
+}
+
+unsigned int QWindow_windowState(QWindowH handle)
+{
+	return (unsigned int) ((QWindow *)handle)->windowState();
+}
+
+void QWindow_setWindowState(QWindowH handle, unsigned int state)
+{
+	((QWindow *)handle)->setWindowState((Qt::WindowState)state);
+}
+
+void QWindow_setTransientParent(QWindowH handle, QWindowH parent)
+{
+  ((QWindow *)handle)->setTransientParent((QWindow*)parent);
+}
+
+QWindowH QWindow_transientParent(QWindowH handle)
+{
+	return (QWindowH) ((QWindow *)handle)->transientParent();
+}
+
+bool QWindow_isAncestorOf(QWindowH handle, const QWindowH child, QWindow::AncestorMode mode)
+{
+  return (bool) ((QWindow *)handle)->isAncestorOf((QWindow *)child, (QWindow::AncestorMode) mode);
+}
+
+bool QWindow_isExposed(QWindowH handle)
+{
+  return (bool) ((QWindow *)handle)->isExposed();
+}
+
+int QWindow_minimumWidth(QWindowH handle)
+{
+	return (int) ((QWindow *)handle)->minimumWidth();
+}
+
+int QWindow_minimumHeight(QWindowH handle)
+{
+	return (int) ((QWindow *)handle)->minimumHeight();
+}
+
+int QWindow_maximumWidth(QWindowH handle)
+{
+	return (int) ((QWindow *)handle)->maximumWidth();
+}
+
+int QWindow_maximumHeight(QWindowH handle)
+{
+	return (int) ((QWindow *)handle)->maximumHeight();
+}
+
+void QWindow_minimumSize(QWindowH handle, PSize retval)
+{
+	*(QSize *)retval = ((QWindow *)handle)->minimumSize();
+}
+
+void QWindow_maximumSize(QWindowH handle, PSize retval)
+{
+	*(QSize *)retval = ((QWindow *)handle)->maximumSize();
+}
+
+void QWindow_baseSize(QWindowH handle, PSize retval)
+{
+	*(QSize *)retval = ((QWindow *)handle)->baseSize();
+}
+
+void QWindow_sizeIncrement(QWindowH handle, PSize retval)
+{
+	*(QSize *)retval = ((QWindow *)handle)->sizeIncrement();
+}
+
+void QWindow_setMinimumSize(QWindowH handle, const QSizeH AnonParam1)
+{
+	((QWindow *)handle)->setMinimumSize(*(const QSize*)AnonParam1);
+}
+
+void QWindow_setMaximumSize(QWindowH handle, const QSizeH AnonParam1)
+{
+	((QWindow *)handle)->setMaximumSize(*(const QSize*)AnonParam1);
+}
+
+void QWindow_setBaseSize(QWindowH handle, const QSizeH AnonParam1)
+{
+	((QWindow *)handle)->setBaseSize(*(const QSize*)AnonParam1);
+}
+
+void QWindow_setSizeIncrement(QWindowH handle, const QSizeH AnonParam1)
+{
+	((QWindow *)handle)->setSizeIncrement(*(const QSize*)AnonParam1);
+}
+
+void QWindow_setGeometry(QWindowH handle, int x, int y, int w, int h)
+{
+	((QWindow *)handle)->setGeometry(x, y, w, h);
+}
+
+void QWindow_setGeometry2(QWindowH handle, PRect AnonParam1)
+{
+	QRect t_AnonParam1;
+	copyPRectToQRect(AnonParam1, t_AnonParam1);
+	((QWindow *)handle)->setGeometry(t_AnonParam1);
+}
+
+void QWindow_geometry(QWindowH handle, PRect retval)
+{
+	QRect t_retval;
+	t_retval = ((QWindow *)handle)->geometry();
+	copyQRectToPRect(t_retval, retval);
+}
+
+void QWindow_frameMargins(QWindowH handle, QMarginsH retval)
+{
+	*(QMargins *)retval = ((QWindow *)handle)->frameMargins();
+}
+
+void QWindow_frameGeometry(QWindowH handle, PRect retval)
+{
+	QRect t_retval;
+	t_retval = ((QWindow *)handle)->frameGeometry();
+	copyQRectToPRect(t_retval, retval);
+}
+
+void QWindow_framePosition(QWindowH handle, PQtPoint retval)
+{
+	*(QPoint *)retval = ((QWindow *)handle)->framePosition();
+}
+
+void QWindow_setFramePosition(QWindowH handle, const QPointH AnonParam1)
+{
+  ((QWindow *)handle)->setFramePosition(*(const QPoint*)AnonParam1);
+}
+
+int QWindow_width(QWindowH handle)
+{
+	return (int) ((QWindow *)handle)->width();
+}
+
+int QWindow_height(QWindowH handle)
+{
+	return (int) ((QWindow *)handle)->height();
+}
+
+int QWindow_x(QWindowH handle)
+{
+	return (int) ((QWindow *)handle)->x();
+}
+
+int QWindow_y(QWindowH handle)
+{
+	return (int) ((QWindow *)handle)->y();
+}
+
+void QWindow_size(QWindowH handle, PSize retval)
+{
+	*(QSize *)retval = ((QWindow *)handle)->size();
+}
+
+void QWindow_position(QWindowH handle, PQtPoint retval)
+{
+	*(QPoint *)retval = ((QWindow *)handle)->position();
+}
+
+void QWindow_setPosition(QWindowH handle, const QPointH AnonParam1)
+{
+  ((QWindow *)handle)->setPosition(*(const QPoint*)AnonParam1);
+}
+
+void QWindow_setPosition2(QWindowH handle, int posx, int posy)
+{
+  ((QWindow *)handle)->setPosition(posx, posy);
+}
+
+void QWindow_resize(QWindowH handle, const QSizeH AnonParam1)
+{
+	((QWindow *)handle)->resize(*(const QSize*)AnonParam1);
+}
+
+void QWindow_resize2(QWindowH handle, int w, int h)
+{
+	((QWindow *)handle)->resize(w, h);
+}
+
+void QWindow_setFilePath(QWindowH handle, PWideString AnonParam1)
+{
+	QString t_AnonParam1;
+	copyPWideStringToQString(AnonParam1, t_AnonParam1);
+	((QWindow *)handle)->setFilePath(t_AnonParam1);
+}
+
+void QWindow_filePath(QWindowH handle, PWideString retval)
+{
+	QString t_retval;
+	t_retval = ((QWindow *)handle)->filePath();
+	copyQStringToPWideString(t_retval, retval);
+}
+
+void QWindow_setIcon(QWindowH handle, const QIconH icon)
+{
+	((QWindow *)handle)->setIcon(*(const QIcon*)icon);
+}
+
+void QWindow_icon(QWindowH handle, QIconH retval)
+{
+	*(QIcon *)retval = ((QWindow *)handle)->icon();
+}
+
+QScreenH QWindow_screen(QWindowH handle)
+{
+  return (QScreenH) ((QWindow *)handle)->screen();
+}
+
+void QWindow_setScreen(QWindowH handle, QScreenH screen)
+{
+  ((QWindow *)handle)->setScreen((QScreen *) screen);
+}
+
+bool QWindow_setKeyboardGrabEnabled(QWindowH handle, bool grab)
+{
+  return ((QWindow *)handle)->setKeyboardGrabEnabled(grab);
+}
+
+bool QWindow_setMouseGrabEnabled(QWindowH handle, bool grab)
+{
+  return ((QWindow *)handle)->setMouseGrabEnabled(grab);
+}
+
+void QWindow_mapToGlobal(QWindowH handle, PQtPoint retval, const QPointH AnonParam1)
+{
+	*(QPoint *)retval = ((QWindow *)handle)->mapToGlobal(*(const QPoint*)AnonParam1);
+}
+
+void QWindow_mapFromGlobal(QWindowH handle, PQtPoint retval, const QPointH AnonParam1)
+{
+	*(QPoint *)retval = ((QWindow *)handle)->mapFromGlobal(*(const QPoint*)AnonParam1);
+}
+
+void QWindow_cursor(QWindowH handle, QCursorH retval)
+{
+	*(QCursor *)retval = ((QWindow *)handle)->cursor();
+}
+
+void QWindow_setCursor(QWindowH handle, const QCursorH AnonParam1)
+{
+	((QWindow *)handle)->setCursor(*(const QCursor*)AnonParam1);
+}
+
+void QWindow_unsetCursor(QWindowH handle)
+{
+	((QWindow *)handle)->unsetCursor();
+}
+
+QObjectH QWindow_focusObject(QWindowH handle)
+{
+  return (QObjectH) ((QWindow *)handle)->focusObject();
+}
+
+QWindowH QWindow_fromWinID(unsigned int id)
+{
+  return (QWindowH) QWindow::fromWinId((WId) id);
+}
+
+void QWindow_requestActivate(QWindowH handle)
+{
+  ((QWindow *)handle)->requestActivate();
+}
+
+void QWindow_setVisible(QWindowH handle, bool visible)
+{
+  ((QWindow *)handle)->setVisible(visible);
+}
+
+void QWindow_show(QWindowH handle)
+{
+  ((QWindow *)handle)->show();
+}
+
+void QWindow_hide(QWindowH handle)
+{
+  ((QWindow *)handle)->hide();
+}
+
+void QWindow_showMinimized(QWindowH handle)
+{
+  ((QWindow *)handle)->showMinimized();
+}
+
+void QWindow_showMaximized(QWindowH handle)
+{
+  ((QWindow *)handle)->showMaximized();
+}
+
+void QWindow_showFullScreen(QWindowH handle)
+{
+  ((QWindow *)handle)->showFullScreen();
+}
+
+void QWindow_showNormal(QWindowH handle)
+{
+  ((QWindow *)handle)->showNormal();
+}
+
+bool QWindow_close(QWindowH handle)
+{
+  return (bool) ((QWindow *)handle)->close();
+}
+
+void QWindow_raise(QWindowH handle)
+{
+  ((QWindow *)handle)->raise();
+}
+
+void QWindow_lower(QWindowH handle)
+{
+  ((QWindow *)handle)->lower();
+}
+
+void QWindow_setWindowTitle(QWindowH handle, PWideString AnonParam1)
+{
+	QString t_AnonParam1;
+	copyPWideStringToQString(AnonParam1, t_AnonParam1);
+	((QWindow *)handle)->setTitle(t_AnonParam1);
+}
+
+void QWindow_setX(QWindowH handle, int argx)
+{
+  ((QWindow *)handle)->setX(argx);
+}
+
+void QWindow_setY(QWindowH handle, int argy)
+{
+  ((QWindow *)handle)->setY(argy);
+}
+
+void QWindow_setWidth(QWindowH handle, int argw)
+{
+  ((QWindow *)handle)->setWidth(argw);
+}
+
+void QWindow_setHeight(QWindowH handle, int argh)
+{
+  ((QWindow *)handle)->setHeight(argh);
+}
+
+void QWindow_setMinimumWidth(QWindowH handle, int w)
+{
+  ((QWindow *)handle)->setMinimumWidth(w);
+}
+
+void QWindow_setMinimumHeight(QWindowH handle, int h)
+{
+  ((QWindow *)handle)->setMinimumHeight(h);
+}
+
+void QWindow_setMaximumWidth(QWindowH handle, int w)
+{
+  ((QWindow *)handle)->setMaximumWidth(w);
+}
+
+void QWindow_setMaximumHeight(QWindowH handle, int h)
+{
+  ((QWindow *)handle)->setMaximumHeight(h);
+}
+
+void QWindow_alert(QWindowH handle, int msec)
+{
+  ((QWindow *)handle)->alert(msec);
+}
+
+void QWindow_requestUpdate(QWindowH handle)
+{
+  ((QWindow *)handle)->requestUpdate();
+}
+
Index: src/qwindow_c.h
===================================================================
--- /dev/null
+++ b/src/qwindow_c.h
@@ -0,0 +1,123 @@
+//******************************************************************************
+//  Copyright (c) 2007 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#ifndef QWINDOW_C_H
+#define QWINDOW_C_H
+
+#include <QtGui>
+#include "pascalbind.h"
+
+C_EXPORT QWindowH QWindow_Create(QWindowH parent);
+C_EXPORT QWindowH QWindow_Create2(QScreenH screen = Q_NULLPTR);
+C_EXPORT void QWindow_Destroy(QWindowH handle);
+C_EXPORT void QWindow_setSurfaceType(QWindowH handle, QSurface::SurfaceType surfaceType);
+C_EXPORT QSurface::SurfaceType QWindow_surfaceType(QWindowH handle);
+C_EXPORT bool QWindow_isVisible(QWindowH handle);
+C_EXPORT QWindow::Visibility QWindow_visibility(QWindowH handle);
+C_EXPORT void QWindow_setVisibility(QWindowH handle, QWindow::Visibility v);
+C_EXPORT void QWindow_createPlatformResources(QWindowH handle); /* void create(); */
+C_EXPORT void QWindow_destroyPlatformResources(QWindowH handle); /* void destroy(); */
+C_EXPORT unsigned int QWindow_winId(QWindowH handle);
+C_EXPORT QWindowH QWindow_parent(QWindowH handle);
+C_EXPORT void QWindow_setParent(QWindowH handle, QWindowH parent);
+C_EXPORT bool QWindow_isTopLevel(QWindowH handle);
+C_EXPORT bool QWindow_isModal(QWindowH handle);
+C_EXPORT Qt::WindowModality QWindow_modality(QWindowH handle);
+C_EXPORT void QWindow_setModality(QWindowH handle, Qt::WindowModality windowModality);
+C_EXPORT void QWindow_setFormat(QWindowH handle, const QSurfaceFormatH format);
+C_EXPORT void QWindow_format(QWindowH handle, QSurfaceFormatH retval);
+C_EXPORT void QWindow_requestedFormat(QWindowH handle, QSurfaceFormatH retval);
+C_EXPORT void QWindow_setFlags(QWindowH handle, unsigned int flags);
+C_EXPORT unsigned int QWindow_flags(QWindowH handle);
+C_EXPORT Qt::WindowType QWindow_type(QWindowH handle);
+C_EXPORT void QWindow_title(QWindowH handle, PWideString retval);
+C_EXPORT void QWindow_setOpacity(QWindowH handle, qreal level);
+C_EXPORT qreal QWindow_opacity(QWindowH handle);
+C_EXPORT void QWindow_setMask(QWindowH handle, const QRegionH AnonParam1);
+C_EXPORT void QWindow_mask(QWindowH handle, QRegionH retval);
+C_EXPORT bool QWindow_isActive(QWindowH handle);
+C_EXPORT void QWindow_reportContentOrientationChange(QWindowH handle, Qt::ScreenOrientation orientation);
+C_EXPORT Qt::ScreenOrientation QWindow_contentOrientation(QWindowH handle);
+C_EXPORT qreal QWindow_devicePixelRatio(QWindowH handle);
+C_EXPORT unsigned int QWindow_windowState(QWindowH handle);
+C_EXPORT void QWindow_setWindowState(QWindowH handle, unsigned int state);
+C_EXPORT void QWindow_setTransientParent(QWindowH handle, QWindowH parent);
+C_EXPORT QWindowH QWindow_transientParent(QWindowH handle);
+C_EXPORT bool QWindow_isAncestorOf(QWindowH handle, const QWindowH child, QWindow::AncestorMode mode = QWindow::AncestorMode::IncludeTransients);
+C_EXPORT bool QWindow_isExposed(QWindowH handle);
+C_EXPORT int QWindow_minimumWidth(QWindowH handle);
+C_EXPORT int QWindow_minimumHeight(QWindowH handle);
+C_EXPORT int QWindow_maximumWidth(QWindowH handle);
+C_EXPORT int QWindow_maximumHeight(QWindowH handle);
+C_EXPORT void QWindow_minimumSize(QWindowH handle, PSize retval);
+C_EXPORT void QWindow_maximumSize(QWindowH handle, PSize retval);
+C_EXPORT void QWindow_baseSize(QWindowH handle, PSize retval);
+C_EXPORT void QWindow_sizeIncrement(QWindowH handle, PSize retval);
+C_EXPORT void QWindow_setMinimumSize(QWindowH handle, const QSizeH AnonParam1);
+C_EXPORT void QWindow_setMaximumSize(QWindowH handle, const QSizeH AnonParam1);
+C_EXPORT void QWindow_setBaseSize(QWindowH handle, const QSizeH AnonParam1);
+C_EXPORT void QWindow_setSizeIncrement(QWindowH handle, const QSizeH AnonParam1);
+C_EXPORT void QWindow_setGeometry(QWindowH handle, int x, int y, int w, int h);
+C_EXPORT void QWindow_setGeometry2(QWindowH handle, PRect AnonParam1);
+C_EXPORT void QWindow_geometry(QWindowH handle, PRect retval);
+C_EXPORT void QWindow_frameMargins(QWindowH handle, QMarginsH retval);
+C_EXPORT void QWindow_frameGeometry(QWindowH handle, PRect retval);
+C_EXPORT void QWindow_framePosition(QWindowH handle, PQtPoint retval);
+C_EXPORT void QWindow_setFramePosition(QWindowH handle, const QPointH AnonParam1);
+C_EXPORT int QWindow_width(QWindowH handle);
+C_EXPORT int QWindow_height(QWindowH handle);
+C_EXPORT int QWindow_x(QWindowH handle);
+C_EXPORT int QWindow_y(QWindowH handle);
+C_EXPORT void QWindow_size(QWindowH handle, PSize retval);
+C_EXPORT void QWindow_position(QWindowH handle, PQtPoint retval);
+C_EXPORT void QWindow_setPosition(QWindowH handle, const QPointH AnonParam1);
+C_EXPORT void QWindow_setPosition2(QWindowH handle, int posx, int posy);
+C_EXPORT void QWindow_resize(QWindowH handle, const QSizeH AnonParam1);
+C_EXPORT void QWindow_resize2(QWindowH handle, int w, int h);
+C_EXPORT void QWindow_setFilePath(QWindowH handle, PWideString AnonParam1);
+C_EXPORT void QWindow_filePath(QWindowH handle, PWideString retval);
+C_EXPORT void QWindow_setIcon(QWindowH handle, const QIconH icon);
+C_EXPORT void QWindow_icon(QWindowH handle, QIconH retval);
+C_EXPORT QScreenH QWindow_screen(QWindowH handle);
+C_EXPORT void QWindow_setScreen(QWindowH handle, QScreenH screen);
+C_EXPORT bool QWindow_setKeyboardGrabEnabled(QWindowH handle, bool grab);
+C_EXPORT bool QWindow_setMouseGrabEnabled(QWindowH handle, bool grab);
+C_EXPORT void QWindow_mapToGlobal(QWindowH handle, PQtPoint retval, const QPointH AnonParam1);
+C_EXPORT void QWindow_mapFromGlobal(QWindowH handle, PQtPoint retval, const QPointH AnonParam1);
+C_EXPORT void QWindow_cursor(QWindowH handle, QCursorH retval);
+C_EXPORT void QWindow_setCursor(QWindowH handle, const QCursorH AnonParam1);
+C_EXPORT void QWindow_unsetCursor(QWindowH handle);
+C_EXPORT QObjectH QWindow_focusObject(QWindowH handle);
+C_EXPORT QWindowH QWindow_fromWinID(unsigned int id);
+C_EXPORT void QWindow_requestActivate(QWindowH handle);
+C_EXPORT void QWindow_setVisible(QWindowH handle, bool visible);
+C_EXPORT void QWindow_show(QWindowH handle);
+C_EXPORT void QWindow_hide(QWindowH handle);
+C_EXPORT void QWindow_showMinimized(QWindowH handle);
+C_EXPORT void QWindow_showMaximized(QWindowH handle);
+C_EXPORT void QWindow_showFullScreen(QWindowH handle);
+C_EXPORT void QWindow_showNormal(QWindowH handle);
+C_EXPORT bool QWindow_close(QWindowH handle);
+C_EXPORT void QWindow_raise(QWindowH handle);
+C_EXPORT void QWindow_lower(QWindowH handle);
+C_EXPORT void QWindow_setTitle(QWindowH handle, PWideString AnonParam1);
+C_EXPORT void QWindow_setX(QWindowH handle, int argx);
+C_EXPORT void QWindow_setY(QWindowH handle, int argy);
+C_EXPORT void QWindow_setWidth(QWindowH handle, int argw);
+C_EXPORT void QWindow_setHeight(QWindowH handle, int argh);
+C_EXPORT void QWindow_setMinimumWidth(QWindowH handle, int w);
+C_EXPORT void QWindow_setMinimumHeight(QWindowH handle, int h);
+C_EXPORT void QWindow_setMaximumWidth(QWindowH handle, int w);
+C_EXPORT void QWindow_setMaximumHeight(QWindowH handle, int h);
+C_EXPORT void QWindow_alert(QWindowH handle, int msec);
+C_EXPORT void QWindow_requestUpdate(QWindowH handle);
+
+#endif
Index: src/qwindow_hook_c.cpp
===================================================================
--- /dev/null
+++ b/src/qwindow_hook_c.cpp
@@ -0,0 +1,112 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#include "qwindow_hook_c.h"
+
+QWindow_hookH QWindow_hook_Create(QObjectH handle)
+{
+	return (QWindow_hookH) new QWindow_hook((QObject*)handle);
+}
+
+void QWindow_hook_Destroy(QWindow_hookH handle)
+{
+	delete (QWindow_hook *)handle;
+}
+
+void QWindow_hook_hook_screenChanged(QWindow_hookH handle, QHookH hook)
+{
+	((QWindow_hook *)handle)->hook_screenChanged(hook);
+}
+
+void QWindow_hook_hook_modalityChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_modalityChanged(hook);
+}
+
+void QWindow_hook_hook_windowStateChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_windowStateChanged(hook);
+}
+
+void QWindow_hook_hook_windowTitleChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_windowTitleChanged(hook);
+}
+
+void QWindow_hook_hook_xChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_xChanged(hook);
+}
+
+void QWindow_hook_hook_yChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_yChanged(hook);
+}
+
+void QWindow_hook_hook_widthChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_widthChanged(hook);
+}
+
+void QWindow_hook_hook_heightChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_heightChanged(hook);
+}
+
+void QWindow_hook_hook_minimumWidthChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_minimumWidthChanged(hook);
+}
+
+void QWindow_hook_hook_minimumHeightChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_minimumHeightChanged(hook);
+}
+
+void QWindow_hook_hook_maximumWidthChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_maximumWidthChanged(hook);
+}
+
+void QWindow_hook_hook_maximumHeightChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_maximumHeightChanged(hook);
+}
+
+void QWindow_hook_hook_visibleChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_visibleChanged(hook);
+}
+
+void QWindow_hook_hook_visibilityChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_visibilityChanged(hook);
+}
+
+void QWindow_hook_hook_activeChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_activeChanged(hook);
+}
+
+void QWindow_hook_hook_contentOrientationChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_contentOrientationChanged(hook);
+}
+
+void QWindow_hook_hook_focusObjectChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_focusObjectChanged(hook);
+}
+
+void QWindow_hook_hook_opacityChanged(QWindow_hookH handle, QHookH hook)
+{
+  ((QWindow_hook *)handle)->hook_opacityChanged(hook);
+}
Index: src/qwindow_hook_c.h
===================================================================
--- /dev/null
+++ b/src/qwindow_hook_c.h
@@ -0,0 +1,38 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#ifndef QWINDOW_HOOK_C_H
+#define QWINDOW_HOOK_C_H
+
+#include "qwindow_hook.h"
+
+C_EXPORT QWindow_hookH QWindow_hook_Create(QObjectH handle);
+C_EXPORT void QWindow_hook_Destroy(QWindow_hookH handle);
+C_EXPORT void QWindow_hook_hook_screenChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_modalityChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_windowStateChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_windowTitleChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_xChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_yChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_widthChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_heightChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_minimumWidthChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_minimumHeightChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_maximumWidthChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_maximumHeightChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_visibleChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_visibilityChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_activeChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_contentOrientationChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_focusObjectChanged(QWindow_hookH handle, QHookH hook);
+C_EXPORT void QWindow_hook_hook_opacityChanged(QWindow_hookH handle, QHookH hook);
+
+#endif
Index: src/qwindow_hook.h
===================================================================
--- /dev/null
+++ b/src/qwindow_hook.h
@@ -0,0 +1,341 @@
+//******************************************************************************
+//  Copyright (c) 2017 by Željan Rikalo
+//
+//  See the included file COPYING.TXT for details about the copyright.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+//******************************************************************************
+
+
+#ifndef QWINDOW_HOOK_H
+#define QWINDOW_HOOK_H
+
+#include <qwindow.h>
+
+#include "qobject_hook.h"
+
+class QWindow_hook : public QObject_hook {
+  Q_OBJECT
+  public:
+    QWindow_hook(QObject *handle) : QObject_hook(handle) {
+      screenChanged_event.func = NULL;;
+      modalityChanged_event.func = NULL;;
+      windowStateChanged_event.func = NULL;;
+      windowTitleChanged_event.func = NULL;;
+      xChanged_event.func = NULL;;
+      yChanged_event.func = NULL;;
+      widthChanged_event.func = NULL;;
+      heightChanged_event.func = NULL;;
+      minimumWidthChanged_event.func = NULL;;
+      minimumHeightChanged_event.func = NULL;;
+      maximumWidthChanged_event.func = NULL;;
+      maximumHeightChanged_event.func = NULL;;
+      visibleChanged_event.func = NULL;;
+      visibilityChanged_event.func = NULL;;
+      activeChanged_event.func = NULL;;
+      contentOrientationChanged_event.func = NULL;;
+      focusObjectChanged_event.func = NULL;;
+      opacityChanged_event.func = NULL;;
+
+    }
+
+    void hook_screenChanged(QHook &hook) {
+      if ( !screenChanged_event.func )
+        connect(handle, SIGNAL(screenChanged(QScreen*)), this, SLOT(screenChanged_hook(QScreen*)));
+      screenChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(screenChanged(QScreen*)), this, SLOT(screenChanged_hook(QScreen*)));
+    }
+
+    void hook_modalityChanged(QHook &hook) {
+      if ( !modalityChanged_event.func )
+        connect(handle, SIGNAL(modalityChanged(Qt::WindowModality)), this, SLOT(modalityChanged_hook(Qt::WindowModality)));
+      modalityChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(modalityChanged(Qt::WindowModality)), this, SLOT(modalityChanged_hook(Qt::WindowModality)));
+    }
+
+    void hook_windowStateChanged(QHook &hook) {
+      if ( !windowStateChanged_event.func )
+        connect(handle, SIGNAL(windowStateChanged(Qt::WindowState)), this, SLOT(windowStateChanged_hook(Qt::WindowState)));
+      windowStateChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(windowStateChanged(Qt::WindowState)), this, SLOT(windowStateChanged_hook(Qt::WindowState)));
+    }
+
+    void hook_windowTitleChanged(QHook &hook) {
+      if ( !windowTitleChanged_event.func )
+        connect(handle, SIGNAL(windowTitleChanged(const QString&)), this, SLOT(windowTitleChanged_hook(const QString&)));
+      windowTitleChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(windowTitleChanged(const QString&)), this, SLOT(windowTitleChanged_hook(const QString&)));
+    }
+
+    void hook_xChanged(QHook &hook) {
+      if ( !xChanged_event.func )
+        connect(handle, SIGNAL(xChanged(int)), this, SLOT(xChanged_hook(int)));
+      xChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(xChanged(int)), this, SLOT(xChanged_hook(int)));
+    }
+
+    void hook_yChanged(QHook &hook) {
+      if ( !yChanged_event.func )
+        connect(handle, SIGNAL(yChanged(int)), this, SLOT(yChanged_hook(int)));
+      yChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(yChanged(int)), this, SLOT(yChanged_hook(int)));
+    }
+
+    void hook_widthChanged(QHook &hook) {
+      if ( !widthChanged_event.func )
+        connect(handle, SIGNAL(widthChanged(int)), this, SLOT(widthChanged_hook(int)));
+      widthChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(widthChanged(int)), this, SLOT(widthChanged_hook(int)));
+    }
+
+    void hook_heightChanged(QHook &hook) {
+      if ( !heightChanged_event.func )
+        connect(handle, SIGNAL(heightChanged(int)), this, SLOT(heightChanged_hook(int)));
+      heightChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(heightChanged(int)), this, SLOT(heightChanged_hook(int)));
+    }
+
+    void hook_minimumWidthChanged(QHook &hook) {
+      if ( !minimumWidthChanged_event.func )
+        connect(handle, SIGNAL(minimumWidthChanged(int)), this, SLOT(minimumWidthChanged_hook(int)));
+      minimumWidthChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(minimumWidthChanged(int)), this, SLOT(minimumWidthChanged_hook(int)));
+    }
+
+    void hook_minimumHeightChanged(QHook &hook) {
+      if ( !minimumHeightChanged_event.func )
+        connect(handle, SIGNAL(minimumHeightChanged(int)), this, SLOT(minimumHeightChanged_hook(int)));
+      minimumHeightChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(minimumHeightChanged(int)), this, SLOT(minimumHeightChanged_hook(int)));
+    }
+
+    void hook_maximumWidthChanged(QHook &hook) {
+      if ( !maximumWidthChanged_event.func )
+        connect(handle, SIGNAL(maximumWidthChanged(int)), this, SLOT(maximumWidthChanged_hook(int)));
+      maximumWidthChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(maximumWidthChanged(int)), this, SLOT(maximumWidthChanged_hook(int)));
+    }
+
+    void hook_maximumHeightChanged(QHook &hook) {
+      if ( !maximumHeightChanged_event.func )
+        connect(handle, SIGNAL(maximumHeightChanged(int)), this, SLOT(maximumHeightChanged_hook(int)));
+      maximumHeightChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(maximumHeightChanged(int)), this, SLOT(maximumHeightChanged_hook(int)));
+    }
+
+    void hook_visibleChanged(QHook &hook) {
+      if ( !visibleChanged_event.func )
+        connect(handle, SIGNAL(visibleChanged(bool)), this, SLOT(visibleChanged_hook(bool)));
+      visibleChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(visibleChanged(bool)), this, SLOT(visibleChanged_hook(bool)));
+    }
+
+    void hook_visibilityChanged(QHook &hook) {
+      if ( !visibilityChanged_event.func )
+        connect(handle, SIGNAL(visibilityChanged(QWindow::Visibility)), this, SLOT(visibilityChanged_hook(QWindow::Visibility)));
+      visibilityChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(visibilityChanged(QWindow::Visibility)), this, SLOT(visibilityChanged_hook(QWindow::Visibility)));
+    }
+
+    void hook_activeChanged(QHook &hook) {
+      if ( !activeChanged_event.func )
+        connect(handle, SIGNAL(activeChanged()), this, SLOT(activeChanged_hook()));
+      activeChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(activeChanged()), this, SLOT(activeChanged_hook()));
+    }
+
+    void hook_contentOrientationChanged(QHook &hook) {
+      if ( !contentOrientationChanged_event.func )
+        connect(handle, SIGNAL(contentOrientationChanged(Qt::ScreenOrientation)), this, SLOT(contentOrientationChanged_hook(Qt::ScreenOrientation)));
+      contentOrientationChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(contentOrientationChanged(Qt::ScreenOrientation)), this, SLOT(contentOrientationChanged_hook(Qt::ScreenOrientation)));
+    }
+
+    void hook_focusObjectChanged(QHook &hook) {
+      if ( !focusObjectChanged_event.func )
+        connect(handle, SIGNAL(focusObjectChanged(QObject*)), this, SLOT(focusObjectChanged_hook(QObject*)));
+      focusObjectChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(focusObjectChanged(QObject*)), this, SLOT(focusObjectChanged_hook(QObject*)));
+    }
+
+    void hook_opacityChanged(QHook &hook) {
+      if ( !opacityChanged_event.func )
+        connect(handle, SIGNAL(opacityChanged(qreal)), this, SLOT(opacityChanged_hook(qreal)));
+      opacityChanged_event = hook;
+      if ( !hook.func )
+        disconnect(handle, SIGNAL(opacityChanged(qreal)), this, SLOT(opacityChanged_hook(qreal)));
+    }
+
+  private slots:
+    void screenChanged_hook(QScreen* screen) {
+      if ( screenChanged_event.func ) {
+        typedef void (*func_type)(void *data, QScreenH screen);
+	(*(func_type)screenChanged_event.func)(screenChanged_event.data, (QScreenH)screen);
+      }
+    }
+
+    void modalityChanged_hook(Qt::WindowModality modality) {
+      if ( modalityChanged_event.func ) {
+        typedef void (*func_type)(void *data, Qt::WindowModality modality);
+	(*(func_type)modalityChanged_event.func)(modalityChanged_event.data, modality);
+      }
+    }
+
+    void windowStateChanged_hook(Qt::WindowState windowState) {
+      if ( windowStateChanged_event.func ) {
+        typedef void (*func_type)(void *data, Qt::WindowState windowState);
+	(*(func_type)windowStateChanged_event.func)(windowStateChanged_event.data, windowState);
+      }
+    }
+
+    void windowTitleChanged_hook(const QString& title) {
+      if ( windowTitleChanged_event.func ) {
+        typedef void (*func_type)(void *data, PWideString title);
+	PWideString t_title;
+	initializePWideString(t_title);
+	copyQStringToPWideString(title, t_title);
+	(*(func_type)windowTitleChanged_event.func)(windowTitleChanged_event.data, t_title);
+	finalizePWideString(t_title);
+      }
+    }
+
+    void xChanged_hook(int arg) {
+      if ( xChanged_event.func ) {
+        typedef void (*func_type)(void *data, int arg);
+	(*(func_type)xChanged_event.func)(xChanged_event.data, arg);
+      }
+    }
+
+    void yChanged_hook(int arg) {
+      if ( yChanged_event.func ) {
+        typedef void (*func_type)(void *data, int arg);
+	(*(func_type)yChanged_event.func)(yChanged_event.data, arg);
+      }
+    }
+
+    void widthChanged_hook(int arg) {
+      if ( widthChanged_event.func ) {
+        typedef void (*func_type)(void *data, int arg);
+	(*(func_type)widthChanged_event.func)(widthChanged_event.data, arg);
+      }
+    }
+
+    void heightChanged_hook(int arg) {
+      if ( heightChanged_event.func ) {
+        typedef void (*func_type)(void *data, int arg);
+	(*(func_type)heightChanged_event.func)(heightChanged_event.data, arg);
+      }
+    }
+
+    void minimumWidthChanged_hook(int arg) {
+      if ( minimumWidthChanged_event.func ) {
+        typedef void (*func_type)(void *data, int arg);
+	(*(func_type)minimumWidthChanged_event.func)(minimumWidthChanged_event.data, arg);
+      }
+    }
+
+    void minimumHeightChanged_hook(int arg) {
+      if ( minimumHeightChanged_event.func ) {
+        typedef void (*func_type)(void *data, int arg);
+	(*(func_type)minimumHeightChanged_event.func)(minimumHeightChanged_event.data, arg);
+      }
+    }
+
+    void maximumWidthChanged_hook(int arg) {
+      if ( maximumWidthChanged_event.func ) {
+        typedef void (*func_type)(void *data, int arg);
+	(*(func_type)maximumWidthChanged_event.func)(maximumWidthChanged_event.data, arg);
+      }
+    }
+
+    void maximumHeightChanged_hook(int arg) {
+      if ( maximumHeightChanged_event.func ) {
+        typedef void (*func_type)(void *data, int arg);
+	(*(func_type)maximumHeightChanged_event.func)(maximumHeightChanged_event.data, arg);
+      }
+    }
+
+    void visibleChanged_hook(bool arg) {
+      if ( visibleChanged_event.func ) {
+        typedef void (*func_type)(void *data, bool arg);
+	(*(func_type)visibleChanged_event.func)(visibleChanged_event.data, arg);
+      }
+    }
+
+    void visibilityChanged_hook(QWindow::Visibility visibility) {
+      if ( visibilityChanged_event.func ) {
+        typedef void (*func_type)(void *data, QWindow::Visibility visibility);
+	(*(func_type)visibilityChanged_event.func)(visibilityChanged_event.data, visibility);
+      }
+    }
+
+    void activeChanged_hook() {
+      if ( activeChanged_event.func ) {
+        typedef void (*func_type)(void *data);
+	(*(func_type)activeChanged_event.func)(activeChanged_event.data);
+      }
+    }
+
+    void contentOrientationChanged_hook(Qt::ScreenOrientation orientation) {
+      if ( contentOrientationChanged_event.func ) {
+        typedef void (*func_type)(void *data, Qt::ScreenOrientation orientation);
+	(*(func_type)contentOrientationChanged_event.func)(contentOrientationChanged_event.data, orientation);
+      }
+    }
+
+    void focusObjectChanged_hook(QObject* object) {
+      if ( focusObjectChanged_event.func ) {
+        typedef void (*func_type)(void *data, QObjectH object);
+	(*(func_type)focusObjectChanged_event.func)(focusObjectChanged_event.data, (QObjectH)object);
+      }
+    }
+
+    void opacityChanged_hook(qreal opacity) {
+      if ( opacityChanged_event.func ) {
+        typedef void (*func_type)(void *data, qreal opacity);
+	(*(func_type)opacityChanged_event.func)(opacityChanged_event.data, opacity);
+      }
+    }
+
+  private:
+    QHook screenChanged_event;
+    QHook modalityChanged_event;
+    QHook windowStateChanged_event;
+    QHook windowTitleChanged_event;
+    QHook xChanged_event;
+    QHook yChanged_event;
+    QHook widthChanged_event;
+    QHook heightChanged_event;
+    QHook minimumWidthChanged_event;
+    QHook minimumHeightChanged_event;
+    QHook maximumWidthChanged_event;
+    QHook maximumHeightChanged_event;
+    QHook visibleChanged_event;
+    QHook visibilityChanged_event;
+    QHook activeChanged_event;
+    QHook contentOrientationChanged_event;
+    QHook focusObjectChanged_event;
+    QHook opacityChanged_event;
+};
+
+
+#endif
Index: qt5.pas
===================================================================
--- a/qt5.pas
+++ b/qt5.pas
@@ -78,11 +78,7 @@ type
   QtHandle = LongWord;
   {$ENDIF}
   PQReal = ^QReal;
-  {$ifdef CPUARM}
-    QReal = single;
-  {$else}
-    QReal = double;
-  {$endif}
+  QReal = double;
 
   PQRgb = ^QRgb;
   QRgb = longword;
Index: src/qpaintdevice_c.cpp
===================================================================
--- a/src/qpaintdevice_c.cpp
+++ b/src/qpaintdevice_c.cpp
@@ -71,6 +71,12 @@ int QPaintDevice_devicePixelRatio(QPaint
 	return (int) ((QPaintDevice *)handle)->devicePixelRatio();
 }
 
+qreal QPaintDevice_devicePixelRatioF(QPaintDeviceH handle)
+{
+	return (qreal) ((QPaintDevice *)handle)->devicePixelRatioF();
+}
+
+
 int QPaintDevice_colorCount(QPaintDeviceH handle)
 {
 	return (int) ((QPaintDevice *)handle)->colorCount();
Index: src/qpaintdevice_c.h
===================================================================
--- a/src/qpaintdevice_c.h
+++ b/src/qpaintdevice_c.h
@@ -27,6 +27,7 @@ C_EXPORT int QPaintDevice_logicalDpiY(QP
 C_EXPORT int QPaintDevice_physicalDpiX(QPaintDeviceH handle);
 C_EXPORT int QPaintDevice_physicalDpiY(QPaintDeviceH handle);
 C_EXPORT int QPaintDevice_devicePixelRatio(QPaintDeviceH handle);
+C_EXPORT qreal QPaintDevice_devicePixelRatioF(QPaintDeviceH handle);
 C_EXPORT int QPaintDevice_colorCount(QPaintDeviceH handle);
 C_EXPORT int QPaintDevice_depth(QPaintDeviceH handle);
 
Index: src/qplaintextedit_c.cpp
===================================================================
--- a/src/qplaintextedit_c.cpp
+++ b/src/qplaintextedit_c.cpp
@@ -355,6 +355,21 @@ void QPlainTextEdit_zoomOut(QPlainTextEd
 	((QPlainTextEdit *)handle)->zoomOut(range);
 }
 
+void QPlainTextEdit_placeholderText(QPlainTextEditH handle, PWideString retval)
+{
+	QString t_retval;
+	t_retval = ((QPlainTextEdit *)handle)->placeholderText();
+	copyQStringToPWideString(t_retval, retval);
+}
+
+void QPlainTextEdit_setPlaceholderText(QPlainTextEditH handle, PWideString text)
+{
+	QString t_text;
+	copyPWideStringToQString(text, t_text);
+	((QPlainTextEdit *)handle)->setPlaceholderText(t_text);
+}
+
+
 QPlainTextDocumentLayoutH QPlainTextDocumentLayout_Create(QTextDocumentH document)
 {
 	return (QPlainTextDocumentLayoutH) new QPlainTextDocumentLayout((QTextDocument*)document);
Index: src/qplaintextedit_c.h
===================================================================
--- a/src/qplaintextedit_c.h
+++ b/src/qplaintextedit_c.h
@@ -79,6 +79,9 @@ C_EXPORT void QPlainTextEdit_appendHtml(
 C_EXPORT void QPlainTextEdit_centerCursor(QPlainTextEditH handle);
 C_EXPORT void QPlainTextEdit_zoomIn(QPlainTextEditH handle, int range);
 C_EXPORT void QPlainTextEdit_zoomOut(QPlainTextEditH handle, int range);
+C_EXPORT void QPlainTextEdit_placeholderText(QPlainTextEditH handle, PWideString retval);
+C_EXPORT void QPlainTextEdit_setPlaceholderText(QPlainTextEditH handle, PWideString text);
+
 C_EXPORT QPlainTextDocumentLayoutH QPlainTextDocumentLayout_Create(QTextDocumentH document);
 C_EXPORT void QPlainTextDocumentLayout_Destroy(QPlainTextDocumentLayoutH handle);
 C_EXPORT int QPlainTextDocumentLayout_hitTest(QPlainTextDocumentLayoutH handle, const QPointFH AnonParam1, Qt::HitTestAccuracy AnonParam2);
Index: src/qprinterinfo_c.cpp
===================================================================
--- a/src/qprinterinfo_c.cpp
+++ b/src/qprinterinfo_c.cpp
@@ -83,6 +83,11 @@ void QPrinterInfo_availablePrinters(PPtr
 	copyQListTemplateToPtrIntArrayWithNew(t_retval, retval);
 }
 
+void QPrinterInfo_availablePrinterNames(QStringListH retval)
+{
+  *(QStringList *)retval = QPrinterInfo::availablePrinterNames();
+}
+
 void QPrinterInfo_defaultPrinter(QPrinterInfoH retval)
 {
 	*(QPrinterInfo *)retval = QPrinterInfo::defaultPrinter();
Index: src/qprinterinfo_c.h
===================================================================
--- a/src/qprinterinfo_c.h
+++ b/src/qprinterinfo_c.h
@@ -27,6 +27,7 @@ C_EXPORT bool QPrinterInfo_isNull(QPrint
 C_EXPORT bool QPrinterInfo_isDefault(QPrinterInfoH handle);
 C_EXPORT void QPrinterInfo_supportedPaperSizes(QPrinterInfoH handle, PPtrIntArray retval);
 C_EXPORT void QPrinterInfo_availablePrinters(PPtrIntArray retval);
+C_EXPORT void QPrinterInfo_availablePrinterNames(QStringListH retval);
 C_EXPORT void QPrinterInfo_defaultPrinter(QPrinterInfoH retval);
 C_EXPORT void QPrinterInfo_printerInfo(QPrinterInfoH retval, PWideString printerName);
 
Index: src/qtextedit_c.cpp
===================================================================
--- a/src/qtextedit_c.cpp
+++ b/src/qtextedit_c.cpp
@@ -472,3 +472,17 @@ void QTextEdit_zoomOut(QTextEditH handle
 	((QTextEdit *)handle)->zoomOut(range);
 }
 
+void QTextEdit_placeholderText(QTextEditH handle, PWideString retval)
+{
+	QString t_retval;
+	t_retval = ((QTextEdit *)handle)->placeholderText();
+	copyQStringToPWideString(t_retval, retval);
+}
+
+void QTextEdit_setPlaceholderText(QTextEditH handle, PWideString text)
+{
+	QString t_text;
+	copyPWideStringToQString(text, t_text);
+	((QTextEdit *)handle)->setPlaceholderText(t_text);
+}
+
Index: src/qtextedit_c.h
===================================================================
--- a/src/qtextedit_c.h
+++ b/src/qtextedit_c.h
@@ -100,5 +100,7 @@ C_EXPORT void QTextEdit_append(QTextEdit
 C_EXPORT void QTextEdit_scrollToAnchor(QTextEditH handle, PWideString name);
 C_EXPORT void QTextEdit_zoomIn(QTextEditH handle, int range);
 C_EXPORT void QTextEdit_zoomOut(QTextEditH handle, int range);
+C_EXPORT void QTextEdit_placeholderText(QTextEditH handle, PWideString retval);
+C_EXPORT void QTextEdit_setPlaceholderText(QTextEditH handle, PWideString text);
 
 #endif
