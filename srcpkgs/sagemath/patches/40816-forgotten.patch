From 5de75421e8c61eb1e7f64cb0cd6075c8b74209d8 Mon Sep 17 00:00:00 2001
From: Chenxin Zhong <chenxin.zhong@outlook.com>
Date: Sat, 13 Dec 2025 03:31:46 +0800
Subject: [PATCH] Fix GCD assertion in MacLaneLimitValuation to handle mutable
 cached limit valuations

---
 src/sage/rings/valuation/limit_valuation.py | 20 +++++++++++++++++++-
 1 file changed, 19 insertions(+), 1 deletion(-)

diff --git a/src/sage/rings/valuation/limit_valuation.py b/src/sage/rings/valuation/limit_valuation.py
index c2555a327b6..063411d8110 100644
--- a/src/sage/rings/valuation/limit_valuation.py
+++ b/src/sage/rings/valuation/limit_valuation.py
@@ -698,7 +698,25 @@ def _ge_(self, other):
                 self._improve_approximation_for_call(other._G)
                 other._improve_approximation_for_call(self._G)
                 if self._G != other._G:
-                    assert self._G.gcd(other._G).is_one()
+                    gcd = self._G.gcd(other._G)
+                    if not gcd.is_one():
+                        # Cached limit valuations are mutable: earlier calls
+                        # to ``_improve_approximation_for_call`` may already
+                        # have replaced ``_G`` by the factor with infinite
+                        # valuation. This can leave one instance with a proper
+                        # factor of the other's ``_G``.
+                        #
+                        # In this situation, force both instances to reduce
+                        # further by calling with the complementary factor.
+                        # (Calling with the common factor itself may be an
+                        # equivalence unit and thus not trigger any reduction.)
+                        if gcd != self._G:
+                            self._improve_approximation_for_call(self._G // gcd)
+                        if gcd != other._G:
+                            other._improve_approximation_for_call(other._G // gcd)
+                        # Recompute after possible reductions.
+                        gcd = self._G.gcd(other._G)
+                    assert gcd.is_one()
                     return False
 
                 # If the valuations are comparable, they must approximate the
