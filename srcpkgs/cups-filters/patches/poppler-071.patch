diff --git a/filter/pdftoijs.cxx b/filter/pdftoijs.cxx
index dd6b6fa0..a9812be5 100644
--- filter/pdftoijs.cxx
+++ filter/pdftoijs.cxx
@@ -293,7 +293,7 @@ int main(int argc, char *argv[]) {
   int job_id;
   enum SplashColorMode cmode;
   int rowpad;
-  GBool reverseVideo;
+  bool reverseVideo;
 
 #if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 19
   setErrorCallback(::myErrorFun,NULL);
@@ -380,7 +380,7 @@ int main(int argc, char *argv[]) {
   /* set image's values */
   int numChan,bitsPerSample;
   const char *devName;
-  reverseVideo = gFalse;
+  reverseVideo = false;
   switch (colspace) {
   case COL_RGB:
     numChan=3;
@@ -394,7 +394,7 @@ int main(int argc, char *argv[]) {
     paperColor[2] = 255;
     break;
   case COL_BLACK1:
-    reverseVideo = gTrue;
+    reverseVideo = true;
   case COL_WHITE1:
     numChan=1;
     bitsPerSample=1;
@@ -405,7 +405,7 @@ int main(int argc, char *argv[]) {
     rowpad = 1;
     break;
   case COL_BLACK8:
-    reverseVideo = gTrue;
+    reverseVideo = true;
   case COL_WHITE8:
     numChan=1;
     bitsPerSample=8;
@@ -436,9 +436,9 @@ int main(int argc, char *argv[]) {
   }
 
   out = new SplashOutputDev(cmode,rowpad/* row padding */,
-    reverseVideo,paperColor,gTrue
+    reverseVideo,paperColor,true
 #if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR <= 30
-    ,gFalse
+    ,false
 #endif
     );
 #if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 19
@@ -467,7 +467,7 @@ int main(int argc, char *argv[]) {
     SplashBitmap *bitmap;
     unsigned int size;
 
-    doc->displayPage(out,i,resolution[0],resolution[1],0,gFalse,gFalse,gFalse);
+    doc->displayPage(out,i,resolution[0],resolution[1],0,false,false,false);
     bitmap = out->getBitmap();
 
     /* set page parameters */
diff --git a/filter/pdftoopvp/OPVPOutputDev.cxx b/filter/pdftoopvp/OPVPOutputDev.cxx
index 45ebe02c..2875cfe2 100644
--- filter/pdftoopvp/OPVPOutputDev.cxx
+++ filter/pdftoopvp/OPVPOutputDev.cxx
@@ -70,7 +70,7 @@ public:
 
   ~SplashOutFontFileID() {}
 
-  GBool matches(SplashFontFileID *id) {
+  bool matches(SplashFontFileID *id) {
     return ((SplashOutFontFileID *)id)->r.num == r.num &&
            ((SplashOutFontFileID *)id)->r.gen == r.gen;
   }
@@ -99,9 +99,9 @@ public:
   T3FontCache(Ref *fontID, double m11A, double m12A,
 	      double m21A, double m22A,
 	      int glyphXA, int glyphYA, int glyphWA, int glyphHA,
-	      GBool aa);
+	      bool aa);
   ~T3FontCache();
-  GBool matches(Ref *idA, double m11A, double m12A,
+  bool matches(Ref *idA, double m11A, double m12A,
 		double m21A, double m22A)
     { return fontID.num == idA->num && fontID.gen == idA->gen &&
 	     m11 == m11A && m12 == m12A && m21 == m21A && m22 == m22A; }
@@ -120,7 +120,7 @@ public:
 T3FontCache::T3FontCache(Ref *fontIDA, double m11A, double m12A,
 			 double m21A, double m22A,
 			 int glyphXA, int glyphYA, int glyphWA, int glyphHA,
-			 GBool aa) {
+			 bool aa) {
   int i;
 
   fontID = *fontIDA;
@@ -189,7 +189,7 @@ OPVPOutputDev::OPVPOutputDev()
   nT3Fonts = 0;
   t3GlyphStack = 0;
   font = NULL;
-  needFontUpdate = gFalse;
+  needFontUpdate = false;
   textClipPath = 0;
   underlayCbk = 0;
   underlayCbkData = 0;
@@ -216,8 +216,8 @@ void OPVPOutputDev::setScale(double w, double h,
 }
 
 int OPVPOutputDev::init(SplashColorMode colorModeA,
-				 GBool colorProfile,
-				 GBool reverseVideoA,
+				 bool colorProfile,
+				 bool reverseVideoA,
 				 SplashColor paperColorA,
                                  const char *driverName,
 				 int outputFD,
@@ -275,13 +275,13 @@ void OPVPOutputDev::startDoc(XRef *xrefA) {
 #endif
 #if HAVE_FREETYPE_FREETYPE_H || HAVE_FREETYPE_H
 				    globalParams->getEnableFreeType(),
-				    gFalse,
-                                    gFalse,
+				    false,
+                                    false,
 #endif
 #if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR <= 30
 				    globalParams->getAntialias());
 #else
-                                    gFalse);
+                                    false);
 #endif
   for (i = 0; i < nT3Fonts; ++i) {
     delete t3FontCache[i];
@@ -337,7 +337,7 @@ void OPVPOutputDev::saveState(GfxState *state) {
 
 void OPVPOutputDev::restoreState(GfxState *state) {
   oprs->restoreState();
-  needFontUpdate = gTrue;
+  needFontUpdate = true;
 }
 
 void OPVPOutputDev::updateAll(GfxState *state) {
@@ -349,7 +349,7 @@ void OPVPOutputDev::updateAll(GfxState *state) {
   updateMiterLimit(state);
   updateFillColor(state);
   updateStrokeColor(state);
-  needFontUpdate = gTrue;
+  needFontUpdate = true;
 }
 
 void OPVPOutputDev::updateCTM(GfxState *state, double m11, double m12,
@@ -490,7 +490,7 @@ SplashPattern *OPVPOutputDev::getColor(GfxGray gray, GfxRGB *rgb) {
 }
 
 void OPVPOutputDev::updateFont(GfxState *state) {
-    needFontUpdate = gTrue;
+    needFontUpdate = true;
 }
 
 void OPVPOutputDev::doUpdateFont(GfxState *state) {
@@ -513,9 +513,9 @@ void OPVPOutputDev::doUpdateFont(GfxState *state) {
   double m11, m12, m21, m22;
   int n;
   int faceIndex = 0;
-  GBool recreateFont = gFalse;
+  bool recreateFont = false;
 
-  needFontUpdate = gFalse;
+  needFontUpdate = false;
   font = NULL;
   fileName = NULL;
   tmpBuf = NULL;
@@ -594,9 +594,9 @@ void OPVPOutputDev::doUpdateFont(GfxState *state) {
 
     fontsrc = new SplashFontSrc;
     if (fileName)
-      fontsrc->setFile(fileName, gFalse);
+      fontsrc->setFile(fileName, false);
     else
-      fontsrc->setBuf(tmpBuf, tmpBufLen, gTrue);
+      fontsrc->setBuf(tmpBuf, tmpBufLen, true);
 
     // load the font file
     switch (fontType) {
@@ -742,7 +742,7 @@ void OPVPOutputDev::doUpdateFont(GfxState *state) {
       // this shouldn't happen
       goto err2;
     }
-    fontFile->doAdjustMatrix = gTrue;
+    fontFile->doAdjustMatrix = true;
   }
 
   // get the font matrix
@@ -777,7 +777,7 @@ void OPVPOutputDev::doUpdateFont(GfxState *state) {
           w1 /= w2;
           m11 *= w1;
           m21 *= w1;
-          recreateFont = gTrue;
+          recreateFont = true;
         }
       }
     }
@@ -836,7 +836,7 @@ void OPVPOutputDev::fill(GfxState *state) {
   }
 
   path = convertPath(state, state->getPath());
-  oprs->fill(path, gFalse);
+  oprs->fill(path, false);
   delete path;
 }
 
@@ -855,7 +855,7 @@ void OPVPOutputDev::eoFill(GfxState *state) {
   }
 
   path = convertPath(state, state->getPath());
-  oprs->fill(path, gTrue);
+  oprs->fill(path, true);
   delete path;
 }
 
@@ -863,7 +863,7 @@ void OPVPOutputDev::clip(GfxState *state) {
   OPVPSplashPath *path;
 
   path = convertPath(state, state->getPath());
-  oprs->clipToPath(path, gFalse);
+  oprs->clipToPath(path, false);
   delete path;
 }
 
@@ -871,7 +871,7 @@ void OPVPOutputDev::eoClip(GfxState *state) {
   OPVPSplashPath *path;
 
   path = convertPath(state, state->getPath());
-  oprs->clipToPath(path, gTrue);
+  oprs->clipToPath(path, true);
   delete path;
 }
 
@@ -918,8 +918,8 @@ void OPVPOutputDev::clipToStrokePath(GfxState *state) {
 
   // use splash for makeStrokePath
   // create dummy bitmap for creating splash
-  tbitmap = new SplashBitmap(1, 1, 1, splashModeMono1, gFalse);
-  tsplash = new Splash(tbitmap, gFalse);
+  tbitmap = new SplashBitmap(1, 1, 1, splashModeMono1, false);
+  tsplash = new Splash(tbitmap, false);
   // set line parameters
   //  except colors
   updateSplashLineDash(state, tsplash);
@@ -939,7 +939,7 @@ void OPVPOutputDev::clipToStrokePath(GfxState *state) {
   delete path;
   delete tsplash;
   delete tbitmap;
-  oprs->clipToPath(path2, gFalse);
+  oprs->clipToPath(path2, false);
   delete path2;
 }
 
@@ -1043,11 +1043,11 @@ void OPVPOutputDev::drawChar(GfxState *state, double x, double y,
   }
 }
 
-GBool OPVPOutputDev::beginType3Char(GfxState *state, double x, double y,
+bool OPVPOutputDev::beginType3Char(GfxState *state, double x, double y,
 				      double dx, double dy,
 				      CharCode code, Unicode *u, int uLen) {
   /* In a vector mode, cache is not needed */
-  return gFalse;
+  return false;
 }
 
 void OPVPOutputDev::endType3Char(GfxState *state) {
@@ -1075,13 +1075,13 @@ void OPVPOutputDev::drawType3Glyph(T3FontCache *t3Font,
   glyph.h = t3Font->glyphH;
   glyph.aa = colorMode != splashModeMono1;
   glyph.data = data;
-  glyph.freeData = gFalse;
+  glyph.freeData = false;
   oprs->fillGlyph((SplashCoord)x, (SplashCoord)y, &glyph);
 }
 
 void OPVPOutputDev::endTextObject(GfxState *state) {
   if (textClipPath) {
-    oprs->clipToPath(textClipPath, gFalse);
+    oprs->clipToPath(textClipPath, false);
     delete textClipPath;
     textClipPath = NULL;
   }
@@ -1089,18 +1089,18 @@ void OPVPOutputDev::endTextObject(GfxState *state) {
 
 struct SplashOutImageMaskData {
   ImageStream *imgStr;
-  GBool invert;
+  bool invert;
   int width, height, y;
 };
 
-GBool OPVPOutputDev::imageMaskSrc(void *data, SplashColorPtr line) {
+bool OPVPOutputDev::imageMaskSrc(void *data, SplashColorPtr line) {
   SplashOutImageMaskData *imgMaskData = (SplashOutImageMaskData *)data;
   Guchar *p;
   SplashColorPtr q;
   int x;
 
   if (imgMaskData->y == imgMaskData->height) {
-    return gFalse;
+    return false;
   }
   for (x = 0, p = imgMaskData->imgStr->getLine(), q = line;
        x < imgMaskData->width;
@@ -1108,13 +1108,13 @@ GBool OPVPOutputDev::imageMaskSrc(void *data, SplashColorPtr line) {
     *q++ = *p++ ^ imgMaskData->invert;
   }
   ++imgMaskData->y;
-  return gTrue;
+  return true;
 }
 
 void OPVPOutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str,
-				    int width, int height, GBool invert,
-				    GBool interpolate,
-				    GBool inlineImg) {
+				    int width, int height, bool invert,
+				    bool interpolate,
+				    bool inlineImg) {
   double *ctm;
   SplashCoord mat[6];
   SplashOutImageMaskData imgMaskData;
@@ -1155,7 +1155,7 @@ struct SplashOutImageData {
   int width, height, y;
 };
 
-GBool OPVPOutputDev::imageSrc(void *data, SplashColorPtr line,
+bool OPVPOutputDev::imageSrc(void *data, SplashColorPtr line,
                               Guchar *alphaLine)
 {
   SplashOutImageData *imgData = (SplashOutImageData *)data;
@@ -1169,7 +1169,7 @@ GBool OPVPOutputDev::imageSrc(void *data, SplashColorPtr line,
   int nComps, x;
 
   if (imgData->y == imgData->height) {
-    return gFalse;
+    return false;
   }
 
   nComps = imgData->colorMap->getNumPixelComps();
@@ -1263,10 +1263,10 @@ GBool OPVPOutputDev::imageSrc(void *data, SplashColorPtr line,
   }
 
   ++imgData->y;
-  return gTrue;
+  return true;
 }
 
-GBool OPVPOutputDev::alphaImageSrc(void *data, SplashColorPtr line,
+bool OPVPOutputDev::alphaImageSrc(void *data, SplashColorPtr line,
                                   Guchar *alphaLine) {
   SplashOutImageData *imgData = (SplashOutImageData *)data;
   Guchar *p;
@@ -1280,7 +1280,7 @@ GBool OPVPOutputDev::alphaImageSrc(void *data, SplashColorPtr line,
   int nComps, x, i;
 
   if (imgData->y == imgData->height) {
-    return gFalse;
+    return false;
   }
 
   nComps = imgData->colorMap->getNumPixelComps();
@@ -1371,14 +1371,14 @@ GBool OPVPOutputDev::alphaImageSrc(void *data, SplashColorPtr line,
   }
 
   ++imgData->y;
-  return gTrue;
+  return true;
 }
 
 void OPVPOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,
 				int width, int height,
 				GfxImageColorMap *colorMap,
-			        GBool interpolate,
-				int *maskColors, GBool inlineImg) {
+			        bool interpolate,
+				int *maskColors, bool inlineImg) {
   double *ctm;
   SplashCoord mat[6];
   SplashOutImageData imgData;
@@ -1471,7 +1471,7 @@ void OPVPOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,
     srcMode = colorMode;
   }
   src = maskColors ? &alphaImageSrc : &imageSrc;
-  oprs->drawImage(src, &imgData, srcMode, maskColors ? gTrue : gFalse,
+  oprs->drawImage(src, &imgData, srcMode, maskColors ? true : false,
                   width, height, mat);
   if (inlineImg) {
     while (imgData.y < height) {
@@ -1494,7 +1494,7 @@ struct SplashOutMaskedImageData {
   int width, height, y;
 };
 
-GBool OPVPOutputDev::maskedImageSrc(void *data, SplashColorPtr line,
+bool OPVPOutputDev::maskedImageSrc(void *data, SplashColorPtr line,
      Guchar *alphaLine) {
   SplashOutMaskedImageData *imgData = (SplashOutMaskedImageData *)data;
   Guchar *p;
@@ -1509,7 +1509,7 @@ GBool OPVPOutputDev::maskedImageSrc(void *data, SplashColorPtr line,
   int nComps, x;
 
   if (imgData->y == imgData->height) {
-    return gFalse;
+    return false;
   }
 
   nComps = imgData->colorMap->getNumPixelComps();
@@ -1594,16 +1594,16 @@ GBool OPVPOutputDev::maskedImageSrc(void *data, SplashColorPtr line,
   }
 
   ++imgData->y;
-  return gTrue;
+  return true;
 }
 
 void OPVPOutputDev::drawMaskedImage(GfxState *state, Object *ref,
 				      Stream *str, int width, int height,
 				      GfxImageColorMap *colorMap,
-				      GBool interpolate,
+				      bool interpolate,
 				      Stream *maskStr, int maskWidth,
-				      int maskHeight, GBool maskInvert,
-				      GBool maskInterpolate) {
+				      int maskHeight, bool maskInvert,
+				      bool maskInterpolate) {
   double *ctm;
   SplashCoord mat[6];
   SplashOutMaskedImageData imgData;
@@ -1634,14 +1634,14 @@ void OPVPOutputDev::drawMaskedImage(GfxState *state, Object *ref,
   imgMaskData.width = maskWidth;
   imgMaskData.height = maskHeight;
   imgMaskData.y = 0;
-  maskBitmap = new SplashBitmap(width, height, 1, splashModeMono1, gFalse);
-  maskSplash = new Splash(maskBitmap, gFalse);
+  maskBitmap = new SplashBitmap(width, height, 1, splashModeMono1, false);
+  maskSplash = new Splash(maskBitmap, false);
   maskColor[0] = 0;
   maskSplash->clear(maskColor);
   maskColor[0] = 1;
   maskSplash->setFillPattern(new SplashSolidColor(maskColor));
   maskSplash->fillImageMask(&imageMaskSrc, &imgMaskData,
-			    maskWidth, maskHeight, mat, gFalse);
+			    maskWidth, maskHeight, mat, false);
   delete imgMaskData.imgStr;
   maskStr->close();
   delete maskSplash;
@@ -1742,7 +1742,7 @@ void OPVPOutputDev::drawMaskedImage(GfxState *state, Object *ref,
     srcMode = splashModeRGB8;
     break;
   }  
-  oprs->drawImage(&maskedImageSrc, &imgData, srcMode, gTrue, 
+  oprs->drawImage(&maskedImageSrc, &imgData, srcMode, true, 
                   width, height, mat);
 
   delete maskBitmap;
@@ -1754,11 +1754,11 @@ void OPVPOutputDev::drawMaskedImage(GfxState *state, Object *ref,
 void OPVPOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref,
 					  Stream *str, int width, int height,
 					  GfxImageColorMap *colorMap,
-					  GBool interpolate,
+					  bool interpolate,
 					  Stream *maskStr,
 					  int maskWidth, int maskHeight,
 					  GfxImageColorMap *maskColorMap,
-					  GBool maskInterpolate) {
+					  bool maskInterpolate) {
   double *ctm;
   SplashCoord mat[6];
   SplashOutImageData imgData;
@@ -1803,21 +1803,21 @@ void OPVPOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref,
     imgMaskData.lookup[i] = colToByte(gray);
   }
   maskBitmap = new SplashBitmap(maskWidth,maskHeight,
-				1, splashModeMono8, gFalse);
-  maskSplash = new Splash(maskBitmap, gFalse);
+				1, splashModeMono8, false);
+  maskSplash = new Splash(maskBitmap, false);
   maskColor[0] = 0;
   maskSplash->clear(maskColor);
 #if POPPLER_VERSION_MAJOR <= 0 && (POPPLER_VERSION_MINOR <= 20 || (POPPLER_VERSION_MINOR == 21 && POPPLER_VERSION_MICRO <= 2))
   maskSplash->drawImage(&imageSrc, &imgMaskData,
-			splashModeMono8, gFalse, maskWidth, maskHeight, mat);
+			splashModeMono8, false, maskWidth, maskHeight, mat);
 #elif POPPLER_VERSION_MAJOR <= 0 && POPPLER_VERSION_MINOR <= 33
   maskSplash->drawImage(&imageSrc, &imgMaskData,
-			splashModeMono8, gFalse, maskWidth, maskHeight,
-                        mat,gFalse);
+			splashModeMono8, false, maskWidth, maskHeight,
+                        mat,false);
 #else
   maskSplash->drawImage(&imageSrc, 0, &imgMaskData,
-                          splashModeMono8, gFalse, maskWidth, maskHeight,
-			                          mat,gFalse);
+                          splashModeMono8, false, maskWidth, maskHeight,
+			                          mat,false);
 #endif
   delete imgMaskData.imgStr;
   maskStr->close();
@@ -1913,7 +1913,7 @@ void OPVPOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref,
     srcMode = splashModeRGB8;
     break;
   }  
-  oprs->drawImage(&imageSrc, &imgData, srcMode, gFalse, width, height, mat);
+  oprs->drawImage(&imageSrc, &imgData, srcMode, false, width, height, mat);
 
   oprs->setSoftMask(NULL);
   gfree(imgData.lookup);
diff --git a/filter/pdftoopvp/OPVPOutputDev.h b/filter/pdftoopvp/OPVPOutputDev.h
index c2af86e3..f3d08257 100644
--- filter/pdftoopvp/OPVPOutputDev.h
+++ filter/pdftoopvp/OPVPOutputDev.h
@@ -52,7 +52,7 @@ public:
   OPVPOutputDev();
 
   // Second Constructor
-  int init(SplashColorMode colorModeA, GBool colorProfile, GBool reverseVideoA,
+  int init(SplashColorMode colorModeA, bool colorProfile, bool reverseVideoA,
 		  SplashColor paperColorA,
 		  const char *driverName, int outputFD,
 		  const char *printerModel,
@@ -66,14 +66,14 @@ public:
 
   // Does this device use upside-down coordinates?
   // (Upside-down means (0,0) is the top left corner of the page.)
-  virtual GBool upsideDown() { return gTrue; }
+  virtual bool upsideDown() { return true; }
 
   // Does this device use drawChar() or drawString()?
-  virtual GBool useDrawChar() { return gTrue; }
+  virtual bool useDrawChar() { return true; }
 
   // Does this device use beginType3Char/endType3Char?  Otherwise,
   // text in Type 3 fonts will be drawn with drawChar/drawString.
-  virtual GBool interpretType3Chars() { return gTrue; }
+  virtual bool interpretType3Chars() { return true; }
 
   //----- initialization and control
 
@@ -118,7 +118,7 @@ public:
 			double dx, double dy,
 			double originX, double originY,
 			CharCode code, int nBytes, Unicode *u, int uLen);
-  virtual GBool beginType3Char(GfxState *state, double x, double y,
+  virtual bool beginType3Char(GfxState *state, double x, double y,
 			       double dx, double dy,
 			       CharCode code, Unicode *u, int uLen);
   virtual void endType3Char(GfxState *state);
@@ -126,27 +126,27 @@ public:
 
   //----- image drawing
   virtual void drawImageMask(GfxState *state, Object *ref, Stream *str,
-			     int width, int height, GBool invert,
-			     GBool interpolate,
-			     GBool inlineImg);
+			     int width, int height, bool invert,
+			     bool interpolate,
+			     bool inlineImg);
   virtual void drawImage(GfxState *state, Object *ref, Stream *str,
 			 int width, int height, GfxImageColorMap *colorMap,
-			 GBool interpolate,
-			 int *maskColors, GBool inlineImg);
+			 bool interpolate,
+			 int *maskColors, bool inlineImg);
   virtual void drawMaskedImage(GfxState *state, Object *ref, Stream *str,
 			       int width, int height,
 			       GfxImageColorMap *colorMap,
-			       GBool interpolate,
+			       bool interpolate,
 			       Stream *maskStr, int maskWidth, int maskHeight,
-			       GBool maskInvert, GBool maskeInterpolate);
+			       bool maskInvert, bool maskeInterpolate);
   virtual void drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str,
 				   int width, int height,
 				   GfxImageColorMap *colorMap,
-				   GBool interpolate,
+				   bool interpolate,
 				   Stream *maskStr,
 				   int maskWidth, int maskHeight,
 				   GfxImageColorMap *maskColorMap,
-				   GBool maskInterpolate);
+				   bool maskInterpolate);
 
   //----- Type 3 font operators
   virtual void type3D0(GfxState *state, double wx, double wy);
@@ -158,7 +158,7 @@ public:
   // Called to indicate that a new PDF document has been loaded.
   void startDoc(XRef *xrefA);
 
-  GBool isReverseVideo() { return reverseVideo; }
+  bool isReverseVideo() { return reverseVideo; }
 
   // Get the bitmap and its size.
   SplashBitmap *getBitmap() { return bitmap; }
@@ -200,12 +200,12 @@ private:
   void patternFillChar(GfxState *state,
     double x, double y, CharCode code);
 
-  static GBool imageMaskSrc(void *data, SplashColorPtr line);
-  static GBool imageSrc(void *data, SplashColorPtr line,
+  static bool imageMaskSrc(void *data, SplashColorPtr line);
+  static bool imageSrc(void *data, SplashColorPtr line,
                               Guchar *alphaLine);
-  static GBool alphaImageSrc(void *data, SplashColorPtr line,
+  static bool alphaImageSrc(void *data, SplashColorPtr line,
                               Guchar *alphaLine);
-  static GBool maskedImageSrc(void *data, SplashColorPtr line,
+  static bool maskedImageSrc(void *data, SplashColorPtr line,
                               Guchar *alphaLine);
 
   OPVPSplashPath *bitmapToPath(SplashBitmap *bitmapA, int width, int height);
@@ -218,7 +218,7 @@ private:
   void updateSplashLineDash(GfxState *state, Splash *splash);
 
   SplashColorMode colorMode;
-  GBool reverseVideo;		// reverse video mode
+  bool reverseVideo;		// reverse video mode
   SplashColor paperColor;	// paper color
 
   XRef *xref;			// xref table for current document
@@ -233,7 +233,7 @@ private:
   T3GlyphStack *t3GlyphStack;	// Type 3 glyph context stack
 
   SplashFont *font;		// current font
-  GBool needFontUpdate;		// set when the font needs to be updated
+  bool needFontUpdate;		// set when the font needs to be updated
   OPVPSplashPath *textClipPath;	// clipping path built with text object
 
   void (*underlayCbk)(void *data);
diff --git a/filter/pdftoopvp/oprs/OPRS.cxx b/filter/pdftoopvp/oprs/OPRS.cxx
index e9c7e86d..21cabc00 100644
--- filter/pdftoopvp/oprs/OPRS.cxx
+++ filter/pdftoopvp/oprs/OPRS.cxx
@@ -56,15 +56,15 @@ OPRS::OPRS()
   opvp = 0;
   splash = 0;
   opvpSplash = 0;
-  rasterMode = gFalse;
+  rasterMode = false;
 }
 
 int OPRS::setBitmap(SplashBitmap *bitmapA) {
   if (splash != 0) {
     delete splash;
   }
-  splash = new Splash(bitmapA, gFalse);
-  rasterMode = gTrue;
+  splash = new Splash(bitmapA, false);
+  rasterMode = true;
   return 0;
 }
 
@@ -181,7 +181,7 @@ void OPRS::setLineDash(SplashCoord *lineDash, int lineDashLength,
     SPLASH(setLineDash(lineDash,lineDashLength,lineDashPhase));
 }
 
-SplashError OPRS::clipToPath(OPVPSplashPath *path, GBool eo) {
+SplashError OPRS::clipToPath(OPVPSplashPath *path, bool eo) {
     return SPLASH(clipToPath(path,eo));
 }
 
@@ -210,7 +210,7 @@ SplashError OPRS::stroke(OPVPSplashPath *path) {
     return SPLASH(stroke(path));
 }
 
-SplashError OPRS::fill(OPVPSplashPath *path, GBool eo) {
+SplashError OPRS::fill(OPVPSplashPath *path, bool eo) {
     return SPLASH(fill(path,eo));
 }
 
@@ -231,20 +231,20 @@ SplashError OPRS::fillGlyph(SplashCoord x, SplashCoord y,
 }
 
 SplashError OPRS::fillImageMask(SplashImageMaskSource src, void *srcData,
-			  int w, int h, SplashCoord *mat, GBool glyphMode) {
+			  int w, int h, SplashCoord *mat, bool glyphMode) {
     return SPLASH(fillImageMask(src,srcData,w,h,mat,glyphMode));
 }
 
 SplashError OPRS::drawImage(SplashImageSource src, void *srcData,
-			      SplashColorMode srcMode, GBool srcAlpha,
+			      SplashColorMode srcMode, bool srcAlpha,
 			      int w, int h, SplashCoord *mat) {
     if (rasterMode) {
 #if POPPLER_VERSION_MAJOR <= 0 && (POPPLER_VERSION_MINOR <= 20 || (POPPLER_VERSION_MINOR == 21 && POPPLER_VERSION_MICRO <= 2))
 	return splash->drawImage(src,srcData,srcMode,srcAlpha,w,h,mat);
 #elif POPPLER_VERSION_MAJOR <= 0 && POPPLER_VERSION_MINOR <= 33
-	return splash->drawImage(src,srcData,srcMode,srcAlpha,w,h,mat,gFalse);
+	return splash->drawImage(src,srcData,srcMode,srcAlpha,w,h,mat,false);
 #else
-	return splash->drawImage(src,0,srcData,srcMode,srcAlpha,w,h,mat,gFalse);
+	return splash->drawImage(src,0,srcData,srcMode,srcAlpha,w,h,mat,false);
 #endif
     } else {
 	return opvpSplash->drawImage(src,srcData,srcMode,srcAlpha,w,h,mat);
@@ -260,7 +260,7 @@ int OPRS::init(const char *driverName, int outputFD,
 {
     opvp = OPVPWrapper::loadDriver(driverName,outputFD,printerModel);
     if (opvp == 0) return -1;
-    rasterMode = gFalse;
+    rasterMode = false;
     if (!rasterMode) {
 	opvpSplash = new OPVPSplash(opvp,nOptions,
 	  optionKeys, optionVals);
@@ -424,7 +424,7 @@ int OPRS::getRasterSize(SplashBitmap *bitmap)
     return 0;
 }
 
-GBool OPRS::checkAll1(unsigned char *bp, int n, int width, int mode)
+bool OPRS::checkAll1(unsigned char *bp, int n, int width, int mode)
 {
     int lastbytemask = 0xff;
     int i;
@@ -434,7 +434,7 @@ GBool OPRS::checkAll1(unsigned char *bp, int n, int width, int mode)
 	lastbytemask &= 0xff;
     }
     for (i = 0;i < n-1;i++) {
-	if (*bp++ != 0xff) return gFalse;
+	if (*bp++ != 0xff) return false;
     }
     return (*bp & lastbytemask) == lastbytemask;
 }
@@ -487,7 +487,7 @@ int OPRS::outSlice()
     return 0;
 }
 
-int OPRS::setColorMode(int colorModeA, GBool colorProfile)
+int OPRS::setColorMode(int colorModeA, bool colorProfile)
 {
     opvp_cspace_t cspace = OPVP_CSPACE_STANDARDRGB;
 
@@ -532,7 +532,7 @@ SplashBitmap *OPRS::getBitmap()
     return SPLASH(getBitmap());
 }
 
-void OPRS::setDebugMode(GBool debugModeA)
+void OPRS::setDebugMode(bool debugModeA)
 {
     SPLASH(setDebugMode(debugModeA));
 }
@@ -553,7 +553,7 @@ void OPRS::initGS(int colorMode, int w, int h, SplashColor paperColor)
   case splashModeRGB8: color[0] = color[1] = color[2] = 0; break;
   }
   if (!rasterMode) {
-    opvpSplash->setStateBypass(gTrue);
+    opvpSplash->setStateBypass(true);
   }
   SPLASH(setStrokePattern(new SplashSolidColor(color)));
   SPLASH(setFillPattern(new SplashSolidColor(color)));
@@ -566,7 +566,7 @@ void OPRS::initGS(int colorMode, int w, int h, SplashColor paperColor)
   SPLASH(clipResetToRect(0,0,w-1,h-1));
   SPLASH(clear(paperColor));
   if (!rasterMode) {
-    opvpSplash->setStateBypass(gFalse);
+    opvpSplash->setStateBypass(false);
   }
 }
 
diff --git a/filter/pdftoopvp/oprs/OPRS.h b/filter/pdftoopvp/oprs/OPRS.h
index d72dd157..e47804c5 100644
--- filter/pdftoopvp/oprs/OPRS.h
+++ filter/pdftoopvp/oprs/OPRS.h
@@ -72,7 +72,7 @@ public:
   // the <lineDash> array will be copied
   void setLineDash(SplashCoord *lineDash, int lineDashLength,
 		   SplashCoord lineDashPhase);
-  SplashError clipToPath(OPVPSplashPath *path, GBool eo);
+  SplashError clipToPath(OPVPSplashPath *path, bool eo);
 
   //----- state save/restore
 
@@ -90,7 +90,7 @@ public:
   SplashError stroke(OPVPSplashPath *path);
 
   // Fill a path using the current fill pattern.
-  SplashError fill(OPVPSplashPath *path, GBool eo);
+  SplashError fill(OPVPSplashPath *path, bool eo);
 
   // Draw a character, using the current fill pattern.
   SplashError fillChar(SplashCoord x, SplashCoord y, int c, SplashFont *font,
@@ -115,7 +115,7 @@ public:
   // is assumed to produce pixels in raster order, starting from the
   // top line.
   SplashError fillImageMask(SplashImageMaskSource src, void *srcData,
-			    int w, int h, SplashCoord *mat, GBool glyphMode);
+			    int w, int h, SplashCoord *mat, bool glyphMode);
 
   // Draw an image.  This will read <w>*<h> pixels from <src>, in
   // raster order, starting with the top line.  These pixels are
@@ -130,7 +130,7 @@ public:
   //    BGR8packed   BGR8Packed
   // The matrix behaves as for fillImageMask.
   SplashError drawImage(SplashImageSource src, void *srcData,
-			SplashColorMode srcMode, GBool srcAlpha,
+			SplashColorMode srcMode, bool srcAlpha,
 			int w, int h, SplashCoord *mat);
 
   //~ drawMaskedImage
@@ -141,13 +141,13 @@ public:
   SplashBitmap *getBitmap();
 
   // Toggle debug mode on or off.
-  void setDebugMode(GBool debugModeA);
+  void setDebugMode(bool debugModeA);
 
   int init(const char *driverName, int outputFD,
       const char *printerModel, int nOptions,
       const char *optionKeys[], const char *optionVals[]);
   void initGS(int colorMode, int w, int h, SplashColor paperColor);
-  int setColorMode(int colorModeA, GBool colorProfile);
+  int setColorMode(int colorModeA, bool colorProfile);
   int unloadVectorDriver();
 
   int OPVPStartJob(char *jobInfo);
@@ -182,7 +182,7 @@ private:
     unsigned char *bitmap, int rasterWidth);
 
   GetScanLineDataFunT getGetScanLineDataFun(SplashBitmap *bitmap);
-  GBool checkAll1(unsigned char *bp, int n, int width, int mode);
+  bool checkAll1(unsigned char *bp, int n, int width, int mode);
 };
 
 #endif
diff --git a/filter/pdftoopvp/oprs/OPVPSplash.cxx b/filter/pdftoopvp/oprs/OPVPSplash.cxx
index d0b3f204..396a7735 100644
--- filter/pdftoopvp/oprs/OPVPSplash.cxx
+++ filter/pdftoopvp/oprs/OPVPSplash.cxx
@@ -55,58 +55,58 @@ OPVPSplash::OPVPSplash(OPVPWrapper *opvpA,
 
   opvp = opvpA;
   // with default screen params
-  state = new OPVPSplashState(0,0,gFalse,(SplashScreenParams *)NULL);
-  debugMode = gFalse;
-  stateBypass = gFalse;
+  state = new OPVPSplashState(0,0,false,(SplashScreenParams *)NULL);
+  debugMode = false;
+  stateBypass = false;
   clipPath = 0;
   if (getOption("OPVP_OLDLIPSDRIVER",nOptions,
      optionKeys,optionVals) != NULL) {
-    oldLipsDriver = gTrue;
+    oldLipsDriver = true;
   } else {
-    oldLipsDriver = gFalse;
+    oldLipsDriver = false;
   }
   if (getOption("OPVP_CLIPPATHNOTSAVED",nOptions,
      optionKeys,optionVals) != NULL) {
-    clipPathNotSaved = gTrue;
+    clipPathNotSaved = true;
   } else {
-    clipPathNotSaved = gFalse;
+    clipPathNotSaved = false;
   }
   if (getOption("OPVP_NOSHEARIMAGE",nOptions,
      optionKeys,optionVals) != NULL) {
-    noShearImage = gTrue;
+    noShearImage = true;
   } else {
-    noShearImage = gFalse;
+    noShearImage = false;
   }
   if (getOption("OPVP_NOLINESTYLE",nOptions,
      optionKeys,optionVals) != NULL) {
-    noLineStyle = gTrue;
+    noLineStyle = true;
   } else {
-    noLineStyle = gFalse;
+    noLineStyle = false;
   }
   if (!opvpA->supportSetLineStyle || !opvpA->supportSetLineDash
      || !opvpA->supportSetLineDashOffset) {
-    noLineStyle = gTrue;
+    noLineStyle = true;
   }
   if (getOption("OPVP_NOCLIPPATH",nOptions,
      optionKeys,optionVals) != NULL) {
-    noClipPath = gTrue;
+    noClipPath = true;
   } else {
-    noClipPath = gFalse;
+    noClipPath = false;
   }
   if (getOption("OPVP_IGNOREMITERLIMIT",nOptions,
      optionKeys,optionVals) != NULL) {
-    ignoreMiterLimit = gTrue;
+    ignoreMiterLimit = true;
   } else {
-    ignoreMiterLimit = gFalse;
+    ignoreMiterLimit = false;
   }
   if (getOption("OPVP_NOMITERLIMIT",nOptions,
      optionKeys,optionVals) != NULL) {
-    noMiterLimit = gTrue;
+    noMiterLimit = true;
   } else {
-    noMiterLimit = gFalse;
+    noMiterLimit = false;
   }
   if (!opvpA->supportSetMiterLimit) {
-    noMiterLimit = gTrue;
+    noMiterLimit = true;
   }
   if ((opv = getOption("OPVP_BITMAPCHARTHRESHOLD",nOptions,
      optionKeys,optionVals)) != NULL) {
@@ -128,16 +128,16 @@ OPVPSplash::OPVPSplash(OPVPWrapper *opvpA,
   }
   if (getOption("OPVP_NOIMAGEMASK",nOptions,
      optionKeys,optionVals) != NULL) {
-    noImageMask = gTrue;
+    noImageMask = true;
   } else {
-    noImageMask = gFalse;
+    noImageMask = false;
   }
   if (getOption("OPVP_NOBITMAPCHAR",nOptions,
      optionKeys,optionVals) != NULL) {
     bitmapCharThreshold = 0;
   }
   if (!opvpA->supportSetClipPath) {
-    noClipPath = gTrue;
+    noClipPath = true;
   }
   savedNoClipPath = noClipPath;
   saveDriverStateCount = 0;
@@ -289,13 +289,13 @@ void OPVPSplash::makeBrush(SplashPattern *pattern, opvp_brush_t *brush)
   }
 }
 
-GBool OPVPSplash::equalPattern(SplashPattern *pat1, SplashPattern *pat2)
+bool OPVPSplash::equalPattern(SplashPattern *pat1, SplashPattern *pat2)
 {
   SplashColor c1, c2;
   if (pat1 == NULL || pat2 == NULL) {
     return pat1 == pat2;
   }
-  if (typeid(*pat1) != typeid(*pat2)) return gFalse;
+  if (typeid(*pat1) != typeid(*pat2)) return false;
 
   pat1->getColor(0,0,c1);
   pat2->getColor(0,0,c2);
@@ -312,7 +312,7 @@ GBool OPVPSplash::equalPattern(SplashPattern *pat1, SplashPattern *pat2)
   default:
     break;
   }
-  return gTrue;
+  return true;
 }
 
 void OPVPSplash::setStrokePattern(SplashPattern *strokePattern) {
@@ -447,7 +447,7 @@ void OPVPSplash::setLineDash(SplashCoord *lineDash, int lineDashLength,
 			 SplashCoord lineDashPhase) {
   int i;
   opvp_fix_t *pdash;
-  GBool equal;
+  bool equal;
 
   if (stateBypass || lineDash != state->lineDash) {
     if (lineDash == NULL || lineDashLength == 0) {
@@ -471,7 +471,7 @@ void OPVPSplash::setLineDash(SplashCoord *lineDash, int lineDashLength,
     equal = (state->lineDash != NULL);
     pdash = new opvp_fix_t[lineDashLength];
     for (i = 0;i < lineDashLength;i++) {
-      if (equal && lineDash[i] != state->lineDash[i]) equal = gFalse;
+      if (equal && lineDash[i] != state->lineDash[i]) equal = false;
       OPVP_F2FIX(lineDash[i],pdash[i]);
     }
     if (!equal && opvp->SetLineDash(lineDashLength,pdash) < 0) {
@@ -493,7 +493,7 @@ err:
   state->setLineDash(lineDash, lineDashLength, lineDashPhase);
 }
 
-SplashError OPVPSplash::doClipPath(OPVPSplashPath *path, GBool eo,
+SplashError OPVPSplash::doClipPath(OPVPSplashPath *path, bool eo,
   OPVPClipPath *prevClip)
 {
   SplashError result;
@@ -508,7 +508,7 @@ SplashError OPVPSplash::doClipPath(OPVPSplashPath *path, GBool eo,
 	  return splashErrOPVP;
 	}
       }
-      noClipPath = gTrue;
+      noClipPath = true;
     }
   } else {
     noClipPath = savedNoClipPath;
@@ -555,12 +555,12 @@ void OPVPSplash::clipResetToRect(SplashCoord x0, SplashCoord y0,
 
   if (makeRectanglePath(x0,y0,x1,y1,&p) != splashOk) return;
 
-  if (doClipPath(p,gTrue,clipPath) != splashOk) return;
-  clipPath = new OPVPClipPath(p,gTrue);
+  if (doClipPath(p,true,clipPath) != splashOk) return;
+  clipPath = new OPVPClipPath(p,true);
   state->clip->resetToRect(x0, y0, x1, y1);
 }
 
-SplashError OPVPSplash::clipToPath(OPVPSplashPath *path, GBool eo) {
+SplashError OPVPSplash::clipToPath(OPVPSplashPath *path, bool eo) {
   SplashError result;
   SplashCoord x0, y0, x1, y1;
   SplashCoord x2, y2, x3, y3;
@@ -633,7 +633,7 @@ SplashError OPVPSplash::clipToPath(OPVPSplashPath *path, GBool eo) {
       /* non rectangle path */
 
       OPVPSplashXPath *xpath = new OPVPSplashXPath(path, state->matrix, 
-                                     state->flatness, gFalse);
+                                     state->flatness, false);
 
       xpath->sort();
 #if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 19
@@ -655,7 +655,7 @@ SplashError OPVPSplash::clipToPath(OPVPSplashPath *path, GBool eo) {
 	}
 	path = new OPVPSplashPath();
       } else if (clipResult == splashClipPartial) {
-	OPVPSplashClip *nclip = new OPVPSplashClip(xMin,yMin,xMax,yMax,gFalse);
+	OPVPSplashClip *nclip = new OPVPSplashClip(xMin,yMin,xMax,yMax,false);
 	nclip->clipToPath(path,state->matrix,state->flatness,eo);
 	state->clip->getBBox(&xMin,&yMin,&xMax,&yMax);
 	if ((clipResult = nclip->testRect(xMin,yMin,xMax,yMax))
@@ -727,7 +727,7 @@ SplashError OPVPSplash::restoreState() {
   OPVPSplashState *oldState;
   OPVPClipPath *oldClip;
   OPVPSplashPath *path;
-  GBool saved = gFalse;
+  bool saved = false;
 
   if (!state->next) {
     return splashErrNoSave;
@@ -755,7 +755,7 @@ SplashError OPVPSplash::restoreState() {
 	      OPRS::error("ResetClipPath error\n");
 	    return splashErrOPVP;
 	}
-	noClipPath = gTrue;
+	noClipPath = true;
       }
     } else {
       noClipPath = savedNoClipPath;
@@ -875,7 +875,7 @@ SplashError OPVPSplash::strokeByMyself(OPVPSplashPath *path)
     return splashOk;
   }
 
-  osplash = new Splash(new SplashBitmap(1,1,4,splashModeMono1,gFalse),gFalse);
+  osplash = new Splash(new SplashBitmap(1,1,4,splashModeMono1,false),false);
   state->setState(osplash);
   dPath = osplash->makeStrokePath(path,state->lineWidth);
   oPath = new OPVPSplashPath(dPath);
@@ -883,7 +883,7 @@ SplashError OPVPSplash::strokeByMyself(OPVPSplashPath *path)
 
   if (state->lineWidth <= 1) {
     OPVPSplashXPath *xPath;
-    xPath = new OPVPSplashXPath(oPath, state->matrix, state->flatness, gFalse);
+    xPath = new OPVPSplashXPath(oPath, state->matrix, state->flatness, false);
     xPath->strokeNarrow(this,state);
     delete xPath;
   } else {
@@ -891,7 +891,7 @@ SplashError OPVPSplash::strokeByMyself(OPVPSplashPath *path)
     savedPattern = state->fillPattern->copy();
     setFillPattern(state->strokePattern->copy());
 
-    fillByMyself(oPath,gFalse);
+    fillByMyself(oPath,false);
 
     /* restore fill pattern */
     setFillPattern(savedPattern);
@@ -906,7 +906,7 @@ SplashError OPVPSplash::strokeByMyself(OPVPSplashPath *path)
   if (path->getLength() == 0) {
     return splashOk;
   }
-  xPath = new OPVPSplashXPath(path, state->matrix, state->flatness, gFalse);
+  xPath = new OPVPSplashXPath(path, state->matrix, state->flatness, false);
   if (state->lineDash != NULL && state->lineDashLength > 0) {
     xPath2 = xPath->makeDashedPath(state);
     delete xPath;
@@ -975,7 +975,7 @@ SplashError OPVPSplash::stroke(OPVPSplashPath *path) {
   return splashOk;
 }
 
-SplashError OPVPSplash::fillByMyself(OPVPSplashPath *path, GBool eo)
+SplashError OPVPSplash::fillByMyself(OPVPSplashPath *path, bool eo)
 {
   OPVPSplashXPath *xPath;
   SplashXPathScanner *scanner;
@@ -985,7 +985,7 @@ SplashError OPVPSplash::fillByMyself(OPVPSplashPath *path, GBool eo)
   if (path->getLength() == 0) {
     return splashOk;
   }
-  xPath = new OPVPSplashXPath(path, state->matrix, state->flatness, gTrue);
+  xPath = new OPVPSplashXPath(path, state->matrix, state->flatness, true);
   xPath->sort();
 #if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 19
   scanner = new SplashXPathScanner(xPath, eo, INT_MIN, INT_MAX);
@@ -1009,7 +1009,7 @@ SplashError OPVPSplash::fillByMyself(OPVPSplashPath *path, GBool eo)
       while (scanner->getNextSpan(y, &x0, &x1)) {
         if (x0 == x1) continue;
 	if (clipRes == splashClipAllInside) {
-	  drawSpan(x0, x1-1, y, gTrue);
+	  drawSpan(x0, x1-1, y, true);
 	} else {
 	  clipRes2 = state->clip->testSpan(x0, x1, y);
 	  drawSpan(x0, x1-1, y, clipRes2 == splashClipAllInside);
@@ -1025,7 +1025,7 @@ SplashError OPVPSplash::fillByMyself(OPVPSplashPath *path, GBool eo)
   return splashOk;
 }
 
-SplashError OPVPSplash::fill(OPVPSplashPath *path, GBool eo) {
+SplashError OPVPSplash::fill(OPVPSplashPath *path, bool eo) {
   SplashError result;
   opvp_fillmode_t mode;
 
@@ -1133,20 +1133,20 @@ void OPVPSplash::fillGlyph(SplashCoord x, SplashCoord y,
 
 
     for (ty = 0;ty < glyph->h;ty++) {
-      GBool dmode = gFalse;
+      bool dmode = false;
       for (tx = 0;tx < glyph->w;tx++) {
-	GBool on = (bp[opvpbytes*ty+(tx/8)] & (0x80 >> (tx & 7))) != 0;
+	bool on = (bp[opvpbytes*ty+(tx/8)] & (0x80 >> (tx & 7))) != 0;
 
 	if (on && !dmode) {
 	  sx = tx;
-	  dmode = gTrue;
+	  dmode = true;
 	} else if (!on && dmode) {
-	  drawSpan(x0+sx,x0+tx-1,y0+ty,gTrue);
-	  dmode = gFalse;
+	  drawSpan(x0+sx,x0+tx-1,y0+ty,true);
+	  dmode = false;
 	}
       }
       if (dmode) {
-	drawSpan(x0+sx,x0+tx-1,y0+ty,gTrue);
+	drawSpan(x0+sx,x0+tx-1,y0+ty,true);
       }
     }
     /* restore stroke pattern */
@@ -1218,7 +1218,7 @@ SplashError OPVPSplash::fillChar(SplashCoord x, SplashCoord y,
     goto err0;
   }
   path->offset(xt,yt);
-  err = fill(path,gFalse);
+  err = fill(path,false);
 err0:
   if (path != 0) delete path;
   return err;
@@ -1294,8 +1294,8 @@ SplashError OPVPSplash::fillImageMaskFastWithCTM(SplashImageMaskSource src,
 }
 
 SplashError OPVPSplash::fillImageMask(SplashImageMaskSource src, void *srcData,
-			  int w, int h, SplashCoord *mat, GBool glyphMode) {
-  GBool rot;
+			  int w, int h, SplashCoord *mat, bool glyphMode) {
+  bool rot;
   SplashCoord xScale, yScale, xShear, yShear;
   int tx, ty, scaledWidth, scaledHeight, xSign, ySign;
   int ulx, uly, llx, lly, urx, ury, lrx, lry;
@@ -1435,18 +1435,18 @@ SplashError OPVPSplash::fillImageMask(SplashImageMaskSource src, void *srcData,
     cpath.lineTo(mat[0]+tx,mat[1]+ty);
     cpath.lineTo(mat[0]+mat[2]+tx,mat[1]+mat[3]+ty);
     cpath.lineTo(mat[2]+tx,mat[3]+ty);
-    clip->clipToPath(&cpath,state->matrix,1.0,gFalse);
+    clip->clipToPath(&cpath,state->matrix,1.0,false);
   }
   for (y = 0;y < height;y++) {
     int dy = y+yMin-ty;
     int sx = 0;
-    GBool dmode = gFalse;
+    bool dmode = false;
 
     for (x = 0;x < width;x++) {
       if (!clip->test(x+xMin,y+yMin)) {
 	if (dmode) {
-	  drawSpan(xMin+sx,xMin+x-1,yMin+y,gTrue);
-	  dmode = gFalse;
+	  drawSpan(xMin+sx,xMin+x-1,yMin+y,true);
+	  dmode = false;
 	}
 	continue;
       }
@@ -1456,22 +1456,22 @@ SplashError OPVPSplash::fillImageMask(SplashImageMaskSource src, void *srcData,
       ox = (int)trunc((imat[0]*dx+imat[2]*dy)*w);
       oy = (int)trunc((imat[1]*dx+imat[3]*dy)*h);
       if (ox >= 0 && ox < w && oy >= 0 && oy < h) {
-	GBool on = pixBuf[oy*w+ox] != 0;
+	bool on = pixBuf[oy*w+ox] != 0;
 
 	if (on && !dmode) {
-	  dmode = gTrue;
+	  dmode = true;
 	  sx = x;
 	} else if (!on && dmode) {
-	  drawSpan(xMin+sx,xMin+x-1,yMin+y,gTrue);
-	  dmode = gFalse;
+	  drawSpan(xMin+sx,xMin+x-1,yMin+y,true);
+	  dmode = false;
 	}
       } else if (dmode) {
-	drawSpan(xMin+sx,xMin+x-1,yMin+y,gTrue);
-	dmode = gFalse;
+	drawSpan(xMin+sx,xMin+x-1,yMin+y,true);
+	dmode = false;
       }
     }
     if (dmode) {
-      drawSpan(xMin+sx,xMin+x-1,yMin+y,gTrue);
+      drawSpan(xMin+sx,xMin+x-1,yMin+y,true);
     }
   }
   delete clip;
@@ -1495,7 +1495,7 @@ SplashError OPVPSplash::drawImageNotShear(SplashImageSource src,
 			      int w, int h,
 			      int tx, int ty,
 			      int scaledWidth, int scaledHeight,
-			      int xSign, int ySign, GBool rot) {
+			      int xSign, int ySign, bool rot) {
   int i, j;
   opvp_fix_t opvpx,opvpy;
   int opvpbytes, linesize;
@@ -1790,9 +1790,9 @@ err0:
 }
 
 SplashError OPVPSplash::drawImage(SplashImageSource src, void *srcData,
-			      SplashColorMode srcMode, GBool srcAlpha,
+			      SplashColorMode srcMode, bool srcAlpha,
 			      int w, int h, SplashCoord *mat) {
-  GBool ok, rot;
+  bool ok, rot;
   SplashCoord xScale, yScale, xShear, yShear;
   int tx, ty, scaledWidth, scaledHeight, xSign, ySign;
   int ulx, uly, llx, lly, urx, ury, lrx, lry;
@@ -1809,7 +1809,7 @@ SplashError OPVPSplash::drawImage(SplashImageSource src, void *srcData,
   }
 
   // check color modes
-  ok = gFalse; // make gcc happy
+  ok = false; // make gcc happy
   switch (colorMode) {
   case splashModeMono1:
     ok = srcMode == splashModeMono1 || srcMode == splashModeMono8;
@@ -1979,7 +1979,7 @@ SplashError OPVPSplash::drawImage(SplashImageSource src, void *srcData,
     cpath.lineTo(mat[0]+tx,mat[1]+ty);
     cpath.lineTo(mat[0]+mat[2]+tx,mat[1]+mat[3]+ty);
     cpath.lineTo(mat[2]+tx,mat[3]+ty);
-    clip->clipToPath(&cpath,state->matrix,1.0,gFalse);
+    clip->clipToPath(&cpath,state->matrix,1.0,false);
   }
   for (y = 0;y < height;y++) {
     int dy = y+yMin-ty;
@@ -2128,7 +2128,7 @@ void OPVPSplash::setColorMode(int colorModeA)
     colorMode = colorModeA;
 }
 
-void OPVPSplash::drawSpan(int x0, int x1, int y, GBool noClip)
+void OPVPSplash::drawSpan(int x0, int x1, int y, bool noClip)
 {
   int s,e;
   opvp_point_t points[1];
@@ -2137,7 +2137,7 @@ void OPVPSplash::drawSpan(int x0, int x1, int y, GBool noClip)
   int savedLineDashLength;
   SplashCoord savedLineDashPhase;
   SplashCoord savedLineWidth;
-  GBool noSpan;
+  bool noSpan;
 
 
   if (opvp->NewPath() < 0) {
@@ -2145,7 +2145,7 @@ void OPVPSplash::drawSpan(int x0, int x1, int y, GBool noClip)
     return;
   }
   if (noClip) {
-    noSpan = gFalse;
+    noSpan = false;
     OPVP_i2Fix(x0,opvpx);
     OPVP_i2Fix(y,opvpy);
     if (opvp->SetCurrentPoint(opvpx,opvpy) < 0) {
@@ -2159,7 +2159,7 @@ void OPVPSplash::drawSpan(int x0, int x1, int y, GBool noClip)
       return;
     }
   } else {
-    noSpan = gTrue;
+    noSpan = true;
     s = x0;
     while (s < x1) {
       /* find start point */
@@ -2173,7 +2173,7 @@ void OPVPSplash::drawSpan(int x0, int x1, int y, GBool noClip)
 	  if (!state->clip->test(e, y)) break;
 	}
 	/* do make span */
-	noSpan = gFalse;
+	noSpan = false;
 	OPVP_i2Fix(s,opvpx);
 	OPVP_i2Fix(y,opvpy);
 	if (opvp->SetCurrentPoint(opvpx,opvpy) < 0) {
@@ -2225,7 +2225,7 @@ void OPVPSplash::drawSpan(int x0, int x1, int y, GBool noClip)
   draw pixel with StrokePath
   color is stroke color
 */
-void OPVPSplash::drawPixel(int x, int y, GBool noClip)
+void OPVPSplash::drawPixel(int x, int y, bool noClip)
 {
   opvp_point_t points[1];
   opvp_fix_t opvpx, opvpy;
@@ -2293,12 +2293,12 @@ SplashCoord *OPVPSplash::getMatrix()
 
 OPVPClipPath *OPVPClipPath::stackTop = 0;
 
-OPVPClipPath::OPVPClipPath(OPVPSplashPath *pathA, GBool eoA)
+OPVPClipPath::OPVPClipPath(OPVPSplashPath *pathA, bool eoA)
 {
   path = pathA;
   eo = eoA;
   next = 0;
-  saved = gFalse;
+  saved = false;
 }
 
 void OPVPClipPath::push()
@@ -2308,7 +2308,7 @@ void OPVPClipPath::push()
   p = stackTop;
   stackTop = copy();
   stackTop->next = p;
-  saved = gTrue;
+  saved = true;
 }
 
 OPVPClipPath *OPVPClipPath::pop() {
diff --git a/filter/pdftoopvp/oprs/OPVPSplash.h b/filter/pdftoopvp/oprs/OPVPSplash.h
index 525d3c3c..200fda37 100644
--- filter/pdftoopvp/oprs/OPVPSplash.h
+++ filter/pdftoopvp/oprs/OPVPSplash.h
@@ -45,19 +45,19 @@ class SplashFont;
 
 class OPVPClipPath {
 public:
-  OPVPClipPath(OPVPSplashPath *pathA, GBool eoA);
+  OPVPClipPath(OPVPSplashPath *pathA, bool eoA);
   void push();
   static OPVPClipPath *pop();
   ~OPVPClipPath() { delete path; }
   OPVPSplashPath *getPath() { return path; }
-  GBool getEo() { return eo; }
-  GBool getSaved() { return saved; }
+  bool getEo() { return eo; }
+  bool getSaved() { return saved; }
 private:
   OPVPClipPath *copy();
   OPVPClipPath *next;
   OPVPSplashPath *path;
-  GBool eo;
-  GBool saved;
+  bool eo;
+  bool saved;
   static OPVPClipPath *stackTop;
 };
 
@@ -104,7 +104,7 @@ public:
 		   SplashCoord lineDashPhase);
   void clipResetToRect(SplashCoord x0, SplashCoord y0,
 		       SplashCoord x1, SplashCoord y1);
-  SplashError clipToPath(OPVPSplashPath *path, GBool eo);
+  SplashError clipToPath(OPVPSplashPath *path, bool eo);
 
   //----- state save/restore
 
@@ -121,7 +121,7 @@ public:
   SplashError stroke(OPVPSplashPath *path);
 
   // Fill a path using the current fill pattern.
-  SplashError fill(OPVPSplashPath *path, GBool eo);
+  SplashError fill(OPVPSplashPath *path, bool eo);
 
   // Draw a character, using the current fill pattern.
   SplashError fillChar(SplashCoord x, SplashCoord y, int c,
@@ -147,7 +147,7 @@ public:
   // is assumed to produce pixels in raster order, starting from the
   // top line.
   SplashError fillImageMask(SplashImageMaskSource src, void *srcData,
-			    int w, int h, SplashCoord *mat, GBool glyphMode);
+			    int w, int h, SplashCoord *mat, bool glyphMode);
 
   // Draw an image.  This will read <w>*<h> pixels from <src>, in
   // raster order, starting with the top line.  These pixels are
@@ -162,7 +162,7 @@ public:
   //    BGR8packed   BGR8Packed
   // The matrix behaves as for fillImageMask.
   SplashError drawImage(SplashImageSource src, void *srcData,
-			SplashColorMode srcMode, GBool srcAlpha,
+			SplashColorMode srcMode, bool srcAlpha,
 			int w, int h, SplashCoord *mat);
 
   //~ drawMaskedImage
@@ -173,17 +173,17 @@ public:
   SplashBitmap *getBitmap() { return 0; }
 
   // Toggle debug mode on or off.
-  void setDebugMode(GBool debugModeA) { debugMode = debugModeA; }
+  void setDebugMode(bool debugModeA) { debugMode = debugModeA; }
 
   void setColorMode(int colorModeA);
-  void setStateBypass(GBool bypass) {stateBypass = bypass;}
+  void setStateBypass(bool bypass) {stateBypass = bypass;}
   void endPage();
   SplashCoord *getMatrix();
-  void drawSpan(int x0, int x1, int y, GBool noClip);
+  void drawSpan(int x0, int x1, int y, bool noClip);
 #ifdef OLD_DRAW_IMAGE
-  void drawPixel(int x, int y, SplashColor *color, GBool noClip);
+  void drawPixel(int x, int y, SplashColor *color, bool noClip);
 #endif
-  void drawPixel(int x, int y, GBool noClip);
+  void drawPixel(int x, int y, bool noClip);
   void arcToCurve(SplashCoord x0, SplashCoord y0,
     SplashCoord x3, SplashCoord y3,
     SplashCoord cx, SplashCoord cy, SplashCoord *rx1, SplashCoord *ry1,
@@ -191,10 +191,10 @@ public:
 
 private:
   void makeBrush(SplashPattern *pattern, opvp_brush_t *brush);
-  SplashError doClipPath(OPVPSplashPath *path, GBool eo,
+  SplashError doClipPath(OPVPSplashPath *path, bool eo,
      OPVPClipPath *prevClip);
   opvp_cspace_t getOPVPColorSpace();
-  GBool equalPattern(SplashPattern *pt1, SplashPattern *pt2);
+  bool equalPattern(SplashPattern *pt1, SplashPattern *pt2);
   SplashError makeRectanglePath(SplashCoord x0, SplashCoord y0,
     SplashCoord x1, SplashCoord y1, OPVPSplashPath **p);
   SplashError drawImageFastWithCTM(SplashImageSource src, void *srcData,
@@ -205,11 +205,11 @@ private:
 			      int w, int h,
 			      int tx, int ty,
 			      int scaledWidth, int scaledHeight,
-			      int xSign, int ySign, GBool rot);
+			      int xSign, int ySign, bool rot);
   SplashError fillImageMaskFastWithCTM(SplashImageMaskSource src,
        void *srcData, int w, int h, int tx, int ty,SplashCoord *mat);
   SplashError strokeByMyself(OPVPSplashPath *path);
-  SplashError fillByMyself(OPVPSplashPath *path, GBool eo);
+  SplashError fillByMyself(OPVPSplashPath *path, bool eo);
   OPVPSplashXPath *makeDashedPath(OPVPSplashXPath *xPath);
   void transform(SplashCoord *matrix, SplashCoord xi, SplashCoord yi,
 	   SplashCoord *xo, SplashCoord *yo);
@@ -221,20 +221,20 @@ private:
   int printerContext;
 
   OPVPSplashState *state;
-  GBool debugMode;
+  bool debugMode;
   int colorMode;
-  GBool stateBypass;
+  bool stateBypass;
   OPVPClipPath *clipPath;
 
-  GBool oldLipsDriver;
-  GBool clipPathNotSaved;
-  GBool noShearImage;
-  GBool noLineStyle;
-  GBool noClipPath;
-  GBool noMiterLimit;
-  GBool ignoreMiterLimit;
-  GBool savedNoClipPath;
-  GBool noImageMask;
+  bool oldLipsDriver;
+  bool clipPathNotSaved;
+  bool noShearImage;
+  bool noLineStyle;
+  bool noClipPath;
+  bool noMiterLimit;
+  bool ignoreMiterLimit;
+  bool savedNoClipPath;
+  bool noImageMask;
   int bitmapCharThreshold;
   int maxClipPathLength;
   int maxFillPathLength;
diff --git a/filter/pdftoopvp/oprs/OPVPSplashClip.h b/filter/pdftoopvp/oprs/OPVPSplashClip.h
index d531fcad..05bd57b1 100644
--- filter/pdftoopvp/oprs/OPVPSplashClip.h
+++ filter/pdftoopvp/oprs/OPVPSplashClip.h
@@ -9,7 +9,7 @@ public:
 
   OPVPSplashClip(SplashCoord x0, SplashCoord y0,
                SplashCoord x1, SplashCoord y1,
-	                    GBool antialiasA) :
+	                    bool antialiasA) :
      SplashClip(x0,y0,x1,y1,antialiasA) {
   }
 
diff --git a/filter/pdftoopvp/oprs/OPVPSplashPath.cxx b/filter/pdftoopvp/oprs/OPVPSplashPath.cxx
index 5779dce5..f03c128f 100644
--- filter/pdftoopvp/oprs/OPVPSplashPath.cxx
+++ filter/pdftoopvp/oprs/OPVPSplashPath.cxx
@@ -36,7 +36,7 @@ void OPVPSplashPath::getBBox(int *xMinA, int *yMinA, int *xMaxA,
   *yMaxA = splashRound(yMax);
 }
 
-GBool OPVPSplashPath::isRectanglePath(
+bool OPVPSplashPath::isRectanglePath(
   SplashCoord *xMin, SplashCoord *yMin, SplashCoord *xMax, SplashCoord *yMax)
 {
   if (length != 5
@@ -47,22 +47,22 @@ GBool OPVPSplashPath::isRectanglePath(
       || flags[2] != 0
       || flags[3] != 0
       || flags[4] != (splashPathLast | splashPathClosed)) {
-    return gFalse;
+    return false;
   }
   if (splashRound(pts[0].x) == splashRound(pts[1].x)) {
     if (splashRound(pts[1].y) != splashRound(pts[2].y)
       || splashRound(pts[2].x) != splashRound(pts[3].x)
       || splashRound(pts[3].y) != splashRound(pts[4].y)) {
-      return gFalse;
+      return false;
     }
   } else if (splashRound(pts[0].y) == splashRound(pts[1].y)) {
     if (splashRound(pts[1].x) != splashRound(pts[2].x)
       || splashRound(pts[2].y) != splashRound(pts[3].y)
       || splashRound(pts[3].x) != splashRound(pts[4].x)) {
-      return gFalse;
+      return false;
     }
   } else {
-    return gFalse;
+    return false;
   }
   *xMin = pts[0].x;
   *yMin = pts[0].y;
@@ -80,7 +80,7 @@ GBool OPVPSplashPath::isRectanglePath(
     *yMin = *yMax;
     *yMax = t;
   }
-  return gTrue;
+  return true;
 }
 
 SplashError OPVPSplashPath::makePath(OPVPWrapper *opvp)
@@ -140,7 +140,7 @@ SplashError OPVPSplashPath::makePath(OPVPWrapper *opvp)
       }
     } else {
       /* line */
-      GBool closed = (flags[j-1] & splashPathClosed) != 0;
+      bool closed = (flags[j-1] & splashPathClosed) != 0;
 
       if (closed) {
 	if (opvp->LinePath(OPVP_PATHCLOSE,
diff --git a/filter/pdftoopvp/oprs/OPVPSplashPath.h b/filter/pdftoopvp/oprs/OPVPSplashPath.h
index d8a3b233..38bfeffb 100644
--- filter/pdftoopvp/oprs/OPVPSplashPath.h
+++ filter/pdftoopvp/oprs/OPVPSplashPath.h
@@ -16,7 +16,7 @@ public:
   OPVPSplashPath *copy() { return new OPVPSplashPath(this); }
   
   void getBBox(int *xMinA, int *yMinA, int *xMaxA, int *yMaxA);
-  GBool isRectanglePath(SplashCoord *xMin, SplashCoord *yMin,
+  bool isRectanglePath(SplashCoord *xMin, SplashCoord *yMin,
     SplashCoord *xMax, SplashCoord *yMax);
   SplashError makePath(OPVPWrapper *opvp);
   void closeAllSubPath();
diff --git a/filter/pdftoopvp/oprs/OPVPSplashState.cxx b/filter/pdftoopvp/oprs/OPVPSplashState.cxx
index b4a7ec85..62351fa7 100644
--- filter/pdftoopvp/oprs/OPVPSplashState.cxx
+++ filter/pdftoopvp/oprs/OPVPSplashState.cxx
@@ -26,7 +26,7 @@
 // SplashState
 //------------------------------------------------------------------------
 
-OPVPSplashState::OPVPSplashState(int width, int height, GBool vectorAntialias,
+OPVPSplashState::OPVPSplashState(int width, int height, bool vectorAntialias,
 			 SplashScreenParams *screenParams) {
   SplashColor color;
 
@@ -48,16 +48,16 @@ OPVPSplashState::OPVPSplashState(int width, int height, GBool vectorAntialias,
   lineDash = NULL;
   lineDashLength = 0;
   lineDashPhase = 0;
-  strokeAdjust = gFalse;
+  strokeAdjust = false;
   clip = new OPVPSplashClip(0, 0, width - 0.001,
                height - 0.001, vectorAntialias);
   softMask = NULL;
-  deleteSoftMask = gFalse;
-  inNonIsolatedGroup = gFalse;
+  deleteSoftMask = false;
+  inNonIsolatedGroup = false;
   next = NULL;
 }
 
-OPVPSplashState::OPVPSplashState(int width, int height, GBool vectorAntialias,
+OPVPSplashState::OPVPSplashState(int width, int height, bool vectorAntialias,
 			 SplashScreen *screenA) {
   SplashColor color;
 
@@ -79,12 +79,12 @@ OPVPSplashState::OPVPSplashState(int width, int height, GBool vectorAntialias,
   lineDash = NULL;
   lineDashLength = 0;
   lineDashPhase = 0;
-  strokeAdjust = gFalse;
+  strokeAdjust = false;
   clip = new OPVPSplashClip(0, 0, width - 0.001,
                height - 0.001, vectorAntialias);
   softMask = NULL;
-  deleteSoftMask = gFalse;
-  inNonIsolatedGroup = gFalse;
+  deleteSoftMask = false;
+  inNonIsolatedGroup = false;
   next = NULL;
 }
 
@@ -113,7 +113,7 @@ OPVPSplashState::OPVPSplashState(OPVPSplashState *state) {
   strokeAdjust = state->strokeAdjust;
   clip = state->clip->copy();
   softMask = state->softMask;
-  deleteSoftMask = gFalse;
+  deleteSoftMask = false;
   inNonIsolatedGroup = state->inNonIsolatedGroup;
   next = NULL;
 }
@@ -174,5 +174,5 @@ void OPVPSplashState::setSoftMask(SplashBitmap *softMaskA) {
     delete softMask;
   }
   softMask = softMaskA;
-  deleteSoftMask = gTrue;
+  deleteSoftMask = true;
 }
diff --git a/filter/pdftoopvp/oprs/OPVPSplashState.h b/filter/pdftoopvp/oprs/OPVPSplashState.h
index 9cb16db2..b40aaf46 100644
--- filter/pdftoopvp/oprs/OPVPSplashState.h
+++ filter/pdftoopvp/oprs/OPVPSplashState.h
@@ -31,9 +31,9 @@ class OPVPSplashState {
 public:
 
   // Create a new state object, initialized with default settings.
-  OPVPSplashState(int width, int height, GBool vectorAntialias,
+  OPVPSplashState(int width, int height, bool vectorAntialias,
 	      SplashScreenParams *screenParams);
-  OPVPSplashState(int width, int height, GBool vectorAntialias,
+  OPVPSplashState(int width, int height, bool vectorAntialias,
 	      SplashScreen *screenA);
 
   // Copy a state object.
@@ -80,11 +80,11 @@ private:
   SplashCoord *lineDash;
   int lineDashLength;
   SplashCoord lineDashPhase;
-  GBool strokeAdjust;
+  bool strokeAdjust;
   OPVPSplashClip *clip;
   SplashBitmap *softMask;
-  GBool deleteSoftMask;
-  GBool inNonIsolatedGroup;
+  bool deleteSoftMask;
+  bool inNonIsolatedGroup;
 
   OPVPSplashState *next;	// used by OPVPSplash class
 
diff --git a/filter/pdftoopvp/oprs/OPVPSplashXPath.cxx b/filter/pdftoopvp/oprs/OPVPSplashXPath.cxx
index 7a6f429b..924fe9fa 100644
--- filter/pdftoopvp/oprs/OPVPSplashXPath.cxx
+++ filter/pdftoopvp/oprs/OPVPSplashXPath.cxx
@@ -14,8 +14,8 @@
 OPVPSplashXPath *OPVPSplashXPath::makeDashedPath(OPVPSplashState *state)
 {
   OPVPSplashXPath *dPath;
-  GBool lineDashStartOn, lineDashOn;
-  GBool atSegStart, atSegEnd, atDashStart, atDashEnd;
+  bool lineDashStartOn, lineDashOn;
+  bool atSegStart, atSegEnd, atDashStart, atDashEnd;
   int lineDashStartIdx, lineDashIdx, subpathStart;
   SplashCoord lineDashTotal, lineDashStartPhase, lineDashDist;
   int segIdx;
@@ -32,7 +32,7 @@ OPVPSplashXPath *OPVPSplashXPath::makeDashedPath(OPVPSplashState *state)
   lineDashStartPhase = state->lineDashPhase;
   i = splashFloor(lineDashStartPhase / lineDashTotal);
   lineDashStartPhase -= i * lineDashTotal;
-  lineDashStartOn = gTrue;
+  lineDashStartOn = true;
   lineDashStartIdx = 0;
   while (lineDashStartPhase >= state->lineDash[lineDashStartIdx]) {
     lineDashStartOn = !lineDashStartOn;
@@ -50,8 +50,8 @@ OPVPSplashXPath *OPVPSplashXPath::makeDashedPath(OPVPSplashState *state)
   lineDashOn = lineDashStartOn;
   lineDashIdx = lineDashStartIdx;
   lineDashDist = state->lineDash[lineDashIdx] - lineDashStartPhase;
-  atSegStart = gTrue;
-  atDashStart = gTrue;
+  atSegStart = true;
+  atDashStart = true;
   subpathStart = dPath->length;
 
   while (segIdx < length) {
@@ -63,7 +63,7 @@ OPVPSplashXPath *OPVPSplashXPath::makeDashedPath(OPVPSplashState *state)
       ay1 = sy1;
       lineDashDist -= dist;
       dist = 0;
-      atSegEnd = gTrue;
+      atSegEnd = true;
       atDashEnd = lineDashDist == 0 || (seg->flags & splashXPathLast);
     } else {
       ax1 = sx0 + (lineDashDist / dist) * (sx1 - sx0);
@@ -72,8 +72,8 @@ OPVPSplashXPath *OPVPSplashXPath::makeDashedPath(OPVPSplashState *state)
       sy0 = ay1;
       dist -= lineDashDist;
       lineDashDist = 0;
-      atSegEnd = gFalse;
-      atDashEnd = gTrue;
+      atSegEnd = false;
+      atDashEnd = true;
     }
 
     if (lineDashOn) {
@@ -95,9 +95,9 @@ OPVPSplashXPath *OPVPSplashXPath::makeDashedPath(OPVPSplashState *state)
 	lineDashIdx = 0;
       }
       lineDashDist = state->lineDash[lineDashIdx];
-      atDashStart = gTrue;
+      atDashStart = true;
     } else {
-      atDashStart = gFalse;
+      atDashStart = false;
     }
     if (atSegEnd) {
       if (++segIdx < length) {
@@ -111,13 +111,13 @@ OPVPSplashXPath *OPVPSplashXPath::makeDashedPath(OPVPSplashState *state)
 	  lineDashOn = lineDashStartOn;
 	  lineDashIdx = lineDashStartIdx;
 	  lineDashDist = state->lineDash[lineDashIdx] - lineDashStartPhase;
-	  atDashStart = gTrue;
+	  atDashStart = true;
 	  subpathStart = dPath->length;
 	}
       }
-      atSegStart = gTrue;
+      atSegStart = true;
     } else {
-      atSegStart = gFalse;
+      atSegStart = false;
     }
   }
 
@@ -257,7 +257,7 @@ void OPVPSplashXPath::strokeWide(OPVPSplash *splash, OPVPSplashState *state)
     widePath->lineTo(seg->x0 - wdy, seg->y0 + wdx);
 
     // fill the segment
-    splash->fill(widePath, gTrue);
+    splash->fill(widePath, true);
     delete widePath;
 
     // draw the line join
@@ -340,7 +340,7 @@ void OPVPSplashXPath::strokeWide(OPVPSplash *splash, OPVPSplashState *state)
 	break;
       }
       if (widePath) {
-	splash->fill(widePath, gTrue);
+	splash->fill(widePath, true);
 	delete widePath;
       }
     }
diff --git a/filter/pdftoopvp/oprs/OPVPSplashXPath.h b/filter/pdftoopvp/oprs/OPVPSplashXPath.h
index f51b8686..c80243ae 100644
--- filter/pdftoopvp/oprs/OPVPSplashXPath.h
+++ filter/pdftoopvp/oprs/OPVPSplashXPath.h
@@ -14,7 +14,7 @@ class OPVPSplash;
 class OPVPSplashXPath : public SplashXPath {
 public:
   OPVPSplashXPath(OPVPSplashPath *path, SplashCoord *matrix,
-                SplashCoord flatness, GBool closeSubpaths) :
+                SplashCoord flatness, bool closeSubpaths) :
 	SplashXPath(path,matrix,flatness,closeSubpaths) {
   }
 
@@ -28,7 +28,7 @@ public:
 #endif
 private:
 #if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 19
-  OPVPSplashXPath() : SplashXPath(new SplashPath(), 0, 0, gFalse) {};
+  OPVPSplashXPath() : SplashXPath(new SplashPath(), 0, 0, false) {};
 #else
   OPVPSplashXPath() {};
 #endif
diff --git a/filter/pdftoopvp/pdftoopvp.cxx b/filter/pdftoopvp/pdftoopvp.cxx
index bf25983b..1391b66d 100644
--- filter/pdftoopvp/pdftoopvp.cxx
+++ filter/pdftoopvp/pdftoopvp.cxx
@@ -35,28 +35,28 @@
 static int resolution = 300;
 static int hResolution = 0;
 static int vResolution = 0;
-static GBool mono = gFalse;
-static GBool reverse = gFalse;
-static GBool gray = gFalse;
+static bool mono = false;
+static bool reverse = false;
+static bool gray = false;
 static char enableFreeTypeStr[16] = "";
-static GBool quiet = gFalse;
+static bool quiet = false;
 static char outputOrderStr[256] = "";
-static GBool oldLipsDriver = gFalse;
-static GBool HPDriver = gFalse;
-static GBool NECDriver = gFalse;
-static GBool clipPathNotSaved = gFalse;
-static GBool noShearImage = gFalse;
-static GBool noLineStyle = gFalse;
-static GBool noImageMask = gFalse;
-static GBool noClipPath = gFalse;
-static GBool ignoreMiterLimit = gFalse;
-static GBool noMiterLimit = gFalse;
+static bool oldLipsDriver = false;
+static bool HPDriver = false;
+static bool NECDriver = false;
+static bool clipPathNotSaved = false;
+static bool noShearImage = false;
+static bool noLineStyle = false;
+static bool noImageMask = false;
+static bool noClipPath = false;
+static bool ignoreMiterLimit = false;
+static bool noMiterLimit = false;
 static char printerDriver[1024] = "";
 static char printerModel[1024] = "";
 static char jobInfo[4096] = "";
 static char docInfo[1024] = "";
 static char pageInfo[1024] = "";
-static GBool noBitmapChar = gFalse;
+static bool noBitmapChar = false;
 static char bitmapCharThreshold[20] = "2000";
 static char maxClipPathLength[20] = "2000";
 static char maxFillPathLength[20] = "4000";
@@ -97,7 +97,7 @@ static int outOnePage(PDFDoc *doc, OPVPOutputDev *opvpOut, int pg)
   }
   opvpOut->setScale(1.0,1.0,0,0,0,0,paperHeight);
   doc->displayPage(opvpOut, pg, resolution, resolution,
-    0, gTrue, gTrue, gFalse);
+    0, true, true, false);
   if (opvpOut->outSlice() < 0) {
     opvpError(-1,"OutSlice failed");
     return 2;
@@ -146,7 +146,7 @@ void CDECL myErrorFun(int pos, char *msg, va_list args)
 }
 #endif
 
-static GBool getColorProfilePath(ppd_file_t *ppd, GooString *path)
+static bool getColorProfilePath(ppd_file_t *ppd, GooString *path)
 {
     // get color profile path
     const char *colorModel;
@@ -227,9 +227,9 @@ static GBool getColorProfilePath(ppd_file_t *ppd, GooString *path)
 	    path->append("/profiles/");
 	}
 	path->append(attr->value);
-	return gTrue;
+	return true;
     }
-    return gFalse;
+    return false;
 }
 
 int main(int argc, char *argv[]) {
@@ -239,7 +239,7 @@ int main(int argc, char *argv[]) {
   PDFDoc *doc;
   SplashColor paperColor;
   OPVPOutputDev *opvpOut;
-  GBool ok = gTrue;
+  bool ok = true;
   int pg;
   const char *optionKeys[MAX_OPVP_OPTIONS];
   const char *optionVals[MAX_OPVP_OPTIONS];
@@ -266,7 +266,7 @@ int main(int argc, char *argv[]) {
   GooString jobInfoStr;
   GooString docInfoStr;
   GooString pageInfoStr;
-  GBool colorProfile = gFalse;
+  bool colorProfile = false;
 
 
   if (argc < 6 || argc > 7) {
@@ -289,72 +289,72 @@ int main(int argc, char *argv[]) {
       }
       if ((attr = ppdFindAttr(ppd,"pdftoopvpOldLipsDriver",0)) != 0) {
 	if (strcasecmp(attr->value,"true") == 0) {
-	  oldLipsDriver = gTrue;
+	  oldLipsDriver = true;
 	} else {
-	  oldLipsDriver = gFalse;
+	  oldLipsDriver = false;
 	}
       }
       if ((attr = ppdFindAttr(ppd,"pdftoopvpHPDriver",0)) != 0) {
 	if (strcasecmp(attr->value,"true") == 0) {
-	  HPDriver = gTrue;
+	  HPDriver = true;
 	} else {
-	  HPDriver = gFalse;
+	  HPDriver = false;
 	}
       }
       if ((attr = ppdFindAttr(ppd,"pdftoopvpNECDriver",0)) != 0) {
 	if (strcasecmp(attr->value,"true") == 0) {
-	  NECDriver = gTrue;
+	  NECDriver = true;
 	} else {
-	  NECDriver = gFalse;
+	  NECDriver = false;
 	}
       }
       if ((attr = ppdFindAttr(ppd,"pdftoopvpClipPathNotSaved",0)) != 0) {
 	if (strcasecmp(attr->value,"true") == 0) {
-	  clipPathNotSaved = gTrue;
+	  clipPathNotSaved = true;
 	} else {
-	  clipPathNotSaved = gFalse;
+	  clipPathNotSaved = false;
 	}
       }
       if ((attr = ppdFindAttr(ppd,"pdftoopvpShearImage",0)) != 0) {
 	if (strcasecmp(attr->value,"true") == 0) {
-	  noShearImage = gFalse;
+	  noShearImage = false;
 	} else {
-	  noShearImage = gTrue;
+	  noShearImage = true;
 	}
       }
       if ((attr = ppdFindAttr(ppd,"pdftoopvpLineStyle",0)) != 0) {
 	if (strcasecmp(attr->value,"true") == 0) {
-	  noLineStyle = gFalse;
+	  noLineStyle = false;
 	} else {
-	  noLineStyle = gTrue;
+	  noLineStyle = true;
 	}
       }
       if ((attr = ppdFindAttr(ppd,"pdftoopvpImageMask",0)) != 0) {
 	if (strcasecmp(attr->value,"true") == 0) {
-	  noImageMask = gFalse;
+	  noImageMask = false;
 	} else {
-	  noImageMask = gTrue;
+	  noImageMask = true;
 	}
       }
       if ((attr = ppdFindAttr(ppd,"pdftoopvpClipPath",0)) != 0) {
 	if (strcasecmp(attr->value,"true") == 0) {
-	  noClipPath = gFalse;
+	  noClipPath = false;
 	} else {
-	  noClipPath = gTrue;
+	  noClipPath = true;
 	}
       }
       if ((attr = ppdFindAttr(ppd,"pdftoopvpMiterLimit",0)) != 0) {
 	if (strcasecmp(attr->value,"true") == 0) {
-	  noMiterLimit = gFalse;
+	  noMiterLimit = false;
 	} else {
-	  noMiterLimit = gTrue;
+	  noMiterLimit = true;
 	}
       }
       if ((attr = ppdFindAttr(ppd,"pdftoopvpIgnoreMiterLimit",0)) != 0) {
 	if (strcasecmp(attr->value,"true") == 0) {
-	  ignoreMiterLimit = gTrue;
+	  ignoreMiterLimit = true;
 	} else {
-	  ignoreMiterLimit = gFalse;
+	  ignoreMiterLimit = false;
 	}
       }
       if ((attr = ppdFindAttr(ppd,"pdftoopvpBitmapCharThreshold",0)) != 0) {
@@ -371,9 +371,9 @@ int main(int argc, char *argv[]) {
       }
       if ((attr = ppdFindAttr(ppd,"pdftoopvpBitmapChar",0)) != 0) {
 	if (strcasecmp(attr->value,"true") == 0) {
-	  noBitmapChar = gFalse;
+	  noBitmapChar = false;
 	} else {
-	  noBitmapChar = gTrue;
+	  noBitmapChar = true;
 	}
       }
       if ((attr = ppdFindAttr(ppd,"opvpDriver",0)) != 0) {
@@ -395,41 +395,41 @@ int main(int argc, char *argv[]) {
     if (strcasecmp(options[i].name,"Resolution") == 0) {
       resolution = atoi(options[i].value);
     } else if (strcasecmp(options[i].name,"pdftoopvpOldLipsDriver") == 0) {
-      oldLipsDriver = gTrue;
+      oldLipsDriver = true;
     } else if (strcasecmp(options[i].name,"pdftoopvpHPDriver") == 0) {
-      HPDriver = gTrue;
+      HPDriver = true;
     } else if (strcasecmp(options[i].name,"pdftoopvpNECDriver") == 0) {
-      NECDriver = gTrue;
+      NECDriver = true;
     } else if (strcasecmp(options[i].name,"pdftoopvpClipPathNotSaved") == 0) {
-      clipPathNotSaved = gTrue;
+      clipPathNotSaved = true;
     } else if (strcasecmp(options[i].name,"pdftoopvpShearImage") == 0) {
       if (strcasecmp(options[i].value,"false") == 0) {
-	noShearImage = gTrue;
+	noShearImage = true;
       }
     } else if (strcasecmp(options[i].name,"pdftoopvpLineStyle") == 0) {
       if (strcasecmp(options[i].value,"false") == 0) {
-	noLineStyle = gTrue;
+	noLineStyle = true;
       }
     } else if (strcasecmp(options[i].name,"pdftoopvpImageMask") == 0) {
       if (strcasecmp(options[i].value,"false") == 0) {
-	noImageMask = gTrue;
+	noImageMask = true;
       }
     } else if (strcasecmp(options[i].name,"pdftoopvpClipPath") == 0) {
       if (strcasecmp(options[i].value,"false") == 0) {
-	noClipPath = gTrue;
+	noClipPath = true;
       }
     } else if (strcasecmp(options[i].name,"pdftoopvpMiterLimit") == 0) {
       if (strcasecmp(options[i].value,"false") == 0) {
-	noMiterLimit = gTrue;
+	noMiterLimit = true;
       }
     } else if (strcasecmp(options[i].name,"pdftoopvpIgnoreMiterLimit") == 0) {
       if (strcasecmp(options[i].value,"true") == 0) {
-	ignoreMiterLimit = gTrue;
+	ignoreMiterLimit = true;
       }
     }
      else if (strcasecmp(options[i].name,"pdftoopvpBitmapChar") == 0) {
       if (strcasecmp(options[i].value,"false") == 0) {
-	noBitmapChar = gTrue;
+	noBitmapChar = true;
       }
     } else if (strcasecmp(options[i].name,"pdftoopvpBitmapCharThreshold") == 0) {
       strncpy(bitmapCharThreshold,options[i].value,
@@ -534,18 +534,18 @@ exit(0);
     optionKeys[nOptions] = "OPVP_OLDLIPSDRIVER";
     optionVals[nOptions] = "1";
     nOptions++;
-    clipPathNotSaved = gTrue;
-    noShearImage = gTrue;
+    clipPathNotSaved = true;
+    noShearImage = true;
   }
   if (HPDriver) {
-    noClipPath = gTrue;
-    noLineStyle = gTrue;
-    noShearImage = gTrue;
+    noClipPath = true;
+    noLineStyle = true;
+    noShearImage = true;
   }
   if (NECDriver) {
-    noMiterLimit = gTrue;
+    noMiterLimit = true;
     strcpy(maxClipPathLength,"6");
-    noShearImage = gTrue;
+    noShearImage = true;
   }
   if (clipPathNotSaved) {
     optionKeys[nOptions] = "OPVP_CLIPPATHNOTSAVED";
@@ -600,7 +600,7 @@ exit(0);
   if (hResolution == 0) hResolution = resolution;
   if (vResolution == 0) vResolution = resolution;
   if (strcasecmp(outputOrderStr,"reverse") == 0) {
-    reverse = gTrue;
+    reverse = true;
   }
 
   if (argc > 6) {
@@ -614,7 +614,7 @@ exit(0);
   if (enableFreeTypeStr[0]) {
     if (!globalParams->setEnableFreeType(enableFreeTypeStr)) {
       opvpError(-1,"Bad '-freetype' value on command line");
-      ok = gFalse;
+      ok = false;
     }
   }
 #if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR <= 30
@@ -718,7 +718,7 @@ exit(0);
 				    gray ? splashModeMono8 :
 				             splashModeRGB8,
 				  colorProfile,
-				  gFalse, paperColor,
+				  false, paperColor,
                                  printerDriver,1,printerModel,
 				 nOptions,optionKeys,optionVals) < 0) {
       opvpError(-1,"OPVPOutputDev Initialize fail");
diff --git a/filter/pdftopdf/pdftopdf.cc b/filter/pdftopdf/pdftopdf.cc
index f474f08c..01ab0a64 100644
--- filter/pdftopdf/pdftopdf.cc
+++ filter/pdftopdf/pdftopdf.cc
@@ -559,7 +559,7 @@ void getParameters(ppd_file_t *ppd,int num_options,cups_option_t *options,Proces
 
   if ((val = cupsGetOption("scaling",num_options,options)) != 0) {
     scaling = atoi(val) * 0.01;
-    fitplot = gTrue;
+    fitplot = true;
   } else if (fitplot) {
     scaling = 1.0;
   }
diff --git a/filter/pdftoraster.cxx b/filter/pdftoraster.cxx
index 4ebf02b0..aabac8df 100644
--- filter/pdftoraster.cxx
+++ filter/pdftoraster.cxx
@@ -331,7 +331,7 @@ static void lcmsErrorHandler(cmsContext contextId, cmsUInt32Number ErrorCode,
 
 
 #if 0
-static GBool getColorProfilePath(ppd_file_t *ppd, GooString *path)
+static bool getColorProfilePath(ppd_file_t *ppd, GooString *path)
 {
     // get color profile path
     const char *colorModel;
@@ -412,9 +412,9 @@ static GBool getColorProfilePath(ppd_file_t *ppd, GooString *path)
 	    path->append("/profiles/");
 	}
 	path->append(attr->value);
-	return gTrue;
+	return true;
     }
-    return gFalse;
+    return false;
 }
 #endif
 
@@ -1814,7 +1814,7 @@ static void outPage(PDFDoc *doc, Catalog *catalog, int pageNo,
 
   doc->displayPage(out,pageNo,header.HWResolution[0],
 		   header.HWResolution[1],(landscape == 0 ? 0 : 90),
-		   gTrue,gTrue,gTrue);
+		   true,true,true);
   bitmap = out->getBitmap();
   bitmapoffset[0] = margins[0] / 72.0 * header.HWResolution[0];
   bitmapoffset[1] = margins[3] / 72.0 * header.HWResolution[1];
@@ -2124,9 +2124,9 @@ int main(int argc, char *argv[]) {
   }
 
   out = new SplashOutputDev(cmode,rowpad/* row padding */,
-    gFalse,paperColor,gTrue
+    false,paperColor,true
 #if POPPLER_VERSION_MAJOR == 0 && POPPLER_VERSION_MINOR <= 30
-    ,gFalse
+    ,false
 #endif
     );
 #if POPPLER_VERSION_MAJOR > 0 || POPPLER_VERSION_MINOR >= 19

