diff -Naur wxFormBuilder.orig/subprojects/ticpp/.git wxFormBuilder/subprojects/ticpp/.git
--- wxFormBuilder.orig/subprojects/ticpp/.git	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/.git	2019-11-18 10:42:57.671406056 +0100
@@ -0,0 +1 @@
+gitdir: ../../.git/modules/sdk/tinyxml
diff -Naur wxFormBuilder.orig/subprojects/ticpp/CMakeLists.txt wxFormBuilder/subprojects/ticpp/CMakeLists.txt
--- wxFormBuilder.orig/subprojects/ticpp/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/CMakeLists.txt	2019-11-18 10:42:57.706406053 +0100
@@ -0,0 +1,27 @@
+project(ticpp)
+cmake_minimum_required(VERSION 2.8.7 FATAL_ERROR)
+
+set(CMAKE_POSITION_INDEPENDENT_CODE ON)
+set(CMAKE_DEBUG_POSTFIX "d")
+
+if(CMAKE_COMPILER_IS_GNUCXX)
+    add_definitions(-std=c++11)
+endif()
+
+if(BUILD_SHARED_LIBS)
+    add_definitions(-DBUILD_TICPP_DLL)
+endif(BUILD_SHARED_LIBS)
+
+add_library(ticpp
+    ticpp.cpp
+    tinystr.cpp
+    tinyxml.cpp
+    tinyxmlerror.cpp
+    tinyxmlparser.cpp
+)
+target_include_directories(ticpp
+    INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
+)
+target_compile_definitions(ticpp
+    PUBLIC TIXML_USE_TICPP
+)
diff -Naur wxFormBuilder.orig/subprojects/ticpp/LICENSE wxFormBuilder/subprojects/ticpp/LICENSE
--- wxFormBuilder.orig/subprojects/ticpp/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/LICENSE	2019-11-18 10:42:57.707406053 +0100
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2006 Ryan Pusztai, Ryan Mulder
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff -Naur wxFormBuilder.orig/subprojects/ticpp/README.md wxFormBuilder/subprojects/ticpp/README.md
--- wxFormBuilder.orig/subprojects/ticpp/README.md	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/README.md	2019-11-18 10:42:57.707406053 +0100
@@ -0,0 +1,10 @@
+**TiCPP** is short for the official name TinyXML++. It is a completely new interface to [TinyXML](http://www.grinninglizard.com/tinyxml/) that uses MANY of the C++ strengths. Templates, exceptions, and much better error handling. It is also fully documented in Doxygen. It is really cool because this version lets you interface tiny the exact same way as before or you can choose to use the new `ticpp` classes. All you need to do is define `TIXML_USE_TICPP`. It has been tested in VC 6.0, VC 7.0, VC 7.1, VC 8.0, MinGW gcc 3.4.5, and in Linux GNU gcc 3+.
+
+[![Build status](https://ci.appveyor.com/api/projects/status/mljbncrk0i7ti870?svg=true)](https://ci.appveyor.com/project/wxFormBuilder/ticpp)
+
+Get Help:
+  * [TinyXML++ Discussion Group](http://groups.google.com/group/ticpp)
+
+Documentation:
+  * [Online](http://rawgit.com/wxFormBuilder/ticpp/docs/ticpp.html)
+  * [Download](http://rawgit.com/wxFormBuilder/ticpp/docs/TinyXMLHelp_v2.5.3.chm)
diff -Naur wxFormBuilder.orig/subprojects/ticpp/appveyor.yml wxFormBuilder/subprojects/ticpp/appveyor.yml
--- wxFormBuilder.orig/subprojects/ticpp/appveyor.yml	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/appveyor.yml	2019-11-18 10:42:57.707406053 +0100
@@ -0,0 +1,13 @@
+build_script:
+- cmd: >-
+    C:\msys64\usr\bin\bash -lc "pacman -S --needed --noconfirm mingw-w64-i686-premake mingw-w64-x86_64-premake"
+
+    set MSYSTEM=MINGW32
+
+    C:\msys64\usr\bin\bash -lc "cd '%cd%' && premake4 gmake && make && make config=release"
+
+    git clean -xfd
+
+    set MSYSTEM=MINGW64
+
+    C:\msys64\usr\bin\bash -lc "cd '%cd%' && premake4 gmake && make && make config=release"
diff -Naur wxFormBuilder.orig/subprojects/ticpp/build_instructions.txt wxFormBuilder/subprojects/ticpp/build_instructions.txt
--- wxFormBuilder.orig/subprojects/ticpp/build_instructions.txt	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/build_instructions.txt	2019-11-18 10:42:57.707406053 +0100
@@ -0,0 +1,76 @@
+TiCPP (TinyXML C++ wrapper)
+---------------------------------------------------
+Introduction:
+	'TiCPP' is short for the official name TinyXML++. It is a completely new
+	interface to TinyXML (http://http://www.grinninglizard.com/tinyxml/) that
+	uses MANY of the C++ strengths. Templates, exceptions, and much better error
+	handling. It is also fully documented in doxygen. It is really cool because
+	this version let's you interface tiny the exact same way as before or you
+	can choose to use the new 'TiCPP' classes. All you need to do is define
+	TIXML_USE_TICPP. It has been tested in VC 6.0, VC 7.0, VC 7.1, VC 8.0,
+	MinGW gcc 3.4.5, and in Linux GNU gcc 3+.
+
+	TinyXML++ uses Premake as the build system, so you won't find any project files
+	because you generate them for your specific system. Premake is a build script
+	generator. Premake supports creatation of build scripts for:
+
+		* MS Visual Studio 6, 2002, 2003, or 2005
+		* GNU make (including Cygwin and MinGW)
+		* Code::Blocks
+		* And more ...
+
+Build Steps:
+	1) Download Premake from http://premake.sf.net/download
+	2) Checkout the source for TinyXML++ using Subversion.
+		- svn checkout https://github.com/rjpcomputing/ticpp ticpp
+	3) Place the Premake executable in the root directory of TiCPP or somewhere in your
+	   path.
+	4) To create the needed build files navigate to the TinyXML++ directory (ticpp)
+	   and type:
+
+		* Code::Blocks Projects and workspace:
+			* Premake v3.x:	premake --target cb-gcc [--unicode] [--dynamic-runtime] [--ticpp-shared]
+			* Premake v4.x:	premake4 codeblocks [--unicode] [--dynamic-runtime] [--ticpp-shared]
+
+		* GNU makefiles:
+			* Premake v3.x:	premake --target gnu [--unicode] [--dynamic-runtime] [--ticpp-shared]
+			* Premake v4.x:	premake4 gmake [--unicode] [--dynamic-runtime] [--ticpp-shared]
+
+		* Visual Studio 2005 (8.0) [Windows ONLY]
+			* Premake v3.x:	premake --target vs2005 [--unicode] [--dynamic-runtime] [--ticpp-shared]
+			* Premake v4.x:	premake4 vs2005 [--unicode] [--dynamic-runtime] [--ticpp-shared]
+
+		* Visual Studio 2008 (9.0) [Windows ONLY]
+			* Premake v3.x:	premake --target vs2008 [--unicode] [--dynamic-runtime] [--ticpp-shared]
+			* Premake v4.x:	premake4 vs2008 [--unicode] [--dynamic-runtime] [--ticpp-shared]
+
+	5) Now use the build system of your choice.
+
+		- For Code::Blocks, use the generated .cbp/.workspace to build TinyXML++ as a
+		  static library.
+
+		- For GNU makefiles type: (Assumes you have properly setup your system to build
+		  with gcc or MinGW)
+
+			* Release:
+				make CONFIG=Release         (if generated with premake)
+				make config=release         (if generated with premake4)
+
+			* Debug:
+				make
+		- For Visual Studio, use the generated .vcproj/.sln to build TinyXML++ as a
+		  static library.
+
+Notes:
+	- Premake can be found here:
+	  http://premake.sourceforge.net
+
+	- Subversion is a great free cross-platform version control manager.
+	  It can be found here:
+	  http://subversion.tigris.org
+
+	- Code::Blocks is a free cross-platform IDE and it can be found here:
+	  http://codeblocks.org
+
+Enjoy,
+  The TiCPP Team
diff -Naur wxFormBuilder.orig/subprojects/ticpp/changes.txt wxFormBuilder/subprojects/ticpp/changes.txt
--- wxFormBuilder.orig/subprojects/ticpp/changes.txt	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/changes.txt	2019-11-18 10:42:57.707406053 +0100
@@ -0,0 +1,269 @@
+Changes in version 1.0.1:
+- Fixed comment tags which were outputing as '<?--' instead of 
+  the correct '<!--'.
+- Implemented the Next and Prev methods of the TiXmlAttribute class.
+- Renamed 'LastAttribtute' to 'LastAttribute'
+- Fixed bad pointer to 'isspace' that could occur while parsing text.
+- Errors finding beginning and end of tags no longer throw it into an
+  infinite loop. (Hopefully.)
+
+Changes in version 1.0.2
+- Minor documentation fixes.
+
+Changes in version 1.0.3
+- After nodes are added to a document, they return a pointer
+  to the new node instead of a bool for success.
+- Elements can be constructed with a value, which is the
+  element name. Every element must have a value or it will be
+  invalid, but the code changes to enforce this are not fully
+  in place.
+
+Changes in version 1.1.0
+- Added the	TiXmlAttributeSet class to pull the attributes into
+  a seperate container.
+- Moved the doubly liked list out of XmlBase. Now XmlBase only
+  requires the Print() function and defines some utility functions.
+- Moved errors into a seperate file. (With the idea of internationalization
+  to the other latin-1 languages.)
+- Added the "NodeType"
+- Fixed white space parsing in text to conform with the standard. 
+  Basically, all white space becomes just one space.
+- Added the TiXmlDeclaration class to read xml declarations.
+
+Changes in version 1.2.0
+- Removed the factory. The factory was not really in the spirit 
+  of small and simple, confused the code, and was of limited value.
+- Added FirstChildElement and NextSiblingElement, because they
+  are such common functions.
+- Re-wrote the example to test and demonstrate more functionality.
+
+Changes in version 1.2.1
+- Fixed a bug where comments couldn't be inside elements.
+- Loading now clears out existing XML rather than appending.
+- Added the "Clear" method on a node to delete all its children.
+
+Changes in version 1.2.2
+- Fixed TiXmlAttribute::Previous actually returning "next." Thanks
+  to Rickard Troedsson for the bug fix.
+
+Changes in version 1.2.3
+- Added the TIXML prefix to the error strings to resolve conflicts
+  with #defines in OS headers. Thanks to Steve Lhomme.
+- Fixed a delete buf that should be a delete [] buf. 
+  Thanks to Ephi Sinowitz.
+
+Changes in version 1.2.4
+- ReplaceChild() was almost guarenteed to fail. Should be fixed,
+  thanks to Joe Smith. Joe also pointed out that the Print() functions
+  should take stream references: I agree, and would like to overload
+  the Print() method to take either format, but I don't want to do 
+  this in a dot release.
+- Some compilers seem to need an extra <ctype.h> include. Thanks
+  to Steve Lhomme for that.
+
+Changes in version 2.0.0 BETA
+- Made the ToXXX() casts safe if 'this' is null. 
+  When "LoadFile" is called with a filename, the value will correctly get set.
+  Thanks to Brian Yoder.
+- Fixed bug where isalpha() and isalnum() would get called with a negative value for 
+  high ascii numbers. Thanks to Alesky Aksenov.
+- Fixed some errors codes that were not getting set.
+- Made methods "const" that were not.
+- Added a switch to enable or disable the ignoring of white space. ( TiXmlDocument::SetIgnoreWhiteSpace() )
+- Greater standardization and code re-use in the parser.
+- Added a stream out operator.
+- Added a stream in operator.
+- Entity support, of predefined entites. &#x entities are untouched by input or output.
+- Improved text out formatting.
+- Fixed ReplaceChild bug, thanks to Tao Chen.
+
+Changes in version 2.0.1
+- Fixed hanging on loading a 0 length file. Thanks to Jeff Scozzafava.
+- Fixed crashing on InsertBeforeChild and InsertAfterChild. Also possibility of bad links being
+  created by same function. Thanks to Frank De prins.
+- Added missing licence text. Thanks to Lars Willemsens.
+- Added <ctype.h> include, at the suggestion of Steve Walters.
+
+Changes in version 2.1.0
+- Yves Berquin brings us the STL switch. The forum on SourceForge, and various emails to
+  me, have long debated all out STL vs. no STL at all. And now you can have it both ways.
+  TinyXml will compile either way.
+
+Changes in version 2.1.1
+- Compilation warnings.
+
+Changes in version 2.1.2
+- Uneeded code is not compiled in the STL case.
+- Changed headers so that STL can be turned on or off in tinyxml.h
+
+Changes in version 2.1.3
+- Fixed non-const reference in API; now uses a pointer.
+- Copy constructor of TiXmlString not checking for assignment to self.
+- Nimrod Cohen found a truly evil bug in the STL implementation that occurs
+  when a string is converted to a c_str and then assigned to self. Search for
+  STL_STRING_BUG for a full description. I'm asserting this is a Microsoft STL
+  bug, since &string and string.c_str() should never be the same. Nevertheless,
+  the code works around it.
+- Urivan Saaib pointed out a compiler conflict, where the C headers define
+  the isblank macro, which was wiping out the TiXmlString::isblank() method.
+  The method was unused and has been removed.
+
+Changes in version 2.1.4
+- Reworked the entity code. Entities were not correctly surving round trip input and output.
+  Will now automatically create entities for high ascii in output.
+
+Changes in version 2.1.5
+- Bug fix by kylotan : infinite loop on some input (tinyxmlparser.cpp rev 1.27)
+- Contributed by Ivica Aracic (bytelord) : 1 new VC++ project to compile versions as static libraries (tinyxml_lib.dsp), 
+  and an example usage in xmltest.dsp
+  (Patch request ID 678605)
+- A suggestion by Ronald Fenner Jr (dormlock) to add #include <istream> and <ostream> for Apple's Project Builder 
+  (Patch request ID 697642)
+- A patch from ohommes that allows to parse correctly dots in element names and attribute names
+  (Patch request 602600 and kylotan 701728)
+- A patch from  hermitgeek ( James ) and wasteland for improper error reporting
+- Reviewed by Lee, with the following changes:
+	- Got sick of fighting the STL/non-STL thing in the windows build. Broke
+	  them out as seperate projects.
+	- I have too long not included the dsw. Added.
+	- TinyXmlText had a protected Print. Odd.
+	- Made LinkEndChild public, with docs and appropriate warnings.
+	- Updated the docs.
+
+2.2.0
+- Fixed an uninitialized pointer in the TiXmlAttributes
+- Fixed STL compilation problem in MinGW (and gcc 3?) - thanks Brian Yoder for finding this one
+- Fixed a syntax error in TiXmlDeclaration - thanks Brian Yoder
+- Fletcher Dunn proposed and submitted new error handling that tracked the row and column. Lee
+  modified it to not have performance impact.
+- General cleanup suggestions from Fletcher Dunn.
+- In error handling, general errors will no longer clear the error state of specific ones.
+- Fix error in documentation : comments starting with "<?--" instead of "<!--" (thanks ion_pulse)
+- Added the TiXmlHandle. An easy, safe way to browse XML DOMs with less code.
+- Added QueryAttribute calls which have better error messaging. (Proposed by Fletcher Dunn)
+- Nodes and attributes can now print themselves to strings. (Yves suggestion)
+- Fixed bug where entities with one character would confuse parser. (Thanks Roman)
+
+2.2.1
+- Additional testing (no more bugs found to be fixed in this release)
+- Significant performance improvement to the cursor code.
+
+2.3.0
+- User Data are now defined in TiXmlBase instead of TiXmlNode
+- Character Entities are now UCS-2
+- Character Entities can be decimal or hexadecimal
+- UTF-8 conversion.
+- Fixed many, many bugs.
+
+2.3.1
+- Fixed bug in handling nulls embedded in the input.
+- Make UTF-8 parser tolerant of bad text encoding.
+- Added encoding detection. 
+- Many fixes and input from John-Philip Leonard Johansson (JP) and Ellers, 
+  including UTF-8 feedback, bug reports, and patches. Thanks!
+- Added version # constants - a suggestion from JP and Ellers.
+- [ 979180 ] Missing ; in entity reference, fix from Rob Laveaux.
+- Copy constructors and assignment have been a long time coming. Thanks to
+  Fokke and JP.
+
+2.3.2
+- Made the IsAlpha and IsAlphaNum much more tolerant of non-UTF-8 encodings. Thanks
+  Volker Boerchers for finding the issue.
+- Ran the program though the magnificent Valgrind - http://valgrind.kde.org - to check
+  for memory errors. Fixed some minor issues.
+
+2.3.3
+- Fixed crash when test program was run from incorrect directory.
+- Fixed bug 1070717 - empty document not returned correctly - thanks Katsuhisa Yuasa.
+- Bug 1079301 resolved - deprecated stdlib calls. Thanks Adrian Boeing.
+- Bug 1035218 fixed - documentation errors. Xunji Luo
+- Other bug fixes have accumulated and been fixed on the way as well; my apologies to
+  authors not credited!
+- Big fix / addition is to correctly return const values. TinyXml could basically
+  remove const in a method like this: TiXmlElement* Foo() const, where the returned element
+  was a pointer to internal data. That is now: const TiXmlElement* Foo() const and
+  TiXmlElement* Foo().
+
+2.3.4
+- Fixed additional const errors, thanks Kent Gibson.
+- Correctly re-enable warnings after tinyxml header. Thanks Cory Nelson.
+- Variety of type cleanup and warning fixes. Thanks Warren Stevens.
+- Cleaned up unneeded constructor calls in TinyString - thanks to Geoff Carlton and
+  the discussion group on sourceforge.
+
+2.4.0
+- Improved string class, thanks Tyge Lovset (whose name gets mangled in English - sorry)
+- Type cast compiler warning, thanks Rob van den Bogaard
+- Added GetText() convenience function. Thanks Ilya Parniuk & Andrew Ellers for input.
+- Many thanks to marlonism for finding an infinite loop in bad xml.
+- A patch to cleanup warnings from Robert Gebis.
+- Added ValueStr() to get the value of a node as a string.
+- TiXmlText can now parse and output as CDATA
+- Additional string improvement from James (z2895)
+- Removed extraneous 'const', thanks David Aldrich
+- First pass at switching to the "safe" stdlib functions. Many people have suggested and
+  pushed on this, but Warren Stevens put together the first proposal.
+- TinyXml now will do EOL normalization before parsing, consistent with the W3C XML spec.
+- Documents loaded with the UTF-8 BOM will now save with the UTF-8 BOM. Good suggestion 
+  from 'instructor_'
+- Ellers submitted his very popular tutorials, which have been added to the distribution.
+
+2.4.1
+- Fixed CDATA output formatting
+- Fixed memory allocators in TinyString to work with overloaded new/delete
+
+2.4.2
+- solosnake pointed out that TIXML_LOG causes problems on an XBOX. The definition in the header
+  was superflous and was moved inside of DEBUG_PARSING
+
+2.4.3
+- Fixed a test bug that caused a crash in 'xmltest'. TinyXML was fine, but it isn't good
+  to ship with a broken test suite.
+- Started converting some functions to not cast between std::string and const char* 
+  quite as often.
+- Added FILE* versions of the document loads - good suggestion from Wade Brainerd
+- Empty documents might not always return the errors they should. [1398915] Thanks to igor v.
+- Added some asserts for multiply adding a node, regardng bug [1391937] suggested by Paco Arjonilla.
+
+2.4.4
+- Bug find thanks to andre-gross found a memory leak that occured when a document failed to load.
+- Bug find (and good analysis) by VirtualJim who found a case where attribute parsing 
+  should be throwing an error and wasn't.
+- Steve Hyatt suggested the QueryValueAttribute method, which is now implemented.
+- DavidA identified a chunk of dead code.
+- Andrew Baxter sent in some compiler warnings that were good clean up points.
+
+2.5
+- Added the Visit() API. Many thanks to both Andrew Ellerton and John-Philip for all their
+  work, code, suggestion, and just general pushing that it should be done.
+- Removed existing streaming code and use TiXmlPrinter instead.
+- [ tinyxml-Bugs-1527079 ] Compile error in tinystr.cpp fixed, thanks to Paul Suggs
+- [ tinyxml-Bugs-1522890 ] SaveFile has no error checks fixed, thanks to Ivan Dobrokotov
+- Ivan Dobrokotov also reported redundant memory allocation in the Attribute() method, which
+  upon investigation was a mess. The attribute should now be fixed for both const char* and 
+  std::string, and the return types match the input parameters.
+- Feature [ 1511105 ] Make TiXmlComment constructor accept a string / char*, implemented.
+  Thanks to Karl Itschen for the feedback.
+- [ 1480108 ] Stream parsing fails when CDATA contains tags was found by Tobias Grimm, who also
+  submitted a test case and patch. A significant bug in CDATA streaming (operator>>) has now
+  been fixed.
+
+2.5.2
+- Lieven, and others, pointed out a missing const-cast that upset the Open Watcom compiler.
+  Should now be fixed.
+- ErrorRow and ErrorCol should have been const, and weren't. Fixed thanks to Dmitry Polutov.
+
+2.5.3
+- zloe_zlo identified a missing string specialization for QueryValueAttribute() [ 1695429 ]. Worked
+  on this bug, but not sure how to fix it in a safe, cross-compiler way.
+- increased warning level to 4 and turned on detect 64 bit portability issues for VC2005.
+  May address [ 1677737 ] VS2005: /Wp64 warnings
+- grosheck identified several problems with the Document copy. Many thanks for [ 1660367 ]
+- Nice catch, and suggested fix, be Gilad Novik on the Printer dropping entities.
+  "[ 1600650 ] Bug when printing xml text" is now fixed.
+- A subtle fix from Nicos Gollan in the tinystring initializer: 
+  [ 1581449 ] Fix initialiser of TiXmlString::nullrep_
+- Great catch, although there isn't a submitter for the bug. [ 1475201 ] TinyXML parses entities in comments. 
+  Comments should not, in fact, parse entities. Fixed the code path and added tests.
+- We were not catching all the returns from ftell. Thanks to Bernard for catching that.
+  
diff -Naur wxFormBuilder.orig/subprojects/ticpp/dox wxFormBuilder/subprojects/ticpp/dox
--- wxFormBuilder.orig/subprojects/ticpp/dox	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/dox	2019-11-18 10:42:57.708406053 +0100
@@ -0,0 +1,1229 @@
+# Doxyfile 1.4.3
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = TinyXml
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
+# if some version control system is used.
+
+PROJECT_NUMBER = 2.5.3
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = ./docs
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
+# 4096 sub-directories (in 2 levels) under the output directory of each output 
+# format and will distribute the generated files over these directories. 
+# Enabling this option can be useful when feeding doxygen a huge amount of 
+# source files, where putting all generated files in the same directory would 
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Brazilian, Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, 
+# Dutch, Finnish, French, German, Greek, Hungarian, Italian, Japanese, 
+# Japanese-en (Japanese with English messages), Korean, Korean-en, Norwegian, 
+# Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Slovene, Spanish, 
+# Swedish, and Ukrainian.
+
+OUTPUT_LANGUAGE        = English
+
+# This tag can be used to specify the encoding used in the generated output. 
+# The encoding is not always determined by the language that is chosen, 
+# but also whether or not the output is meant for Windows or non-Windows users. 
+# In case there is a difference, setting the USE_WINDOWS_ENCODING tag to YES 
+# forces the Windows encoding (this is the default for the Windows binary), 
+# whereas setting the tag to NO uses a Unix-style encoding (the default for 
+# all platforms other than Windows).
+
+USE_WINDOWS_ENCODING   = YES
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator 
+# that is used to form the text in various listings. Each string 
+# in this list, if found as the leading text of the brief description, will be 
+# stripped from the text and the result after processing the whole list, is 
+# used as the annotated text. Otherwise, the brief description is used as-is. 
+# If left blank, the following values are used ("$name" is automatically 
+# replaced with the name of the entity): "The $name class" "The $name widget" 
+# "The $name file" "is" "provides" "specifies" "contains" 
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       = 
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
+# inherited members of a class in the documentation of that class as if those 
+# members were ordinary class members. Constructors, destructors and assignment 
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user-defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. The tag can be used to show relative paths in the file list. 
+# If left blank the directory from which doxygen is run is used as the 
+# path to strip.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
+# the path mentioned in the documentation of a class, which tells 
+# the reader which header file to include in order to use a class. 
+# If left blank only the name of the header file containing the class 
+# definition is used. Otherwise one should specify the include paths that 
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful is your file systems 
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments will behave just like the Qt-style comments (thus requiring an 
+# explicit @brief command for a brief description.
+
+JAVADOC_AUTOBRIEF      = YES
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the DETAILS_AT_TOP tag is set to YES then Doxygen 
+# will output the detailed description near the top, like JavaDoc.
+# If set to NO, the detailed description appears after the member 
+# documentation.
+
+DETAILS_AT_TOP         = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce 
+# a new page for each member. If set to NO, the documentation of a member will 
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 4
+
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user-defined paragraph with heading "Side Effects:". 
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
+# sources only. Doxygen will then generate output that is more tailored for C. 
+# For instance, some of the names that are used will be different. The list 
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java sources 
+# only. Doxygen will then generate output that is more tailored for Java. 
+# For instance, namespaces will be presented as packages, qualified scopes 
+# will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
+# the same type (for instance a group of public functions) to be put as a 
+# subgroup of that type (e.g. under the Public Functions section). Set it to 
+# NO to prevent subgrouping. Alternatively, this can be done per class using 
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
+# will be included in the documentation.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local 
+# methods, which are defined in the implementation section but not in 
+# the interface are included in the documentation. 
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = YES
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these classes will be included in the various 
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = YES
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower-case letters. If set to YES upper-case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put a list of the files that are included by a file in the documentation 
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
+# brief documentation of file, namespace and class members alphabetically 
+# by member name. If set to NO (the default) the members will appear in 
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
+# sorted by fully-qualified names, including namespaces. If set to 
+# NO (the default), the class list will be sorted only by class name, 
+# not including the namespace part. 
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the 
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional 
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or define consists of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and defines in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+# If the sources in your project are distributed over multiple directories 
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
+# in the documentation.
+
+SHOW_DIRECTORIES       = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
+# doxygen should invoke to get the current version for each file (typically from the 
+# version control system). Doxygen will invoke the program by executing (via 
+# popen()) the command <command> <input-file>, where <command> is the value of 
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
+# provided by doxygen. Whatever the progam writes to standard output 
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated 
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = YES
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for 
+# functions that are documented, but have no documentation for their parameters 
+# or return value. If set to NO (the default) doxygen will only warn about 
+# wrong or incomplete parameter documentation, but not about the absence of 
+# documentation.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text. Optionally the format may contain 
+# $version, which will be replaced by the version of the file (if it could 
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
+# to stderr.
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
+# with spaces.
+
+INPUT                  = . \
+                         readme.txt \
+                         tutorial_gettingStarted.txt \
+						 tutorial_ticpp.txt
+
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx 
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm
+
+FILE_PATTERNS          = *.h
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
+# If left blank NO is used.
+
+RECURSIVE              = NO
+
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                = 
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
+# directories that are symbolic links (a Unix filesystem feature) are excluded 
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories.
+
+EXCLUDE_PATTERNS       = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
+# the \include command).
+
+EXAMPLE_PATH           = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank all files are included.
+
+EXAMPLE_PATTERNS       = 
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
+# the \image command).
+
+IMAGE_PATH             = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output.  If FILTER_PATTERNS is specified, this tag will be 
+# ignored.
+
+INPUT_FILTER           = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
+# basis.  Doxygen will compare the file name with each pattern and apply the 
+# filter if there is a match.  The filters are a list of the form: 
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER 
+# is applied to all files.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources. 
+# Note: To get rid of all source code in the generated output, make sure also 
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body 
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES (the default) 
+# then for each documented function all documented 
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES (the default) 
+# then for each documented function all documented entities 
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code 
+# will point to the HTML generated by the htags(1) tool instead of doxygen 
+# built-in source browser. The htags tool is part of GNU's global source 
+# tagging system (see http://www.gnu.org/software/global/global.html). You 
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
+# of all compounds will be generated. Enable this if the project 
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = NO
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = .
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard header.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard footer.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet. Note that doxygen will try to copy 
+# the style sheet file to the HTML output directory, so don't put your own 
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        = 
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compressed HTML help file (.chm) 
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = YES
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
+# written to the html output directory.
+
+CHM_FILE               = TinyXML Help_v2.5.3.chm
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           = "C:\Program Files\DocRunner\hhc.exe"
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [1..20]) 
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the GENERATE_TREEVIEW tag is set to YES, a side panel will be
+# generated containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+, 
+# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are 
+# probably better off using the HTML help feature.
+
+GENERATE_TREEVIEW      = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
+# generate Latex output.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, a4wide, letter, legal and 
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = NO
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = NO
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
+# include the index chapters (such as File Index, Compound Index, etc.) 
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimized for Word 97 and may not look very pretty with 
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assignments. You only have to provide 
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an rtf document. 
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to 
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_SCHEMA             = 
+
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_DTD                = 
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
+# dump the program listings (including syntax highlighting 
+# and cross-referencing information) to the XML output. Note that 
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader.  This is useful 
+# if you want to understand what is going on.  On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
+# files.
+
+ENABLE_PREPROCESSING   = NO
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
+# PREDEFINED and EXPAND_AS_PREDEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
+# the preprocessor.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
+# be used.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed. To prevent a macro definition from being 
+# undefined via #undef or recursively expanded use the := operator 
+# instead of the = operator.
+
+PREDEFINED             = 
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all function-like macros that are alone 
+# on a line, have an all uppercase name, and do not end with a semicolon. Such 
+# function macros are typically used for boiler-plate code, and will confuse 
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles. 
+# Optionally an initial location of the external documentation 
+# can be added for each tagfile. The format of a tag file without 
+# this location is as follows: 
+#   TAGFILES = file1 file2 ... 
+# Adding location for the tag files is done as follows: 
+#   TAGFILES = file1=loc1 "file2 = loc2" ... 
+# where "loc1" and "loc2" can be relative or absolute paths or 
+# URLs. If a location is present for each tag, the installdox tool 
+# does not have to be run to correct the links.
+# Note that each tag file must have a unique name
+# (where the name does NOT include the path)
+# If a tag file is not located in the directory in which doxygen 
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script 
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
+# or super classes. Setting the tag to NO turns the diagrams off. Note that 
+# this option is superseded by the HAVE_DOT option below. This is only a 
+# fallback. It is recommended to install and use dot, since it yields more 
+# powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = NO
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
+# collaboration diagrams in a style similar to the OMG's Unified Modeling 
+# Language.
+
+UML_LOOK               = NO
+
+# If set to YES, the inheritance and collaboration graphs will show the 
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT tags are set to YES then doxygen will 
+# generate a call dependency graph for every global function or class method. 
+# Note that enabling this option will significantly increase the time of a run. 
+# So in most cases it will be better to enable call graphs for selected 
+# functions only using the \callgraph command.
+
+CALL_GRAPH             = NO
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
+# then doxygen will show the dependencies a directory has on other directories 
+# in a graphical way. The dependency relations are determined by the #include
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, jpg, or gif
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
+# \dotfile command).
+
+DOTFILE_DIRS           = 
+
+# The MAX_DOT_GRAPH_WIDTH tag can be used to set the maximum allowed width 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_WIDTH    = 1024
+
+# The MAX_DOT_GRAPH_HEIGHT tag can be used to set the maximum allows height 
+# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
+# this value, doxygen will try to truncate the graph, so that it fits within 
+# the specified constraint. Beware that most browsers cannot cope with very 
+# large images.
+
+MAX_DOT_GRAPH_HEIGHT   = 1024
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
+# graphs generated by dot. A depth value of 3 means that only nodes reachable 
+# from the root by following a path via at most 3 edges will be shown. Nodes 
+# that lay further from the root node will be omitted. Note that setting this 
+# option to 1 or 2 may greatly reduce the computation time needed for large 
+# code bases. Also note that a graph may be further truncated if the graph's 
+# image dimensions are not sufficient to fit the graph (see MAX_DOT_GRAPH_WIDTH 
+# and MAX_DOT_GRAPH_HEIGHT). If 0 is used for the depth value (the default), 
+# the graph is not depth-constrained.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
+# background. This is disabled by default, which results in a white background. 
+# Warning: Depending on the platform used, enabling this option may lead to 
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to 
+# read).
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
+# files in one run (i.e. multiple -o and -T options on the command line). This 
+# makes dot run faster, but since only newer versions of dot (>1.8.10) 
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermediate dot files that are used to generate 
+# the various graphs.
+
+DOT_CLEANUP            = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+
+# The SEARCHENGINE tag specifies whether or not a search engine should be 
+# used. If set to NO the values of all tags below this one will be ignored.
+
+SEARCHENGINE           = NO
\ No newline at end of file
diff -Naur wxFormBuilder.orig/subprojects/ticpp/meson.build wxFormBuilder/subprojects/ticpp/meson.build
--- wxFormBuilder.orig/subprojects/ticpp/meson.build	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/meson.build	2019-11-18 10:42:57.708406053 +0100
@@ -0,0 +1,12 @@
+project('ticpp', 'cpp', default_options : ['cpp_std=c++17'])
+
+add_project_arguments('-DTIXML_USE_TICPP', language : 'cpp')
+
+ticpp_dep = declare_dependency(include_directories : include_directories('.'),
+	link_with : static_library('ticpp', [
+			'ticpp.cpp',
+			'tinystr.cpp',
+			'tinyxml.cpp',
+			'tinyxmlerror.cpp',
+			'tinyxmlparser.cpp',
+		]))
diff -Naur wxFormBuilder.orig/subprojects/ticpp/premake.lua wxFormBuilder/subprojects/ticpp/premake.lua
--- wxFormBuilder.orig/subprojects/ticpp/premake.lua	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/premake.lua	2019-11-18 10:42:57.708406053 +0100
@@ -0,0 +1,36 @@
+--*****************************************************************************
+--*	Author:		RJP Computing <rjpcomputing@gmail.com>
+--* Copyright (C) 2007 RJP Computing
+--*
+--*	Permission is hereby granted, free of charge, to any person obtaining a copy of
+--*	this software and associated documentation files (the "Software"), to deal in
+--*	the Software without restriction, including without limitation the rights to
+--* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+--*	the Software, and to permit persons to whom the Software is furnished to do so,
+--*	subject to the following conditions:
+--*	
+--* The above copyright notice and this permission notice shall be included in all
+--*	copies or substantial portions of the Software.
+--*	
+--*	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+--* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+--*	FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+--*	COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+--*	IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+--* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+--*
+--*	NOTES:
+--*		- use the '/' slash for all paths.
+--*****************************************************************************
+project.name	= "TinyXML++"
+
+project.bindir	= "lib"
+project.libdir	= "lib"
+
+-- This is for including other Premake scripts.
+dopackage( "ticpp.lua" )
+
+-- Add options here.
+addoption( "dynamic-runtime", "Use the dynamicly loadable version of the runtime." )
+addoption( "unicode", "Use the Unicode character set" )
+
diff -Naur wxFormBuilder.orig/subprojects/ticpp/premake4.lua wxFormBuilder/subprojects/ticpp/premake4.lua
--- wxFormBuilder.orig/subprojects/ticpp/premake4.lua	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/premake4.lua	2019-11-18 10:42:57.709406053 +0100
@@ -0,0 +1,46 @@
+--*****************************************************************************
+--*	Author:		RJP Computing <rjpcomputing@gmail.com>
+--* Copyright (C) 2009 RJP Computing
+--*
+--*	Permission is hereby granted, free of charge, to any person obtaining a copy of
+--*	this software and associated documentation files (the "Software"), to deal in
+--*	the Software without restriction, including without limitation the rights to
+--* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+--*	the Software, and to permit persons to whom the Software is furnished to do so,
+--*	subject to the following conditions:
+--*
+--* The above copyright notice and this permission notice shall be included in all
+--*	copies or substantial portions of the Software.
+--*
+--*	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+--* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+--*	FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+--*	COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+--*	IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+--* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+--*
+--*	NOTES:
+--*		- use the '/' slash for all paths.
+--*****************************************************************************
+solution "TinyXML++"
+	targetdir "lib"
+	implibdir "lib"
+	configurations { "Debug", "Release" }
+	buildoptions { "-std=c++14" }
+
+-- This is for including other Premake scripts.
+dofile( "ticpp4.lua" )
+
+-- Add options here.
+newoption
+{
+	trigger = "dynamic-runtime",
+	description = "Use the dynamicly loadable version of the runtime."
+}
+
+newoption
+{
+	trigger = "unicode",
+	description = "Use the Unicode character set"
+}
+
diff -Naur wxFormBuilder.orig/subprojects/ticpp/tests/mocks/TicppMock.hh wxFormBuilder/subprojects/ticpp/tests/mocks/TicppMock.hh
--- wxFormBuilder.orig/subprojects/ticpp/tests/mocks/TicppMock.hh	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/tests/mocks/TicppMock.hh	2019-11-18 10:42:57.709406053 +0100
@@ -0,0 +1,175 @@
+#if !defined ( __TINY_XML_MOCK__ )
+#define __TINY_XML_MOCK__
+
+namespace ticpp
+{
+	namespace mock
+	{
+		struct Node;
+		struct Element;
+		struct Declaration;
+
+		struct NodeBase
+		{
+			NodeBase( void )
+			{
+			}
+			MOCK_METHOD0( Clear, void ( void ) );
+			MOCK_METHOD1( SetValue, void( const std::string& ) );
+			MOCK_METHOD1( InsertEndChild, void( const Node& ) );
+			MOCK_METHOD1( LinkEndChild, void( const Node* ) );
+			MOCK_METHOD1( SetText, void ( const double ) );
+			MOCK_METHOD1( SetText, void ( const std::string& ) );
+			MOCK_METHOD1( GetValue, void ( std::string* ) );
+			MOCK_METHOD1( SetIntText, void ( const unsigned int ) );
+			MOCK_METHOD1( RemoveChild, void ( Node* ) );
+			MOCK_CONST_METHOD0( Clone, const Node& ( void ) );		//This is done because unique_ptr's copy constructor is deleted and generates a compiler error inside googlemock.
+			MOCK_CONST_METHOD0( ToElement, Element*( void ) );
+			MOCK_CONST_METHOD0( NoChildren, bool ( void ) );
+			MOCK_CONST_METHOD0( FirstChild, Node*( void ) );
+			MOCK_CONST_METHOD1( FirstChild, Node*( const std::string& ) );
+			MOCK_CONST_METHOD2( FirstChild, Node*( const std::string&, bool ) );
+			MOCK_CONST_METHOD1( IterateChildren, Node*( Node* ) );
+			MOCK_CONST_METHOD2( IterateChildren, Node*( const std::string, Node* ) );
+			MOCK_CONST_METHOD0( FirstChildElement, Element*() );
+			MOCK_CONST_METHOD1( FirstChildElement, Element*( bool ) );
+			MOCK_CONST_METHOD0( Value, std::string( void ) );
+			virtual ~NodeBase( void )
+			{
+			}
+		};
+
+		struct Node : public StrictMock< NodeBase >
+		{
+			//This is the work around for the Clone method not returning unique_ptr.
+			const Node* release( void ) const
+			{
+				return this;
+			}
+
+			Node( void ) : StrictMock< NodeBase >()
+			{
+			}
+
+			Node( const Node& ) : StrictMock< NodeBase >()
+			{
+			}
+
+			bool operator==( const Node& other ) const
+			{
+				return *this == other;
+			}
+			virtual ~Node( void )
+			{
+			}
+		};
+
+		struct ElementBase : public Node
+		{
+			ElementBase( const std::string& ) : Node()
+			{
+			}
+			MOCK_CONST_METHOD1( GetAttribute, std::string( const std::string& ) );
+			MOCK_CONST_METHOD2( GetAttribute, std::string( std::string, bool ) );
+			MOCK_METHOD2( SetAttribute, void ( const std::string&, const int ) );
+			MOCK_METHOD2( SetAttribute, void ( const std::string&, const std::string& ) );
+			MOCK_CONST_METHOD0( GetText, std::string( void ) );
+			MOCK_CONST_METHOD1( GetText, std::string( bool ) );
+			virtual ~ElementBase( void )
+			{
+			}
+		};
+
+		struct Element : public StrictMock< ElementBase >
+		{
+			explicit Element( const std::string& name = std::string() ) : StrictMock< ElementBase >( name )
+			{
+			}
+
+			bool operator==( const Element& other ) const
+			{
+				return *this == other;
+			}
+			virtual ~Element( void )
+			{
+			}
+		};
+
+		struct DocumentBase : public Node
+		{
+			DocumentBase( void ) : Node()
+			{
+			}
+			DocumentBase( const std::string& ) : Node()
+			{
+			}
+			MOCK_METHOD0( SaveFile, void ( void ) );
+			MOCK_METHOD1( SaveFile, void ( const std::string& ) );
+			MOCK_METHOD0( LoadFile, void ( void ) );
+			MOCK_METHOD1( LoadFile, void ( const std::string& ) );
+			MOCK_METHOD1( Parse, void ( const std::string& ) );
+
+			virtual ~DocumentBase( void )
+			{
+			}
+		};
+
+		struct Document : public StrictMock< DocumentBase >
+		{
+			Document( void ) : StrictMock< DocumentBase >()
+			{
+			}
+			Document( const std::string& name ) : StrictMock< DocumentBase >( name )
+			{
+			}
+			MOCK_CONST_METHOD0( GetDocument, Document*( void ) );
+			virtual ~Document( void )
+			{
+			}
+		};
+
+		struct DeclarationBase : public Node
+		{
+			DeclarationBase( void ) : Node()
+			{
+			}
+
+			DeclarationBase( const std::string&, const std::string&, const std::string& ) : Node()
+			{
+			}
+			virtual ~DeclarationBase( void )
+			{
+			}
+		};
+
+		struct Declaration : public StrictMock< DeclarationBase >
+		{
+			Declaration( void ) : StrictMock< DeclarationBase >()
+			{
+			}
+
+			Declaration( const std::string& p1, const std::string& p2, const std::string& p3 ) : StrictMock< DeclarationBase >( p1, p2, p3 )
+			{
+			}
+			virtual ~Declaration( void )
+			{
+			}
+		};
+
+		struct Comment : public Node
+		{
+			Comment( void )
+			{
+			}
+			virtual ~Comment( void )
+			{
+			}
+		};
+
+		inline std::ostream& operator << ( std::ostream& os, const Node& )
+		{
+			return( os );
+		}
+	}
+}
+#endif // !defined ( __TINY_XML_MOCK__ )
diff -Naur wxFormBuilder.orig/subprojects/ticpp/ticpp.cpp wxFormBuilder/subprojects/ticpp/ticpp.cpp
--- wxFormBuilder.orig/subprojects/ticpp/ticpp.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/ticpp.cpp	2019-11-18 10:42:57.709406053 +0100
@@ -0,0 +1,1085 @@
+/*
+http://code.google.com/p/ticpp/
+Copyright (c) 2006 Ryan Pusztai, Ryan Mulder
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+#ifdef TIXML_USE_TICPP
+
+#include "ticpp.h"
+
+using namespace ticpp;
+
+Attribute::Attribute()
+{
+	SetTiXmlPointer( new TiXmlAttribute() );
+	m_impRC->InitRef();
+}
+
+Attribute::Attribute( TiXmlAttribute* attribute )
+{
+	SetTiXmlPointer( attribute );
+	m_impRC->IncRef();
+}
+
+Attribute::Attribute( const std::string& name, const std::string& value )
+{
+	SetTiXmlPointer( new TiXmlAttribute( name, value ) );
+	m_impRC->InitRef();
+}
+
+void Attribute::operator=( const Attribute& copy )
+{
+	// Dropping the reference to the old object
+	this->m_impRC->DecRef();
+
+	// Pointing to the new Object
+	SetTiXmlPointer( copy.m_tiXmlPointer );
+
+	// The internal tixml pointer changed in the above line
+	this->m_impRC->IncRef();
+}
+
+Attribute::~Attribute()
+{
+	m_impRC->DecRef();
+}
+
+std::string Attribute::Value() const
+{
+	ValidatePointer();
+	return m_tiXmlPointer->ValueStr();
+}
+
+std::string Attribute::Name() const
+{
+	ValidatePointer();
+	return m_tiXmlPointer->Name();
+}
+
+Attribute* Attribute::Next( bool throwIfNoAttribute ) const
+{
+	ValidatePointer();
+	TiXmlAttribute* attribute = m_tiXmlPointer->Next();
+	if ( 0 == attribute )
+	{
+		if ( throwIfNoAttribute )
+		{
+			TICPPTHROW( "No more attributes found" )
+		}
+		else
+		{
+			return 0;
+		}
+	}
+
+	Attribute* temp = new Attribute( attribute );
+	attribute->m_spawnedWrappers.push_back( temp );
+
+	return temp;
+}
+
+Attribute* Attribute::Previous( bool throwIfNoAttribute ) const
+{
+	ValidatePointer();
+	TiXmlAttribute* attribute = m_tiXmlPointer->Previous();
+	if ( 0 == attribute )
+	{
+		if ( throwIfNoAttribute )
+		{
+			TICPPTHROW( "No more attributes found" )
+		}
+		else
+		{
+			return 0;
+		}
+	}
+
+	Attribute* temp = new Attribute( attribute );
+	attribute->m_spawnedWrappers.push_back( temp );
+
+	return temp;
+}
+
+void Attribute::IterateNext( const std::string&, Attribute** next ) const
+{
+	*next = Next( false );
+}
+
+void Attribute::IteratePrevious( const std::string&, Attribute** previous ) const
+{
+	*previous = Previous( false );
+}
+
+void Attribute::Print( FILE* file, int depth ) const
+{
+	ValidatePointer();
+	m_tiXmlPointer->Print( file, depth );
+}
+
+void Attribute::SetTiXmlPointer( TiXmlAttribute* newPointer )
+{
+	m_tiXmlPointer = newPointer;
+	SetImpRC( newPointer );
+}
+
+//*****************************************************************************
+
+Node* Node::NodeFactory( TiXmlNode* tiXmlNode, bool throwIfNull, bool rememberSpawnedWrapper ) const
+{
+	if ( 0 == tiXmlNode )
+	{
+		if ( throwIfNull )
+		{
+			TICPPTHROW( "tiXmlNode is NULL" )
+		}
+		else
+		{
+			return 0;
+		}
+	}
+
+	Node* temp;
+	switch ( tiXmlNode->Type() )
+	{
+		case TiXmlNode::DOCUMENT:
+			temp = new Document( tiXmlNode->ToDocument() );
+			break;
+
+		case TiXmlNode::ELEMENT:
+			temp = new Element( tiXmlNode->ToElement() );
+			break;
+
+		case TiXmlNode::COMMENT:
+			temp = new Comment( tiXmlNode->ToComment() );
+			break;
+
+		case TiXmlNode::TEXT:
+			temp = new Text( tiXmlNode->ToText() );
+			break;
+
+		case TiXmlNode::DECLARATION:
+			temp = new Declaration( tiXmlNode->ToDeclaration() );
+			break;
+
+		case TiXmlNode::STYLESHEETREFERENCE:
+			temp = new StylesheetReference( tiXmlNode->ToStylesheetReference() );
+			break;
+
+		default:
+			TICPPTHROW( "Type is unsupported" )
+	}
+
+	if ( rememberSpawnedWrapper )
+	{
+		tiXmlNode->m_spawnedWrappers.push_back( temp );
+	}
+	return temp;
+}
+
+
+std::string Node::Value() const
+{
+	return GetTiXmlPointer()->ValueStr();
+}
+
+void Node::Clear()
+{
+	GetTiXmlPointer()->Clear();
+}
+
+Node* Node::Parent( bool throwIfNoParent ) const
+{
+	TiXmlNode* parent = GetTiXmlPointer()->Parent();
+	if ( ( 0 == parent ) && throwIfNoParent )
+	{
+		TICPPTHROW( "No parent exists" );
+	}
+
+	return NodeFactory( parent, false );
+}
+
+Node* Node::FirstChild( bool throwIfNoChildren ) const
+{
+	return FirstChild( "", throwIfNoChildren );
+}
+
+Node* Node::FirstChild( const std::string& value, bool throwIfNoChildren ) const
+{
+	return FirstChild( value.c_str(), throwIfNoChildren );
+}
+
+Node* Node::FirstChild( const char* value, bool throwIfNoChildren ) const
+{
+	TiXmlNode* childNode;
+	if ( 0 == strlen( value ) )
+	{
+		childNode = GetTiXmlPointer()->FirstChild();
+	}
+	else
+	{
+		childNode = GetTiXmlPointer()->FirstChild( value );
+	}
+
+	if ( ( 0 == childNode ) && throwIfNoChildren )
+	{
+		TICPPTHROW( "Child with the value of \"" << value << "\" not found" );
+	}
+
+	return NodeFactory( childNode, false );
+}
+
+Node* Node::LastChild( bool throwIfNoChildren ) const
+{
+	return LastChild( "", throwIfNoChildren );
+}
+
+Node* Node::LastChild( const std::string& value, bool throwIfNoChildren ) const
+{
+	return LastChild( value.c_str(), throwIfNoChildren );
+}
+
+Node* Node::LastChild( const char* value, bool throwIfNoChildren ) const
+{
+	TiXmlNode* childNode;
+	if ( 0 == strlen( value ) )
+	{
+		childNode = GetTiXmlPointer()->LastChild();
+	}
+	else
+	{
+		childNode = GetTiXmlPointer()->LastChild( value );
+	}
+
+	if ( ( 0 == childNode ) && throwIfNoChildren )
+	{
+		TICPPTHROW( "Child with the value of \"" << value << "\" not found" );
+	}
+
+	return NodeFactory( childNode, false );
+}
+
+Node* Node::IterateChildren ( Node* previous ) const
+{
+	TiXmlNode* pointer;
+	if ( 0 == previous )
+	{
+		pointer = GetTiXmlPointer()->IterateChildren( 0 );
+	}
+	else
+	{
+		pointer = GetTiXmlPointer()->IterateChildren( previous->GetTiXmlPointer() );
+	}
+
+	return NodeFactory( pointer, false );
+}
+
+Node* Node::IterateChildren( const std::string& value, Node* previous ) const
+{
+	TiXmlNode* pointer;
+	if ( 0 == previous )
+	{
+		pointer = GetTiXmlPointer()->IterateChildren( value, 0 );
+	}
+	else
+	{
+		pointer = GetTiXmlPointer()->IterateChildren( value, previous->GetTiXmlPointer() );
+	}
+
+	return NodeFactory( pointer, false );
+}
+
+Node* Node::InsertEndChild( const Node& addThis )
+{
+	if ( addThis.Type() == TiXmlNode::DOCUMENT )
+	{
+		TICPPTHROW( "Node is a Document and can't be inserted" );
+	}
+
+	TiXmlNode* pointer = GetTiXmlPointer()->InsertEndChild( *addThis.GetTiXmlPointer() );
+	if ( 0 == pointer )
+	{
+		TICPPTHROW( "Node can't be inserted" );
+	}
+
+	return NodeFactory( pointer );
+}
+
+Node* Node::LinkEndChild( Node* childNode )
+{
+	if ( childNode->Type() == TiXmlNode::DOCUMENT )
+	{
+		TICPPTHROW( "Node is a Document and can't be linked" );
+	}
+
+	// Increment reference count when adding to the tree
+	childNode->m_impRC->IncRef();
+
+	if ( 0 == GetTiXmlPointer()->LinkEndChild( childNode->GetTiXmlPointer() ) )
+	{
+		TICPPTHROW( "Node can't be linked" );
+	}
+
+	return childNode;
+}
+
+Node* Node::InsertBeforeChild( Node* beforeThis, const Node& addThis )
+{
+	if ( addThis.Type() == TiXmlNode::DOCUMENT )
+	{
+		TICPPTHROW( "Node is a Document and can't be inserted" );
+	}
+
+	// Increment reference count when adding to the tree
+	addThis.m_impRC->IncRef();
+
+	TiXmlNode* pointer = GetTiXmlPointer()->InsertBeforeChild( beforeThis->GetTiXmlPointer(), *addThis.GetTiXmlPointer() );
+	if ( 0 == pointer )
+	{
+		TICPPTHROW( "Node can't be inserted" );
+	}
+
+	return NodeFactory( pointer );
+}
+
+Node* Node::InsertAfterChild( Node* afterThis, const Node& addThis )
+{
+	if ( addThis.Type() == TiXmlNode::DOCUMENT )
+	{
+		TICPPTHROW( "Node is a Document and can't be inserted" );
+	}
+
+	// Increment reference count when adding to the tree
+	addThis.m_impRC->IncRef();
+
+	TiXmlNode* pointer = GetTiXmlPointer()->InsertAfterChild( afterThis->GetTiXmlPointer(), *addThis.GetTiXmlPointer() );
+	if ( 0 == pointer )
+	{
+		TICPPTHROW( "Node can't be inserted" );
+	}
+
+	return NodeFactory( pointer );
+}
+
+Node* Node::ReplaceChild( Node* replaceThis, const Node& withThis )
+{
+	if ( withThis.Type() == TiXmlNode::DOCUMENT )
+	{
+		TICPPTHROW( "Node is a Document and can't be inserted" );
+	}
+
+	// Increment reference count when adding to the tree
+	withThis.m_impRC->IncRef();
+
+	TiXmlNode* pointer = GetTiXmlPointer()->ReplaceChild( replaceThis->GetTiXmlPointer(), *withThis.GetTiXmlPointer() );
+	if ( 0 == pointer )
+	{
+		TICPPTHROW( "Node can't be inserted" );
+	}
+
+	return NodeFactory( pointer );
+}
+
+void Node::RemoveChild( Node* removeThis )
+{
+	if  ( !GetTiXmlPointer()->RemoveChild( removeThis->GetTiXmlPointer() ) )
+	{
+		TICPPTHROW( "Node to remove (" << removeThis->Value() << ") is not a child of this Node (" << Value() << ")" )
+	}
+}
+
+Node* Node::PreviousSibling( bool throwIfNoSiblings ) const
+{
+	return PreviousSibling( "", throwIfNoSiblings );
+}
+
+Node* Node::PreviousSibling( const std::string& value, bool throwIfNoSiblings ) const
+{
+	return PreviousSibling( value.c_str(), throwIfNoSiblings );
+}
+
+Node* Node::PreviousSibling( const char* value, bool throwIfNoSiblings ) const
+{
+	TiXmlNode* sibling;
+	if ( 0 == strlen( value ) )
+	{
+		sibling = GetTiXmlPointer()->PreviousSibling();
+	}
+	else
+	{
+		sibling = GetTiXmlPointer()->PreviousSibling( value );
+	}
+
+	if ( ( 0 == sibling ) && throwIfNoSiblings )
+	{
+		TICPPTHROW( "No Siblings found with value, '" << value << "', Prior to this Node (" << Value() << ")" )
+	}
+
+	return NodeFactory( sibling, false );
+}
+
+Node* Node::NextSibling( bool throwIfNoSiblings ) const
+{
+	return NextSibling( "", throwIfNoSiblings );
+}
+
+Node* Node::NextSibling( const std::string& value, bool throwIfNoSiblings ) const
+{
+	return NextSibling( value.c_str(), throwIfNoSiblings );
+}
+
+Node* Node::NextSibling( const char* value, bool throwIfNoSiblings ) const
+{
+	TiXmlNode* sibling;
+	if ( 0 == strlen( value ) )
+	{
+		sibling = GetTiXmlPointer()->NextSibling();
+	}
+	else
+	{
+		sibling = GetTiXmlPointer()->NextSibling( value );
+	}
+
+	if ( ( 0 == sibling ) && throwIfNoSiblings )
+	{
+		TICPPTHROW( "No Siblings found with value, '" << value << "', After this Node (" << Value() << ")" )
+	}
+
+	return NodeFactory( sibling, false );
+}
+
+Element* Node::NextSiblingElement( bool throwIfNoSiblings ) const
+{
+	return NextSiblingElement( "", throwIfNoSiblings );
+}
+
+Element* Node::NextSiblingElement( const std::string& value, bool throwIfNoSiblings ) const
+{
+	return NextSiblingElement( value.c_str(), throwIfNoSiblings );
+}
+
+Element* Node::NextSiblingElement( const char* value, bool throwIfNoSiblings ) const
+{
+	TiXmlElement* sibling;
+	if ( 0 == strlen( value ) )
+	{
+		sibling = GetTiXmlPointer()->NextSiblingElement();
+	}
+	else
+	{
+		sibling = GetTiXmlPointer()->NextSiblingElement( value );
+	}
+
+	if ( 0 == sibling )
+	{
+		if ( throwIfNoSiblings )
+		{
+			TICPPTHROW( "No Element Siblings found with value, '" << value << "', After this Node (" << Value() << ")" )
+		}
+		else
+		{
+			return 0;
+		}
+	}
+
+	Element* temp = new Element( sibling );
+	sibling->m_spawnedWrappers.push_back( temp );
+
+	return temp;
+}
+
+Element* Node::FirstChildElement( bool throwIfNoChildren ) const
+{
+	return FirstChildElement( "", throwIfNoChildren );
+}
+
+Element* Node::FirstChildElement( const std::string& value, bool throwIfNoChildren ) const
+{
+	return FirstChildElement( value.c_str(), throwIfNoChildren );
+}
+
+Element* Node::FirstChildElement( const char* value, bool throwIfNoChildren ) const
+{
+	TiXmlElement* element;
+	if ( 0 == strlen( value ) )
+	{
+		element = GetTiXmlPointer()->FirstChildElement();
+	}
+	else
+	{
+		element = GetTiXmlPointer()->FirstChildElement( value );
+	}
+
+	if ( 0 == element )
+	{
+		if( throwIfNoChildren )
+		{
+			TICPPTHROW( "Element (" << Value() << ") does NOT contain a child with the value of '" << value << "'" )
+		}
+		else
+		{
+			return 0;
+		}
+	}
+
+	Element* temp = new Element( element );
+	element->m_spawnedWrappers.push_back( temp );
+
+	return temp;
+}
+
+int Node::Type() const
+{
+	return GetTiXmlPointer()->Type();
+}
+
+Document* Node::GetDocument( bool throwIfNoDocument ) const
+{
+	TiXmlDocument* doc = GetTiXmlPointer()->GetDocument();
+	if ( 0 == doc )
+	{
+		if( throwIfNoDocument )
+		{
+			TICPPTHROW( "This node (" << Value() << ") is not linked under a document" )
+		}
+		else
+		{
+			return 0;
+		}
+	}
+	Document* temp = new Document( doc );
+	doc->m_spawnedWrappers.push_back( temp );
+
+	return temp;
+}
+
+bool Node::NoChildren() const
+{
+	return GetTiXmlPointer()->NoChildren();
+}
+
+Document* Node::ToDocument() const
+{
+	TiXmlDocument* doc = GetTiXmlPointer()->ToDocument();
+	if ( 0 == doc )
+	{
+		TICPPTHROW( "This node (" << Value() << ") is not a Document" )
+	}
+	Document* temp = new Document( doc );
+	doc->m_spawnedWrappers.push_back( temp );
+
+	return temp;
+}
+
+Element* Node::ToElement() const
+{
+	TiXmlElement* doc = GetTiXmlPointer()->ToElement();
+	if ( 0 == doc )
+	{
+		TICPPTHROW( "This node (" << Value() << ") is not a Element" )
+	}
+	Element* temp = new Element( doc );
+	doc->m_spawnedWrappers.push_back( temp );
+
+	return temp;
+}
+
+Comment* Node::ToComment() const
+{
+	TiXmlComment* doc = GetTiXmlPointer()->ToComment();
+	if ( 0 == doc )
+	{
+		TICPPTHROW( "This node (" << Value() << ") is not a Comment" )
+	}
+	Comment* temp = new Comment( doc );
+	doc->m_spawnedWrappers.push_back( temp );
+
+	return temp;
+}
+
+Text* Node::ToText() const
+{
+	TiXmlText* doc = GetTiXmlPointer()->ToText();
+	if ( 0 == doc )
+	{
+		TICPPTHROW( "This node (" << Value() << ") is not a Text" )
+	}
+	Text* temp = new Text( doc );
+	doc->m_spawnedWrappers.push_back( temp );
+
+	return temp;
+}
+
+Declaration* Node::ToDeclaration() const
+{
+	TiXmlDeclaration* doc = GetTiXmlPointer()->ToDeclaration();
+	if ( 0 == doc )
+	{
+		TICPPTHROW( "This node (" << Value() << ") is not a Declaration" )
+	}
+	Declaration* temp = new Declaration( doc );
+	doc->m_spawnedWrappers.push_back( temp );
+
+	return temp;
+}
+
+StylesheetReference* Node::ToStylesheetReference() const
+{
+	TiXmlStylesheetReference* doc = GetTiXmlPointer()->ToStylesheetReference();
+	if ( 0 == doc )
+	{
+		TICPPTHROW( "This node (" << Value() << ") is not a StylesheetReference" )
+	}
+	StylesheetReference* temp = new StylesheetReference( doc );
+	doc->m_spawnedWrappers.push_back( temp );
+
+	return temp;
+}
+
+std::unique_ptr< Node > Node::Clone() const
+{
+	TiXmlNode* node = GetTiXmlPointer()->Clone();
+	if ( 0 == node )
+	{
+		TICPPTHROW( "Node could not be cloned" );
+	}
+	std::unique_ptr< Node > temp( NodeFactory( node, false, false ) );
+
+	// Take ownership of the memory from TiXml
+	temp->m_impRC->InitRef();
+
+	return temp;
+}
+
+bool Node::Accept( TiXmlVisitor* visitor ) const
+{
+	return GetTiXmlPointer()->Accept( visitor );
+}
+
+//*****************************************************************************
+
+Comment::Comment()
+: NodeImp< TiXmlComment >( new TiXmlComment() )
+{
+	m_impRC->InitRef();
+}
+
+Comment::Comment( TiXmlComment* comment )
+: NodeImp< TiXmlComment >( comment )
+{
+}
+
+Comment::Comment( const std::string& comment )
+: NodeImp< TiXmlComment >( new TiXmlComment() )
+{
+	m_impRC->InitRef();
+	m_tiXmlPointer->SetValue( comment );
+}
+
+//*****************************************************************************
+
+Text::Text()
+: NodeImp< TiXmlText >( new TiXmlText("") )
+{
+	m_impRC->InitRef();
+}
+
+
+Text::Text( const std::string& value )
+: NodeImp< TiXmlText >( new TiXmlText( value ) )
+{
+	m_impRC->InitRef();
+}
+
+Text::Text( TiXmlText* text )
+: NodeImp< TiXmlText >( text )
+{
+}
+
+
+//*****************************************************************************
+
+Document::Document()
+: NodeImp< TiXmlDocument >( new TiXmlDocument() )
+{
+	m_impRC->InitRef();
+}
+
+Document::Document( TiXmlDocument* document )
+: NodeImp< TiXmlDocument >( document )
+{
+}
+
+Document::Document( const char* documentName )
+: NodeImp< TiXmlDocument >( new TiXmlDocument( documentName ) )
+{
+	m_impRC->InitRef();
+}
+
+Document::Document( const std::string& documentName )
+: NodeImp< TiXmlDocument >( new TiXmlDocument( documentName ) )
+{
+	m_impRC->InitRef();
+}
+
+void Document::LoadFile( TiXmlEncoding encoding )
+{
+	if ( !m_tiXmlPointer->LoadFile( encoding ) )
+	{
+		TICPPTHROW( "Couldn't load " << m_tiXmlPointer->Value() );
+	}
+}
+
+void Document::SaveFile() const {
+	if ( !m_tiXmlPointer->SaveFile() )
+	{
+		TICPPTHROW( "Couldn't save " << m_tiXmlPointer->Value() );
+	}
+}
+
+void Document::LoadFile( const std::string& filename, TiXmlEncoding encoding )
+{
+	if ( !m_tiXmlPointer->LoadFile( filename.c_str(), encoding ) )
+	{
+		TICPPTHROW( "Couldn't load " << filename );
+	}
+}
+
+void Document::LoadFile( const char* filename, TiXmlEncoding encoding )
+{
+	if ( !m_tiXmlPointer->LoadFile( filename, encoding ) )
+	{
+		TICPPTHROW( "Couldn't load " << filename );
+	}
+}
+
+void Document::SaveFile( const std::string& filename ) const
+{
+	if ( !m_tiXmlPointer->SaveFile( filename.c_str() ) )
+	{
+		TICPPTHROW( "Couldn't save " << filename );
+	}
+}
+
+void Document::Parse( const std::string& xml, bool throwIfParseError, TiXmlEncoding encoding )
+{
+	m_tiXmlPointer->Parse( xml.c_str(), 0, encoding );
+	if( throwIfParseError && m_tiXmlPointer->Error() )
+	{
+		TICPPTHROW( "Error parsing xml." );
+	}
+}
+
+//*****************************************************************************
+
+Element::Element()
+: NodeImp< TiXmlElement >( new TiXmlElement( "DefaultValueCausedByCreatingAnElementWithNoParameters" ) )
+{
+	m_impRC->InitRef();
+}
+
+Element::Element( const std::string& value )
+: NodeImp< TiXmlElement >( new TiXmlElement( value ) )
+{
+	m_impRC->InitRef();
+}
+
+Element::Element( const char* value )
+: NodeImp< TiXmlElement >( new TiXmlElement( value ) )
+{
+	m_impRC->InitRef();
+}
+
+Element::Element( TiXmlElement* element )
+: NodeImp< TiXmlElement >( element )
+{
+}
+
+Attribute* Element::FirstAttribute( bool throwIfNoAttributes ) const
+{
+	ValidatePointer();
+	TiXmlAttribute* attribute = m_tiXmlPointer->FirstAttribute();
+	if ( ( 0 == attribute ) && throwIfNoAttributes )
+	{
+		TICPPTHROW( "This Element (" << Value() << ") has no attributes" )
+	}
+
+	if ( 0 == attribute )
+	{
+		if( throwIfNoAttributes )
+		{
+			TICPPTHROW( "Element (" << Value() << ") has no attributes" )
+		}
+		else
+		{
+			return 0;
+		}
+	}
+
+	Attribute* temp = new Attribute( attribute );
+	attribute->m_spawnedWrappers.push_back( temp );
+
+	return temp;
+}
+
+Attribute* Element::LastAttribute( bool throwIfNoAttributes ) const
+{
+	ValidatePointer();
+	TiXmlAttribute* attribute = m_tiXmlPointer->LastAttribute();
+	if ( ( 0 == attribute ) && throwIfNoAttributes )
+	{
+		TICPPTHROW( "This Element (" << Value() << ") has no attributes" )
+	}
+
+	if ( 0 == attribute )
+	{
+		if( throwIfNoAttributes )
+		{
+			TICPPTHROW( "Element (" << Value() << ") has no attributes" )
+		}
+		else
+		{
+			return 0;
+		}
+	}
+
+	Attribute* temp = new Attribute( attribute );
+	attribute->m_spawnedWrappers.push_back( temp );
+
+	return temp;
+}
+
+std::string Element::GetAttributeOrDefault( const std::string& name, const std::string& defaultValue ) const
+{
+	std::string value;
+	if ( !GetAttributeImp( name, &value ) )
+	{
+		return defaultValue;
+	}
+	return value;
+}
+
+std::string Element::GetAttribute( const std::string& name ) const
+{
+	return GetAttributeOrDefault( name, std::string() );
+}
+
+bool Element::HasAttribute( const std::string& name ) const
+{
+	ValidatePointer();
+	return ( 0 != m_tiXmlPointer->Attribute( name.c_str() ) );
+}
+
+void Element::RemoveAttribute( const std::string& name )
+{
+	ValidatePointer();
+	m_tiXmlPointer->RemoveAttribute( name.c_str() );
+}
+
+bool Element::GetAttributeImp( const std::string& name, std::string* value ) const
+{
+	ValidatePointer();
+
+	// Get value from TinyXML, if the attribute exists
+	const char* retVal = m_tiXmlPointer->Attribute( name.c_str() );
+
+	// TinyXML returns NULL if the attribute doesn't exist
+	if ( 0 == retVal )
+	{
+		return false;
+	}
+	else
+	{
+		*value = retVal;
+		return true;
+	}
+}
+
+bool Element::GetTextImp( std::string* value ) const
+{
+	ValidatePointer();
+
+	// Get value from TinyXML, if the attribute exists
+	const char* retVal = m_tiXmlPointer->GetText();
+
+	// TinyXML returns NULL if the attribute doesn't exist
+	if ( 0 == retVal )
+	{
+		return false;
+	}
+	else
+	{
+		*value = retVal;
+		return true;
+	}
+}
+
+//*****************************************************************************
+
+Declaration::Declaration()
+: NodeImp< TiXmlDeclaration >( new TiXmlDeclaration() )
+{
+	m_impRC->InitRef();
+}
+
+Declaration::Declaration( TiXmlDeclaration* declaration )
+: NodeImp< TiXmlDeclaration >( declaration )
+{
+}
+
+Declaration::Declaration( const std::string& version, const std::string& encoding, const std::string& standalone )
+: NodeImp< TiXmlDeclaration >( new TiXmlDeclaration( version, encoding, standalone ) )
+{
+	m_impRC->InitRef();
+}
+
+std::string Declaration::Version() const
+{
+	return m_tiXmlPointer->Version();
+}
+
+std::string Declaration::Encoding() const
+{
+	return m_tiXmlPointer->Encoding();
+}
+
+std::string Declaration::Standalone() const
+{
+	return m_tiXmlPointer->Standalone();
+}
+
+//*****************************************************************************
+
+StylesheetReference::StylesheetReference()
+: NodeImp< TiXmlStylesheetReference >( new TiXmlStylesheetReference() )
+{
+	m_impRC->InitRef();
+}
+
+StylesheetReference::StylesheetReference( TiXmlStylesheetReference* stylesheetReference )
+: NodeImp< TiXmlStylesheetReference >( stylesheetReference )
+{
+}
+
+StylesheetReference::StylesheetReference( const std::string& type, const std::string& href )
+: NodeImp< TiXmlStylesheetReference >( new TiXmlStylesheetReference( type, href ) )
+{
+	m_impRC->InitRef();
+}
+
+std::string StylesheetReference::Type() const
+{
+	return m_tiXmlPointer->Type();
+}
+
+std::string StylesheetReference::Href() const
+{
+	return m_tiXmlPointer->Href();
+}
+
+//*****************************************************************************
+
+Exception::Exception(const std::string &details)
+:
+m_details( details )
+{
+
+}
+
+Exception::~Exception() throw()
+{
+}
+
+const char* Exception::what() const throw()
+{
+	return m_details.c_str();
+}
+
+//*****************************************************************************
+
+TiCppRC::TiCppRC()
+{
+	// Spawn reference counter for this object
+	m_tiRC = new TiCppRCImp( this );
+}
+
+void TiCppRC::DeleteSpawnedWrappers()
+{
+	std::vector< Base* >::reverse_iterator wrapper;
+	for ( wrapper = m_spawnedWrappers.rbegin(); wrapper != m_spawnedWrappers.rend(); ++wrapper )
+	{
+		delete *wrapper;
+	}
+	m_spawnedWrappers.clear();
+}
+
+TiCppRC::~TiCppRC()
+{
+	DeleteSpawnedWrappers();
+
+	// Set pointer held by reference counter to NULL
+	this->m_tiRC->Nullify();
+
+	// Decrement reference - so reference counter will delete itself if necessary
+	this->m_tiRC->DecRef();
+}
+
+//*****************************************************************************
+
+TiCppRCImp::TiCppRCImp( TiCppRC* tiCppRC )
+	: m_count( 1 ), m_tiCppRC ( tiCppRC )
+{
+}
+
+void TiCppRCImp::IncRef()
+{
+	m_count++;
+}
+
+void TiCppRCImp::DecRef()
+{
+	m_count--;
+	if ( 0 == m_count )
+	{
+		delete m_tiCppRC;
+		delete this;
+	}
+}
+
+void TiCppRCImp::InitRef()
+{
+	m_count = 1;
+}
+
+void TiCppRCImp::Nullify()
+{
+	m_tiCppRC = 0;
+}
+
+TiCppRC* TiCppRCImp::Get()
+{
+	return m_tiCppRC;
+}
+
+bool TiCppRCImp::IsNull()
+{
+	return 0 == m_tiCppRC;
+}
+
+#endif // TIXML_USE_TICPP
diff -Naur wxFormBuilder.orig/subprojects/ticpp/ticpp.h wxFormBuilder/subprojects/ticpp/ticpp.h
--- wxFormBuilder.orig/subprojects/ticpp/ticpp.h	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/ticpp.h	2019-11-18 10:42:57.710406052 +0100
@@ -0,0 +1,1862 @@
+/*
+http://code.google.com/p/ticpp/
+Copyright (c) 2006 Ryan Pusztai, Ryan Mulder
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+/**
+@copydoc ticpp
+@file
+@author		Ryan Pusztai
+@author		Ryan Mulder
+@date		04/11/2006
+
+@version	0.04a by edam@waxworlds.org: based Exception based on std::exception; added stream
+					<< and >> support; added Document::Parse(); bug fix; improved THROW() macro.
+@version	0.04 Added NodeImp class. Also made all the classes inherit from NodeImp.
+@version	0.03 Added Declaration class
+@version	0.02 Added Element class
+@version	0.01 Added Exception class, Document class
+
+@todo add UNKNOWN support. See ticpp::NodeFactory.
+@todo add TYPECOUNT support. See ticpp::NodeFactory.
+@todo Add a quick reference
+*/
+
+ /*
+ * THIS FILE WAS ALTERED BY Matt Janisz, 12. October 2012.
+ *
+ * - added ticppapi.h include and TICPP_API dll-interface to support building DLL using VS200X
+ */
+
+#ifndef TIXML_USE_TICPP
+	#define TIXML_USE_TICPP
+#endif
+
+#ifndef TICPP_INCLUDED
+#define TICPP_INCLUDED
+
+#include "tinyxml.h"
+
+#include <memory>
+
+/**
+@subpage ticpp is a TinyXML wrapper that uses a lot more C++ ideals.
+It throws exceptions, uses templates, is in its own name space, and
+<b>requires</b> STL (Standard Template Library). This is done to ease the use
+of getting values in and out of the xml.
+
+If you don't perfer to use some of the concepts just don't use it.
+It is just a wrapper that extends TinyXML. It doesn't actually change
+any of TinyXML.
+*/
+namespace ticpp
+{
+    /**
+	This is a ticpp exception class
+	*/
+	class TICPP_API Exception : public std::exception
+	{
+	public:
+		/**
+		Construct an exception with a message
+		*/
+		Exception( const std::string& details );
+		~Exception() throw();
+
+		/// Override std::exception::what() to return m_details
+		const char* what() const throw();
+
+		std::string m_details; /**< Exception Details */
+	};
+
+	/**
+	This allows you to stream your exceptions in.
+	It will take care of the conversion	and throwing the exception.
+	*/
+	#define TICPPTHROW( message ) 											\
+	{																		\
+		std::ostringstream full_message;									\
+		std::string file( __FILE__ );										\
+		file = file.substr( file.find_last_of( "\\/" ) + 1 );				\
+		full_message << message << " <" << file << "@" << __LINE__ << ">";	\
+		full_message << BuildDetailedErrorString();							\
+		throw Exception( full_message.str() );								\
+	}
+
+	// Forward Declarations for Visitor, and others.
+	class TICPP_API Document;
+	class TICPP_API Element;
+	class TICPP_API Declaration;
+	class TICPP_API StylesheetReference;
+	class TICPP_API Text;
+	class TICPP_API Comment;
+	class TICPP_API Attribute;
+
+	/** Wrapper around TiXmlBase */
+	class TICPP_API Base
+	{
+	public:
+
+		/**
+		Converts any class with a proper overload of the << opertor to a std::string
+		@param value The value to be converted
+		@throws Exception When value cannot be converted to a std::string
+		*/
+		template < class T >
+			std::string ToString( const T& value ) const
+		{
+			std::stringstream convert;
+			convert << value;
+			if ( convert.fail() )
+			{
+				TICPPTHROW( "Could not convert value to text" );
+			}
+			return convert.str();
+		}
+
+		std::string ToString( const std::string& value ) const
+		{
+			return value;
+		}
+
+		/**
+		Converts a std::string to any class with a proper overload of the >> opertor
+		@param temp			The string to be converted
+		@param out	[OUT]	The container for the returned value
+		@throws Exception When temp cannot be converted to the target type
+		*/
+		template < class T >
+			void FromString( const std::string& temp, T* out ) const
+		{
+			std::istringstream val( temp );
+			val >> *out;
+
+			if ( val.fail() )
+			{
+				TICPPTHROW( "Could not convert \"" << temp << "\" to target type" );
+			}
+		}
+
+		/**
+		Specialization for std::string
+		*/
+		void FromString( const std::string& temp, std::string* out ) const
+		{
+			*out = temp;
+		}
+
+		/**
+		Return the position, in the original source file, of this node or attribute.
+		Wrapper around TiXmlBase::Row()
+		*/
+		int Row() const
+		{
+			return GetBasePointer()->Row();
+		}
+
+		/**
+		Return the position, in the original source file, of this node or attribute.
+		Wrapper around TiXmlBase::Row()
+		*/
+		int Column() const
+		{
+			return GetBasePointer()->Column();
+		}
+
+		/**
+		Compare internal TiXml pointers to determine is both are wrappers around the same node
+		*/
+		bool operator == ( const Base& rhs ) const
+		{
+			return ( GetBasePointer() == rhs.GetBasePointer() );
+		}
+
+		/**
+		Compare internal TiXml pointers to determine is both are wrappers around the same node
+		*/
+		bool operator != ( const Base& rhs ) const
+		{
+			return ( GetBasePointer() != rhs.GetBasePointer() );
+		}
+
+		/**
+		Builds detailed error string using TiXmlDocument::Error() and others
+		*/
+		std::string BuildDetailedErrorString() const
+		{
+			std::ostringstream full_message;
+			#ifndef TICPP_NO_RTTI
+			TiXmlNode* node = dynamic_cast< TiXmlNode* >( GetBasePointer() );
+			if ( node != 0 )
+			{
+				TiXmlDocument* doc = node->GetDocument();
+				if ( doc != 0 )
+				{
+					if ( doc->Error() )
+					{
+						full_message 	<< "\nDescription: " << doc->ErrorDesc()
+										<< "\nFile: " << (strlen( doc->Value() ) > 0 ? doc->Value() : "<unnamed-file>")
+										<< "\nLine: " << doc->ErrorRow()
+										<< "\nColumn: " << doc->ErrorCol();
+					}
+				}
+			}
+			#endif
+			return full_message.str();
+		}
+
+		/**
+		Destructor
+		*/
+		virtual ~Base()
+		{
+		}
+
+	protected:
+		mutable TiCppRCImp* m_impRC;	/**< Holds status of internal TiXmlPointer - use this to determine if object has been deleted already */
+
+		/**
+		@internal
+		Updates the pointer to the reference counter to point at the counter in the new node.
+
+		@param node TiXmlBase containing the new reference counter
+		*/
+		void SetImpRC( TiXmlBase* node )
+		{
+			m_impRC = node->m_tiRC;
+		}
+
+		void ValidatePointer() const
+		{
+			if ( m_impRC->IsNull() )
+			{
+				TICPPTHROW( "Internal TiXml Pointer is NULL" );
+			}
+		}
+
+		/**
+		@internal
+		Get internal TiXmlBase*
+		*/
+		virtual TiXmlBase* GetBasePointer() const = 0;
+	};
+
+	/**
+	Wrapper around TiXmlAttribute
+	*/
+	class TICPP_API Attribute : public Base
+	{
+	private:
+		TiXmlAttribute* m_tiXmlPointer;
+		TiXmlBase* GetBasePointer() const
+		{
+			ValidatePointer();
+			return m_tiXmlPointer;
+		}
+
+	public:
+		/**
+		Construct an empty attribute.
+		*/
+		Attribute();
+
+		/**
+		Construct an attribute with @a name and @a value
+
+		@param name The name of the attribute
+		@param value The value of the attribute
+		*/
+		Attribute( const std::string& name, const std::string& value );
+
+		/**
+		@internal
+		Construct an attribute with the internal pointer
+
+		@param attribute The internal pointer
+		*/
+		Attribute( TiXmlAttribute* attribute );
+
+		/**
+		Get the value of this attribute
+		Uses Base::FromString to convert TiXmlAttribute::ValueStr from a std::string,
+		and puts it in the passed pointer.
+
+		@param value [OUT] A pointer to fill with the value
+		*/
+		template < class T >
+			void GetValue( T* value ) const
+		{
+			ValidatePointer();
+			FromString( m_tiXmlPointer->ValueStr(), value );
+		}
+
+		/**
+		Get the value of this attribute.
+		Simple wrapper for TiXmlAttribute::ValueStr.
+
+		@see GetValue
+		*/
+		std::string Value() const;
+
+		/**
+		Set the value of this node.
+		Uses Base::ToString to convert value to a std::string, then calls TiXmlAttribute::SetValue.
+
+		@param value The value to set
+		*/
+		template < class T >
+			void SetValue( const T& value )
+		{
+			ValidatePointer();
+			m_tiXmlPointer->SetValue( ToString( value ) );
+		}
+
+		/**
+		Get the value of this attribute
+		Uses Base::FromString to convert TiXmlAttribute::Name from a std::string,
+		and puts it in the passed pointer.
+
+		@param name [OUT] A pointer to fill with the name
+		*/
+		template < class T >
+			void GetName( T* name ) const
+		{
+			ValidatePointer();
+			FromString( m_tiXmlPointer->Name(), name );
+		}
+
+		/**
+		Get the value of this attribute.
+		Simple wrapper for TiXmlAttribute::Name.
+
+		@see GetName
+		*/
+		std::string Name() const;
+
+		/**
+		Set the value of this attribute.
+		Uses Base::ToString to convert @a name to a std::string, then calls TiXmlAttribute::SetName.
+
+		@param name The name to set
+		*/
+		template < class T >
+			void SetName( const T& name )
+		{
+			ValidatePointer();
+			m_tiXmlPointer->SetName( ToString( name ) );
+		}
+
+		/**
+		@internal
+		Updates the reference count for the old and new pointers.
+		*/
+		void operator=( const Attribute& copy );
+
+		Attribute( const Attribute& copy ) = delete;
+
+		/*
+		Decrements reference count.
+		*/
+		~Attribute();
+
+		/**
+		Get the next sibling attribute in the DOM.
+		*/
+		Attribute* Next( bool throwIfNoAttribute = true ) const;
+
+		/**
+		Get the previous sibling attribute in the DOM.
+		*/
+		Attribute* Previous( bool throwIfNoAttribute = true ) const;
+
+		/**
+		@internal
+		Just for Iterator<>
+
+		@param next [OUT] The pointer to the next valid attribute
+		@return true if there is a next attribute, false if not
+		*/
+		void IterateNext( const std::string&, Attribute** next ) const;
+
+		/**
+		@internal
+		Just for Iterator<>
+
+		@param previous [OUT] The pointer to the previous valid attribute
+		@return true if there is a previous attribute, false if not
+		*/
+		void IteratePrevious( const std::string&, Attribute** previous ) const;
+
+		/**
+		All TinyXml classes can print themselves to a filestream.
+		*/
+		virtual void Print( FILE* file, int depth ) const;
+
+	private:
+
+		/**
+		@internal
+		Sets the internal pointer.
+		Saves a copy of the pointer to the RC object.
+
+		@param newPointer TiXmlAttribute* to set.
+		*/
+		void SetTiXmlPointer( TiXmlAttribute* newPointer );
+	};
+
+	/**
+	Wrapper around TiXmlNode
+	*/
+	class TICPP_API Node : public Base
+	{
+	public:
+
+		/**
+		Get the value of this node
+		Uses Base::FromString to convert TiXmlNode::ValueStr from a std::string,
+		and puts it in the passed pointer.
+
+		@param value [OUT] A pointer to fill with the value
+		*/
+		template < class T >
+			void GetValue( T* value) const
+		{
+			FromString( GetTiXmlPointer()->ValueStr(), value );
+		}
+
+		/**
+		Get the value of this node.
+		Simple wrapper for TiXmlNode::ValueStr.
+
+		@see GetValue
+		*/
+		std::string Value() const;
+
+		/**
+		Set the value of this node.
+		Uses Base::ToString to convert value to a std::string, then calls TiXmlNode::SetValue.
+
+		@param value The value to set
+		*/
+		template < class T >
+			void SetValue( const T& value )
+		{
+			GetTiXmlPointer()->SetValue( ToString( value ) );
+		}
+
+		/**
+		Clear all Nodes below this.
+		Simple wrapper for TiXmlNode::Clear.
+		*/
+		void Clear();
+
+		/**
+		The Parent of this Node.
+		Simple wrapper for TiXmlNode::Parent.
+
+		@param throwIfNoParent [DEF] If true, throws when Parent = NULL.
+		@return The parent of this node, NULL if there is no Parent.
+		@throws Exception When throwIfNoParent is true, and TiXmlNode::Parent returns Null.
+		*/
+		Node* Parent( bool throwIfNoParent = true ) const;
+
+		/**
+		The first child of this node.
+
+		@param throwIfNoChildren [DEF] If true, will throw an exception if there are no children.
+		@return Pointer to child, Null if no children and 'throwIfNoChildren' is false.
+		@throws Exception When throwIfNoChildren is true, and TiXmlNode::FirstChild returns Null.
+
+		@see TiXmlNode::FirstChild
+		*/
+		Node* FirstChild( bool throwIfNoChildren = true ) const;
+
+		/**
+		@internal
+		The first child of this node with the matching @a value.
+
+		@overload
+		@param value				Value to match.
+		@param throwIfNoChildren	[DEF] If true, will throw an exception if there are no children.
+
+		@see FirstChild( bool throwIfNoChildren = true )
+		*/
+		Node* FirstChild( const char* value, bool throwIfNoChildren = true ) const;
+
+		/**
+		The first child of this node with the matching @a value.
+
+		@overload
+		@param value				Value to match.
+		@param throwIfNoChildren	[DEF] If true, will throw an exception if there are no children.
+
+		@see FirstChild( const char* value, bool throwIfNoChildren = true )
+		*/
+		Node* FirstChild( const std::string& value, bool throwIfNoChildren = true ) const;
+
+		/**
+		The last child of this node.
+
+		@param throwIfNoChildren [DEF] If true, will throw an exception if there are no children.
+		@return Pointer to child, Null if no children and 'throwIfNoChildren' is false.
+		@throws Exception When throwIfNoChildren is true, and TiXmlNode::LastChild returns Null.
+
+		@see TiXmlNode::LastChild
+		*/
+		Node* LastChild( bool throwIfNoChildren = true ) const;
+
+		/**
+		@internal
+		The last child of this node with the matching @a value.
+
+		@overload
+		@param value				Value to match.
+		@param throwIfNoChildren	[DEF] If true, will throw an exception if there are no children.
+
+		@see LastChild( bool throwIfNoChildren = true )
+		*/
+		Node* LastChild( const char* value, bool throwIfNoChildren = true ) const;
+
+		/**
+		The last child of this node with the matching @a value.
+
+		@overload
+		@param value				Value to match.
+		@param throwIfNoChildren	[DEF] If true, will throw an exception if there are no children.
+
+		@see LastChild( const char* value, bool throwIfNoChildren = true )
+		*/
+		Node* LastChild( const std::string& value, bool throwIfNoChildren = true ) const;
+
+		/**
+		An alternate way to walk the children of a node.
+		Simple wrapper for TiXmlNode::IterateChildren.
+
+		@param previous The previous Node* that was returned from IterateChildren.
+		@return NULL When there are no more children.
+		*/
+		Node* IterateChildren( Node* previous ) const;
+
+		/**
+		This flavor of IterateChildren searches for children with a particular @a value.
+		Simple wrapper for TiXmlNode::IterateChildren.
+
+		@param value	The value you want to search for.
+		@param previous The previous Node* that was returned from IterateChildren.
+		@return NULL When there are no more children.
+		*/
+		Node* IterateChildren( const std::string& value, Node* previous ) const;
+
+		/**
+		Adds a child past the LastChild.
+		Throws if you try to insert a document.
+
+		@note This takes a copy of @a addThis so it is not as efficiant as LinkEndChild.
+		@param addThis Node to insert.
+		@throws Exception When TiXmlNode::InsertEndChild returns Null
+
+		@see LinkEndChild
+		@see TiXmlNode::InsertEndChild
+		*/
+		Node* InsertEndChild( const Node& addThis );
+
+		/**
+		Adds a child past the LastChild.
+		Throws if you try to link a document.
+
+		@param childNode Node to link.
+		@throws Exception When TiXmlNode::LinkEndChild returns Null.
+
+		@see InsertEndChild
+		@see TiXmlNode::LinkEndChild
+		*/
+		Node* LinkEndChild( Node* childNode );
+
+		/**
+		Adds a child before the specified child.
+		Throws if you try to insert a document.
+
+		@param beforeThis	Node that will have @a addThis linked before.
+		@param addThis		Node to insert before.
+		@throws Exception When TiXmlNode::InsertBeforeChild returns Null.
+
+		@see InsertAfterChild
+		@see TiXmlNode::InsertBeforeChild
+		*/
+		Node* InsertBeforeChild( Node* beforeThis, const Node& addThis );
+
+		/**
+		Adds a child after the specified child.
+		Throws if you try to insert a document.
+
+		@param afterThis	Node that will have @a addThis linked after.
+		@param addThis		Node to insert after.
+		@throws Exception When TiXmlNode::InsertAfterChild returns Null.
+
+		@see InsertBeforeChild
+		@see TiXmlNode::InsertAfterChild
+		*/
+		Node* InsertAfterChild( Node* afterThis, const Node& addThis );
+
+		/**
+		Replace a child of this node.
+		Throws if you try to replace with a document.
+
+		@param replaceThis	Node to replace.
+		@param withThis		Node that is replacing @a replaceThis.
+		@throws Exception When TiXmlNode::ReplaceChild returns Null.
+
+		@see TiXmlNode::ReplaceChild
+		*/
+		Node* ReplaceChild( Node* replaceThis, const Node& withThis );
+
+		/**
+		Delete a child of this node.
+
+		@param removeThis Node to delete.
+		@throws Exception When removeThis is not a child of this Node.
+
+		@see TiXmlNode::RemoveChild
+		*/
+		void RemoveChild( Node* removeThis );
+
+		/**
+		Navigate to a sibling node.
+		Wrapper around TiXmlNode::PreviousSibling.
+
+		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no siblings.
+		@return Pointer to sibling, Null if no siblings and 'throwIfNoSiblings' is false.
+		@throws Exception When TiXmlNode::PreviousSibling returns Null and 'throwIfNoSiblings' is true.
+		*/
+		Node* PreviousSibling( bool throwIfNoSiblings = true ) const;
+
+		/**
+		Navigate to a sibling node with the given @a value.
+
+		@overload
+		@param value The value of the node to look for.
+		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no siblings.
+
+		@see PreviousSibling( bool throwIfNoSiblings )
+		*/
+		Node* PreviousSibling( const std::string& value, bool throwIfNoSiblings = true ) const;
+
+		/**
+		@internal
+		Navigate to a sibling node with the given @a value.
+
+		@overload
+		@param value The value of the node to look for.
+		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no siblings.
+
+		@see PreviousSibling( const std::string& value, bool throwIfNoSiblings )
+		*/
+		Node* PreviousSibling( const char* value, bool throwIfNoSiblings = true ) const;
+
+		/**
+		Navigate to a sibling node.
+		Wrapper around TiXmlNode::NextSibling.
+
+		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no siblings.
+		@return Pointer to sibling, Null if no siblings and 'throwIfNoSiblings' is false.
+		@throws Exception When TiXmlNode::NextSibling returns Null and 'throwIfNoSiblings' is true.
+		*/
+		Node* NextSibling( bool throwIfNoSiblings = true ) const;
+
+		/**
+		Navigate to a sibling node with the given @a value.
+
+		@overload
+		@param value The value of the node to look for.
+		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no siblings.
+
+		@see NextSibling( bool throwIfNoSiblings )
+		*/
+		Node* NextSibling( const std::string& value, bool throwIfNoSiblings = true ) const;
+
+		/**
+		@internal
+		Navigate to a sibling node with the given @a value.
+
+		@overload
+		@param value The value of the node to look for.
+		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no siblings.
+
+		@see NextSibling( const std::string& value, bool throwIfNoSiblings )
+		*/
+		Node* NextSibling( const char* value, bool throwIfNoSiblings = true ) const;
+
+		/**
+		@internal
+		Just for Iterator<>
+
+		@param value The value of nodes to iterate through
+		@param next [OUT] The pointer to the first valid node
+		*/
+		template < class T >
+			void IterateFirst( const std::string& value, T** first ) const
+		{
+			*first = 0;
+			for( Node* child = FirstChild( value, false ); child; child = child->NextSibling( value, false ) )
+			{
+				*first = dynamic_cast< T* >( child );
+				if ( 0 != *first )
+				{
+					return;
+				}
+			}
+		}
+
+		virtual	void IterateFirst( const std::string&, Attribute** ) const
+		{
+			TICPPTHROW( "Attributes can only be iterated with Elements." )
+		}
+
+		/**
+		@internal
+		Just for Iterator<>
+
+		@param value The value of nodes to iterate through
+		@param next [OUT] The pointer to the next valid node
+		*/
+		template < class T >
+			void IterateNext( const std::string& value, T** next ) const
+		{
+			Node* sibling = NextSibling( value, false );
+			*next = dynamic_cast< T* >( sibling );
+
+			while ( ( 0 != sibling ) && ( 0 == *next ) )
+			{
+				sibling = sibling->NextSibling( value, false );
+				*next = dynamic_cast< T* >( sibling );
+			}
+		}
+
+		/**
+		@internal
+		Just for Iterator<>
+
+		@param value The value of nodes to iterate through
+		@param previous [OUT] The pointer to the previous valid node
+		*/
+		template < class T >
+			void IteratePrevious( const std::string& value, T** previous  ) const
+		{
+			Node* sibling = PreviousSibling( value, false );
+			*previous = dynamic_cast< T* >( sibling );
+
+			while ( ( 0 != sibling ) && ( 0 == *previous ) )
+			{
+				sibling = sibling->PreviousSibling( value, false );
+				*previous = dynamic_cast< T* >( sibling );
+			}
+		}
+
+		/**
+		Navigate to a sibling element.
+		Wrapper around TiXmlNode::NextSibling.
+
+		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no sibling element.
+		@return Pointer to sibling, Null if no siblings and 'throwIfNoSiblings' is false.
+		@throws Exception When TiXmlNode::NextSibling returns Null and 'throwIfNoSiblings' is true.
+		*/
+		Element* NextSiblingElement( bool throwIfNoSiblings = true ) const;
+
+		/**
+		Navigate to a sibling element with the given @a value.
+
+		@overload
+		@param value The value of the element to look for.
+		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no sibling elements.
+		@see NextSiblingElement( bool throwIfNoSiblings )
+		*/
+		Element* NextSiblingElement( const std::string& value, bool throwIfNoSiblings = true ) const;
+
+		/**
+		@internal
+		Navigate to a sibling element with the given @a value.
+
+		@overload
+		@param value The value of the element to look for.
+		@param throwIfNoSiblings [DEF] If true, will throw an exception if there are no sibling elements.
+
+		@see NextSiblingElement( const std::string& value, bool throwIfNoSiblings )
+		*/
+		Element* NextSiblingElement( const char* value, bool throwIfNoSiblings = true ) const;
+
+		/**
+		The first child element of this node.
+
+		@param throwIfNoChildren [DEF] If true, will throw an exception if there are no element children.
+		@return Pointer to child, Null if no element children and 'throwIfNoChildren' is false.
+		@throws Exception When throwIfNoChildren is true, and TiXmlNode::FirstChildElement returns Null.
+
+		@see TiXmlNode::FirstChildElement
+		*/
+		Element* FirstChildElement( bool throwIfNoChildren = true ) const;
+
+		/**
+		@internal
+		The first child element of this node with the matching @a value.
+
+		@overload
+		@param value Value to match.
+		@param throwIfNoChildren [DEF] If true, will throw an exception if there are no element children.
+
+		@see FirstChildElement( bool throwIfNoChildren = true )
+		*/
+		Element* FirstChildElement( const char* value, bool throwIfNoChildren = true ) const;
+
+		/**
+		The first child element of this node with the matching @a value.
+
+		@overload
+		@param value Value to match.
+		@param throwIfNoChildren [DEF] If true, will throw an exception if there are no element children.
+
+		@see FirstChildElement( const char* value, bool throwIfNoChildren = true )
+		*/
+		Element* FirstChildElement( const std::string& value, bool throwIfNoChildren = true ) const;
+
+		/**
+		Query the type (as TiXmlNode::NodeType ) of this node.
+		*/
+		int Type() const;
+
+		/**
+		Return a pointer to the Document this node lives in.
+
+		@param throwIfNoDocument [DEF] If true, will throw an exception if this node is not linked under a Document.
+		@return A pointer to the Document this node lives in, NULL if not linked under a Document, and 'throwIfNoDocument' is false.
+		@throws Exception When this node is not linked under a Document and 'throwIfNoDocument' is true.
+		*/
+		Document* GetDocument( bool throwIfNoDocument = true ) const;
+
+		/**
+		Check if this node has no children.
+
+		@return true if this node has no children.
+		*/
+		bool NoChildren() const;
+
+		#ifndef TICPP_NO_RTTI
+		/**
+		Pointer conversion ( NOT OBJECT CONVERSION ) - replaces TiXmlNode::ToElement, TiXmlNode::ToDocument, TiXmlNode::ToComment, etc.
+
+		@throws Exception When the target is not an object of class T
+		@warning Some ancient compilers do not support explicit specification of member template arguments, which this depends on ( e.g. VC6 ).
+		*/
+		template < class T >
+			T* To() const
+		{
+			T* pointer = dynamic_cast< T* >( this );
+			if ( 0 == pointer )
+			{
+				std::string thisType = typeid( this ).name();
+				std::string targetType = typeid( T ).name();
+				std::string thatType = typeid( *this ).name();
+				TICPPTHROW( "The " << thisType.substr( 6 ) << " could not be casted to a " << targetType.substr( 6 )
+					<< " *, because the target object is not a " << targetType.substr( 6 ) << ". (It is a " << thatType.substr( 6 ) << ")" );
+			}
+			return pointer;
+		}
+		#endif
+
+		/**
+		Pointer conversion - replaces TiXmlNode::ToDocument.
+
+		@throws Exception When this node is not a Document.
+		*/
+		Document* ToDocument() const;
+
+		/**
+		Pointer conversion - replaces TiXmlNode::ToElement.
+
+		@throws Exception When this node is not a Element.
+		*/
+		Element* ToElement() const;
+
+		/**
+		Pointer conversion - replaces TiXmlNode::ToComment.
+
+		@throws Exception When this node is not a Comment.
+		*/
+		Comment* ToComment() const;
+
+		/**
+		Pointer conversion - replaces TiXmlNode::ToText.
+
+		@throws Exception When this node is not a Text.
+		*/
+		Text* ToText() const;
+
+		/**
+		Pointer conversion - replaces TiXmlNode::ToDeclaration.
+
+		@throws Exception When this node is not a Declaration.
+		*/
+		Declaration* ToDeclaration() const;
+
+		/**
+		Pointer conversion - replaces TiXmlNode::ToStylesheetReference.
+
+		@throws Exception When this node is not a StylesheetReference.
+		*/
+		StylesheetReference* ToStylesheetReference() const;
+
+		/**
+		Create an exact duplicate of this node and return it.
+
+		@note Using unique_ptr to manage the memory declared on the heap by TiXmlNode::Clone.
+		@code
+		// Now using clone
+		ticpp::Document doc( "C:\\Test.xml" );
+		ticpp::Node* sectionToClone;
+		sectionToClone = doc.FirstChild( "settings" );
+		std::unique_ptr< ticpp::Node > clonedNode = sectionToClone->Clone();
+		// Now you can use the clone.
+		ticpp::Node* node2 = clonedNode->FirstChildElement()->FirstChild();
+		...
+		// After the variable clonedNode goes out of scope it will automatically be cleaned up.
+		@endcode
+		@return Pointer the duplicate node.
+		*/
+		std::unique_ptr< Node > Clone() const;
+
+		/**
+		Accept a hierchical visit the nodes in the TinyXML DOM.
+		@return The boolean returned by the visitor.
+		*/
+		bool Accept( TiXmlVisitor* visitor ) const;
+
+		/**
+ 		Stream input operator.
+ 		*/
+ 		friend std::istream& operator >>( std::istream& in, Node& base )
+ 		{
+ 			in >> *base.GetTiXmlPointer();
+ 			return in;
+ 		}
+
+ 		/**
+ 		Stream output operator.
+ 		*/
+ 		friend std::ostream& operator <<( std::ostream& out, const Node& base )
+ 		{
+ 			out << *base.GetTiXmlPointer();
+ 			return out;
+ 		}
+
+	protected:
+		/**
+		@internal
+		Allows NodeImp to use Node*'s.
+		*/
+		virtual TiXmlNode* GetTiXmlPointer() const = 0;
+
+		TiXmlBase* GetBasePointer() const
+		{
+			return GetTiXmlPointer();
+		}
+
+		/**
+		@internal
+		Constructs the correct child of Node, based on the Type of the TiXmlNode*.
+		*/
+		Node* NodeFactory( TiXmlNode* tiXmlNode, bool throwIfNull = true, bool rememberSpawnedWrapper = true ) const;
+
+	};
+
+	/** Iterator for conveniently stepping through Nodes and Attributes.
+	TinyXML++ introduces iterators:
+	@code
+	ticpp::Iterator< ticpp::Node > child;
+	for ( child = child.begin( parent ); child != child.end(); child++ )
+	@endcode
+
+	Iterators have the added advantage of filtering by type:
+	@code
+	// Only iterates through Comment nodes
+	ticpp::Iterator< ticpp::Comment > child;
+	for ( child = child.begin( parent ); child != child.end(); child++ )
+	@endcode
+
+	@code
+	// Only iterates through Element nodes with value "ElementValue"
+	ticpp::Iterator< ticpp::Element > child( "ElementValue" );
+	for ( child = child.begin( parent ); child != child.end(); child++ )
+	@endcode
+
+	Finally, Iterators also work with Attributes
+	@code
+	ticpp::Iterator< ticpp::Attribute > attribute;
+	for ( attribute = attribute.begin( element ); attribute != attribute.end(); attribute++ )
+	@endcode
+	*/
+	template < class T = Node >
+		class Iterator
+	{
+	private:
+		T* m_p;					/**< Internal Pointer */
+		std::string m_value;	/**< Value for NextSibling  calls */
+
+	public:
+
+		/**
+		For for loop comparisons.
+		@param parent The parent of the nodes to iterate.
+		@return The first child of type T.
+		@code
+		ticpp::Iterator< ticpp::Node > child;
+		for ( child = child.begin( parent ); child != child.end(); child++ )
+		@endcode
+		*/
+		T* begin( const Node* parent ) const
+		{
+			T* pointer;
+			parent->IterateFirst( m_value, &pointer );
+			return pointer;
+		}
+
+		/**
+		For for loop comparisons.
+		@return NULL
+		@code
+		ticpp::Iterator< ticpp::Node > child;
+		for ( child = child.begin( parent ); child != child.end(); child++ )
+		@endcode
+		*/
+		T* end() const
+		{
+			return 0;
+		}
+
+		/** Constructor.
+		@param value If not empty, this iterator will only visit nodes with matching value.
+		@code
+		// Only iterates through Element nodes with value "ElementValue"
+		ticpp::Iterator< ticpp::Element > child( "ElementValue" );
+		for ( child = child.begin( parent ); child != child.end(); child++ )
+		@endcode
+		*/
+		Iterator( const std::string& value = "" )
+			: m_p( 0 ), m_value( value )
+		{
+		}
+
+		/// Constructor
+		Iterator( T* node, const std::string& value = "" )
+			: m_p( node ), m_value( value )
+		{
+		}
+
+		/// Constructor
+		Iterator( const Iterator& it )
+			: m_p( it.m_p ), m_value( it.m_value )
+		{
+		}
+
+		/**
+		Gets internal pointer.
+		@return The internal pointer.
+		*/
+		T* Get() const
+		{
+			return m_p;
+		}
+
+		/** Sets internal pointer */
+		Iterator& operator=( const Iterator& it )
+		{
+			m_p = it.m_p;
+			m_value = it.m_value;
+			return *this;
+		}
+
+		/** Sets internal pointer */
+		Iterator& operator=( T* p )
+		{
+			m_p = p;
+			return *this;
+		}
+
+		/** Sets internal pointer to the Next Sibling, or Iterator::END, if there are no more siblings */
+		Iterator& operator++()
+		{
+			m_p->IterateNext( m_value, &m_p );
+			return *this;
+		}
+
+		/** Sets internal pointer to the Next Sibling, or Iterator::END, if there are no more siblings */
+		Iterator operator++(int)
+		{
+			Iterator tmp(*this);
+			++(*this);
+			return tmp;
+		}
+
+		/** Sets internal pointer to the Previous Sibling, or Iterator::END, if there are no prior siblings */
+		Iterator& operator--()
+		{
+			m_p->IteratePrevious( m_value, &m_p );
+			return *this;
+		}
+
+		/** Sets internal pointer to the Previous Sibling, or Iterator::END, if there are no prior siblings */
+		Iterator operator--(int)
+		{
+			Iterator tmp(*this);
+			--(*this);
+			return tmp;
+		}
+
+		/** Compares internal pointer */
+		bool operator!=( const T* p ) const
+		{
+			if ( m_p == p )
+			{
+				return false;
+			}
+			if ( 0 == m_p || 0 == p )
+			{
+				return true;
+			}
+			return *m_p != *p;
+		}
+
+		/** Compares internal pointer */
+		bool operator!=( const Iterator& it ) const
+		{
+			return operator!=( it.m_p );
+		}
+
+		/** Compares internal pointer* */
+		bool operator==( T* p ) const
+		{
+			if ( m_p == p )
+			{
+				return true;
+			}
+			if ( 0 == m_p || 0 == p )
+			{
+				return false;
+			}
+			return *m_p == *p;
+		}
+
+		/** Compares internal pointer */
+		bool operator==( const Iterator& it ) const
+		{
+			return operator==( it.m_p );
+		}
+
+		/** So Iterator behaves like a STL iterator */
+		T* operator->() const
+		{
+			return m_p;
+		}
+
+		/** So Iterator behaves like a STL iterator */
+		T& operator*() const
+		{
+			return *m_p;
+		}
+	};
+
+	/** Implementation of Node wrapper */
+	template < class T >
+		class NodeImp : public Node
+	{
+	protected:
+
+		T* m_tiXmlPointer;		/**< Internal pointer to the TiXml Class which is being wrapped */
+
+		/**
+		@internal
+		Gets the internal TinyXML pointer.
+
+		@returns The internal TiXmlNode*.
+		*/
+		TiXmlNode* GetTiXmlPointer() const
+		{
+			ValidatePointer();
+			return m_tiXmlPointer;
+		}
+
+		/**
+		@internal
+		Sets the internal pointer.
+		Saves a copy of the pointer to the RC object.
+
+		@param newPointer TiXmlNode* to set.
+		*/
+		void SetTiXmlPointer( T* newPointer )
+		{
+			m_tiXmlPointer = newPointer;
+			SetImpRC( newPointer );
+		}
+
+		/**
+		@internal
+		Constructor used by child classes.
+		*/
+		NodeImp( T* tiXmlPointer )
+		{
+			// Check for NULL pointers
+			if ( 0 == tiXmlPointer )
+			{
+				#ifdef TICPP_NO_RTTI
+					TICPPTHROW( "Can not create TinyXML objext" );
+				#else
+					TICPPTHROW( "Can not create a " << typeid( T ).name() );
+				#endif
+			}
+			SetTiXmlPointer( tiXmlPointer );
+			m_impRC->IncRef();
+		}
+
+		/**
+		@internal
+		Updates the reference count for the old and new pointers.
+		In addition, the spawnedWrappers must be cleared out before a new TiXml object is loaded in.
+		*/
+		virtual void operator=( const NodeImp<T>& copy )
+		{
+			// Dropping the reference to the old object
+			this->m_impRC->DecRef();
+
+			// Pointing to the new Object
+			SetTiXmlPointer( copy.m_tiXmlPointer );
+
+			// The internal tixml pointer changed in the above line
+			this->m_impRC->IncRef();
+		}
+
+		/**
+		@internal
+		Updates the reference count for the old and new pointers.
+		In addition, the spawnedWrappers must be cleared out before a new TiXml object is loaded in
+		*/
+		NodeImp( const NodeImp<T>& copy ) : Node( copy )
+		{
+			// Pointing to the new Object
+			SetTiXmlPointer( copy.m_tiXmlPointer );
+
+			// The internal tixml pointer changed in the above line
+			this->m_impRC->IncRef();
+		}
+
+	public:
+
+		/*
+		Deletes the spawned wrapper objects.
+		Decrements reference count.
+		*/
+		virtual ~NodeImp()
+		{
+			m_impRC->DecRef();
+		}
+	};
+
+	/** Wrapper around TiXmlComment */
+	class TICPP_API Comment : public NodeImp< TiXmlComment >
+	{
+	public:
+
+		/**
+		Constructor.
+		*/
+		Comment();
+
+		/**
+		Constructor.
+		*/
+		Comment( TiXmlComment* comment );
+
+		/**
+		Constructor.
+		*/
+		Comment( const std::string& comment );
+	};
+
+	/** Wrapper around TiXmlText */
+	class TICPP_API Text : public NodeImp< TiXmlText >
+	{
+	public:
+
+		/**
+		Constructor.
+		*/
+		Text();
+
+		/**
+		Constructor.
+		@overload
+		*/
+		Text( TiXmlText* text );
+
+		/**
+		Constructor.
+		@overload
+		*/
+		Text( const std::string& value );
+
+		/**
+		Streams value into a string and creates a Text with it.
+		Uses ToString to covert the parameter to a string.
+
+		@param value The value of the Text node.
+		@throws Exception
+
+		@see TiXmlText
+        */
+		template < class T >
+			Text( const T& value )
+				: NodeImp< TiXmlText >( new TiXmlText( ToString( value ) ) )
+		{
+			m_impRC->InitRef();
+		}
+	};
+
+	/** Wrapper around TiXmlDocument */
+	class TICPP_API Document : public NodeImp< TiXmlDocument >
+	{
+	public:
+		/**
+		Default	Constructor.
+		Create an empty document, that has no name.
+		*/
+		Document();
+
+		/**
+		Constructor.
+		*/
+		Document( TiXmlDocument* document );
+
+		/**
+		Constructor.
+		*/
+		Document( const char* documentName );
+
+		/**
+		 * Constructor.
+		 * Create a document with a name. The name of the document is also the filename of the xml.
+		 * @param documentName Name to set in the Document.
+		 * @note LoadFile() needs to be called to actually load the data from the file specified by documentName
+		 * 		 SaveFile() needs to be called to save data to file specified by documentName.
+		 */
+		Document( const std::string& documentName );
+
+		/**
+		Load a file using the current document value. Throws if load is unsuccessful.
+
+		@param encoding Sets the documents encoding.
+		@see TiXmlEncoding
+		@throws Exception
+		*/
+		void LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+
+		/**
+		Save a file using the current document value. Throws if it can't save the file.
+
+		@throws Exception
+		*/
+		void SaveFile() const;
+
+		/**
+		Load a file using the given filename. Throws if load is unsuccessful.
+
+		@param filename File to load.
+		@param encoding Sets the documents encoding.
+		@see TiXmlEncoding
+		@throws Exception
+		*/
+		void LoadFile( const std::string& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+
+		/**
+		@copydoc Document::LoadFile( const std::string&, TiXmlEncoding )
+		*/
+		void LoadFile( const char* filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+
+		/**
+		Save a file using the given filename. Throws if it can't save the file.
+
+		@param filename File to save.
+		@throws Exception
+		*/
+		void SaveFile( const std::string& filename ) const;
+
+		/**
+		Parse the given xml data.
+
+		@param xml Xml to parse.
+		@param throwIfParseError [DEF] If true, throws when there is a parse error.
+		@param encoding Sets the documents encoding.
+		@throws Exception
+		*/
+		void Parse( const std::string& xml, bool throwIfParseError = true, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	};
+
+	/** Wrapper around TiXmlElement */
+	class TICPP_API Element : public NodeImp< TiXmlElement >
+	{
+	public:
+		/**
+		Default Constructor.
+		*/
+		Element();
+
+		/**
+		Default	Constructor. Initializes all the variables.
+		@param value The value of the element.
+		*/
+		Element( const std::string& value );
+
+		/**
+		Default	Constructor. Initializes all the variables.
+		@param value The value of the element.
+		*/
+		Element( const char* value );
+
+		/**
+		Constructor.
+		*/
+		Element( TiXmlElement* element );
+
+		/**
+		Constructor that allows you to set the element text
+		@param value The value of the element.
+		@param text The text to set.
+		*/
+		template < class T >
+			Element( const std::string& value, const T& text )
+			: NodeImp< TiXmlElement >( new TiXmlElement( value ) )
+		{
+			m_impRC->InitRef();
+			SetText( text );
+		}
+
+		/**
+		Access the first attribute in this element.
+
+		@param throwIfNoAttributes [DEF] If true, throws when there are no attributes
+		@return The first attribute, NULL if there are none and @a throwIfNoAttributes is true
+		*/
+		Attribute* FirstAttribute( bool throwIfNoAttributes = true ) const;
+
+		/**
+		Access the last attribute in this element.
+
+		@param throwIfNoAttributes [DEF] If true, throws when there are no attributes
+		@return The last attribute, NULL if there are none and @a throwIfNoAttributes is true
+		*/
+		Attribute* LastAttribute( bool throwIfNoAttributes = true ) const;
+
+		/**
+		@internal
+		Just for Iterator<>
+
+		@param value The value of nodes to iterate through
+		@param next [OUT] The pointer to the first valid node
+		*/
+		void IterateFirst( const std::string&, Attribute** first ) const
+		{
+			*first = 0;
+			for( Attribute* child = FirstAttribute( false ); child; child = child->Next( false ) )
+			{
+				*first = dynamic_cast< Attribute* >( child );
+				if ( 0 != *first )
+				{
+					return;
+				}
+			}
+		}
+
+		/**
+		Sets an attribute of name to a given value.
+		The attribute will be created if it does not exist, or changed if it does.
+		Uses ToString to convert the @a value to a string, so there is no need to use any other SetAttribute methods.
+
+		@see GetAttribute
+		*/
+		template < class T >
+			void SetAttribute ( const std::string& name, const T& value )
+		{
+			ValidatePointer();
+			m_tiXmlPointer->SetAttribute( name, ToString( value ) );
+		}
+
+		/**
+		Gets the text of an Element.
+
+		@param throwIfNotFound	[DEF]	If true, will throw an exception if there is no text in this element
+		@note This only works if the Text is the FirstChild node
+		@throws Exception When there is no text and throwIfNotFound is true
+
+		@see GetText( T* value, bool throwIfNotFound = false )
+		@see GetTextOrDefault
+		@see GetTextOrDefault( T* value, const DefaultT& defaultValue )
+		@see TiXmlElement::GetText
+		*/
+		std::string GetText( bool throwIfNotFound = true ) const
+		{
+			// Get the element's text value as a std::string
+			std::string temp;
+			if ( !GetTextImp( &temp ) )
+			{
+				if ( throwIfNotFound )
+				{
+					TICPPTHROW( "Text does not exists in the current element" );
+				}
+			}
+
+			return temp;
+		}
+
+		/**
+		Gets the text of an Element, if it doesn't exist it will return the defaultValue.
+
+		@param defaultValue			What to put in 'value' if there is no text in this element
+		@note This only works if the Text is the FirstChild node
+
+		@see GetText
+		@see GetText( T* value, bool throwIfNotFound = false )
+		@see GetTextOrDefault( T* value, const DefaultT& defaultValue )
+		@see TiXmlElement::GetText
+		*/
+		std::string GetTextOrDefault( const std::string& defaultValue ) const
+		{
+			// Get the element's text value as a std::string
+			std::string temp;
+			if ( !GetTextImp( &temp ) )
+			{
+				return defaultValue;
+			}
+
+			return temp;
+		}
+
+		/**
+		Gets the text value of an Element, if it doesn't exist it will return the defaultValue.
+		Uses FromString to convert the string to the type of choice
+
+		@param value		[OUT]	The container for the returned value
+		@param defaultValue			What to put in 'value' if there is no text in this element
+		@note This is different than GetText() in that it will covert the text to what ever type you want.
+		@note This only works if the Text is the FirstChild node
+
+		@see GetText
+		@see GetText( T* value, bool throwIfNotFound = false )
+		@see GetTextOrDefault( const std::string& defaultValue )
+		@see TiXmlElement::GetText
+		*/
+		template < class T, class DefaultT >
+			void GetTextOrDefault( T* value, const DefaultT& defaultValue ) const
+		{
+			// Get the element's text value as a std::string
+			std::string temp;
+			if ( !GetTextImp( &temp ) )
+			{
+				// The text value does not exist - set value to the default
+				*value = defaultValue;
+				return;
+			}
+
+			// Stream the value from the string to T
+			FromString( temp, value );
+		}
+
+		/**
+		Gets the text of an Element.
+		Uses FromString to convert the string to the type of choice.
+
+		@param value			[OUT]	The container for the returned value
+		@param throwIfNotFound	[DEF]	If true, will throw an exception if there is no text in this element
+		@note This is different than GetText() in that it will covert the text to what ever type you want
+		@note This only works if the Text is the FirstChild node
+		@throws Exception When there is no text and throwIfNotFound is true
+
+		@see GetText
+		@see GetTextOrDefault
+		@see GetTextOrDefault( T* value, const DefaultT& defaultValue )
+		@see TiXmlElement::GetText
+		*/
+		template< class T >
+			void GetText( T* value, bool throwIfNotFound = true ) const
+		{
+			// Get the element's text value as a std::string
+			std::string temp;
+			if ( !GetTextImp( &temp ) )
+			{
+				if ( throwIfNotFound )
+				{
+					TICPPTHROW( "Text does not exists in the current element" );
+				}
+				else
+				{
+					return;
+				}
+			}
+
+			// Stream the value from the string to T
+			FromString( temp, value );
+		}
+
+		/**
+		Convenience function to set the text of an element.
+		Creates a Text node and inserts it as the first child.
+		Uses ToString to convert the parameter to a string.
+
+		@param value The text to set.
+		*/
+		template < class T >
+			void SetText( const T& value )
+		{
+			ValidatePointer();
+			std::string temp = ToString( value );
+
+			if ( m_tiXmlPointer->NoChildren() )
+			{
+				m_tiXmlPointer->LinkEndChild( new TiXmlText( temp ) );
+			}
+			else
+			{
+				if ( 0 == m_tiXmlPointer->GetText() )
+				{
+					m_tiXmlPointer->InsertBeforeChild( m_tiXmlPointer->FirstChild(), TiXmlText( temp ) );
+				}
+				else
+				{
+					// There already is text, so change it
+					m_tiXmlPointer->FirstChild()->SetValue( temp );
+				}
+			}
+		}
+
+		/**
+		Gets an attribute of @a name from an element, if it doesn't exist it will return the defaultValue.
+		Uses FromString to convert the string to the type of choice.
+
+		@param name			The name of the attribute you are querying.
+		@param value		[OUT] The container for the returned value.
+		@param defaultValue	What to put in @a value if there is no attribute in this element.
+		@throws Exception
+
+		@see GetAttribute
+		*/
+		template < class T, class DefaulT >
+			void GetAttributeOrDefault( const std::string& name, T* value, const DefaulT& defaultValue ) const
+		{
+			// Get the attribute's value as a std::string
+			std::string temp;
+			if ( !GetAttributeImp( name, &temp ) )
+			{
+				// The attribute does not exist - set value to the default
+				*value = defaultValue;
+				return;
+			}
+
+			// Stream the value from the string to T
+			FromString( temp, value );
+		}
+
+		/**
+		Gets an attribute of @a name from an element, if it doesn't exist it will return the defaultValue.
+
+		@param name			The name of the attribute you are querying.
+		@param defaultValue	What to put in @a value if there is no attribute in this element.
+
+		@see GetAttribute
+		*/
+		std::string GetAttributeOrDefault( const std::string& name, const std::string& defaultValue ) const;
+
+		/**
+		Returns an attribute of @a name from an element.
+		Uses FromString to convert the string to the type of choice.
+
+		@param name				The name of the attribute you are querying.
+		@param throwIfNotFound	[DEF]	If true, will throw an exception if the attribute doesn't exist
+		@throws Exception When the attribute doesn't exist and throwIfNotFound is true
+		@see GetAttributeOrDefault
+		*/
+		template < class T >
+			T GetAttribute( const std::string& name, bool throwIfNotFound = true ) const
+		{
+			// Get the attribute's value as a std::string
+			std::string temp;
+			T value;
+			if ( !GetAttributeImp( name, &temp ) )
+			{
+				if ( throwIfNotFound )
+				{
+					const std::string error( std::string( "Attribute '" ) + name + std::string( "' does not exist" ) );
+					TICPPTHROW( error );
+				}
+			}
+			else
+			{
+				// Stream the value from the string to T
+				FromString( temp, &value );
+			}
+
+			return value;
+		}
+
+		/**
+		Gets an attribute of @a name from an element.
+		Uses FromString to convert the string to the type of choice.
+
+		@param name				The name of the attribute you are querying.
+		@param value			[OUT]	The container for the returned value
+		@param throwIfNotFound	[DEF]	If true, will throw an exception if the attribute doesn't exist
+		@throws Exception When the attribute doesn't exist and throwIfNotFound is true
+
+		@see GetAttributeOrDefault
+		*/
+		template< class T >
+			void GetAttribute( const std::string& name, T* value, bool throwIfNotFound = true ) const
+		{
+			// Get the attribute's value as a std::string
+			std::string temp;
+			if ( !GetAttributeImp( name, &temp ) )
+			{
+				if ( throwIfNotFound )
+				{
+					const std::string error( std::string( "Attribute '" ) + name + std::string( "' does not exist" ) );
+					TICPPTHROW( error );
+				}
+				else
+				{
+					return;
+				}
+			}
+
+			// Stream the value from the string to T
+			FromString( temp, value );
+		}
+
+		/**
+		Gets an attribute of @a name from an element.
+		Returns an empty string if the attribute does not exist.
+
+		@param name	The name of the attribute you are querying.
+		@return The value of the attribute, or an empty string if it does not exist.
+
+		@see GetAttributeOrDefault
+		*/
+		std::string GetAttribute( const std::string& name ) const;
+
+		/**
+		Returns true, if attribute exists
+
+		@param name The name of the attribute you are checking.
+		@return Existence of attribute
+		*/
+		bool HasAttribute( const std::string& name ) const;
+
+		/**
+		Removes attribute from element.
+
+		@param name The name of the attribute to remove.
+		*/
+		void RemoveAttribute( const std::string& name );
+
+	private:
+
+		/**
+		@internal
+		Implimentation of the GetAttribute and GetAttributeOrDefault template methods.
+		*/
+		bool GetAttributeImp( const std::string& name, std::string* value ) const;
+
+		/**
+		@internal
+		Implimentation of the GetText, GetTextOrDefault, GetTextValue, and GetTextValueOrDefault template methods.
+		*/
+		bool GetTextImp( std::string* value ) const;
+	};
+
+	/** Wrapper around TiXmlDeclaration */
+	class TICPP_API Declaration : public NodeImp< TiXmlDeclaration >
+	{
+	public:
+		/**
+		Default	Constructor. Construct an empty declaration.
+		*/
+		Declaration();
+
+		/**
+		Constructor.
+		*/
+		Declaration( TiXmlDeclaration* declaration );
+
+		/**
+		Constructor.
+		*/
+		Declaration( const std::string& version, const std::string& encoding, const std::string& standalone );
+
+		/**
+		Version. Will return an empty string if none was found.
+		*/
+		std::string Version() const;
+
+		/**
+		Encoding. Will return an empty string if none was found.
+		*/
+		std::string Encoding() const;
+
+		/**
+		StandAlone. Is this a standalone document?
+		*/
+		std::string Standalone() const;
+	};
+
+	/** Wrapper around TiXmlStylesheetReference */
+	class TICPP_API StylesheetReference : public NodeImp< TiXmlStylesheetReference >
+	{
+	public:
+		/**
+		Default	Constructor. Construct an empty declaration.
+		*/
+		StylesheetReference();
+
+		/**
+		Constructor.
+		*/
+		StylesheetReference( TiXmlStylesheetReference* stylesheetReference );
+
+		/**
+		Constructor.
+		*/
+		StylesheetReference( const std::string& type, const std::string& href );
+
+		/**
+		Type. Will return an empty string if none was found.
+		*/
+		std::string Type() const;
+
+		/**
+		Href. Will return an empty string if none was found.
+		*/
+		std::string Href() const;
+	};
+}
+
+#endif	// TICPP_INCLUDED
diff -Naur wxFormBuilder.orig/subprojects/ticpp/ticpp.lua wxFormBuilder/subprojects/ticpp/ticpp.lua
--- wxFormBuilder.orig/subprojects/ticpp/ticpp.lua	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/ticpp.lua	2019-11-18 10:42:57.710406052 +0100
@@ -0,0 +1,121 @@
+--*****************************************************************************
+--*	Author:		RJP Computing <rjpcomputing@gmail.com>
+--*	Date:		01/21/2008
+--*	Version:	1.02
+--* Copyright (C) 2008 RJP Computing
+--*
+--*	Permission is hereby granted, free of charge, to any person obtaining a copy of
+--*	this software and associated documentation files (the "Software"), to deal in
+--*	the Software without restriction, including without limitation the rights to
+--* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+--*	the Software, and to permit persons to whom the Software is furnished to do so,
+--*	subject to the following conditions:
+--*
+--* The above copyright notice and this permission notice shall be included in all
+--*	copies or substantial portions of the Software.
+--*
+--*	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+--* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+--*	FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+--*	COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+--*	IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+--* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+--*
+--*	NOTES:
+--*		- use the '/' slash for all paths.
+--*****************************************************************************
+
+--******* Initial Setup ************
+--*	Most of the setting are set here.
+--**********************************
+
+-- Set the name of your package.
+package.name								= "TiCPP"
+-- Set this if you want a different name for your target than the package's name.
+local targetName							= "ticpp"
+-- Set the kind of package you want to create.
+if ( options["ticpp-shared"] ) then
+	package.kind							= "dll"
+else
+	package.kind							= "lib"
+end
+-- Set the files to include/exclude.
+package.files								= { matchfiles( "*.cpp", "*.h" ) }
+package.excludes							= { "xmltest.cpp" }
+-- Setup the output directory options.
+--		Note: Use 'libdir' for "lib" kind only.
+package.bindir								= "../lib"
+package.libdir								= "../lib"
+-- Set the defines.
+package.defines								= { "TIXML_USE_TICPP" }
+
+--------------------------- DO NOT EDIT BELOW ----------------------------------
+
+--******* GENAERAL SETUP **********
+--*	Settings that are not dependant
+--*	on the operating system.
+--*********************************
+-- Package options
+addoption( "ticpp-shared", "Build the library as a dll" )
+
+-- Common setup
+package.language							= "c++"
+
+-- Set object output directory.
+if ( string.find( target or "", ".*-gcc" ) or target == "gnu" ) then
+	package.objdir							= ".obj"
+end
+
+-- Set the default targetName if none is specified.
+if ( string.len( targetName ) == 0 ) then
+	targetName								= package.name
+end
+
+-- Set the targets.
+package.config["Release"].target			= targetName
+package.config["Debug"].target				= targetName.."d"
+
+-- Set the build options.
+if ( options["dynamic-runtime"] ) then
+	package.buildflags						= { "extra-warnings" }
+	package.config["Release"].buildflags	= { "no-symbols", "optimize-speed" }
+else
+	package.buildflags						= { "static-runtime", "extra-warnings" }
+	package.config["Release"].buildflags	= { "no-symbols", "optimize-speed" }
+end
+if ( options["unicode"] ) then
+	table.insert( package.buildflags, "unicode" )
+end
+if ( string.find( target or "", ".*-gcc" ) or target == "gnu" ) then
+	table.insert( package.config["Debug"].buildoptions, "-O0" )
+end
+
+-- Set the defines.
+if ( options["unicode"] ) then
+	table.insert( package.defines, { "UNICODE", "_UNICODE" } )
+end
+table.insert( package.config["Debug"].defines, { "DEBUG", "_DEBUG" } )
+table.insert( package.config["Release"].defines, "NDEBUG" )
+if ( ( target == "vs2005" ) or ( target == "vs2008" ) ) then
+		-- Windows and Visual C++ 2005/2008
+	table.insert( package.defines, "_CRT_SECURE_NO_DEPRECATE" )
+end
+
+if ( OS == "windows" ) then
+--******* WINDOWS SETUP ***********
+--*	Settings that are Windows specific.
+--*********************************
+	-- Set the Windows defines.
+	table.insert( package.defines, { "WIN32", "_WINDOWS" } )
+else
+--******* LINUX SETUP *************
+--*	Settings that are Linux specific.
+--*********************************
+	-- Ignore resource files in Linux.
+	table.insert( package.excludes, matchrecursive( "*.rc" ) )
+	table.insert( package.buildoptions, "-fPIC" )
+end
+
+if ( package.kind == "dll" ) then
+    table.insert( package.defines, "BUILD_TICPP_DLL" )
+end
diff -Naur wxFormBuilder.orig/subprojects/ticpp/ticpp4.lua wxFormBuilder/subprojects/ticpp/ticpp4.lua
--- wxFormBuilder.orig/subprojects/ticpp/ticpp4.lua	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/ticpp4.lua	2019-11-18 10:42:57.710406052 +0100
@@ -0,0 +1,131 @@
+--*****************************************************************************
+--*	Author:		RJP Computing <rjpcomputing@gmail.com>
+--*	Date:		01/21/2008
+--*	Version:	1.02
+--* Copyright (C) 2009 RJP Computing
+--*
+--*	Permission is hereby granted, free of charge, to any person obtaining a copy of
+--*	this software and associated documentation files (the "Software"), to deal in
+--*	the Software without restriction, including without limitation the rights to
+--* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+--*	the Software, and to permit persons to whom the Software is furnished to do so,
+--*	subject to the following conditions:
+--*
+--* The above copyright notice and this permission notice shall be included in all
+--*	copies or substantial portions of the Software.
+--*
+--*	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+--* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+--*	FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+--*	COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+--*	IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+--* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+--*
+--*	NOTES:
+--*		- use the '/' slash for all paths.
+--*****************************************************************************
+
+
+--
+-- Package options
+--
+newoption
+{
+	trigger = "ticpp-shared",
+	description = "Build TinyXML++ as a dll"
+}
+
+ticpp = {}
+
+function ticpp.GetCustomValue( item )
+	local prj = project()
+	for _, block in pairs( prj.blocks ) do
+		if block[item] then
+			return block[item]
+		end
+	end
+	return nil
+end
+
+-- Set the name of your package.
+project "TiCPP"
+
+	-- Set the files to include/exclude.
+	files						{ "*.cpp", "*.h" }
+	excludes					{ "xmltest.cpp" }
+
+	-- Set the defines.
+	defines						{ "TIXML_USE_TICPP" }
+
+	-- Common setup
+	language					"C++"
+	flags						{ "ExtraWarnings" }
+
+	--
+	-- TinyXML++ dll
+	--
+	if _OPTIONS["ticpp-shared"] then
+		kind 					"SharedLib"
+	else
+		kind 					"StaticLib"
+		if not ticpp.GetCustomValue( "targetdir" ) then
+			targetdir( solution().basedir .. "/lib" )
+		end
+	end
+
+	--
+	-- Dynamic Runtime
+	--
+	if not _OPTIONS["dynamic-runtime"] then
+		flags					{ "StaticRuntime" }
+	end
+
+	--
+	-- Operating Systems specific
+	--
+	if os.is( "windows" ) then
+		defines					{ "WIN32", "_WINDOWS" }
+	else
+		excludes				{ "**.rc" }		-- Ignore resource files in Linux.
+		buildoptions			{ "-fPIC" }
+	end
+
+	--
+	-- Unicode
+	--
+	configuration "unicode"
+		flags					{ "Unicode" }
+		defines					{ "UNICODE", "_UNICODE" }
+
+	--
+	-- GCC compilers
+	--
+	configuration { "code*", "gmake" }
+		objdir					".obj"
+		buildoptions			{ "-O0" }
+
+	--
+	-- Visual Studio
+	--
+	configuration "vs*"
+		-- Windows and Visual C++ 2005/2008
+		defines					{ "_CRT_SECURE_NO_DEPRECATE" }
+
+	configuration( "vs*", "not vs2005" )
+		-- multi-process building
+		flags( "NoMinimalRebuild" )
+		buildoptions( "-MP" )
+
+	--
+	-- Release/Debug
+	--
+
+	-- Set the targets.
+	configuration "Release"
+		targetname				( "ticpp" )
+		defines					{ "NDEBUG" }
+		flags					{ "OptimizeSpeed" }
+	configuration "Debug"
+		targetname 				( "ticppd" )
+		defines					{ "DEBUG", "_DEBUG" }
+		flags					{ "Symbols" }
diff -Naur wxFormBuilder.orig/subprojects/ticpp/ticppapi.h wxFormBuilder/subprojects/ticpp/ticppapi.h
--- wxFormBuilder.orig/subprojects/ticpp/ticppapi.h	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/ticppapi.h	2019-11-18 10:42:57.710406052 +0100
@@ -0,0 +1,52 @@
+/*
+Copyright (c) 2012 Matt Janisz
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+#ifndef TICPP_API_INCLUDED
+#define TICPP_API_INCLUDED
+
+#undef TICPP_API
+
+#if defined(_WIN32) | defined(WIN32) | defined(WINDOWS) | defined(_WINDOWS)
+    // define BUILD_TICPP_DLL when building TiCPP dll.
+    #ifdef BUILD_TICPP_DLL
+        #define TICPP_API __declspec(dllexport)
+    #endif
+
+    // define TICPP_DLL when linking TiCPP dll.
+    #ifdef TICPP_DLL
+        #define TICPP_API __declspec(dllimport)
+    #endif
+
+    // Disable dll-interface warning
+    #ifdef TICPP_API
+        #pragma warning( push )
+        #pragma warning( disable : 4251 ) // X needs to have dll-interface to be used by clients of class Y
+        #pragma warning( disable : 4275 ) // X is derived from class Y but only X is exported
+    #endif
+
+#endif
+
+#ifndef TICPP_API
+    //linux or windows-static library defines
+    #define TICPP_API
+#endif
+
+#endif	// TICPP_API_INCLUDED
diff -Naur wxFormBuilder.orig/subprojects/ticpp/ticpprc.h wxFormBuilder/subprojects/ticpp/ticpprc.h
--- wxFormBuilder.orig/subprojects/ticpp/ticpprc.h	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/ticpprc.h	2019-11-18 10:42:57.711406052 +0100
@@ -0,0 +1,129 @@
+/*
+http://code.google.com/p/ticpp/
+Copyright (c) 2006 Ryan Pusztai, Ryan Mulder
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+ /*
+ * THIS FILE WAS ALTERED BY Matt Janisz, 12. October 2012.
+ *
+ * - added ticppapi.h include and TICPP_API dll-interface to support building DLL using VS200X
+ */
+
+#ifdef TIXML_USE_TICPP
+
+#ifndef TICPPRC_INCLUDED
+#define TICPPRC_INCLUDED
+
+#include "ticppapi.h"
+#include <vector>
+
+// Forward declare ticpp::Node, so it can be made a friend of TiCppRC
+namespace ticpp
+{
+	class TICPP_API Base;
+}
+
+// Forward declare TiCppRCImp so TiCppRC can hold a pointer to it
+class TICPP_API TiCppRCImp;
+
+/**
+Base class for reference counting functionality
+*/
+class TICPP_API TiCppRC
+{
+	// Allow ticpp::Node to directly modify reference count
+	friend class ticpp::Base;
+
+private:
+
+	TiCppRCImp* m_tiRC; /**< Pointer to reference counter */
+
+public:
+
+	/**
+	Constructor
+	Spawns new reference counter with a pointer to this
+	*/
+	TiCppRC();
+
+	/**
+	Destructor
+	Nullifies the pointer to this held by the reference counter
+	Decrements reference count
+	*/
+	virtual ~TiCppRC();
+	
+	std::vector< ticpp::Base* > m_spawnedWrappers; /**< Remember all wrappers that we've created with 'new' - ( e.g. NodeFactory, FirstChildElement, etc. )*/
+
+	/**
+	Delete all container objects we've spawned with 'new'.
+	*/
+	void DeleteSpawnedWrappers();
+};
+
+class TICPP_API TiCppRCImp
+{
+private:
+
+	int m_count;		/**< Holds reference count to me, and to the node I point to */
+
+	TiCppRC* m_tiCppRC;	/**< Holds pointer to an object inheriting TiCppRC */
+
+public:
+
+	/**
+	Initializes m_tiCppRC pointer, and set reference count to 1
+	*/
+	TiCppRCImp( TiCppRC* tiCppRC );
+
+	/**
+	Allows the TiCppRC object to set the pointer to itself ( m_tiCppRc ) to NULL when the TiCppRC object is deleted
+	*/
+	void Nullify();
+
+	/**
+	Increment Reference Count
+	*/
+	void IncRef();
+
+	/**
+	Decrement Reference Count
+	*/
+	void DecRef();
+
+	/**
+	Set Reference Count to 1 - dangerous! - Use only if you are sure of the consequences
+	*/
+	void InitRef();
+
+	/**
+	Get internal pointer to the TiCppRC object - not reference counted, use at your own risk
+	*/
+	TiCppRC* Get();
+
+	/**
+	Returns state of internal pointer - will be null if the object was deleted
+	*/
+	bool IsNull();
+};
+
+#endif // TICPP_INCLUDED
+
+#endif // TIXML_USE_TICPP
diff -Naur wxFormBuilder.orig/subprojects/ticpp/tinystr.cpp wxFormBuilder/subprojects/ticpp/tinystr.cpp
--- wxFormBuilder.orig/subprojects/ticpp/tinystr.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/tinystr.cpp	2019-11-18 10:42:57.711406052 +0100
@@ -0,0 +1,116 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+/*
+ * THIS FILE WAS ALTERED BY Tyge Lvset, 7. April 2005.
+ */
+
+
+#ifndef TIXML_USE_STL
+
+#include "tinystr.h"
+
+// Error value for find primitive
+const TiXmlString::size_type TiXmlString::npos = static_cast< TiXmlString::size_type >(-1);
+
+
+// Null rep.
+TiXmlString::Rep TiXmlString::nullrep_ = { 0, 0, { '\0' } };
+
+
+void TiXmlString::reserve (size_type cap)
+{
+	if (cap > capacity())
+	{
+		TiXmlString tmp;
+		tmp.init(length(), cap);
+		memcpy(tmp.start(), data(), length());
+		swap(tmp);
+	}
+}
+
+
+TiXmlString& TiXmlString::assign(const char* str, size_type len)
+{
+	size_type cap = capacity();
+	if (len > cap || cap > 3*(len + 8))
+	{
+		TiXmlString tmp;
+		tmp.init(len);
+		memcpy(tmp.start(), str, len);
+		swap(tmp);
+	}
+	else
+	{
+		memmove(start(), str, len);
+		set_size(len);
+	}
+	return *this;
+}
+
+
+TiXmlString& TiXmlString::append(const char* str, size_type len)
+{
+	size_type newsize = length() + len;
+	if (newsize > capacity())
+	{
+		reserve (newsize + capacity());
+	}
+	memmove(finish(), str, len);
+	set_size(newsize);
+	return *this;
+}
+
+
+TiXmlString operator + (const TiXmlString & a, const TiXmlString & b)
+{
+	TiXmlString tmp;
+	tmp.reserve(a.length() + b.length());
+	tmp += a;
+	tmp += b;
+	return tmp;
+}
+
+TiXmlString operator + (const TiXmlString & a, const char* b)
+{
+	TiXmlString tmp;
+	TiXmlString::size_type b_len = static_cast<TiXmlString::size_type>( strlen(b) );
+	tmp.reserve(a.length() + b_len);
+	tmp += a;
+	tmp.append(b, b_len);
+	return tmp;
+}
+
+TiXmlString operator + (const char* a, const TiXmlString & b)
+{
+	TiXmlString tmp;
+	TiXmlString::size_type a_len = static_cast<TiXmlString::size_type>( strlen(a) );
+	tmp.reserve(a_len + b.length());
+	tmp.append(a, a_len);
+	tmp += b;
+	return tmp;
+}
+
+
+#endif	// TIXML_USE_STL
diff -Naur wxFormBuilder.orig/subprojects/ticpp/tinystr.h wxFormBuilder/subprojects/ticpp/tinystr.h
--- wxFormBuilder.orig/subprojects/ticpp/tinystr.h	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/tinystr.h	2019-11-18 10:42:57.711406052 +0100
@@ -0,0 +1,326 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+/*
+ * THIS FILE WAS ALTERED BY Tyge Lovset, 7. April 2005.
+ *
+ * - completely rewritten. compact, clean, and fast implementation.
+ * - sizeof(TiXmlString) = pointer size (4 bytes on 32-bit systems)
+ * - fixed reserve() to work as per specification.
+ * - fixed buggy compares operator==(), operator<(), and operator>()
+ * - fixed operator+=() to take a const ref argument, following spec.
+ * - added "copy" constructor with length, and most compare operators.
+ * - added swap(), clear(), size(), capacity(), operator+().
+ */
+
+ /*
+ * THIS FILE WAS ALTERED BY Matt Janisz, 12. October 2012.
+ *
+ * - added ticppapi.h include and TICPP_API dll-interface to support building DLL using VS200X
+ */
+
+#ifndef TIXML_USE_STL
+
+#ifndef TIXML_STRING_INCLUDED
+#define TIXML_STRING_INCLUDED
+
+#include "ticppapi.h"
+#include <assert.h>
+#include <string.h>
+
+/*	The support for explicit isn't that universal, and it isn't really
+	required - it is used to check that the TiXmlString class isn't incorrectly
+	used. Be nice to old compilers and macro it here:
+*/
+#if defined(_MSC_VER) && (_MSC_VER >= 1200 )
+	// Microsoft visual studio, version 6 and higher.
+	#define TIXML_EXPLICIT explicit
+#elif defined(__GNUC__) && (__GNUC__ >= 3 )
+	// GCC version 3 and higher.s
+	#define TIXML_EXPLICIT explicit
+#else
+	#define TIXML_EXPLICIT
+#endif
+
+
+/*
+   TiXmlString is an emulation of a subset of the std::string template.
+   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.
+   Only the member functions relevant to the TinyXML project have been implemented.
+   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase
+   a string and there's no more room, we allocate a buffer twice as big as we need.
+*/
+class TICPP_API TiXmlString
+{
+  public :
+	// The size type used
+  	typedef size_t size_type;
+
+	// Error value for find primitive
+	static const size_type npos; // = -1;
+
+
+	// TiXmlString empty constructor
+	TiXmlString () : rep_(&nullrep_)
+	{
+	}
+
+	// TiXmlString copy constructor
+	TiXmlString ( const TiXmlString & copy) : rep_(0)
+	{
+		init(copy.length());
+		memcpy(start(), copy.data(), length());
+	}
+
+	// TiXmlString constructor, based on a string
+	TIXML_EXPLICIT TiXmlString ( const char * copy) : rep_(0)
+	{
+		init( static_cast<size_type>( strlen(copy) ));
+		memcpy(start(), copy, length());
+	}
+
+	// TiXmlString constructor, based on a string
+	TIXML_EXPLICIT TiXmlString ( const char * str, size_type len) : rep_(0)
+	{
+		init(len);
+		memcpy(start(), str, len);
+	}
+
+	// TiXmlString destructor
+	~TiXmlString ()
+	{
+		quit();
+	}
+
+	// = operator
+	TiXmlString& operator = (const char * copy)
+	{
+		return assign( copy, (size_type)strlen(copy));
+	}
+
+	// = operator
+	TiXmlString& operator = (const TiXmlString & copy)
+	{
+		return assign(copy.start(), copy.length());
+	}
+
+
+	// += operator. Maps to append
+	TiXmlString& operator += (const char * suffix)
+	{
+		return append(suffix, static_cast<size_type>( strlen(suffix) ));
+	}
+
+	// += operator. Maps to append
+	TiXmlString& operator += (char single)
+	{
+		return append(&single, 1);
+	}
+
+	// += operator. Maps to append
+	TiXmlString& operator += (const TiXmlString & suffix)
+	{
+		return append(suffix.data(), suffix.length());
+	}
+
+
+	// Convert a TiXmlString into a null-terminated char *
+	const char * c_str () const { return rep_->str; }
+
+	// Convert a TiXmlString into a char * (need not be null terminated).
+	const char * data () const { return rep_->str; }
+
+	// Return the length of a TiXmlString
+	size_type length () const { return rep_->size; }
+
+	// Alias for length()
+	size_type size () const { return rep_->size; }
+
+	// Checks if a TiXmlString is empty
+	bool empty () const { return rep_->size == 0; }
+
+	// Return capacity of string
+	size_type capacity () const { return rep_->capacity; }
+
+
+	// single char extraction
+	const char& at (size_type index) const
+	{
+		assert( index < length() );
+		return rep_->str[ index ];
+	}
+
+	// [] operator
+	char& operator [] (size_type index) const
+	{
+		assert( index < length() );
+		return rep_->str[ index ];
+	}
+
+	// find a char in a string. Return TiXmlString::npos if not found
+	size_type find (char lookup) const
+	{
+		return find(lookup, 0);
+	}
+
+	// find a char in a string from an offset. Return TiXmlString::npos if not found
+	size_type find (char tofind, size_type offset) const
+	{
+		if (offset >= length()) return npos;
+
+		for (const char* p = c_str() + offset; *p != '\0'; ++p)
+		{
+		   if (*p == tofind) return static_cast< size_type >( p - c_str() );
+		}
+		return npos;
+	}
+
+	void clear ()
+	{
+		//Lee:
+		//The original was just too strange, though correct:
+		//	TiXmlString().swap(*this);
+		//Instead use the quit & re-init:
+		quit();
+		init(0,0);
+	}
+
+	/*	Function to reserve a big amount of data when we know we'll need it. Be aware that this
+		function DOES NOT clear the content of the TiXmlString if any exists.
+	*/
+	void reserve (size_type cap);
+
+	TiXmlString& assign (const char* str, size_type len);
+
+	TiXmlString& append (const char* str, size_type len);
+
+	void swap (TiXmlString& other)
+	{
+		Rep* r = rep_;
+		rep_ = other.rep_;
+		other.rep_ = r;
+	}
+
+  private:
+
+	void init(size_type sz) { init(sz, sz); }
+	void set_size(size_type sz) { rep_->str[ rep_->size = sz ] = '\0'; }
+	char* start() const { return rep_->str; }
+	char* finish() const { return rep_->str + rep_->size; }
+
+	struct Rep
+	{
+		size_type size, capacity;
+		char str[1];
+	};
+
+	void init(size_type sz, size_type cap)
+	{
+		if (cap)
+		{
+			// Lee: the original form:
+			//	rep_ = static_cast<Rep*>(operator new(sizeof(Rep) + cap));
+			// doesn't work in some cases of new being overloaded. Switching
+			// to the normal allocation, although use an 'int' for systems
+			// that are overly picky about structure alignment.
+			const size_type bytesNeeded = sizeof(Rep) + cap;
+			const size_type intsNeeded = ( bytesNeeded + sizeof(int) - 1 ) / sizeof( int ); 
+			rep_ = reinterpret_cast<Rep*>( new int[ intsNeeded ] );
+
+			rep_->str[ rep_->size = sz ] = '\0';
+			rep_->capacity = cap;
+		}
+		else
+		{
+			rep_ = &nullrep_;
+		}
+	}
+
+	void quit()
+	{
+		if (rep_ != &nullrep_)
+		{
+			// The rep_ is really an array of ints. (see the allocator, above).
+			// Cast it back before delete, so the compiler won't incorrectly call destructors.
+			delete [] ( reinterpret_cast<int*>( rep_ ) );
+		}
+	}
+
+	Rep * rep_;
+	static Rep nullrep_;
+
+} ;
+
+
+inline bool operator == (const TiXmlString & a, const TiXmlString & b)
+{
+	return    ( a.length() == b.length() )				// optimization on some platforms
+	       && ( strcmp(a.c_str(), b.c_str()) == 0 );	// actual compare
+}
+inline bool operator < (const TiXmlString & a, const TiXmlString & b)
+{
+	return strcmp(a.c_str(), b.c_str()) < 0;
+}
+
+inline bool operator != (const TiXmlString & a, const TiXmlString & b) { return !(a == b); }
+inline bool operator >  (const TiXmlString & a, const TiXmlString & b) { return b < a; }
+inline bool operator <= (const TiXmlString & a, const TiXmlString & b) { return !(b < a); }
+inline bool operator >= (const TiXmlString & a, const TiXmlString & b) { return !(a < b); }
+
+inline bool operator == (const TiXmlString & a, const char* b) { return strcmp(a.c_str(), b) == 0; }
+inline bool operator == (const char* a, const TiXmlString & b) { return b == a; }
+inline bool operator != (const TiXmlString & a, const char* b) { return !(a == b); }
+inline bool operator != (const char* a, const TiXmlString & b) { return !(b == a); }
+
+TiXmlString operator + (const TiXmlString & a, const TiXmlString & b);
+TiXmlString operator + (const TiXmlString & a, const char* b);
+TiXmlString operator + (const char* a, const TiXmlString & b);
+
+
+/*
+   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.
+   Only the operators that we need for TinyXML have been developped.
+*/
+class TICPP_API TiXmlOutStream : public TiXmlString
+{
+public :
+
+	// TiXmlOutStream << operator.
+	TiXmlOutStream & operator << (const TiXmlString & in)
+	{
+		*this += in;
+		return *this;
+	}
+
+	// TiXmlOutStream << operator.
+	TiXmlOutStream & operator << (const char * in)
+	{
+		*this += in;
+		return *this;
+	}
+
+} ;
+
+#endif	// TIXML_STRING_INCLUDED
+#endif	// TIXML_USE_STL
diff -Naur wxFormBuilder.orig/subprojects/ticpp/tinyxml.cpp wxFormBuilder/subprojects/ticpp/tinyxml.cpp
--- wxFormBuilder.orig/subprojects/ticpp/tinyxml.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/tinyxml.cpp	2019-11-18 10:42:57.711406052 +0100
@@ -0,0 +1,1968 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+#include "tinyxml.h"
+
+#include <cctype>
+
+#ifdef TIXML_USE_STL
+#include <sstream>
+#include <iostream>
+#endif
+
+
+bool TiXmlBase::condenseWhiteSpace = true;
+
+// Microsoft compiler security
+FILE* TiXmlFOpen( const char* filename, const char* mode )
+{
+	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
+		FILE* fp = 0;
+		errno_t err = fopen_s( &fp, filename, mode );
+		if ( !err && fp )
+			return fp;
+		return 0;
+	#else
+		return fopen( filename, mode );
+	#endif
+}
+
+void TiXmlBase::EncodeString( const TIXML_STRING& str, TIXML_STRING* outString )
+{
+	int i=0;
+
+	while( i<(int)str.length() )
+	{
+		unsigned char c = (unsigned char) str[i];
+
+		if (    c == '&'
+		     && i < ( (int)str.length() - 2 )
+			 && str[i+1] == '#'
+			 && str[i+2] == 'x' )
+		{
+			// Hexadecimal character reference.
+			// Pass through unchanged.
+			// &#xA9;	-- copyright symbol, for example.
+			//
+			// The -1 is a bug fix from Rob Laveaux. It keeps
+			// an overflow from happening if there is no ';'.
+			// There are actually 2 ways to exit this loop -
+			// while fails (error case) and break (semicolon found).
+			// However, there is no mechanism (currently) for
+			// this function to return an error.
+			while ( i<(int)str.length()-1 )
+			{
+				outString->append( str.c_str() + i, 1 );
+				++i;
+				if ( str[i] == ';' )
+					break;
+			}
+		}
+		else if ( c == '&' )
+		{
+			outString->append( entity[0].str, entity[0].strLength );
+			++i;
+		}
+		else if ( c == '<' )
+		{
+			outString->append( entity[1].str, entity[1].strLength );
+			++i;
+		}
+		else if ( c == '>' )
+		{
+			outString->append( entity[2].str, entity[2].strLength );
+			++i;
+		}
+		else if ( c == '\"' )
+		{
+			outString->append( entity[3].str, entity[3].strLength );
+			++i;
+		}
+		else if ( c == '\'' )
+		{
+			outString->append( entity[4].str, entity[4].strLength );
+			++i;
+		}
+		else if ( c < 32 )
+		{
+			// Easy pass at non-alpha/numeric/symbol
+			// Below 32 is symbolic.
+			char buf[ 32 ];
+
+			#if defined(TIXML_SNPRINTF)
+				TIXML_SNPRINTF( buf, sizeof(buf), "&#x%02X;", (unsigned) ( c & 0xff ) );
+			#else
+				sprintf( buf, "&#x%02X;", (unsigned) ( c & 0xff ) );
+			#endif
+
+			//*ME:	warning C4267: convert 'size_t' to 'int'
+			//*ME:	Int-Cast to make compiler happy ...
+			outString->append( buf, (int)strlen( buf ) );
+			++i;
+		}
+		else
+		{
+			//char realc = (char) c;
+			//outString->append( &realc, 1 );
+			*outString += (char) c;	// somewhat more efficient function call.
+			++i;
+		}
+	}
+}
+
+TiXmlNode::TiXmlNode(NodeType _type) {
+	parent = 0;
+	type = _type;
+	firstChild = 0;
+	lastChild = 0;
+	prev = 0;
+	next = 0;
+}
+
+
+TiXmlNode::~TiXmlNode()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}
+}
+
+
+void TiXmlNode::CopyTo( TiXmlNode* target ) const
+{
+	target->SetValue (value.c_str() );
+	target->userData = userData;
+}
+
+
+void TiXmlNode::Clear()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}
+
+	firstChild = 0;
+	lastChild = 0;
+}
+
+
+TiXmlNode* TiXmlNode::LinkEndChild( TiXmlNode* node )
+{
+	assert( node->parent == 0 || node->parent == this );
+	assert( node->GetDocument() == 0 || node->GetDocument() == this->GetDocument() );
+
+	if ( node->Type() == TiXmlNode::DOCUMENT )
+	{
+		delete node;
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	node->parent = this;
+
+	node->prev = lastChild;
+	node->next = 0;
+
+	if ( lastChild )
+		lastChild->next = node;
+	else
+		firstChild = node;			// it was an empty list.
+
+	lastChild = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertEndChild( const TiXmlNode& addThis )
+{
+	if ( addThis.Type() == TiXmlNode::DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+
+	return LinkEndChild( node );
+}
+
+
+TiXmlNode* TiXmlNode::InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis )
+{
+	if ( !beforeThis || beforeThis->parent != this ) {
+		return 0;
+	}
+	if ( addThis.Type() == TiXmlNode::DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->next = beforeThis;
+	node->prev = beforeThis->prev;
+	if ( beforeThis->prev )
+	{
+		beforeThis->prev->next = node;
+	}
+	else
+	{
+		assert( firstChild == beforeThis );
+		firstChild = node;
+	}
+	beforeThis->prev = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis )
+{
+	if ( !afterThis || afterThis->parent != this ) {
+		return 0;
+	}
+	if ( addThis.Type() == TiXmlNode::DOCUMENT )
+	{
+		if ( GetDocument() ) GetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->prev = afterThis;
+	node->next = afterThis->next;
+	if ( afterThis->next )
+	{
+		afterThis->next->prev = node;
+	}
+	else
+	{
+		assert( lastChild == afterThis );
+		lastChild = node;
+	}
+	afterThis->next = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis )
+{
+	if ( replaceThis->parent != this )
+		return 0;
+
+	TiXmlNode* node = withThis.Clone();
+	if ( !node )
+		return 0;
+
+	node->next = replaceThis->next;
+	node->prev = replaceThis->prev;
+
+	if ( replaceThis->next )
+		replaceThis->next->prev = node;
+	else
+		lastChild = node;
+
+	if ( replaceThis->prev )
+		replaceThis->prev->next = node;
+	else
+		firstChild = node;
+
+	delete replaceThis;
+	node->parent = this;
+	return node;
+}
+
+
+bool TiXmlNode::RemoveChild( TiXmlNode* removeThis )
+{
+	if ( removeThis->parent != this )
+	{
+		assert( 0 );
+		return false;
+	}
+
+	if ( removeThis->next )
+		removeThis->next->prev = removeThis->prev;
+	else
+		lastChild = removeThis->prev;
+
+	if ( removeThis->prev )
+		removeThis->prev->next = removeThis->next;
+	else
+		firstChild = removeThis->next;
+
+	delete removeThis;
+	return true;
+}
+
+const TiXmlNode* TiXmlNode::FirstChild( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = firstChild; node; node = node->next )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::LastChild( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = lastChild; node; node = node->prev )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::IterateChildren( const TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild();
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling();
+	}
+}
+
+
+const TiXmlNode* TiXmlNode::IterateChildren( const char * val, const TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild( val );
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling( val );
+	}
+}
+
+
+const TiXmlNode* TiXmlNode::NextSibling( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = next; node; node = node->next )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+const TiXmlNode* TiXmlNode::PreviousSibling( const char * _value ) const
+{
+	const TiXmlNode* node;
+	for ( node = prev; node; node = node->prev )
+	{
+		if ( strcmp( node->Value(), _value ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+
+void TiXmlElement::RemoveAttribute( const char * name )
+{
+    #ifdef TIXML_USE_STL
+	TIXML_STRING str( name );
+	TiXmlAttribute* node = attributeSet.Find( str );
+	#else
+	TiXmlAttribute* node = attributeSet.Find( name );
+	#endif
+	if ( node )
+	{
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+const TiXmlElement* TiXmlNode::FirstChildElement() const
+{
+	const TiXmlNode* node;
+
+	for (	node = FirstChild();
+			node;
+			node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::FirstChildElement( const char * _value ) const
+{
+	const TiXmlNode* node;
+
+	for (	node = FirstChild( _value );
+			node;
+			node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::NextSiblingElement() const
+{
+	const TiXmlNode* node;
+
+	for (	node = NextSibling();
+			node;
+			node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlElement* TiXmlNode::NextSiblingElement( const char * _value ) const
+{
+	const TiXmlNode* node;
+
+	for (	node = NextSibling( _value );
+			node;
+			node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+const TiXmlDocument* TiXmlNode::GetDocument() const
+{
+	const TiXmlNode* node;
+
+	for( node = this; node; node = node->parent )
+	{
+		if ( node->ToDocument() )
+			return node->ToDocument();
+	}
+	return 0;
+}
+
+
+TiXmlElement::TiXmlElement (const char * _value)
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlElement::TiXmlElement( const std::string& _value )
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+#endif
+
+
+TiXmlElement::TiXmlElement( const TiXmlElement& copy)
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	copy.CopyTo( this );
+}
+
+
+void TiXmlElement::operator=( const TiXmlElement& base )
+{
+	ClearThis();
+	base.CopyTo( this );
+}
+
+
+TiXmlElement::~TiXmlElement()
+{
+	ClearThis();
+}
+
+
+void TiXmlElement::ClearThis()
+{
+	Clear();
+	while( attributeSet.First() )
+	{
+		TiXmlAttribute* node = attributeSet.First();
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+
+const char* TiXmlElement::Attribute( const char* name ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+		return node->Value();
+	return 0;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+		return &node->ValueStr();
+	return 0;
+}
+#endif
+
+
+const char* TiXmlElement::Attribute( const char* name, int* i ) const
+{
+	const char* s = Attribute( name );
+	if ( i )
+	{
+		if ( s ) {
+			*i = atoi( s );
+		}
+		else {
+			*i = 0;
+		}
+	}
+	return s;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name, int* i ) const
+{
+	const std::string* s = Attribute( name );
+	if ( i )
+	{
+		if ( s ) {
+			*i = atoi( s->c_str() );
+		}
+		else {
+			*i = 0;
+		}
+	}
+	return s;
+}
+#endif
+
+
+const char* TiXmlElement::Attribute( const char* name, double* d ) const
+{
+	const char* s = Attribute( name );
+	if ( d )
+	{
+		if ( s ) {
+			*d = atof( s );
+		}
+		else {
+			*d = 0;
+		}
+	}
+	return s;
+}
+
+
+#ifdef TIXML_USE_STL
+const std::string* TiXmlElement::Attribute( const std::string& name, double* d ) const
+{
+	const std::string* s = Attribute( name );
+	if ( d )
+	{
+		if ( s ) {
+			*d = atof( s->c_str() );
+		}
+		else {
+			*d = 0;
+		}
+	}
+	return s;
+}
+#endif
+
+
+int TiXmlElement::QueryIntAttribute( const char* name, int* ival ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+	return node->QueryIntValue( ival );
+}
+
+
+#ifdef TIXML_USE_STL
+int TiXmlElement::QueryIntAttribute( const std::string& name, int* ival ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+	return node->QueryIntValue( ival );
+}
+#endif
+
+
+int TiXmlElement::QueryDoubleAttribute( const char* name, double* dval ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+	return node->QueryDoubleValue( dval );
+}
+
+
+#ifdef TIXML_USE_STL
+int TiXmlElement::QueryDoubleAttribute( const std::string& name, double* dval ) const
+{
+	const TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+	return node->QueryDoubleValue( dval );
+}
+#endif
+
+
+void TiXmlElement::SetAttribute( const char * name, int val )
+{
+	char buf[64];
+	#if defined(TIXML_SNPRINTF)
+		TIXML_SNPRINTF( buf, sizeof(buf), "%d", val );
+	#else
+		sprintf( buf, "%d", val );
+	#endif
+	SetAttribute( name, buf );
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlElement::SetAttribute( const std::string& name, int val )
+{
+   std::ostringstream oss;
+   oss << val;
+   SetAttribute( name, oss.str() );
+}
+#endif
+
+
+void TiXmlElement::SetDoubleAttribute( const char * name, double val )
+{
+	char buf[256];
+	#if defined(TIXML_SNPRINTF)
+		TIXML_SNPRINTF( buf, sizeof(buf), "%f", val );
+	#else
+		sprintf( buf, "%f", val );
+	#endif
+	SetAttribute( name, buf );
+}
+
+
+void TiXmlElement::SetAttribute( const char * cname, const char * cvalue )
+{
+    #ifdef TIXML_USE_STL
+	TIXML_STRING _name( cname );
+	TIXML_STRING _value( cvalue );
+	#else
+	const char* _name = cname;
+	const char* _value = cvalue;
+	#endif
+
+	TiXmlAttribute* node = attributeSet.Find( _name );
+	if ( node )
+	{
+		node->SetValue( _value );
+		return;
+	}
+
+	TiXmlAttribute* attrib = new TiXmlAttribute( cname, cvalue );
+	if ( attrib )
+	{
+		attributeSet.Add( attrib );
+	}
+	else
+	{
+		TiXmlDocument* document = GetDocument();
+		if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
+	}
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlElement::SetAttribute( const std::string& name, const std::string& _value )
+{
+	TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+	{
+		node->SetValue( _value );
+		return;
+	}
+
+	TiXmlAttribute* attrib = new TiXmlAttribute( name, _value );
+	if ( attrib )
+	{
+		attributeSet.Add( attrib );
+	}
+	else
+	{
+		TiXmlDocument* document = GetDocument();
+		if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
+	}
+}
+#endif
+
+
+void TiXmlElement::Print( FILE* cfile, int depth ) const
+{
+	int i;
+	assert( cfile );
+	for ( i=0; i<depth; i++ ) {
+		fprintf( cfile, "    " );
+	}
+
+	fprintf( cfile, "<%s", value.c_str() );
+
+	const TiXmlAttribute* attrib;
+	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
+	{
+		fprintf( cfile, " " );
+		attrib->Print( cfile, depth );
+	}
+
+	// There are 3 different formatting approaches:
+	// 1) An element without children is printed as a <foo /> node
+	// 2) An element with only a text child is printed as <foo> text </foo>
+	// 3) An element with children is printed on multiple lines.
+	TiXmlNode* node;
+	if ( !firstChild )
+	{
+		fprintf( cfile, " />" );
+	}
+	else if ( firstChild == lastChild && firstChild->ToText() )
+	{
+		fprintf( cfile, ">" );
+		firstChild->Print( cfile, depth + 1 );
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+	else
+	{
+		fprintf( cfile, ">" );
+
+		for ( node = firstChild; node; node=node->NextSibling() )
+		{
+			if ( !node->ToText() )
+			{
+				fprintf( cfile, "\n" );
+			}
+			node->Print( cfile, depth+1 );
+		}
+		fprintf( cfile, "\n" );
+		for( i=0; i<depth; ++i ) {
+			fprintf( cfile, "    " );
+		}
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+}
+
+
+void TiXmlElement::CopyTo( TiXmlElement* target ) const
+{
+	// superclass:
+	TiXmlNode::CopyTo( target );
+
+	// Element class:
+	// Clone the attributes, then clone the children.
+	const TiXmlAttribute* attribute = 0;
+	for(	attribute = attributeSet.First();
+	attribute;
+	attribute = attribute->Next() )
+	{
+		target->SetAttribute( attribute->Name(), attribute->Value() );
+	}
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}
+}
+
+bool TiXmlElement::Accept( TiXmlVisitor* visitor ) const
+{
+	if ( visitor->VisitEnter( *this, attributeSet.First() ) )
+	{
+		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+		{
+			if ( !node->Accept( visitor ) )
+				break;
+		}
+	}
+	return visitor->VisitExit( *this );
+}
+
+
+TiXmlNode* TiXmlElement::Clone() const
+{
+	TiXmlElement* clone = new TiXmlElement( Value() );
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+const char* TiXmlElement::GetText() const
+{
+	const TiXmlNode* child = this->FirstChild();
+	if ( child ) {
+		const TiXmlText* childText = child->ToText();
+		if ( childText ) {
+			return childText->Value();
+		}
+	}
+	return 0;
+}
+
+
+TiXmlDocument::TiXmlDocument() : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+	ClearError();
+}
+
+TiXmlDocument::TiXmlDocument( const char * documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+	value = documentName;
+	ClearError();
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDocument::TiXmlDocument( const std::string& documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+	useMicrosoftBOM = false;
+    value = documentName;
+	ClearError();
+}
+#endif
+
+
+TiXmlDocument::TiXmlDocument( const TiXmlDocument& copy ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDocument::operator=( const TiXmlDocument& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+bool TiXmlDocument::LoadFile( TiXmlEncoding encoding )
+{
+	// See STL_STRING_BUG below.
+	//StringToBuffer buf( value );
+
+	return LoadFile( Value(), encoding );
+}
+
+
+bool TiXmlDocument::SaveFile() const
+{
+	// See STL_STRING_BUG below.
+//	StringToBuffer buf( value );
+//
+//	if ( buf.buffer && SaveFile( buf.buffer ) )
+//		return true;
+//
+//	return false;
+	return SaveFile( Value() );
+}
+
+bool TiXmlDocument::LoadFile( const char* _filename, TiXmlEncoding encoding )
+{
+	// There was a really terrifying little bug here. The code:
+	//		value = filename
+	// in the STL case, cause the assignment method of the std::string to
+	// be called. What is strange, is that the std::string had the same
+	// address as it's c_str() method, and so bad things happen. Looks
+	// like a bug in the Microsoft STL implementation.
+	// Add an extra string to avoid the crash.
+	TIXML_STRING filename( _filename );
+	value = filename;
+
+	// reading in binary mode so that tinyxml can normalize the EOL
+	FILE* file = TiXmlFOpen( value.c_str (), "rb" );
+
+	if ( file )
+	{
+		bool result = LoadFile( file, encoding );
+		fclose( file );
+		return result;
+	}
+	else
+	{
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+}
+
+bool TiXmlDocument::LoadFile( FILE* file, TiXmlEncoding encoding )
+{
+	if ( !file )
+	{
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	// Delete the existing data:
+	Clear();
+	location.Clear();
+
+	// Get the file size, so we can pre-allocate the string. HUGE speed impact.
+	long length = 0;
+	fseek( file, 0, SEEK_END );
+	length = ftell( file );
+	fseek( file, 0, SEEK_SET );
+
+	// Strange case, but good to handle up front.
+	if ( length <= 0 )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	// If we have a file, assume it is all one big XML file, and read it in.
+	// The document parser may decide the document ends sooner than the entire file, however.
+	TIXML_STRING data;
+	data.reserve( length );
+
+	// Subtle bug here. TinyXml did use fgets. But from the XML spec:
+	// 2.11 End-of-Line Handling
+	// <snip>
+	// <quote>
+	// ...the XML processor MUST behave as if it normalized all line breaks in external
+	// parsed entities (including the document entity) on input, before parsing, by translating
+	// both the two-character sequence #xD #xA and any #xD that is not followed by #xA to
+	// a single #xA character.
+	// </quote>
+	//
+	// It is not clear fgets does that, and certainly isn't clear it works cross platform.
+	// Generally, you expect fgets to translate from the convention of the OS to the c/unix
+	// convention, and not work generally.
+
+	/*
+	while( fgets( buf, sizeof(buf), file ) )
+	{
+		data += buf;
+	}
+	*/
+
+	char* buf = new char[ length+1 ];
+	buf[0] = 0;
+
+	if ( fread( buf, length, 1, file ) != 1 ) {
+		delete [] buf;
+		SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return false;
+	}
+
+	const char* lastPos = buf;
+	const char* p = buf;
+
+	buf[length] = 0;
+	while( *p ) {
+		assert( p < (buf+length) );
+		if ( *p == 0xa ) {
+			// Newline character. No special rules for this. Append all the characters
+			// since the last string, and include the newline.
+			data.append( lastPos, (p-lastPos+1) );	// append, include the newline
+			++p;									// move past the newline
+			lastPos = p;							// and point to the new buffer (may be 0)
+			assert( p <= (buf+length) );
+		}
+		else if ( *p == 0xd ) {
+			// Carriage return. Append what we have so far, then
+			// handle moving forward in the buffer.
+			if ( (p-lastPos) > 0 ) {
+				data.append( lastPos, p-lastPos );	// do not add the CR
+			}
+			data += (char)0xa;						// a proper newline
+
+			if ( *(p+1) == 0xa ) {
+				// Carriage return - new line sequence
+				p += 2;
+				lastPos = p;
+				assert( p <= (buf+length) );
+			}
+			else {
+				// it was followed by something else...that is presumably characters again.
+				++p;
+				lastPos = p;
+				assert( p <= (buf+length) );
+			}
+		}
+		else {
+			++p;
+		}
+	}
+	// Handle any left over characters.
+	if ( p-lastPos ) {
+		data.append( lastPos, p-lastPos );
+	}
+	delete [] buf;
+	buf = 0;
+
+	Parse( data.c_str(), 0, encoding );
+
+	if (  Error() )
+        return false;
+    else
+		return true;
+}
+
+
+bool TiXmlDocument::SaveFile( const char * filename ) const
+{
+	// The old c stuff lives on...
+	FILE* fp = TiXmlFOpen( filename, "w" );
+	if ( fp )
+	{
+		bool result = SaveFile( fp );
+		fclose( fp );
+		return result;
+	}
+	return false;
+}
+
+
+bool TiXmlDocument::SaveFile( FILE* fp ) const
+{
+	if ( useMicrosoftBOM )
+	{
+		const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
+		const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
+		const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;
+
+		fputc( TIXML_UTF_LEAD_0, fp );
+		fputc( TIXML_UTF_LEAD_1, fp );
+		fputc( TIXML_UTF_LEAD_2, fp );
+	}
+	Print( fp, 0 );
+	return (ferror(fp) == 0);
+}
+
+
+void TiXmlDocument::CopyTo( TiXmlDocument* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->error = error;
+	target->errorId = errorId;
+	target->errorDesc = errorDesc;
+	target->tabsize = tabsize;
+	target->errorLocation = errorLocation;
+	target->useMicrosoftBOM = useMicrosoftBOM;
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}
+}
+
+
+TiXmlNode* TiXmlDocument::Clone() const
+{
+	TiXmlDocument* clone = new TiXmlDocument();
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlDocument::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+	{
+		node->Print( cfile, depth );
+		fprintf( cfile, "\n" );
+	}
+}
+
+
+bool TiXmlDocument::Accept( TiXmlVisitor* visitor ) const
+{
+	if ( visitor->VisitEnter( *this ) )
+	{
+		for ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )
+		{
+			if ( !node->Accept( visitor ) )
+				break;
+		}
+	}
+	return visitor->VisitExit( *this );
+}
+
+
+const TiXmlAttribute* TiXmlAttribute::Next() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( next->value.empty() && next->name.empty() )
+		return 0;
+	return next;
+}
+
+/*
+TiXmlAttribute* TiXmlAttribute::Next()
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( next->value.empty() && next->name.empty() )
+		return 0;
+	return next;
+}
+*/
+
+const TiXmlAttribute* TiXmlAttribute::Previous() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( prev->value.empty() && prev->name.empty() )
+		return 0;
+	return prev;
+}
+
+/*
+TiXmlAttribute* TiXmlAttribute::Previous()
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( prev->value.empty() && prev->name.empty() )
+		return 0;
+	return prev;
+}
+*/
+
+void TiXmlAttribute::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
+{
+	TIXML_STRING n, v;
+
+	EncodeString( name, &n );
+	EncodeString( value, &v );
+
+	if (value.find ('\"') == TIXML_STRING::npos) {
+		if ( cfile ) {
+		fprintf (cfile, "%s=\"%s\"", n.c_str(), v.c_str() );
+		}
+		if ( str ) {
+			(*str) += n; (*str) += "=\""; (*str) += v; (*str) += "\"";
+		}
+	}
+	else {
+		if ( cfile ) {
+		fprintf (cfile, "%s='%s'", n.c_str(), v.c_str() );
+		}
+		if ( str ) {
+			(*str) += n; (*str) += "='"; (*str) += v; (*str) += "'";
+		}
+	}
+}
+
+
+int TiXmlAttribute::QueryIntValue( int* ival ) const
+{
+	if ( TIXML_SSCANF( value.c_str(), "%d", ival ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+int TiXmlAttribute::QueryDoubleValue( double* dval ) const
+{
+	if ( TIXML_SSCANF( value.c_str(), "%lf", dval ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+void TiXmlAttribute::SetIntValue( int _value )
+{
+	char buf [64];
+	#if defined(TIXML_SNPRINTF)
+		TIXML_SNPRINTF(buf, sizeof(buf), "%d", _value);
+	#else
+		sprintf (buf, "%d", _value);
+	#endif
+	SetValue (buf);
+}
+
+void TiXmlAttribute::SetDoubleValue( double _value )
+{
+	char buf [256];
+	#if defined(TIXML_SNPRINTF)
+		TIXML_SNPRINTF( buf, sizeof(buf), "%lf", _value);
+	#else
+		sprintf (buf, "%lf", _value);
+	#endif
+	SetValue (buf);
+}
+
+int TiXmlAttribute::IntValue() const
+{
+	return atoi (value.c_str ());
+}
+
+double  TiXmlAttribute::DoubleValue() const
+{
+	return atof (value.c_str ());
+}
+
+
+TiXmlComment::TiXmlComment( const TiXmlComment& copy ) : TiXmlNode( TiXmlNode::COMMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlComment::operator=( const TiXmlComment& base )
+{
+	Clear();
+	base.CopyTo( this );
+}
+
+
+void TiXmlComment::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	for ( int i=0; i<depth; i++ )
+	{
+		fprintf( cfile,  "    " );
+	}
+	fprintf( cfile, "<!--%s-->", value.c_str() );
+}
+
+
+void TiXmlComment::CopyTo( TiXmlComment* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+bool TiXmlComment::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlComment::Clone() const
+{
+	TiXmlComment* clone = new TiXmlComment();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlText::Print( FILE* cfile, int depth ) const
+{
+	assert( cfile );
+	if ( cdata )
+	{
+		int i;
+		fprintf( cfile, "\n" );
+		for ( i=0; i<depth; i++ ) {
+			fprintf( cfile, "    " );
+		}
+		fprintf( cfile, "<![CDATA[%s]]>\n", value.c_str() );	// unformatted output
+	}
+	else
+	{
+		TIXML_STRING buffer;
+		EncodeString( value, &buffer );
+		fprintf( cfile, "%s", buffer.c_str() );
+	}
+}
+
+
+void TiXmlText::CopyTo( TiXmlText* target ) const
+{
+	TiXmlNode::CopyTo( target );
+	target->cdata = cdata;
+}
+
+
+bool TiXmlText::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlText::Clone() const
+{
+	TiXmlText* clone = 0;
+	clone = new TiXmlText( "" );
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlDeclaration::TiXmlDeclaration( const char * _version,
+									const char * _encoding,
+									const char * _standalone )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDeclaration::TiXmlDeclaration(	const std::string& _version,
+									const std::string& _encoding,
+									const std::string& _standalone )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+#endif
+
+
+TiXmlDeclaration::TiXmlDeclaration( const TiXmlDeclaration& copy )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDeclaration::operator=( const TiXmlDeclaration& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDeclaration::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
+{
+	if ( cfile ) fprintf( cfile, "<?xml " );
+	if ( str )	 (*str) += "<?xml ";
+
+	if ( !version.empty() ) {
+		if ( cfile ) fprintf (cfile, "version=\"%s\" ", version.c_str ());
+		if ( str ) { (*str) += "version=\""; (*str) += version; (*str) += "\" "; }
+	}
+	if ( !encoding.empty() ) {
+		if ( cfile ) fprintf (cfile, "encoding=\"%s\" ", encoding.c_str ());
+		if ( str ) { (*str) += "encoding=\""; (*str) += encoding; (*str) += "\" "; }
+	}
+	if ( !standalone.empty() ) {
+		if ( cfile ) fprintf (cfile, "standalone=\"%s\" ", standalone.c_str ());
+		if ( str ) { (*str) += "standalone=\""; (*str) += standalone; (*str) += "\" "; }
+	}
+	if ( cfile ) fprintf( cfile, "?>" );
+	if ( str )	 (*str) += "?>";
+}
+
+
+void TiXmlDeclaration::CopyTo( TiXmlDeclaration* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->version = version;
+	target->encoding = encoding;
+	target->standalone = standalone;
+}
+
+
+bool TiXmlDeclaration::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlDeclaration::Clone() const
+{
+	TiXmlDeclaration* clone = new TiXmlDeclaration();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+TiXmlStylesheetReference::TiXmlStylesheetReference( const char * _type,
+													const char * _href )
+	: TiXmlNode( TiXmlNode::STYLESHEETREFERENCE )
+{
+	type = _type;
+	href = _href;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlStylesheetReference::TiXmlStylesheetReference(	const std::string& _type,
+													const std::string& _href )
+	: TiXmlNode( TiXmlNode::STYLESHEETREFERENCE )
+{
+	type = _type;
+	href = _href;
+}
+#endif
+
+
+TiXmlStylesheetReference::TiXmlStylesheetReference( const TiXmlStylesheetReference& copy )
+	: TiXmlNode( TiXmlNode::STYLESHEETREFERENCE )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlStylesheetReference::operator=( const TiXmlStylesheetReference& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+void TiXmlStylesheetReference::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const
+{
+	if ( cfile ) fprintf( cfile, "<?xml-stylesheet " );
+	if ( str )	 (*str) += "<?xml-stylesheet ";
+
+	if ( !type.empty() ) {
+		if ( cfile ) fprintf (cfile, "type=\"%s\" ", type.c_str ());
+		if ( str ) { (*str) += "type=\""; (*str) += type; (*str) += "\" "; }
+	}
+	if ( !href.empty() ) {
+		if ( cfile ) fprintf (cfile, "href=\"%s\" ", href.c_str ());
+		if ( str ) { (*str) += "href=\""; (*str) += href; (*str) += "\" "; }
+	}
+	if ( cfile ) fprintf (cfile, "?>");
+	if ( str )	 (*str) += "?>";
+}
+
+void TiXmlStylesheetReference::CopyTo( TiXmlStylesheetReference* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->type = type;
+	target->href = href;
+}
+
+bool TiXmlStylesheetReference::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+TiXmlNode* TiXmlStylesheetReference::Clone() const
+{
+	TiXmlStylesheetReference* clone = new TiXmlStylesheetReference();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlUnknown::Print( FILE* cfile, int depth ) const
+{
+	for ( int i=0; i<depth; i++ )
+		fprintf( cfile, "    " );
+	fprintf( cfile, "<%s>", value.c_str() );
+}
+
+
+void TiXmlUnknown::CopyTo( TiXmlUnknown* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+bool TiXmlUnknown::Accept( TiXmlVisitor* visitor ) const
+{
+	return visitor->Visit( *this );
+}
+
+
+TiXmlNode* TiXmlUnknown::Clone() const
+{
+	TiXmlUnknown* clone = new TiXmlUnknown();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlAttributeSet::TiXmlAttributeSet()
+{
+	sentinel.next = &sentinel;
+	sentinel.prev = &sentinel;
+}
+
+
+TiXmlAttributeSet::~TiXmlAttributeSet()
+{
+	assert( sentinel.next == &sentinel );
+	assert( sentinel.prev == &sentinel );
+}
+
+
+void TiXmlAttributeSet::Add( TiXmlAttribute* addMe )
+{
+    #ifdef TIXML_USE_STL
+	assert( !Find( TIXML_STRING( addMe->Name() ) ) );	// Shouldn't be multiply adding to the set.
+	#else
+	assert( !Find( addMe->Name() ) );	// Shouldn't be multiply adding to the set.
+	#endif
+
+	addMe->next = &sentinel;
+	addMe->prev = sentinel.prev;
+
+	sentinel.prev->next = addMe;
+	sentinel.prev      = addMe;
+}
+
+void TiXmlAttributeSet::Remove( TiXmlAttribute* removeMe )
+{
+	assert(removeMe);
+	TiXmlAttribute* node;
+
+	for( node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node == removeMe )
+		{
+			node->prev->next = node->next;
+			node->next->prev = node->prev;
+			node->next = 0;
+			node->prev = 0;
+			return;
+		}
+	}
+	assert( 0 );		// we tried to remove a non-linked attribute.
+}
+
+
+#ifdef TIXML_USE_STL
+const TiXmlAttribute* TiXmlAttributeSet::Find( const std::string& name ) const
+{
+	for( const TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node->name == name )
+			return node;
+	}
+	return 0;
+}
+
+/*
+TiXmlAttribute*	TiXmlAttributeSet::Find( const std::string& name )
+{
+	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node->name == name )
+			return node;
+	}
+	return 0;
+}
+*/
+#endif
+
+
+const TiXmlAttribute* TiXmlAttributeSet::Find( const char* name ) const
+{
+	for( const TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( strcmp( node->name.c_str(), name ) == 0 )
+			return node;
+	}
+	return 0;
+}
+
+/*
+TiXmlAttribute*	TiXmlAttributeSet::Find( const char* name )
+{
+	for( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( strcmp( node->name.c_str(), name ) == 0 )
+			return node;
+	}
+	return 0;
+}
+*/
+
+#ifdef TIXML_USE_STL
+std::istream& operator>> (std::istream & in, TiXmlNode & base)
+{
+	TIXML_STRING tag;
+	tag.reserve( 8 * 1000 );
+	base.StreamIn( &in, &tag );
+
+	base.Parse( tag.c_str(), 0, TIXML_DEFAULT_ENCODING );
+	return in;
+}
+#endif
+
+
+#ifdef TIXML_USE_STL
+std::ostream& operator<< (std::ostream & out, const TiXmlNode & base)
+{
+	TiXmlPrinter printer;
+	printer.SetStreamPrinting();
+	base.Accept( &printer );
+	out << printer.Str();
+
+	return out;
+}
+
+
+std::string& operator<< (std::string& out, const TiXmlNode& base )
+{
+	TiXmlPrinter printer;
+	printer.SetStreamPrinting();
+	base.Accept( &printer );
+	out.append( printer.Str() );
+
+	return out;
+}
+#endif
+
+
+TiXmlHandle TiXmlHandle::FirstChild() const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChild( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement() const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+bool TiXmlPrinter::VisitEnter( const TiXmlDocument& )
+{
+	return true;
+}
+
+bool TiXmlPrinter::VisitExit( const TiXmlDocument& )
+{
+	return true;
+}
+
+bool TiXmlPrinter::VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute )
+{
+	DoIndent();
+	buffer += "<";
+	buffer += element.Value();
+
+	for( const TiXmlAttribute* attrib = firstAttribute; attrib; attrib = attrib->Next() )
+	{
+		buffer += " ";
+		attrib->Print( 0, 0, &buffer );
+	}
+
+	if ( !element.FirstChild() )
+	{
+		buffer += " />";
+		DoLineBreak();
+	}
+	else
+	{
+		buffer += ">";
+		if (    element.FirstChild()->ToText()
+			  && element.LastChild() == element.FirstChild()
+			  && element.FirstChild()->ToText()->CDATA() == false )
+		{
+			simpleTextPrint = true;
+			// no DoLineBreak()!
+		}
+		else
+		{
+			DoLineBreak();
+		}
+	}
+	++depth;
+	return true;
+}
+
+
+bool TiXmlPrinter::VisitExit( const TiXmlElement& element )
+{
+	--depth;
+	if ( !element.FirstChild() )
+	{
+		// nothing.
+	}
+	else
+	{
+		if ( simpleTextPrint )
+		{
+			simpleTextPrint = false;
+		}
+		else
+		{
+			DoIndent();
+		}
+		buffer += "</";
+		buffer += element.Value();
+		buffer += ">";
+		DoLineBreak();
+	}
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlText& text )
+{
+	if ( text.CDATA() )
+	{
+		DoIndent();
+		buffer += "<![CDATA[";
+		buffer += text.Value();
+		buffer += "]]>";
+		DoLineBreak();
+	}
+	else if ( simpleTextPrint )
+	{
+		TIXML_STRING str;
+		TiXmlBase::EncodeString( text.ValueTStr(), &str );
+		buffer += str;
+	}
+	else
+	{
+		DoIndent();
+		TIXML_STRING str;
+		TiXmlBase::EncodeString( text.ValueTStr(), &str );
+		buffer += str;
+		DoLineBreak();
+	}
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlDeclaration& declaration )
+{
+	DoIndent();
+	declaration.Print( 0, 0, &buffer );
+	DoLineBreak();
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlComment& comment )
+{
+	DoIndent();
+	buffer += "<!--";
+	buffer += comment.Value();
+	buffer += "-->";
+	DoLineBreak();
+	return true;
+}
+
+
+bool TiXmlPrinter::Visit( const TiXmlUnknown& unknown )
+{
+	DoIndent();
+	buffer += "<";
+	buffer += unknown.Value();
+	buffer += ">";
+	DoLineBreak();
+	return true;
+}
+
+bool TiXmlPrinter::Visit( const TiXmlStylesheetReference& stylesheet )
+{
+	    DoIndent();
+	    stylesheet.Print( 0, 0, &buffer );
+	    DoLineBreak();
+	    return true;
+}
diff -Naur wxFormBuilder.orig/subprojects/ticpp/tinyxml.h wxFormBuilder/subprojects/ticpp/tinyxml.h
--- wxFormBuilder.orig/subprojects/ticpp/tinyxml.h	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/tinyxml.h	2019-11-18 10:42:57.712406052 +0100
@@ -0,0 +1,1887 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+ /*
+ * THIS FILE WAS ALTERED BY Matt Janisz, 12. October 2012.
+ *
+ * - added ticppapi.h include and TICPP_API dll-interface to support building DLL using VS200X
+ */
+
+#ifndef TINYXML_INCLUDED
+#define TINYXML_INCLUDED
+
+#ifdef _MSC_VER
+#pragma warning( push )
+#pragma warning( disable : 4530 )
+#pragma warning( disable : 4786 )
+#endif
+
+#include "ticppapi.h"
+#include <cstring>
+#include <cassert>
+
+// Help out windows:
+#if defined( _DEBUG ) && !defined( DEBUG )
+#define DEBUG
+#endif
+
+#ifdef TIXML_USE_TICPP
+	#ifndef TIXML_USE_STL
+		#define TIXML_USE_STL
+	#endif
+#endif
+
+#ifdef TIXML_USE_STL
+	#include <string>
+ 	#include <iostream>
+	#include <sstream>
+	#define TIXML_STRING		std::string
+#else
+	#include "tinystr.h"
+	#define TIXML_STRING		TiXmlString
+#endif
+
+// Deprecated library function hell. Compilers want to use the
+// new safe versions. This probably doesn't fully address the problem,
+// but it gets closer. There are too many compilers for me to fully
+// test. If you get compilation troubles, undefine TIXML_SAFE
+#define TIXML_SAFE
+
+#ifdef TIXML_SAFE
+	#if defined(_MSC_VER) && (_MSC_VER >= 1400 )
+		// Microsoft visual studio, version 2005 and higher.
+		#define TIXML_SNPRINTF _snprintf_s
+		#define TIXML_SNSCANF  _snscanf_s
+		#define TIXML_SSCANF   sscanf_s
+	#elif defined(_MSC_VER) && (_MSC_VER >= 1200 )
+		// Microsoft visual studio, version 6 and higher.
+		//#pragma message( "Using _sn* functions." )
+		#define TIXML_SNPRINTF _snprintf
+		#define TIXML_SNSCANF  _snscanf
+		#define TIXML_SSCANF   sscanf
+	#elif defined(__GNUC__) && (__GNUC__ >= 3 )
+		// GCC version 3 and higher.s
+		//#warning( "Using sn* functions." )
+		#define TIXML_SNPRINTF snprintf
+		#define TIXML_SNSCANF  snscanf
+		#define TIXML_SSCANF   sscanf
+	#else
+		#define TIXML_SSCANF   sscanf
+	#endif
+#endif
+
+class TICPP_API TiXmlDocument;
+class TICPP_API TiXmlElement;
+class TICPP_API TiXmlComment;
+class TICPP_API TiXmlUnknown;
+class TICPP_API TiXmlAttribute;
+class TICPP_API TiXmlText;
+class TICPP_API TiXmlDeclaration;
+class TICPP_API TiXmlStylesheetReference;
+class TICPP_API TiXmlParsingData;
+
+const int TIXML_MAJOR_VERSION = 2;
+const int TIXML_MINOR_VERSION = 5;
+const int TIXML_PATCH_VERSION = 3;
+
+/*	Internal structure for tracking location of items
+	in the XML file.
+*/
+struct TICPP_API TiXmlCursor
+{
+	TiXmlCursor()		{ Clear(); }
+	void Clear()		{ row = col = -1; }
+
+	int row;	// 0 based.
+	int col;	// 0 based.
+};
+
+
+/**
+	If you call the Accept() method, it requires being passed a TiXmlVisitor
+	class to handle callbacks. For nodes that contain other nodes (Document, Element)
+	you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves
+	are simple called with Visit().
+
+	If you return 'true' from a Visit method, recursive parsing will continue. If you return
+	false, <b>no children of this node or its sibilings</b> will be Visited.
+
+	All flavors of Visit methods have a default implementation that returns 'true' (continue
+	visiting). You need to only override methods that are interesting to you.
+
+	Generally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.
+
+	You should never change the document from a callback.
+
+	@sa TiXmlNode::Accept()
+*/
+class TICPP_API TiXmlVisitor
+{
+public:
+	virtual ~TiXmlVisitor() {}
+
+	/// Visit a document.
+	virtual bool VisitEnter( const TiXmlDocument& /*doc*/ )			{ return true; }
+	/// Visit a document.
+	virtual bool VisitExit( const TiXmlDocument& /*doc*/ )			{ return true; }
+
+	/// Visit an element.
+	virtual bool VisitEnter( const TiXmlElement& /*element*/, const TiXmlAttribute* /*firstAttribute*/ )	{ return true; }
+	/// Visit an element.
+	virtual bool VisitExit( const TiXmlElement& /*element*/ )		{ return true; }
+
+	/// Visit a declaration
+	virtual bool Visit( const TiXmlDeclaration& /*declaration*/ )	{ return true; }
+	/// Visit a stylesheet reference
+	virtual bool Visit( const TiXmlStylesheetReference& /*stylesheet*/ )	{ return true; }
+	/// Visit a text node
+	virtual bool Visit( const TiXmlText& /*text*/ )					{ return true; }
+	/// Visit a comment node
+	virtual bool Visit( const TiXmlComment& /*comment*/ )			{ return true; }
+	/// Visit an unknow node
+	virtual bool Visit( const TiXmlUnknown& /*unknown*/ )			{ return true; }
+};
+
+// Only used by Attribute::Query functions
+enum
+{
+	TIXML_SUCCESS,
+	TIXML_NO_ATTRIBUTE,
+	TIXML_WRONG_TYPE
+};
+
+
+// Used by the parsing routines.
+enum TiXmlEncoding
+{
+	TIXML_ENCODING_UNKNOWN,
+	TIXML_ENCODING_UTF8,
+	TIXML_ENCODING_LEGACY
+};
+
+const TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;
+
+/** TiXmlBase is a base class for every class in TinyXml.
+	It does little except to establish that TinyXml classes
+	can be printed and provide some utility functions.
+
+	In XML, the document and elements can contain
+	other elements and other types of nodes.
+
+	@verbatim
+	A Document can contain:	Element	(container or leaf)
+							Comment (leaf)
+							Unknown (leaf)
+							Declaration( leaf )
+
+	An Element can contain:	Element (container or leaf)
+							Text	(leaf)
+							Attributes (not on tree)
+							Comment (leaf)
+							Unknown (leaf)
+
+	A Decleration contains: Attributes (not on tree)
+	@endverbatim
+*/
+#ifdef TIXML_USE_TICPP
+#include "ticpprc.h"
+class TICPP_API TiXmlBase : public TiCppRC
+#else
+class TICPP_API TiXmlBase
+#endif
+{
+	friend class TiXmlNode;
+	friend class TiXmlElement;
+	friend class TiXmlDocument;
+
+public:
+	TiXmlBase()	:	userData(0)		{}
+	virtual ~TiXmlBase()			{}
+
+	/**	All TinyXml classes can print themselves to a filestream
+		or the string class (TiXmlString in non-STL mode, std::string
+		in STL mode.) Either or both cfile and str can be null.
+
+		This is a formatted print, and will insert
+		tabs and newlines.
+
+		(For an unformatted stream, use the << operator.)
+	*/
+	virtual void Print( FILE* cfile, int depth ) const = 0;
+
+	/**	The world does not agree on whether white space should be kept or
+		not. In order to make everyone happy, these global, static functions
+		are provided to set whether or not TinyXml will condense all white space
+		into a single space or not. The default is to condense. Note changing this
+		value is not thread safe.
+	*/
+	static void SetCondenseWhiteSpace( bool condense )		{ condenseWhiteSpace = condense; }
+
+	/// Return the current white space setting.
+	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }
+
+	/** Return the position, in the original source file, of this node or attribute.
+		The row and column are 1-based. (That is the first row and first column is
+		1,1). If the returns values are 0 or less, then the parser does not have
+		a row and column value.
+
+		Generally, the row and column value will be set when the TiXmlDocument::Load(),
+		TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
+		when the DOM was created from operator>>.
+
+		The values reflect the initial load. Once the DOM is modified programmatically
+		(by adding or changing nodes and attributes) the new values will NOT update to
+		reflect changes in the document.
+
+		There is a minor performance cost to computing the row and column. Computation
+		can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.
+
+		@sa TiXmlDocument::SetTabSize()
+	*/
+	int Row() const			{ return location.row + 1; }
+	int Column() const		{ return location.col + 1; }	///< See Row()
+
+	void  SetUserData( void* user )			{ userData = user; }	///< Set a pointer to arbitrary user data.
+	void* GetUserData()						{ return userData; }	///< Get a pointer to arbitrary user data.
+	const void* GetUserData() const 		{ return userData; }	///< Get a pointer to arbitrary user data.
+
+	// Table that returs, for a given lead byte, the total number of bytes
+	// in the UTF-8 sequence.
+	static const int utf8ByteTable[256];
+
+	virtual const char* Parse(	const char* p,
+								TiXmlParsingData* data,
+								TiXmlEncoding encoding /*= TIXML_ENCODING_UNKNOWN */ ) = 0;
+
+	/** Expands entities in a string. Note this should not contian the tag's '<', '>', etc,
+		or they will be transformed into entities!
+	*/
+	static void EncodeString( const TIXML_STRING& str, TIXML_STRING* out );
+
+	enum
+	{
+		TIXML_NO_ERROR = 0,
+		TIXML_ERROR,
+		TIXML_ERROR_OPENING_FILE,
+		TIXML_ERROR_OUT_OF_MEMORY,
+		TIXML_ERROR_PARSING_ELEMENT,
+		TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
+		TIXML_ERROR_READING_ELEMENT_VALUE,
+		TIXML_ERROR_READING_ATTRIBUTES,
+		TIXML_ERROR_PARSING_EMPTY,
+		TIXML_ERROR_READING_END_TAG,
+		TIXML_ERROR_PARSING_UNKNOWN,
+		TIXML_ERROR_PARSING_COMMENT,
+		TIXML_ERROR_PARSING_DECLARATION,
+		TIXML_ERROR_DOCUMENT_EMPTY,
+		TIXML_ERROR_EMBEDDED_NULL,
+		TIXML_ERROR_PARSING_CDATA,
+		TIXML_ERROR_DOCUMENT_TOP_ONLY,
+
+		TIXML_ERROR_STRING_COUNT
+	};
+
+protected:
+
+	static const char* SkipWhiteSpace( const char*, TiXmlEncoding encoding );
+	inline static bool IsWhiteSpace( char c )
+	{
+		return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' );
+	}
+	inline static bool IsWhiteSpace( int c )
+	{
+		if ( c < 256 )
+			return IsWhiteSpace( (char) c );
+		return false;	// Again, only truly correct for English/Latin...but usually works.
+	}
+
+	#ifdef TIXML_USE_STL
+	static bool	StreamWhiteSpace( std::istream * in, TIXML_STRING * tag );
+	static bool StreamTo( std::istream * in, int character, TIXML_STRING * tag );
+	#endif
+
+	/*	Reads an XML name into the string provided. Returns
+		a pointer just past the last character of the name,
+		or 0 if the function has an error.
+	*/
+	static const char* ReadName( const char* p, TIXML_STRING* name, TiXmlEncoding encoding );
+
+	/*	Reads text. Returns a pointer past the given end tag.
+		Wickedly complex options, but it keeps the (sensitive) code in one place.
+	*/
+	static const char* ReadText(	const char* in,				// where to start
+									TIXML_STRING* text,			// the string read
+									bool ignoreWhiteSpace,		// whether to keep the white space
+									const char* endTag,			// what ends this text
+									bool ignoreCase,			// whether to ignore case in the end tag
+									TiXmlEncoding encoding );	// the current encoding
+
+	// If an entity has been found, transform it into a character.
+	static const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );
+
+	// Get a character, while interpreting entities.
+	// The length can be from 0 to 4 bytes.
+	inline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )
+	{
+		assert( p );
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			*length = utf8ByteTable[ *((const unsigned char*)p) ];
+			assert( *length >= 0 && *length < 5 );
+		}
+		else
+		{
+			*length = 1;
+		}
+
+		if ( *length == 1 )
+		{
+			if ( *p == '&' )
+				return GetEntity( p, _value, length, encoding );
+			*_value = *p;
+			return p+1;
+		}
+		else if ( *length )
+		{
+			//strncpy( _value, p, *length );	// lots of compilers don't like this function (unsafe),
+												// and the null terminator isn't needed
+			for( int i=0; p[i] && i<*length; ++i ) {
+				_value[i] = p[i];
+			}
+			return p + (*length);
+		}
+		else
+		{
+			// Not valid text.
+			return 0;
+		}
+	}
+
+	// Return true if the next characters in the stream are any of the endTag sequences.
+	// Ignore case only works for english, and should only be relied on when comparing
+	// to English words: StringEqual( p, "version", true ) is fine.
+	static bool StringEqual(	const char* p,
+								const char* endTag,
+								bool ignoreCase,
+								TiXmlEncoding encoding );
+
+	static const char* errorString[ TIXML_ERROR_STRING_COUNT ];
+
+	TiXmlCursor location;
+
+    /// Field containing a generic user pointer
+	void*			userData;
+
+	// None of these methods are reliable for any language except English.
+	// Good for approximation, not great for accuracy.
+	static int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );
+	static int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );
+	inline static int ToLower( int v, TiXmlEncoding encoding )
+	{
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			if ( v < 128 ) return tolower( v );
+			return v;
+		}
+		else
+		{
+			return tolower( v );
+		}
+	}
+	static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );
+
+private:
+	TiXmlBase( const TiXmlBase& );				// not implemented.
+	void operator=( const TiXmlBase& base );	// not allowed.
+
+	struct Entity
+	{
+		const char*     str;
+		unsigned int	strLength;
+		char		    chr;
+	};
+	enum
+	{
+		NUM_ENTITY = 5,
+		MAX_ENTITY_LENGTH = 6
+
+	};
+	static Entity entity[ NUM_ENTITY ];
+	static bool condenseWhiteSpace;
+};
+
+
+/** The parent class for everything in the Document Object Model.
+	(Except for attributes).
+	Nodes have siblings, a parent, and children. A node can be
+	in a document, or stand on its own. The type of a TiXmlNode
+	can be queried, and it can be cast to its more defined type.
+*/
+class TICPP_API TiXmlNode : public TiXmlBase
+{
+	friend class TiXmlDocument;
+	friend class TiXmlElement;
+
+public:
+	#ifdef TIXML_USE_STL
+
+	    /** An input stream operator, for every class. Tolerant of newlines and
+		    formatting, but doesn't expect them.
+	    */
+	    friend std::istream& operator >> (std::istream& in, TiXmlNode& base);
+
+	    /** An output stream operator, for every class. Note that this outputs
+		    without any newlines or formatting, as opposed to Print(), which
+		    includes tabs and new lines.
+
+		    The operator<< and operator>> are not completely symmetric. Writing
+		    a node to a stream is very well defined. You'll get a nice stream
+		    of output, without any extra whitespace or newlines.
+
+		    But reading is not as well defined. (As it always is.) If you create
+		    a TiXmlElement (for example) and read that from an input stream,
+		    the text needs to define an element or junk will result. This is
+		    true of all input streams, but it's worth keeping in mind.
+
+		    A TiXmlDocument will read nodes until it reads a root element, and
+			all the children of that root element.
+	    */
+	    friend std::ostream& operator<< (std::ostream& out, const TiXmlNode& base);
+
+		/// Appends the XML node or attribute to a std::string.
+		friend std::string& operator<< (std::string& out, const TiXmlNode& base );
+
+	#endif
+
+	/** The types of XML nodes supported by TinyXml. (All the
+			unsupported types are picked up by UNKNOWN.)
+	*/
+	enum NodeType
+	{
+		DOCUMENT,
+		ELEMENT,
+		COMMENT,
+		UNKNOWN,
+		TEXT,
+		DECLARATION,
+		STYLESHEETREFERENCE,
+		TYPECOUNT
+	};
+
+	virtual ~TiXmlNode();
+
+	/** The meaning of 'value' changes for the specific type of
+		TiXmlNode.
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+
+		The subclasses will wrap this function.
+	*/
+	const char *Value() const { return value.c_str (); }
+
+    #ifdef TIXML_USE_STL
+	/** Return Value() as a std::string. If you only use STL,
+	    this is more efficient than calling Value().
+		Only available in STL mode.
+	*/
+	const std::string& ValueStr() const { return value; }
+	#endif
+
+	const TIXML_STRING& ValueTStr() const { return value; }
+
+	/** Changes the value of the node. Defined as:
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+	*/
+	void SetValue(const char * _value) { value = _value;}
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetValue( const std::string& _value )	{ value = _value; }
+	#endif
+
+	/// Delete all the children of this node. Does not affect 'this'.
+	void Clear();
+
+	/// One step up the DOM.
+	TiXmlNode* Parent()							{ return parent; }
+	const TiXmlNode* Parent() const				{ return parent; }
+
+	const TiXmlNode* FirstChild()	const		{ return firstChild; }	///< The first child of this node. Will be null if there are no children.
+	TiXmlNode* FirstChild()						{ return firstChild; }
+	const TiXmlNode* FirstChild( const char * value ) const;			///< The first child of this node with the matching 'value'. Will be null if none found.
+	/// The first child of this node with the matching 'value'. Will be null if none found.
+	TiXmlNode* FirstChild( const char * _value ) {
+		// Call through to the const version - safe since nothing is changed. Exiting syntax: cast this to a const (always safe)
+		// call the method, cast the return back to non-const.
+		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->FirstChild( _value ));
+	}
+	const TiXmlNode* LastChild() const	{ return lastChild; }		/// The last child of this node. Will be null if there are no children.
+	TiXmlNode* LastChild()	{ return lastChild; }
+
+	const TiXmlNode* LastChild( const char * value ) const;			/// The last child of this node matching 'value'. Will be null if there are no children.
+	TiXmlNode* LastChild( const char * _value ) {
+		return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->LastChild( _value ));
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* FirstChild( const std::string& _value ) const	{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* FirstChild( const std::string& _value )				{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
+	const TiXmlNode* LastChild( const std::string& _value ) const	{	return LastChild (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* LastChild( const std::string& _value )				{	return LastChild (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** An alternate way to walk the children of a node.
+		One way to iterate over nodes is:
+		@verbatim
+			for( child = parent->FirstChild(); child; child = child->NextSibling() )
+		@endverbatim
+
+		IterateChildren does the same thing with the syntax:
+		@verbatim
+			child = 0;
+			while( child = parent->IterateChildren( child ) )
+		@endverbatim
+
+		IterateChildren takes the previous child as input and finds
+		the next one. If the previous child is null, it returns the
+		first. IterateChildren will return null when done.
+	*/
+	const TiXmlNode* IterateChildren( const TiXmlNode* previous ) const;
+	TiXmlNode* IterateChildren( const TiXmlNode* previous ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( previous ) );
+	}
+
+	/// This flavor of IterateChildren searches for children with a particular 'value'
+	const TiXmlNode* IterateChildren( const char * value, const TiXmlNode* previous ) const;
+	TiXmlNode* IterateChildren( const char * _value, const TiXmlNode* previous ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( _value, previous ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) const	{	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
+	TiXmlNode* IterateChildren( const std::string& _value, const TiXmlNode* previous ) {	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
+	#endif
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertEndChild( const TiXmlNode& addThis );
+
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+
+		NOTE: the node to be added is passed by pointer, and will be
+		henceforth owned (and deleted) by tinyXml. This method is efficient
+		and avoids an extra copy, but should be used with care as it
+		uses a different memory model than the other insert functions.
+
+		@sa InsertEndChild
+	*/
+	TiXmlNode* LinkEndChild( TiXmlNode* addThis );
+
+	/** Add a new node related to this. Adds a child before the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );
+
+	/** Add a new node related to this. Adds a child after the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertAfterChild(  TiXmlNode* afterThis, const TiXmlNode& addThis );
+
+	/** Replace a child of this node.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );
+
+	/// Delete a child of this node.
+	bool RemoveChild( TiXmlNode* removeThis );
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* PreviousSibling() const			{ return prev; }
+	TiXmlNode* PreviousSibling()						{ return prev; }
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* PreviousSibling( const char * ) const;
+	TiXmlNode* PreviousSibling( const char *_prev ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->PreviousSibling( _prev ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlNode* PreviousSibling( const std::string& _value ) const	{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* PreviousSibling( const std::string& _value ) 			{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
+	const TiXmlNode* NextSibling( const std::string& _value) const		{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* NextSibling( const std::string& _value) 					{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Navigate to a sibling node.
+	const TiXmlNode* NextSibling() const				{ return next; }
+	TiXmlNode* NextSibling()							{ return next; }
+
+	/// Navigate to a sibling node with the given 'value'.
+	const TiXmlNode* NextSibling( const char * ) const;
+	TiXmlNode* NextSibling( const char* _next ) {
+		return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->NextSibling( _next ) );
+	}
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	const TiXmlElement* NextSiblingElement() const;
+	TiXmlElement* NextSiblingElement() {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement() );
+	}
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	const TiXmlElement* NextSiblingElement( const char * ) const;
+	TiXmlElement* NextSiblingElement( const char *_next ) {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement( _next ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlElement* NextSiblingElement( const std::string& _value) const	{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
+	TiXmlElement* NextSiblingElement( const std::string& _value)				{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Convenience function to get through elements.
+	const TiXmlElement* FirstChildElement()	const;
+	TiXmlElement* FirstChildElement() {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement() );
+	}
+
+	/// Convenience function to get through elements.
+	const TiXmlElement* FirstChildElement( const char * _value ) const;
+	TiXmlElement* FirstChildElement( const char * _value ) {
+		return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement( _value ) );
+	}
+
+    #ifdef TIXML_USE_STL
+	const TiXmlElement* FirstChildElement( const std::string& _value ) const	{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
+	TiXmlElement* FirstChildElement( const std::string& _value )				{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** Query the type (as an enumerated value, above) of this node.
+		The possible types are: DOCUMENT, ELEMENT, COMMENT,
+								UNKNOWN, TEXT, and DECLARATION.
+	*/
+	int Type() const	{ return type; }
+
+	/** Return a pointer to the Document this node lives in.
+		Returns null if not in a document.
+	*/
+	const TiXmlDocument* GetDocument() const;
+	TiXmlDocument* GetDocument() {
+		return const_cast< TiXmlDocument* >( (const_cast< const TiXmlNode* >(this))->GetDocument() );
+	}
+
+	/// Returns true if this node has no children.
+	bool NoChildren() const						{ return !firstChild; }
+
+	virtual const TiXmlDocument*    ToDocument()    const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlElement*     ToElement()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlComment*     ToComment()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlUnknown*     ToUnknown()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlText*        ToText()        const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlDeclaration* ToDeclaration() const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual const TiXmlStylesheetReference* ToStylesheetReference() const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+
+	virtual TiXmlDocument*          ToDocument()    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlElement*           ToElement()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlComment*           ToComment()     { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlUnknown*           ToUnknown()	    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlText*	            ToText()        { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlDeclaration*       ToDeclaration() { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+	virtual TiXmlStylesheetReference*       ToStylesheetReference() { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.
+
+	/** Create an exact duplicate of this node and return it. The memory must be deleted
+		by the caller.
+	*/
+	virtual TiXmlNode* Clone() const = 0;
+
+	/** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the
+		XML tree will be conditionally visited and the host will be called back
+		via the TiXmlVisitor interface.
+
+		This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
+		the XML for the callbacks, so the performance of TinyXML is unchanged by using this
+		interface versus any other.)
+
+		The interface has been based on ideas from:
+
+		- http://www.saxproject.org/
+		- http://c2.com/cgi/wiki?HierarchicalVisitorPattern
+
+		Which are both good references for "visiting".
+
+		An example of using Accept():
+		@verbatim
+		TiXmlPrinter printer;
+		tinyxmlDoc.Accept( &printer );
+		const char* xmlcstr = printer.CStr();
+		@endverbatim
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const = 0;
+
+protected:
+	TiXmlNode( NodeType _type );
+
+	// Copy to the allocated object. Shared functionality between Clone, Copy constructor,
+	// and the assignment operator.
+	void CopyTo( TiXmlNode* target ) const;
+
+	#ifdef TIXML_USE_STL
+	    // The real work of the input operator.
+	virtual void StreamIn( std::istream* in, TIXML_STRING* tag ) = 0;
+	#endif
+
+	// Figure out what is at *p, and parse it. Returns null if it is not an xml node.
+	TiXmlNode* Identify( const char* start, TiXmlEncoding encoding );
+
+	TiXmlNode*		parent;
+	NodeType		type;
+
+	TiXmlNode*		firstChild;
+	TiXmlNode*		lastChild;
+
+	TIXML_STRING	value;
+
+	TiXmlNode*		prev;
+	TiXmlNode*		next;
+
+private:
+	TiXmlNode( const TiXmlNode& );				// not implemented.
+	void operator=( const TiXmlNode& base );	// not allowed.
+};
+
+
+/** An attribute is a name-value pair. Elements have an arbitrary
+	number of attributes, each with a unique name.
+
+	@note The attributes are not TiXmlNodes, since they are not
+		  part of the tinyXML document object model. There are other
+		  suggested ways to look at this problem.
+*/
+class TICPP_API TiXmlAttribute : public TiXmlBase
+{
+	friend class TiXmlAttributeSet;
+
+public:
+	/// Construct an empty attribute.
+	TiXmlAttribute() : TiXmlBase()
+	{
+		document = 0;
+		prev = next = 0;
+	}
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlAttribute( const std::string& _name, const std::string& _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+	#endif
+
+	/// Construct an attribute with a name and value.
+	TiXmlAttribute( const char * _name, const char * _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+
+	const char*		Name()  const		{ return name.c_str(); }		///< Return the name of this attribute.
+	const char*		Value() const		{ return value.c_str(); }		///< Return the value of this attribute.
+	#ifdef TIXML_USE_STL
+	const std::string& ValueStr() const	{ return value; }				///< Return the value of this attribute.
+	#endif
+	int				IntValue() const;									///< Return the value of this attribute, converted to an integer.
+	double			DoubleValue() const;								///< Return the value of this attribute, converted to a double.
+
+	// Get the tinyxml string representation
+	const TIXML_STRING& NameTStr() const { return name; }
+
+	/** QueryIntValue examines the value string. It is an alternative to the
+		IntValue() method with richer error checking.
+		If the value is an integer, it is stored in 'value' and
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE.
+
+		A specialized but useful call. Note that for success it returns 0,
+		which is the opposite of almost all other TinyXml calls.
+	*/
+	int QueryIntValue( int* _value ) const;
+	/// QueryDoubleValue examines the value string. See QueryIntValue().
+	int QueryDoubleValue( double* _value ) const;
+
+	void SetName( const char* _name )	{ name = _name; }				///< Set the name of this attribute.
+	void SetValue( const char* _value )	{ value = _value; }				///< Set the value.
+
+	void SetIntValue( int _value );										///< Set the value from an integer.
+	void SetDoubleValue( double _value );								///< Set the value from a double.
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetName( const std::string& _name )	{ name = _name; }
+	/// STL std::string form.
+	void SetValue( const std::string& _value )	{ value = _value; }
+	#endif
+
+	/// Get the next sibling attribute in the DOM. Returns null at end.
+	const TiXmlAttribute* Next() const;
+	TiXmlAttribute* Next() {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Next() );
+	}
+
+	/// Get the previous sibling attribute in the DOM. Returns null at beginning.
+	const TiXmlAttribute* Previous() const;
+	TiXmlAttribute* Previous() {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Previous() );
+	}
+
+	bool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }
+	bool operator<( const TiXmlAttribute& rhs )	 const { return name < rhs.name; }
+	bool operator>( const TiXmlAttribute& rhs )  const { return name > rhs.name; }
+
+	/*	Attribute parsing starts: first letter of the name
+						 returns: the next char after the value end quote
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	// Prints this Attribute to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const {
+		Print( cfile, depth, 0 );
+	}
+	void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
+
+	// [internal use]
+	// Set the document pointer so the attribute can report errors.
+	void SetDocument( TiXmlDocument* doc )	{ document = doc; }
+
+private:
+	TiXmlAttribute( const TiXmlAttribute& );				// not implemented.
+	void operator=( const TiXmlAttribute& base );	// not allowed.
+
+	TiXmlDocument*	document;	// A pointer back to a document, for error reporting.
+	TIXML_STRING name;
+	TIXML_STRING value;
+	TiXmlAttribute*	prev;
+	TiXmlAttribute*	next;
+};
+
+
+/*	A class used to manage a group of attributes.
+	It is only used internally, both by the ELEMENT and the DECLARATION.
+
+	The set can be changed transparent to the Element and Declaration
+	classes that use it, but NOT transparent to the Attribute
+	which has to implement a next() and previous() method. Which makes
+	it a bit problematic and prevents the use of STL.
+
+	This version is implemented with circular lists because:
+		- I like circular lists
+		- it demonstrates some independence from the (typical) doubly linked list.
+*/
+class TICPP_API TiXmlAttributeSet
+{
+public:
+	TiXmlAttributeSet();
+	~TiXmlAttributeSet();
+
+	void Add( TiXmlAttribute* attribute );
+	void Remove( TiXmlAttribute* attribute );
+
+	const TiXmlAttribute* First()	const	{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
+	TiXmlAttribute* First()					{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
+	const TiXmlAttribute* Last() const		{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
+	TiXmlAttribute* Last()					{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
+
+	const TiXmlAttribute*	Find( const char* _name ) const;
+	TiXmlAttribute*	Find( const char* _name ) {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttributeSet* >(this))->Find( _name ) );
+	}
+	#ifdef TIXML_USE_STL
+	const TiXmlAttribute*	Find( const std::string& _name ) const;
+	TiXmlAttribute*	Find( const std::string& _name ) {
+		return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttributeSet* >(this))->Find( _name ) );
+	}
+
+	#endif
+
+private:
+	//*ME:	Because of hidden/disabled copy-construktor in TiXmlAttribute (sentinel-element),
+	//*ME:	this class must be also use a hidden/disabled copy-constructor !!!
+	TiXmlAttributeSet( const TiXmlAttributeSet& );	// not allowed
+	void operator=( const TiXmlAttributeSet& );	// not allowed (as TiXmlAttribute)
+
+	TiXmlAttribute sentinel;
+};
+
+
+/** The element is a container class. It has a value, the element name,
+	and can contain other elements, text, comments, and unknowns.
+	Elements also contain an arbitrary number of attributes.
+*/
+class TICPP_API TiXmlElement : public TiXmlNode
+{
+public:
+	/// Construct an element.
+	TiXmlElement (const char * in_value);
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlElement( const std::string& _value );
+	#endif
+
+	TiXmlElement( const TiXmlElement& );
+
+	void operator=( const TiXmlElement& base );
+
+	virtual ~TiXmlElement();
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+	*/
+	const char* Attribute( const char* name ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an integer,
+		the integer value will be put in the return 'i', if 'i'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, int* i ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an double,
+		the double value will be put in the return 'd', if 'd'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, double* d ) const;
+
+	/** QueryIntAttribute examines the attribute - it is an alternative to the
+		Attribute() method with richer error checking.
+		If the attribute is an integer, it is stored in 'value' and
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE. If the attribute
+		does not exist, then TIXML_NO_ATTRIBUTE is returned.
+	*/
+	int QueryIntAttribute( const char* name, int* _value ) const;
+	/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().
+	int QueryDoubleAttribute( const char* name, double* _value ) const;
+	/// QueryFloatAttribute examines the attribute - see QueryIntAttribute().
+	int QueryFloatAttribute( const char* name, float* _value ) const {
+		double d;
+		int result = QueryDoubleAttribute( name, &d );
+		if ( result == TIXML_SUCCESS ) {
+			*_value = (float)d;
+		}
+		return result;
+	}
+
+    #ifdef TIXML_USE_STL
+	/** Template form of the attribute query which will try to read the
+		attribute into the specified type. Very easy, very powerful, but
+		be careful to make sure to call this with the correct type.
+
+		NOTE: This method doesn't work correctly for 'string' types.
+
+		@return TIXML_SUCCESS, TIXML_WRONG_TYPE, or TIXML_NO_ATTRIBUTE
+	*/
+	template< typename T > int QueryValueAttribute( const std::string& name, T* outValue ) const
+	{
+		const TiXmlAttribute* node = attributeSet.Find( name );
+		if ( !node )
+			return TIXML_NO_ATTRIBUTE;
+
+		std::stringstream sstream( node->ValueStr() );
+		sstream >> *outValue;
+		if ( !sstream.fail() )
+			return TIXML_SUCCESS;
+		return TIXML_WRONG_TYPE;
+	}
+	/*
+	 This is - in theory - a bug fix for "QueryValueAtribute returns truncated std::string"
+	 but template specialization is hard to get working cross-compiler. Leaving the bug for now.
+
+	// The above will fail for std::string because the space character is used as a seperator.
+	// Specialize for strings. Bug [ 1695429 ] QueryValueAtribute returns truncated std::string
+	template<> int QueryValueAttribute( const std::string& name, std::string* outValue ) const
+	{
+		const TiXmlAttribute* node = attributeSet.Find( name );
+		if ( !node )
+			return TIXML_NO_ATTRIBUTE;
+		*outValue = node->ValueStr();
+		return TIXML_SUCCESS;
+	}
+	*/
+	#endif
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char* name, const char * _value );
+
+    #ifdef TIXML_USE_STL
+	const std::string* Attribute( const std::string& name ) const;
+	const std::string* Attribute( const std::string& name, int* i ) const;
+	const std::string* Attribute( const std::string& name, double* d ) const;
+	int QueryIntAttribute( const std::string& name, int* _value ) const;
+	int QueryDoubleAttribute( const std::string& name, double* _value ) const;
+
+	/// STL std::string form.
+	void SetAttribute( const std::string& name, const std::string& _value );
+	///< STL std::string form.
+	void SetAttribute( const std::string& name, int _value );
+	#endif
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char * name, int value );
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetDoubleAttribute( const char * name, double value );
+
+	/** Deletes an attribute with the given name.
+	*/
+	void RemoveAttribute( const char * name );
+    #ifdef TIXML_USE_STL
+	void RemoveAttribute( const std::string& name )	{	RemoveAttribute (name.c_str ());	}	///< STL std::string form.
+	#endif
+
+	const TiXmlAttribute* FirstAttribute() const	{ return attributeSet.First(); }		///< Access the first attribute in this element.
+	TiXmlAttribute* FirstAttribute() 				{ return attributeSet.First(); }
+	const TiXmlAttribute* LastAttribute()	const 	{ return attributeSet.Last(); }		///< Access the last attribute in this element.
+	TiXmlAttribute* LastAttribute()					{ return attributeSet.Last(); }
+
+	/** Convenience function for easy access to the text inside an element. Although easy
+		and concise, GetText() is limited compared to getting the TiXmlText child
+		and accessing it directly.
+
+		If the first child of 'this' is a TiXmlText, the GetText()
+		returns the character string of the Text node, else null is returned.
+
+		This is a convenient method for getting the text of simple contained text:
+		@verbatim
+		<foo>This is text</foo>
+		const char* str = fooElement->GetText();
+		@endverbatim
+
+		'str' will be a pointer to "This is text".
+
+		Note that this function can be misleading. If the element foo was created from
+		this XML:
+		@verbatim
+		<foo><b>This is text</b></foo>
+		@endverbatim
+
+		then the value of str would be null. The first child node isn't a text node, it is
+		another element. From this XML:
+		@verbatim
+		<foo>This is <b>text</b></foo>
+		@endverbatim
+		GetText() will return "This is ".
+
+		WARNING: GetText() accesses a child node - don't become confused with the
+				 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are
+				 safe type casts on the referenced node.
+	*/
+	const char* GetText() const;
+
+	/// Creates a new Element and returns it - the returned element is a copy.
+	virtual TiXmlNode* Clone() const;
+	// Print the Element to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: next char past '<'
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlElement*     ToElement()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlElement*           ToElement()	          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children.
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+
+	void CopyTo( TiXmlElement* target ) const;
+	void ClearThis();	// like clear, but initializes 'this' object as well
+
+	// Used to be public [internal use]
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+	/*	[internal use]
+		Reads the "value" of the element -- another element, or text.
+		This should terminate with the current end tag.
+	*/
+	const char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+private:
+
+	TiXmlAttributeSet attributeSet;
+};
+
+
+/**	An XML comment.
+*/
+class TICPP_API TiXmlComment : public TiXmlNode
+{
+public:
+	/// Constructs an empty comment.
+	TiXmlComment() : TiXmlNode( TiXmlNode::COMMENT ) {}
+	/// Construct a comment from text.
+	TiXmlComment( const char* _value ) : TiXmlNode( TiXmlNode::COMMENT ) {
+		SetValue( _value );
+	}
+	TiXmlComment( const TiXmlComment& );
+	void operator=( const TiXmlComment& base );
+
+	virtual ~TiXmlComment()	{}
+
+	/// Returns a copy of this Comment.
+	virtual TiXmlNode* Clone() const;
+	// Write this Comment to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: at the ! of the !--
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlComment*  ToComment() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlComment*  ToComment() { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children.
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+	void CopyTo( TiXmlComment* target ) const;
+
+	// used to be public
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+//	virtual void StreamOut( TIXML_OSTREAM * out ) const;
+
+private:
+
+};
+
+
+/** XML text. A text node can have 2 ways to output the next. "normal" output
+	and CDATA. It will default to the mode it was parsed from the XML file and
+	you generally want to leave it alone, but you can change the output mode with
+	SetCDATA() and query it with CDATA().
+*/
+class TICPP_API TiXmlText : public TiXmlNode
+{
+	friend class TiXmlElement;
+public:
+	/** Constructor for text element. By default, it is treated as
+		normal, encoded text. If you want it be output as a CDATA text
+		element, set the parameter _cdata to 'true'
+	*/
+	TiXmlText (const char * initValue ) : TiXmlNode (TiXmlNode::TEXT)
+	{
+		SetValue( initValue );
+		cdata = false;
+	}
+	virtual ~TiXmlText() {}
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlText( const std::string& initValue ) : TiXmlNode (TiXmlNode::TEXT)
+	{
+		SetValue( initValue );
+		cdata = false;
+	}
+	#endif
+
+	TiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TEXT )	{ copy.CopyTo( this ); }
+	void operator=( const TiXmlText& base )							 	{ base.CopyTo( this ); }
+
+	// Write this text object to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/// Queries whether this represents text using a CDATA section.
+	bool CDATA() const				{ return cdata; }
+	/// Turns on or off a CDATA representation of text.
+	void SetCDATA( bool _cdata )	{ cdata = _cdata; }
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlText* ToText() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlText*       ToText()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children.
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected :
+	///  [internal use] Creates a new Element and returns it.
+	virtual TiXmlNode* Clone() const;
+	void CopyTo( TiXmlText* target ) const;
+
+	bool Blank() const;	// returns true if all white space and new lines
+	// [internal use]
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+	bool cdata;			// true if this should be input and output as a CDATA style text element
+};
+
+
+/** In correct XML the declaration is the first entry in the file.
+	@verbatim
+		<?xml version="1.0" standalone="yes"?>
+	@endverbatim
+
+	TinyXml will happily read or write files without a declaration,
+	however. There are 3 possible attributes to the declaration:
+	version, encoding, and standalone.
+
+	Note: In this version of the code, the attributes are
+	handled as special cases, not generic attributes, simply
+	because there can only be at most 3 and they are always the same.
+*/
+class TICPP_API TiXmlDeclaration : public TiXmlNode
+{
+public:
+	/// Construct an empty declaration.
+	TiXmlDeclaration()   : TiXmlNode( TiXmlNode::DECLARATION ) {}
+
+#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDeclaration(	const std::string& _version,
+						const std::string& _encoding,
+						const std::string& _standalone );
+#endif
+
+	/// Construct.
+	TiXmlDeclaration(	const char* _version,
+						const char* _encoding,
+						const char* _standalone );
+
+	TiXmlDeclaration( const TiXmlDeclaration& copy );
+	void operator=( const TiXmlDeclaration& copy );
+
+	virtual ~TiXmlDeclaration()	{}
+
+	/// Version. Will return an empty string if none was found.
+	const char *Version() const			{ return version.c_str (); }
+	/// Encoding. Will return an empty string if none was found.
+	const char *Encoding() const		{ return encoding.c_str (); }
+	/// Is this a standalone document?
+	const char *Standalone() const		{ return standalone.c_str (); }
+
+	/// Creates a copy of this Declaration and returns it.
+	virtual TiXmlNode* Clone() const;
+	// Print this declaration to a FILE stream.
+	virtual void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
+	virtual void Print( FILE* cfile, int depth ) const {
+		Print( cfile, depth, 0 );
+	}
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlDeclaration* ToDeclaration() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlDeclaration*       ToDeclaration()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children.
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+	void CopyTo( TiXmlDeclaration* target ) const;
+	// used to be public
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+
+	TIXML_STRING version;
+	TIXML_STRING encoding;
+	TIXML_STRING standalone;
+};
+
+/** A stylesheet reference looks like this:
+	@verbatim
+		<?xml-stylesheet type="text/xsl" href="style.xsl"?>
+	@endverbatim
+
+	Note: In this version of the code, the attributes are
+	handled as special cases, not generic attributes, simply
+	because there can only be at most 2 and they are always the same.
+*/
+class TICPP_API TiXmlStylesheetReference : public TiXmlNode
+{
+public:
+	/// Construct an empty declaration.
+	TiXmlStylesheetReference()   : TiXmlNode( TiXmlNode::STYLESHEETREFERENCE ) {}
+
+#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlStylesheetReference(	const std::string& _type,
+								const std::string& _href );
+#endif
+
+	/// Construct.
+	TiXmlStylesheetReference(	const char* _type,
+								const char* _href );
+
+	TiXmlStylesheetReference( const TiXmlStylesheetReference& copy );
+	void operator=( const TiXmlStylesheetReference& copy );
+
+	virtual ~TiXmlStylesheetReference()	{}
+
+	/// Type. Will return an empty string if none was found.
+	const char *Type() const { return type.c_str (); }
+	/// Href. Will return an empty string if none was found.
+	const char *Href() const		{ return href.c_str (); }
+
+	/// Creates a copy of this StylesheetReference and returns it.
+	virtual TiXmlNode* Clone() const;
+	// Print this declaration to a FILE stream.
+	virtual void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;
+	virtual void Print( FILE* cfile, int depth ) const {
+		Print( cfile, depth, 0 );
+	}
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlStylesheetReference* ToStylesheetReference() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlStylesheetReference*       ToStylesheetReference()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children.
+	*/
+	virtual bool Accept( TiXmlVisitor* visitor ) const;
+
+protected:
+	void CopyTo( TiXmlStylesheetReference* target ) const;
+	// used to be public
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+
+	TIXML_STRING type;
+	TIXML_STRING href;
+};
+
+/** Any tag that tinyXml doesn't recognize is saved as an
+	unknown. It is a tag of text, but should not be modified.
+	It will be written back to the XML, unchanged, when the file
+	is saved.
+
+	DTD tags get thrown into TiXmlUnknowns.
+*/
+class TICPP_API TiXmlUnknown : public TiXmlNode
+{
+public:
+	TiXmlUnknown() : TiXmlNode( TiXmlNode::UNKNOWN )	{}
+	virtual ~TiXmlUnknown() {}
+
+	TiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::UNKNOWN )		{ copy.CopyTo( this ); }
+	void operator=( const TiXmlUnknown& copy )										{ copy.CopyTo( this ); }
+
+	/// Creates a copy of this Unknown and returns it.
+	virtual TiXmlNode* Clone() const;
+	// Print this Unknown to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	virtual const TiXmlUnknown*     ToUnknown()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlUnknown*           ToUnknown()	    { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children.
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected:
+	void CopyTo( TiXmlUnknown* target ) const;
+
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+
+};
+
+
+/** Always the top level node. A document binds together all the
+	XML pieces. It can be saved, loaded, and printed to the screen.
+	The 'value' of a document node is the xml file name.
+*/
+class TICPP_API TiXmlDocument : public TiXmlNode
+{
+public:
+	/// Create an empty document, that has no name.
+	TiXmlDocument();
+	/// Create a document with a name. The name of the document is also the filename of the xml.
+	TiXmlDocument( const char * documentName );
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDocument( const std::string& documentName );
+	#endif
+
+	TiXmlDocument( const TiXmlDocument& copy );
+	void operator=( const TiXmlDocument& copy );
+
+	virtual ~TiXmlDocument() {}
+
+	/** Load a file using the current document value.
+		Returns true if successful. Will delete any existing
+		document data before loading.
+	*/
+	bool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the current document value. Returns true if successful.
+	bool SaveFile() const;
+	/// Load a file using the given filename. Returns true if successful.
+	bool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the given filename. Returns true if successful.
+	bool SaveFile( const char * filename ) const;
+	/** Load a file using the given FILE*. Returns true if successful. Note that this method
+		doesn't stream - the entire object pointed at by the FILE*
+		will be interpreted as an XML file. TinyXML doesn't stream in XML from the current
+		file location. Streaming may be added in the future.
+	*/
+	bool LoadFile( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the given FILE*. Returns true if successful.
+	bool SaveFile( FILE* ) const;
+
+	#ifdef TIXML_USE_STL
+	bool LoadFile( const std::string& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )			///< STL std::string version.
+	{
+//		StringToBuffer f( filename );
+//		return ( f.buffer && LoadFile( f.buffer, encoding ));
+		return LoadFile( filename.c_str(), encoding );
+	}
+	bool SaveFile( const std::string& filename ) const		///< STL std::string version.
+	{
+//		StringToBuffer f( filename );
+//		return ( f.buffer && SaveFile( f.buffer ));
+		return SaveFile( filename.c_str() );
+	}
+	#endif
+
+	/** Parse the given null terminated block of xml data. Passing in an encoding to this
+		method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml
+		to use that encoding, regardless of what TinyXml might otherwise try to detect.
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+
+	/** Get the root element -- the only top level element -- of the document.
+		In well formed XML, there should only be one. TinyXml is tolerant of
+		multiple elements at the document level.
+	*/
+	const TiXmlElement* RootElement() const		{ return FirstChildElement(); }
+	TiXmlElement* RootElement()					{ return FirstChildElement(); }
+
+	/** If an error occurs, Error will be set to true. Also,
+		- The ErrorId() will contain the integer identifier of the error (not generally useful)
+		- The ErrorDesc() method will return the name of the error. (very useful)
+		- The ErrorRow() and ErrorCol() will return the location of the error (if known)
+	*/
+	bool Error() const						{ return error; }
+
+	/// Contains a textual (english) description of the error if one occurs.
+	const char * ErrorDesc() const	{ return errorDesc.c_str (); }
+
+	/** Generally, you probably want the error string ( ErrorDesc() ). But if you
+		prefer the ErrorId, this function will fetch it.
+	*/
+	int ErrorId()	const				{ return errorId; }
+
+	/** Returns the location (if known) of the error. The first column is column 1,
+		and the first row is row 1. A value of 0 means the row and column wasn't applicable
+		(memory errors, for example, have no row/column) or the parser lost the error. (An
+		error in the error reporting, in that case.)
+
+		@sa SetTabSize, Row, Column
+	*/
+	int ErrorRow() const	{ return errorLocation.row+1; }
+	int ErrorCol() const	{ return errorLocation.col+1; }	///< The column where the error occured. See ErrorRow()
+
+	/** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())
+		to report the correct values for row and column. It does not change the output
+		or input in any way.
+
+		By calling this method, with a tab size
+		greater than 0, the row and column of each node and attribute is stored
+		when the file is loaded. Very useful for tracking the DOM back in to
+		the source file.
+
+		The tab size is required for calculating the location of nodes. If not
+		set, the default of 4 is used. The tabsize is set per document. Setting
+		the tabsize to 0 disables row/column tracking.
+
+		Note that row and column tracking is not supported when using operator>>.
+
+		The tab size needs to be enabled before the parse or load. Correct usage:
+		@verbatim
+		TiXmlDocument doc;
+		doc.SetTabSize( 8 );
+		doc.Load( "myfile.xml" );
+		@endverbatim
+
+		@sa Row, Column
+	*/
+	void SetTabSize( int _tabsize )		{ tabsize = _tabsize; }
+
+	int TabSize() const	{ return tabsize; }
+
+	/** If you have handled the error, it can be reset with this call. The error
+		state is automatically cleared if you Parse a new XML block.
+	*/
+	void ClearError()						{	error = false;
+												errorId = 0;
+												errorDesc = "";
+												errorLocation.row = errorLocation.col = 0;
+												//errorLocation.last = 0;
+											}
+
+	/** Write the document to standard out using formatted printing ("pretty print"). */
+	void Print() const						{ Print( stdout, 0 ); }
+
+	/* Write the document to a string using formatted printing ("pretty print"). This
+		will allocate a character array (new char[]) and return it as a pointer. The
+		calling code pust call delete[] on the return char* to avoid a memory leak.
+	*/
+	//char* PrintToMemory() const;
+
+	/// Print this Document to a FILE stream.
+	virtual void Print( FILE* cfile, int depth = 0 ) const;
+	// [internal use]
+	void SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+	virtual const TiXmlDocument*    ToDocument()    const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+	virtual TiXmlDocument*          ToDocument()          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Walk the XML tree visiting this node and all of its children.
+	*/
+	virtual bool Accept( TiXmlVisitor* content ) const;
+
+protected :
+	// [internal use]
+	virtual TiXmlNode* Clone() const;
+	#ifdef TIXML_USE_STL
+	virtual void StreamIn( std::istream * in, TIXML_STRING * tag );
+	#endif
+
+private:
+	void CopyTo( TiXmlDocument* target ) const;
+
+	bool error;
+	int  errorId;
+	TIXML_STRING errorDesc;
+	int tabsize;
+	TiXmlCursor errorLocation;
+	bool useMicrosoftBOM;		// the UTF-8 BOM were found when read. Note this, and try to write.
+};
+
+
+/**
+	A TiXmlHandle is a class that wraps a node pointer with null checks; this is
+	an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
+	DOM structure. It is a separate utility class.
+
+	Take an example:
+	@verbatim
+	<Document>
+		<Element attributeA = "valueA">
+			<Child attributeB = "value1" />
+			<Child attributeB = "value2" />
+		</Element>
+	<Document>
+	@endverbatim
+
+	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very
+	easy to write a *lot* of code that looks like:
+
+	@verbatim
+	TiXmlElement* root = document.FirstChildElement( "Document" );
+	if ( root )
+	{
+		TiXmlElement* element = root->FirstChildElement( "Element" );
+		if ( element )
+		{
+			TiXmlElement* child = element->FirstChildElement( "Child" );
+			if ( child )
+			{
+				TiXmlElement* child2 = child->NextSiblingElement( "Child" );
+				if ( child2 )
+				{
+					// Finally do something useful.
+	@endverbatim
+
+	And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
+	of such code. A TiXmlHandle checks for null	pointers so it is perfectly safe
+	and correct to use:
+
+	@verbatim
+	TiXmlHandle docHandle( &document );
+	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
+	if ( child2 )
+	{
+		// do something useful
+	@endverbatim
+
+	Which is MUCH more concise and useful.
+
+	It is also safe to copy handles - internally they are nothing more than node pointers.
+	@verbatim
+	TiXmlHandle handleCopy = handle;
+	@endverbatim
+
+	What they should not be used for is iteration:
+
+	@verbatim
+	int i=0;
+	while ( true )
+	{
+		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
+		if ( !child )
+			break;
+		// do something
+		++i;
+	}
+	@endverbatim
+
+	It seems reasonable, but it is in fact two embedded while loops. The Child method is
+	a linear walk to find the element, so this code would iterate much more than it needs
+	to. Instead, prefer:
+
+	@verbatim
+	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();
+
+	for( child; child; child=child->NextSiblingElement() )
+	{
+		// do something
+	}
+	@endverbatim
+*/
+class TICPP_API TiXmlHandle
+{
+public:
+	/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
+	TiXmlHandle( TiXmlNode* _node )					{ this->node = _node; }
+	/// Copy constructor
+	TiXmlHandle( const TiXmlHandle& ref )			{ this->node = ref.node; }
+	TiXmlHandle operator=( const TiXmlHandle& ref ) { this->node = ref.node; return *this; }
+
+	/// Return a handle to the first child node.
+	TiXmlHandle FirstChild() const;
+	/// Return a handle to the first child node with the given name.
+	TiXmlHandle FirstChild( const char * value ) const;
+	/// Return a handle to the first child element.
+	TiXmlHandle FirstChildElement() const;
+	/// Return a handle to the first child element with the given name.
+	TiXmlHandle FirstChildElement( const char * value ) const;
+
+	/** Return a handle to the "index" child with the given name.
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( const char* value, int index ) const;
+	/** Return a handle to the "index" child.
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( int index ) const;
+	/** Return a handle to the "index" child element with the given name.
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( const char* value, int index ) const;
+	/** Return a handle to the "index" child element.
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( int index ) const;
+
+	#ifdef TIXML_USE_STL
+	TiXmlHandle FirstChild( const std::string& _value ) const				{ return FirstChild( _value.c_str() ); }
+	TiXmlHandle FirstChildElement( const std::string& _value ) const		{ return FirstChildElement( _value.c_str() ); }
+
+	TiXmlHandle Child( const std::string& _value, int index ) const			{ return Child( _value.c_str(), index ); }
+	TiXmlHandle ChildElement( const std::string& _value, int index ) const	{ return ChildElement( _value.c_str(), index ); }
+	#endif
+
+	/** Return the handle as a TiXmlNode. This may return null.
+	*/
+	TiXmlNode* ToNode() const			{ return node; }
+	/** Return the handle as a TiXmlElement. This may return null.
+	*/
+	TiXmlElement* ToElement() const		{ return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }
+	/**	Return the handle as a TiXmlText. This may return null.
+	*/
+	TiXmlText* ToText() const			{ return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }
+	/** Return the handle as a TiXmlUnknown. This may return null.
+	*/
+	TiXmlUnknown* ToUnknown() const		{ return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }
+
+	/** @deprecated use ToNode.
+		Return the handle as a TiXmlNode. This may return null.
+	*/
+	TiXmlNode* Node() const			{ return ToNode(); }
+	/** @deprecated use ToElement.
+		Return the handle as a TiXmlElement. This may return null.
+	*/
+	TiXmlElement* Element() const	{ return ToElement(); }
+	/**	@deprecated use ToText()
+		Return the handle as a TiXmlText. This may return null.
+	*/
+	TiXmlText* Text() const			{ return ToText(); }
+	/** @deprecated use ToUnknown()
+		Return the handle as a TiXmlUnknown. This may return null.
+	*/
+	TiXmlUnknown* Unknown() const	{ return ToUnknown(); }
+
+private:
+	TiXmlNode* node;
+};
+
+
+/** Print to memory functionality. The TiXmlPrinter is useful when you need to:
+
+	-# Print to memory (especially in non-STL mode)
+	-# Control formatting (line endings, etc.)
+
+	When constructed, the TiXmlPrinter is in its default "pretty printing" mode.
+	Before calling Accept() you can call methods to control the printing
+	of the XML document. After TiXmlNode::Accept() is called, the printed document can
+	be accessed via the CStr(), Str(), and Size() methods.
+
+	TiXmlPrinter uses the Visitor API.
+	@verbatim
+	TiXmlPrinter printer;
+	printer.SetIndent( "\t" );
+
+	doc.Accept( &printer );
+	fprintf( stdout, "%s", printer.CStr() );
+	@endverbatim
+*/
+class TICPP_API TiXmlPrinter : public TiXmlVisitor
+{
+public:
+	TiXmlPrinter() : depth( 0 ), simpleTextPrint( false ),
+					 buffer(), indent( "    " ), lineBreak( "\n" ) {}
+
+	virtual bool VisitEnter( const TiXmlDocument& doc );
+	virtual bool VisitExit( const TiXmlDocument& doc );
+
+	virtual bool VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute );
+	virtual bool VisitExit( const TiXmlElement& element );
+
+	virtual bool Visit( const TiXmlDeclaration& declaration );
+	virtual bool Visit( const TiXmlText& text );
+	virtual bool Visit( const TiXmlComment& comment );
+	virtual bool Visit( const TiXmlUnknown& unknown );
+	virtual bool Visit( const TiXmlStylesheetReference& stylesheet );
+
+	/** Set the indent characters for printing. By default 4 spaces
+		but tab (\t) is also useful, or null/empty string for no indentation.
+	*/
+	void SetIndent( const char* _indent )			{ indent = _indent ? _indent : "" ; }
+	/// Query the indention string.
+	const char* Indent()							{ return indent.c_str(); }
+	/** Set the line breaking string. By default set to newline (\n).
+		Some operating systems prefer other characters, or can be
+		set to the null/empty string for no indenation.
+	*/
+	void SetLineBreak( const char* _lineBreak )		{ lineBreak = _lineBreak ? _lineBreak : ""; }
+	/// Query the current line breaking string.
+	const char* LineBreak()							{ return lineBreak.c_str(); }
+
+	/** Switch over to "stream printing" which is the most dense formatting without
+		linebreaks. Common when the XML is needed for network transmission.
+	*/
+	void SetStreamPrinting()						{ indent = "";
+													  lineBreak = "";
+													}
+	/// Return the result.
+	const char* CStr()								{ return buffer.c_str(); }
+	/// Return the length of the result string.
+	size_t Size()									{ return buffer.size(); }
+
+	#ifdef TIXML_USE_STL
+	/// Return the result.
+	const std::string& Str()						{ return buffer; }
+	#endif
+
+private:
+	void DoIndent()	{
+		for( int i=0; i<depth; ++i )
+			buffer += indent;
+	}
+	void DoLineBreak() {
+		buffer += lineBreak;
+	}
+
+	int depth;
+	bool simpleTextPrint;
+	TIXML_STRING buffer;
+	TIXML_STRING indent;
+	TIXML_STRING lineBreak;
+};
+
+
+#ifdef _MSC_VER
+#pragma warning( pop )
+#endif
+
+#endif
+
diff -Naur wxFormBuilder.orig/subprojects/ticpp/tinyxmlerror.cpp wxFormBuilder/subprojects/ticpp/tinyxmlerror.cpp
--- wxFormBuilder.orig/subprojects/ticpp/tinyxmlerror.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/tinyxmlerror.cpp	2019-11-18 10:42:57.712406052 +0100
@@ -0,0 +1,53 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2006 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied 
+warranty. In no event will the authors be held liable for any 
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any 
+purpose, including commercial applications, and to alter it and 
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+
+// The goal of the seperate error file is to make the first
+// step towards localization. tinyxml (currently) only supports
+// english error messages, but the could now be translated.
+//
+// It also cleans up the code a bit.
+//
+
+const char* TiXmlBase::errorString[ TIXML_ERROR_STRING_COUNT ] =
+{
+	"No error",
+	"Error",
+	"Failed to open file",
+	"Memory allocation failed.",
+	"Error parsing Element.",
+	"Failed to read Element name",
+	"Error reading Element value.",
+	"Error reading Attributes.",
+	"Error: empty tag.",
+	"Error reading end tag.",
+	"Error parsing Unknown.",
+	"Error parsing Comment.",
+	"Error parsing Declaration.",
+	"Error document empty.",
+	"Error null (0) or unexpected EOF found in input stream.",
+	"Error parsing CDATA.",
+	"Error when TiXmlDocument added to document, because TiXmlDocument can only be at the root.",
+};
diff -Naur wxFormBuilder.orig/subprojects/ticpp/tinyxmlparser.cpp wxFormBuilder/subprojects/ticpp/tinyxmlparser.cpp
--- wxFormBuilder.orig/subprojects/ticpp/tinyxmlparser.cpp	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/tinyxmlparser.cpp	2019-11-18 10:42:57.713406052 +0100
@@ -0,0 +1,1723 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+
+#include <cstddef>
+
+//#define DEBUG_PARSER
+#if defined( DEBUG_PARSER )
+#	if defined( DEBUG ) && defined( _MSC_VER )
+#		include <windows.h>
+#		define TIXML_LOG OutputDebugString
+#	else
+#		define TIXML_LOG printf
+#	endif
+#endif
+
+// Note tha "PutString" hardcodes the same list. This
+// is less flexible than it appears. Changing the entries
+// or order will break putstring.
+TiXmlBase::Entity TiXmlBase::entity[ NUM_ENTITY ] =
+{
+	{ "&amp;",  5, '&' },
+	{ "&lt;",   4, '<' },
+	{ "&gt;",   4, '>' },
+	{ "&quot;", 6, '\"' },
+	{ "&apos;", 6, '\'' }
+};
+
+// Bunch of unicode info at:
+//		http://www.unicode.org/faq/utf_bom.html
+// Including the basic of this table, which determines the #bytes in the
+// sequence from the lead byte. 1 placed for invalid sequences --
+// although the result will be junk, pass it through as much as possible.
+// Beware of the non-characters in UTF-8:
+//				ef bb bf (Microsoft "lead bytes")
+//				ef bf be
+//				ef bf bf
+
+const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
+const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
+const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;
+
+const int TiXmlBase::utf8ByteTable[256] =
+{
+	//	0	1	2	3	4	5	6	7	8	9	a	b	c	d	e	f
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x00
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x10
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x20
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x30
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x40
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x50
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x60
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x70	End of ASCII range
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x80 0x80 to 0xc1 invalid
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x90
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xa0
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xb0
+		1,	1,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xc0 0xc2 to 0xdf 2 byte
+		2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xd0
+		3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	// 0xe0 0xe0 to 0xef 3 byte
+		4,	4,	4,	4,	4,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1	// 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid
+};
+
+
+void TiXmlBase::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
+{
+	const unsigned long BYTE_MASK = 0xBF;
+	const unsigned long BYTE_MARK = 0x80;
+	const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+	if (input < 0x80)
+		*length = 1;
+	else if ( input < 0x800 )
+		*length = 2;
+	else if ( input < 0x10000 )
+		*length = 3;
+	else if ( input < 0x200000 )
+		*length = 4;
+	else
+		{ *length = 0; return; }	// This code won't covert this correctly anyway.
+
+	output += *length;
+
+	switch (*length)
+	{
+		case 4:
+			--output;
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK);
+			input >>= 6;
+			[[fallthrough]];
+		case 3:
+			--output;
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK);
+			input >>= 6;
+			[[fallthrough]];
+		case 2:
+			--output;
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK);
+			input >>= 6;
+			[[fallthrough]];
+		case 1:
+			--output;
+			*output = (char)(input | FIRST_BYTE_MARK[*length]);
+	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlpha( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalpha( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalpha( anyByte );
+//	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlphaNum( unsigned char anyByte, TiXmlEncoding /*encoding*/ )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalnum( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalnum( anyByte );
+//	}
+}
+
+
+class TiXmlParsingData
+{
+	friend class TiXmlDocument;
+  public:
+	void Stamp( const char* now, TiXmlEncoding encoding );
+
+	const TiXmlCursor& Cursor()	{ return cursor; }
+
+  private:
+	// Only used by the document!
+	TiXmlParsingData( const char* start, int _tabsize, int row, int col )
+	{
+		assert( start );
+		stamp = start;
+		tabsize = _tabsize;
+		cursor.row = row;
+		cursor.col = col;
+	}
+
+	TiXmlCursor		cursor;
+	const char*		stamp;
+	int				tabsize;
+};
+
+
+void TiXmlParsingData::Stamp( const char* now, TiXmlEncoding encoding )
+{
+	assert( now );
+
+	// Do nothing if the tabsize is 0.
+	if ( tabsize < 1 )
+	{
+		return;
+	}
+
+	// Get the current row, column.
+	int row = cursor.row;
+	int col = cursor.col;
+	const char* p = stamp;
+	assert( p );
+
+	while ( p < now )
+	{
+		// Treat p as unsigned, so we have a happy compiler.
+		const unsigned char* pU = (const unsigned char*)p;
+
+		// Code contributed by Fletcher Dunn: (modified by lee)
+		switch (*pU) {
+			case 0:
+				// We *should* never get here, but in case we do, don't
+				// advance past the terminating null character, ever
+				return;
+
+			case '\r':
+				// bump down to the next line
+				++row;
+				col = 0;
+				// Eat the character
+				++p;
+
+				// Check for \r\n sequence, and treat this as a single character
+				if (*p == '\n') {
+					++p;
+				}
+				break;
+
+			case '\n':
+				// bump down to the next line
+				++row;
+				col = 0;
+
+				// Eat the character
+				++p;
+
+				// Check for \n\r sequence, and treat this as a single
+				// character.  (Yes, this bizarre thing does occur still
+				// on some arcane platforms...)
+				if (*p == '\r') {
+					++p;
+				}
+				break;
+
+			case '\t':
+				// Eat the character
+				++p;
+
+				// Skip to next tab stop
+				col = (col / tabsize + 1) * tabsize;
+				break;
+
+			case TIXML_UTF_LEAD_0:
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					if ( *(p+1) && *(p+2) )
+					{
+						// In these cases, don't advance the column. These are
+						// 0-width spaces.
+						if ( *(pU+1)==TIXML_UTF_LEAD_1 && *(pU+2)==TIXML_UTF_LEAD_2 )
+							p += 3;
+						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbeU )
+							p += 3;
+						else if ( *(pU+1)==0xbfU && *(pU+2)==0xbfU )
+							p += 3;
+						else
+							{ p +=3; ++col; }	// A normal character.
+					}
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+
+			default:
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					// Eat the 1 to 4 byte utf8 character.
+					int step = TiXmlBase::utf8ByteTable[*((const unsigned char*)p)];
+					if ( step == 0 )
+						step = 1;		// Error case from bad encoding, but handle gracefully.
+					p += step;
+
+					// Just advance one column, of course.
+					++col;
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+		}
+	}
+	cursor.row = row;
+	cursor.col = col;
+	assert( cursor.row >= -1 );
+	assert( cursor.col >= -1 );
+	stamp = p;
+	assert( stamp );
+}
+
+
+const char* TiXmlBase::SkipWhiteSpace( const char* p, TiXmlEncoding encoding )
+{
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+	if ( encoding == TIXML_ENCODING_UTF8 )
+	{
+		while ( *p )
+		{
+			const unsigned char* pU = (const unsigned char*)p;
+
+			// Skip the stupid Microsoft UTF-8 Byte order marks
+			if (	*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==TIXML_UTF_LEAD_1
+				 && *(pU+2)==TIXML_UTF_LEAD_2 )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==0xbfU
+				 && *(pU+2)==0xbeU )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(pU+0)==TIXML_UTF_LEAD_0
+				 && *(pU+1)==0xbfU
+				 && *(pU+2)==0xbfU )
+			{
+				p += 3;
+				continue;
+			}
+
+			if ( IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )		// Still using old rules for white space.
+				++p;
+			else
+				break;
+		}
+	}
+	else
+	{
+		while ( ( *p && IsWhiteSpace( *p ) ) || *p == '\n' || *p =='\r' )
+			++p;
+	}
+
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+/*static*/ bool TiXmlBase::StreamWhiteSpace( std::istream * in, TIXML_STRING * tag )
+{
+	for( ;; )
+	{
+		if ( !in->good() ) return false;
+
+		int c = in->peek();
+		// At this scope, we can't get to a document. So fail silently.
+		if ( !IsWhiteSpace( c ) || c <= 0 )
+			return true;
+
+		*tag += (char) in->get();
+	}
+}
+
+/*static*/ bool TiXmlBase::StreamTo( std::istream * in, int character, TIXML_STRING * tag )
+{
+	//assert( character > 0 && character < 128 );	// else it won't work in utf-8
+	while ( in->good() )
+	{
+		int c = in->peek();
+		if ( c == character )
+			return true;
+		if ( c <= 0 )		// Silent failure: can't get document at this scope
+			return false;
+
+		in->get();
+		*tag += (char) c;
+	}
+	return false;
+}
+#endif
+
+// One of TinyXML's more performance demanding functions. Try to keep the memory overhead down. The
+// "assign" optimization removes over 10% of the execution time.
+//
+const char* TiXmlBase::ReadName( const char* p, TIXML_STRING * name, TiXmlEncoding encoding )
+{
+	// Oddly, not supported on some comilers,
+	//name->clear();
+	// So use this:
+	*name = "";
+	assert( p );
+
+	// Names start with letters or underscores.
+	// Of course, in unicode, tinyxml has no idea what a letter *is*. The
+	// algorithm is generous.
+	//
+	// After that, they can be letters, underscores, numbers,
+	// hyphens, or colons. (Colons are valid ony for namespaces,
+	// but tinyxml can't tell namespaces from names.)
+	if (    p && *p
+		 && ( IsAlpha( (unsigned char) *p, encoding ) || *p == '_' ) )
+	{
+		const char* start = p;
+		while(		p && *p
+				&&	(		IsAlphaNum( (unsigned char ) *p, encoding )
+						 || *p == '_'
+						 || *p == '-'
+						 || *p == '.'
+						 || *p == ':' ) )
+		{
+			//(*name) += *p; // expensive
+			++p;
+		}
+		if ( p-start > 0 ) {
+			name->assign( start, p-start );
+		}
+		return p;
+	}
+	return 0;
+}
+
+const char* TiXmlBase::GetEntity( const char* p, char* value, int* length, TiXmlEncoding encoding )
+{
+	// Presume an entity, and pull it out.
+    TIXML_STRING ent;
+	int i;
+	*length = 0;
+
+	if ( *(p+1) && *(p+1) == '#' && *(p+2) )
+	{
+		unsigned long ucs = 0;
+		ptrdiff_t delta = 0;
+		unsigned mult = 1;
+
+		if ( *(p+2) == 'x' )
+		{
+			// Hexadecimal.
+			if ( !*(p+3) ) return 0;
+
+			const char* q = p+3;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != 'x' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else if ( *q >= 'a' && *q <= 'f' )
+					ucs += mult * (*q - 'a' + 10);
+				else if ( *q >= 'A' && *q <= 'F' )
+					ucs += mult * (*q - 'A' + 10 );
+				else
+					return 0;
+				mult *= 16;
+				--q;
+			}
+		}
+		else
+		{
+			// Decimal.
+			if ( !*(p+2) ) return 0;
+
+			const char* q = p+2;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != '#' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else
+					return 0;
+				mult *= 10;
+				--q;
+			}
+		}
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			// convert the UCS to UTF-8
+			ConvertUTF32ToUTF8( ucs, value, length );
+		}
+		else
+		{
+			*value = (char)ucs;
+			*length = 1;
+		}
+		return p + delta + 1;
+	}
+
+	// Now try to match it.
+	for( i=0; i<NUM_ENTITY; ++i )
+	{
+		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )
+		{
+			assert( strlen( entity[i].str ) == entity[i].strLength );
+			*value = entity[i].chr;
+			*length = 1;
+			return ( p + entity[i].strLength );
+		}
+	}
+
+	// So it wasn't an entity, its unrecognized, or something like that.
+	*value = *p;	// Don't put back the last one, since we return it!
+	//*length = 1;	// Leave unrecognized entities - this doesn't really work.
+					// Just writes strange XML.
+	return p+1;
+}
+
+
+bool TiXmlBase::StringEqual( const char* p,
+							 const char* tag,
+							 bool ignoreCase,
+							 TiXmlEncoding encoding )
+{
+	assert( p );
+	assert( tag );
+	if ( !p || !*p )
+	{
+		assert( 0 );
+		return false;
+	}
+
+	const char* q = p;
+
+	if ( ignoreCase )
+	{
+		while ( *q && *tag && ToLower( *q, encoding ) == ToLower( *tag, encoding ) )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )
+			return true;
+	}
+	else
+	{
+		while ( *q && *tag && *q == *tag )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )		// Have we found the end of the tag, and everything equal?
+			return true;
+	}
+	return false;
+}
+
+const char* TiXmlBase::ReadText(	const char* p,
+									TIXML_STRING * text,
+									bool trimWhiteSpace,
+									const char* endTag,
+									bool caseInsensitive,
+									TiXmlEncoding encoding )
+{
+    *text = "";
+	if (    !trimWhiteSpace			// certain tags always keep whitespace
+		 || !condenseWhiteSpace )	// if true, whitespace is always kept
+	{
+		// Keep all the white space.
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding )
+			  )
+		{
+			int len;
+			char cArr[4] = { 0, 0, 0, 0 };
+			p = GetChar( p, cArr, &len, encoding );
+			text->append( cArr, len );
+		}
+	}
+	else
+	{
+		bool whitespace = false;
+
+		// Remove leading white space:
+		p = SkipWhiteSpace( p, encoding );
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding ) )
+		{
+			if ( *p == '\r' || *p == '\n' )
+			{
+				whitespace = true;
+				++p;
+			}
+			else if ( IsWhiteSpace( *p ) )
+			{
+				whitespace = true;
+				++p;
+			}
+			else
+			{
+				// If we've found whitespace, add it before the
+				// new character. Any whitespace just becomes a space.
+				if ( whitespace )
+				{
+					(*text) += ' ';
+					whitespace = false;
+				}
+				int len;
+				char cArr[4] = { 0, 0, 0, 0 };
+				p = GetChar( p, cArr, &len, encoding );
+				if ( len == 1 )
+					(*text) += cArr[0];	// more efficient
+				else
+					text->append( cArr, len );
+			}
+		}
+	}
+	if ( p )
+		p += strlen( endTag );
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlDocument::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	// The basic issue with a document is that we don't know what we're
+	// streaming. Read something presumed to be a tag (and hope), then
+	// identify it, and call the appropriate stream method on the tag.
+	//
+	// This "pre-streaming" will never read the closing ">" so the
+	// sub-tag can orient itself.
+
+	if ( !StreamTo( in, '<', tag ) )
+	{
+		SetError( TIXML_ERROR_PARSING_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return;
+	}
+
+	while ( in->good() )
+	{
+		int tagIndex = (int) tag->length();
+		while ( in->good() && in->peek() != '>' )
+		{
+			int c = in->get();
+			if ( c <= 0 )
+			{
+				SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+				break;
+			}
+			(*tag) += (char) c;
+		}
+
+		if ( in->good() )
+		{
+			// We now have something we presume to be a node of
+			// some sort. Identify it, and call the node to
+			// continue streaming.
+			TiXmlNode* node = Identify( tag->c_str() + tagIndex, TIXML_DEFAULT_ENCODING );
+
+			if ( node )
+			{
+				node->StreamIn( in, tag );
+				bool isElement = node->ToElement() != 0;
+				delete node;
+				node = 0;
+
+				// If this is the root element, we're done. Parsing will be
+				// done by the >> operator.
+				if ( isElement )
+				{
+					return;
+				}
+			}
+			else
+			{
+				SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+				return;
+			}
+		}
+	}
+	// We should have returned sooner.
+	SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+}
+
+#endif
+
+const char* TiXmlDocument::Parse( const char* p, TiXmlParsingData* prevData, TiXmlEncoding encoding )
+{
+	ClearError();
+
+	// Parse away, at the document level. Since a document
+	// contains nothing but other tags, most of what happens
+	// here is skipping white space.
+	if ( !p || !*p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	// Note that, for a document, this needs to come
+	// before the while space skip, so that parsing
+	// starts from the pointer we are given.
+	location.Clear();
+	if ( prevData )
+	{
+		location.row = prevData->cursor.row;
+		location.col = prevData->cursor.col;
+	}
+	else
+	{
+		location.row = 0;
+		location.col = 0;
+	}
+	TiXmlParsingData data( p, TabSize(), location.row, location.col );
+	location = data.Cursor();
+
+	if ( encoding == TIXML_ENCODING_UNKNOWN )
+	{
+		// Check for the Microsoft UTF-8 lead bytes.
+		const unsigned char* pU = (const unsigned char*)p;
+		if (	*(pU+0) && *(pU+0) == TIXML_UTF_LEAD_0
+			 && *(pU+1) && *(pU+1) == TIXML_UTF_LEAD_1
+			 && *(pU+2) && *(pU+2) == TIXML_UTF_LEAD_2 )
+		{
+			encoding = TIXML_ENCODING_UTF8;
+			useMicrosoftBOM = true;
+		}
+	}
+
+    p = SkipWhiteSpace( p, encoding );
+	if ( !p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	while ( p && *p )
+	{
+		TiXmlNode* node = Identify( p, encoding );
+		if ( node )
+		{
+			p = node->Parse( p, &data, encoding );
+			LinkEndChild( node );
+		}
+		else
+		{
+			break;
+		}
+
+		// Did we get encoding info?
+		if (    encoding == TIXML_ENCODING_UNKNOWN
+			 && node->ToDeclaration() )
+		{
+			TiXmlDeclaration* dec = node->ToDeclaration();
+			const char* enc = dec->Encoding();
+			assert( enc );
+
+			if ( *enc == 0 )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF-8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;	// incorrect, but be nice
+			else
+				encoding = TIXML_ENCODING_LEGACY;
+		}
+
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	// Was this empty?
+	if ( !firstChild ) {
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, encoding );
+		return 0;
+	}
+
+	// All is well.
+	return p;
+}
+
+void TiXmlDocument::SetError( int err, const char* pError, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	// The first error in a chain is more accurate - don't set again!
+	if ( error )
+		return;
+
+	assert( err > 0 && err < TIXML_ERROR_STRING_COUNT );
+	error   = true;
+	errorId = err;
+	errorDesc = errorString[ errorId ];
+
+	errorLocation.Clear();
+	if ( pError && data )
+	{
+		data->Stamp( pError, encoding );
+		errorLocation = data->Cursor();
+	}
+}
+
+
+TiXmlNode* TiXmlNode::Identify( const char* p, TiXmlEncoding encoding )
+{
+	TiXmlNode* returnNode = 0;
+
+	p = SkipWhiteSpace( p, encoding );
+	if( !p || !*p || *p != '<' )
+	{
+		return 0;
+	}
+
+	TiXmlDocument* doc = GetDocument();
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+
+	// What is this thing?
+	// - Elements start with a letter or underscore, but xml is reserved.
+	// - Comments: <!--
+	// - Decleration: <?xml
+	// - StylesheetReference <?xml-stylesheet
+	// - Everthing else is unknown to tinyxml.
+	//
+
+	const char* xmlHeader = { "<?xml" };
+	const char* xmlSSHeader = { "<?xml-stylesheet" };
+	const char* commentHeader = { "<!--" };
+	const char* dtdHeader = { "<!" };
+	const char* cdataHeader = { "<![CDATA[" };
+
+	if ( StringEqual( p, xmlSSHeader, true, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Stylesheet Reference\n" );
+		#endif
+		returnNode = new TiXmlStylesheetReference();
+	}
+	else if ( StringEqual( p, xmlHeader, true, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Declaration\n" );
+		#endif
+		returnNode = new TiXmlDeclaration();
+	}
+	else if ( StringEqual( p, commentHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Comment\n" );
+		#endif
+		returnNode = new TiXmlComment();
+	}
+	else if ( StringEqual( p, cdataHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing CDATA\n" );
+		#endif
+		TiXmlText* text = new TiXmlText( "" );
+		text->SetCDATA( true );
+		returnNode = text;
+	}
+	else if ( StringEqual( p, dtdHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(1)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+	else if (    IsAlpha( *(p+1), encoding )
+			  || *(p+1) == '_' )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Element\n" );
+		#endif
+		returnNode = new TiXmlElement( "" );
+	}
+	else
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(2)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+
+	if ( returnNode )
+	{
+		// Set the parent, so it can report errors
+		returnNode->parent = this;
+	}
+	else
+	{
+		if ( doc )
+			doc->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
+	}
+	return returnNode;
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlElement::StreamIn (std::istream * in, TIXML_STRING * tag)
+{
+	// We're called with some amount of pre-parsing. That is, some of "this"
+	// element is in "tag". Go ahead and stream to the closing ">"
+	while( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c ;
+
+		if ( c == '>' )
+			break;
+	}
+
+	if ( tag->length() < 3 ) return;
+
+	// Okay...if we are a "/>" tag, then we're done. We've read a complete tag.
+	// If not, identify and stream.
+
+	if (    tag->at( tag->length() - 1 ) == '>'
+		 && tag->at( tag->length() - 2 ) == '/' )
+	{
+		// All good!
+		return;
+	}
+	else if ( tag->at( tag->length() - 1 ) == '>' )
+	{
+		// There is more. Could be:
+		//		text
+		//		cdata text (which looks like another node)
+		//		closing tag
+		//		another node.
+		for ( ;; )
+		{
+			StreamWhiteSpace( in, tag );
+
+			// Do we have text?
+			if ( in->good() && in->peek() != '<' )
+			{
+				// Yep, text.
+				TiXmlText text( "" );
+				text.StreamIn( in, tag );
+
+				// What follows text is a closing tag or another node.
+				// Go around again and figure it out.
+				continue;
+			}
+
+			// We now have either a closing tag...or another node.
+			// We should be at a "<", regardless.
+			if ( !in->good() ) return;
+			assert( in->peek() == '<' );
+			int tagIndex = (int) tag->length();
+
+			bool closingTag = false;
+			bool firstCharFound = false;
+
+			for( ;; )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->peek();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+
+				if ( c == '>' )
+					break;
+
+				*tag += (char) c;
+				in->get();
+
+				// Early out if we find the CDATA id.
+				if ( c == '[' && tag->size() >= 9 )
+				{
+					size_t len = tag->size();
+					const char* start = tag->c_str() + len - 9;
+					if ( strcmp( start, "<![CDATA[" ) == 0 ) {
+						assert( !closingTag );
+						break;
+					}
+				}
+
+				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
+				{
+					firstCharFound = true;
+					if ( c == '/' )
+						closingTag = true;
+				}
+			}
+			// If it was a closing tag, then read in the closing '>' to clean up the input stream.
+			// If it was not, the streaming will be done by the tag.
+			if ( closingTag )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->get();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+				assert( c == '>' );
+				*tag += (char) c;
+
+				// We are done, once we've found our closing tag.
+				return;
+			}
+			else
+			{
+				// If not a closing tag, id it, and stream.
+				const char* tagloc = tag->c_str() + tagIndex;
+				TiXmlNode* node = Identify( tagloc, TIXML_DEFAULT_ENCODING );
+				if ( !node )
+					return;
+				node->StreamIn( in, tag );
+				delete node;
+				node = 0;
+
+				// No return: go around from the beginning: text, closing tag, or node.
+			}
+		}
+	}
+}
+#endif
+
+const char* TiXmlElement::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	TiXmlDocument* document = GetDocument();
+
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, 0, 0, encoding );
+		return 0;
+	}
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+
+	if ( *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, p, data, encoding );
+		return 0;
+	}
+
+	p = SkipWhiteSpace( p+1, encoding );
+
+	// Read the name.
+	const char* pErr = p;
+
+    p = ReadName( p, &value, encoding );
+	if ( !p || !*p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data, encoding );
+		return 0;
+	}
+
+    TIXML_STRING endTag ("</");
+	endTag += value;
+	endTag += ">";
+
+	// Check for and read attributes. Also look for an empty
+	// tag or an end tag.
+	while ( p && *p )
+	{
+		pErr = p;
+		p = SkipWhiteSpace( p, encoding );
+		if ( !p || !*p )
+		{
+			if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+			return 0;
+		}
+		if ( *p == '/' )
+		{
+			++p;
+			// Empty tag.
+			if ( *p  != '>' )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_EMPTY, p, data, encoding );
+				return 0;
+			}
+			return (p+1);
+		}
+		else if ( *p == '>' )
+		{
+			// Done with attributes (if there were any.)
+			// Read the value -- which can include other
+			// elements -- read the end tag, and return.
+			++p;
+			p = ReadValue( p, data, encoding );		// Note this is an Element method, and will set the error if one happens.
+			if ( !p || !*p ) {
+				// We were looking for the end tag, but found nothing.
+				// Fix for [ 1663758 ] Failure to report error on bad XML
+				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
+				return 0;
+			}
+
+			// We should find the end tag now
+			if ( StringEqual( p, endTag.c_str(), false, encoding ) )
+			{
+				p += endTag.length();
+				return p;
+			}
+			else
+			{
+				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
+				return 0;
+			}
+		}
+		else
+		{
+			// Try to read an attribute:
+			TiXmlAttribute* attrib = new TiXmlAttribute();
+			if ( !attrib )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, pErr, data, encoding );
+				return 0;
+			}
+
+			attrib->SetDocument( document );
+			pErr = p;
+			p = attrib->Parse( p, data, encoding );
+
+			if ( !p || !*p )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );
+				delete attrib;
+				return 0;
+			}
+
+			// Handle the strange case of double attributes:
+			#ifdef TIXML_USE_STL
+			TiXmlAttribute* node = attributeSet.Find( attrib->NameTStr() );
+			#else
+			TiXmlAttribute* node = attributeSet.Find( attrib->Name() );
+			#endif
+			if ( node )
+			{
+				node->SetValue( attrib->Value() );
+				delete attrib;
+				return 0;
+			}
+
+			attributeSet.Add( attrib );
+		}
+	}
+	return p;
+}
+
+
+const char* TiXmlElement::ReadValue( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+
+	// Read in text and elements in any order.
+	const char* pWithWhiteSpace = p;
+	p = SkipWhiteSpace( p, encoding );
+
+	while ( p && *p )
+	{
+		if ( *p != '<' )
+		{
+			// Take what we have, make a text element.
+			TiXmlText* textNode = new TiXmlText( "" );
+
+			if ( !textNode )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, encoding );
+				    return 0;
+			}
+
+			if ( TiXmlBase::IsWhiteSpaceCondensed() )
+			{
+				p = textNode->Parse( p, data, encoding );
+			}
+			else
+			{
+				// Special case: we want to keep the white space
+				// so that leading spaces aren't removed.
+				p = textNode->Parse( pWithWhiteSpace, data, encoding );
+			}
+
+			if ( !textNode->Blank() )
+				LinkEndChild( textNode );
+			else
+				delete textNode;
+		}
+		else
+		{
+			// We hit a '<'
+			// Have we hit a new element or an end tag? This could also be
+			// a TiXmlText in the "CDATA" style.
+			if ( StringEqual( p, "</", false, encoding ) )
+			{
+				return p;
+			}
+			else
+			{
+				TiXmlNode* node = Identify( p, encoding );
+				if ( node )
+				{
+					p = node->Parse( p, data, encoding );
+					LinkEndChild( node );
+				}
+				else
+				{
+					return 0;
+				}
+			}
+		}
+		pWithWhiteSpace = p;
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	if ( !p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ELEMENT_VALUE, 0, 0, encoding );
+	}
+	return p;
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlUnknown::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlUnknown::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	if ( !p || !*p || *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_UNKNOWN, p, data, encoding );
+		return 0;
+	}
+	++p;
+    value = "";
+
+	while ( p && *p && *p != '>' )
+	{
+		value += *p;
+		++p;
+	}
+
+	if ( !p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_PARSING_UNKNOWN, 0, 0, encoding );
+	}
+	if ( *p == '>' )
+		return p+1;
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlComment::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+
+		if ( c == '>'
+			 && tag->at( tag->length() - 2 ) == '-'
+			 && tag->at( tag->length() - 3 ) == '-' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlComment::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	value = "";
+
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	const char* startTag = "<!--";
+	const char* endTag   = "-->";
+
+	if ( !StringEqual( p, startTag, false, encoding ) )
+	{
+		document->SetError( TIXML_ERROR_PARSING_COMMENT, p, data, encoding );
+		return 0;
+	}
+	p += strlen( startTag );
+
+	// [ 1475201 ] TinyXML parses entities in comments
+	// Oops - ReadText doesn't work, because we don't want to parse the entities.
+	// p = ReadText( p, &value, false, endTag, false, encoding );
+	//
+	// from the XML spec:
+	/*
+	 [Definition: Comments may appear anywhere in a document outside other markup; in addition,
+	              they may appear within the document type declaration at places allowed by the grammar.
+				  They are not part of the document's character data; an XML processor MAY, but need not,
+				  make it possible for an application to retrieve the text of comments. For compatibility,
+				  the string "--" (double-hyphen) MUST NOT occur within comments.] Parameter entity
+				  references MUST NOT be recognized within comments.
+
+				  An example of a comment:
+
+				  <!-- declarations for <head> & <body> -->
+	*/
+
+    value = "";
+	// Keep all the white space.
+	while (	p && *p && !StringEqual( p, endTag, false, encoding ) )
+	{
+		value.append( p, 1 );
+		++p;
+	}
+	if ( p )
+		p += strlen( endTag );
+
+	return p;
+}
+
+
+const char* TiXmlAttribute::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p ) return 0;
+
+//	int tabsize = 4;
+//	if ( document )
+//		tabsize = document->TabSize();
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	// Read the name, the '=' and the value.
+	const char* pErr = p;
+	p = ReadName( p, &name, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+		return 0;
+	}
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p || *p != '=' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+
+	++p;	// skip '='
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+
+	const char* end;
+	const char SINGLE_QUOTE = '\'';
+	const char DOUBLE_QUOTE = '\"';
+
+	if ( *p == SINGLE_QUOTE )
+	{
+		++p;
+		end = "\'";		// single quote in string
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else if ( *p == DOUBLE_QUOTE )
+	{
+		++p;
+		end = "\"";		// double quote in string
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else
+	{
+		// All attribute values should be in single or double quotes.
+		// But this is such a common error that the parser will try
+		// its best, even without them.
+		value = "";
+		while (    p && *p											// existence
+				&& !IsWhiteSpace( *p ) && *p != '\n' && *p != '\r'	// whitespace
+				&& *p != '/' && *p != '>' )							// tag end
+		{
+			if ( *p == SINGLE_QUOTE || *p == DOUBLE_QUOTE ) {
+				// [ 1451649 ] Attribute values with trailing quotes not handled correctly
+				// We did not have an opening quote but seem to have a
+				// closing one. Give up and throw an error.
+				if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+				return 0;
+			}
+			value += *p;
+			++p;
+		}
+	}
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlText::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->peek();
+		if ( !cdata && (c == '<' ) )
+		{
+			return;
+		}
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+		in->get();	// "commits" the peek made above
+
+		if ( cdata && c == '>' && tag->size() >= 3 ) {
+			size_t len = tag->size();
+			if ( (*tag)[len-2] == ']' && (*tag)[len-3] == ']' ) {
+				// terminator of cdata.
+				return;
+			}
+		}
+	}
+}
+#endif
+
+const char* TiXmlText::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	value = "";
+	TiXmlDocument* document = GetDocument();
+
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+
+	const char* const startTag = "<![CDATA[";
+	const char* const endTag   = "]]>";
+
+	if ( cdata || StringEqual( p, startTag, false, encoding ) )
+	{
+		cdata = true;
+
+		if ( !StringEqual( p, startTag, false, encoding ) )
+		{
+			document->SetError( TIXML_ERROR_PARSING_CDATA, p, data, encoding );
+			return 0;
+		}
+		p += strlen( startTag );
+
+		// Keep all the white space, ignore the encoding, etc.
+		while (	   p && *p
+				&& !StringEqual( p, endTag, false, encoding )
+			  )
+		{
+			value += *p;
+			++p;
+		}
+
+		TIXML_STRING dummy;
+		p = ReadText( p, &dummy, false, endTag, false, encoding );
+		return p;
+	}
+	else
+	{
+		bool ignoreWhite = true;
+
+		const char* end = "<";
+		p = ReadText( p, &value, ignoreWhite, end, false, encoding );
+		if ( p )
+			return p-1;	// don't truncate the '<'
+		return 0;
+	}
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlDeclaration::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+const char* TiXmlDeclaration::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding _encoding )
+{
+	p = SkipWhiteSpace( p, _encoding );
+	// Find the beginning, find the end, and look for
+	// the stuff in-between.
+	TiXmlDocument* document = GetDocument();
+	if ( !p || !*p || !StringEqual( p, "<?xml", true, _encoding ) )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );
+		return 0;
+	}
+	if ( data )
+	{
+		data->Stamp( p, _encoding );
+		location = data->Cursor();
+	}
+	p += 5;
+
+	version = "";
+	encoding = "";
+	standalone = "";
+
+	while ( p && *p )
+	{
+		if ( *p == '>' )
+		{
+			++p;
+			return p;
+		}
+
+		p = SkipWhiteSpace( p, _encoding );
+		if ( StringEqual( p, "version", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );
+			version = attrib.Value();
+		}
+		else if ( StringEqual( p, "encoding", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );
+			encoding = attrib.Value();
+		}
+		else if ( StringEqual( p, "standalone", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );
+			standalone = attrib.Value();
+		}
+		else
+		{
+			// Read over whatever it is.
+			while( p && *p && *p != '>' && !IsWhiteSpace( *p ) )
+				++p;
+		}
+	}
+	return 0;
+}
+
+bool TiXmlText::Blank() const
+{
+	for ( unsigned i=0; i<value.length(); i++ )
+		if ( !IsWhiteSpace( value[i] ) )
+			return false;
+	return true;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlStylesheetReference::StreamIn( std::istream * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+const char* TiXmlStylesheetReference::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding _encoding )
+{
+	p = SkipWhiteSpace( p, _encoding );
+	// Find the beginning, find the end, and look for
+	// the stuff in-between.
+	TiXmlDocument* document = GetDocument();
+	if ( !p || !*p || !StringEqual( p, "<?xml-stylesheet", true, _encoding ) )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );
+		return 0;
+	}
+	if ( data )
+	{
+		data->Stamp( p, _encoding );
+		location = data->Cursor();
+	}
+	p += 5;
+
+	type = "";
+	href = "";
+
+	while ( p && *p )
+	{
+		if ( *p == '>' )
+		{
+			++p;
+			return p;
+		}
+
+		p = SkipWhiteSpace( p, _encoding );
+		if ( StringEqual( p, "type", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );
+			type = attrib.Value();
+		}
+		else if ( StringEqual( p, "href", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );
+			href = attrib.Value();
+		}
+		else
+		{
+			// Read over whatever it is.
+			while( p && *p && *p != '>' && !IsWhiteSpace( *p ) )
+				++p;
+		}
+	}
+	return 0;
+}
diff -Naur wxFormBuilder.orig/subprojects/ticpp/tutorial_gettingStarted.txt wxFormBuilder/subprojects/ticpp/tutorial_gettingStarted.txt
--- wxFormBuilder.orig/subprojects/ticpp/tutorial_gettingStarted.txt	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/tutorial_gettingStarted.txt	2019-11-18 10:42:57.713406052 +0100
@@ -0,0 +1,835 @@
+/** @page tutorial0 TinyXML Tutorial
+
+<h1> What is this? </h1>
+
+This tutorial has a few tips and suggestions on how to use TinyXML
+effectively.
+
+I've also tried to include some C++ tips like how to convert strings to
+integers and vice versa. This isn't anything to do with TinyXML itself, but
+it may helpful for your project so I've put it in anyway.
+
+If you don't know basic C++ concepts this tutorial won't be useful.
+Likewise if you don't know what a DOM is, look elsewhere first.
+
+<h1> Before we start </h1>
+
+Some example XML datasets/files will be used. 
+
+example1.xml:
+
+@verbatim
+<?xml version="1.0" ?>
+<Hello>World</Hello>
+@endverbatim
+
+example2.xml:
+
+@verbatim
+<?xml version="1.0" ?>
+<poetry>
+	<verse>
+		Alas
+		  Great World
+			Alas (again)
+	</verse>
+</poetry>
+@endverbatim
+
+example3.xml:
+
+@verbatim
+<?xml version="1.0" ?>
+<shapes>
+	<circle name="int-based" x="20" y="30" r="50" />
+	<point name="float-based" x="3.5" y="52.1" />
+</shapes>
+@endverbatim
+
+example4.xml
+
+@verbatim
+<?xml version="1.0" ?>
+<MyApp>
+    <!-- Settings for MyApp -->
+    <Messages>
+        <Welcome>Welcome to MyApp</Welcome>
+        <Farewell>Thank you for using MyApp</Farewell>
+    </Messages>
+    <Windows>
+        <Window name="MainFrame" x="5" y="15" w="400" h="250" />
+    </Windows>
+    <Connection ip="192.168.0.1" timeout="123.456000" />
+</MyApp>
+@endverbatim
+
+<h1> Getting Started </h1>
+
+<h2> Load XML from a file </h2>
+
+The simplest way to load a file into a TinyXML DOM is:
+
+@verbatim
+TiXmlDocument doc( "demo.xml" );
+doc.LoadFile();
+@endverbatim
+	
+A more real-world usage is shown below. This will load the file and display
+the contents to STDOUT:
+
+@verbatim
+// load the named file and dump its structure to STDOUT
+void dump_to_stdout(const char* pFilename)
+{
+	TiXmlDocument doc(pFilename);
+	bool loadOkay = doc.LoadFile();
+	if (loadOkay)
+	{
+		printf("\n%s:\n", pFilename);
+		dump_to_stdout( &doc ); // defined later in the tutorial
+	}
+	else
+	{
+		printf("Failed to load file \"%s\"\n", pFilename);
+	}
+}
+@endverbatim
+
+A simple demonstration of this function is to use a main like this:
+
+@verbatim
+int main(void)
+{
+	dump_to_stdout("example1.xml");
+	return 0;
+}
+@endverbatim
+
+Recall that Example 1 XML is:
+
+@verbatim
+<?xml version="1.0" ?>
+<Hello>World</Hello>
+@endverbatim
+
+Running the program with this XML will display this in the console/DOS window:
+
+@verbatim
+DOCUMENT
++ DECLARATION
++ ELEMENT Hello
+  + TEXT[World]
+@endverbatim
+
+
+The ``dump_to_stdout`` function is defined later in this tutorial and is
+useful if you want to understand recursive traversal of a DOM.
+
+<h2> Building Documents Programatically </h2>
+
+
+This is how to build Example 1 pragmatically:
+
+@verbatim
+void build_simple_doc( )
+{
+	// Make xml: <?xml ..><Hello>World</Hello>
+	TiXmlDocument doc;
+	TiXmlDeclaration * decl = new TiXmlDeclaration( "1.0", "", "" );
+	TiXmlElement * element = new TiXmlElement( "Hello" );
+	TiXmlText * text = new TiXmlText( "World" );
+	element->LinkEndChild( text );
+	doc.LinkEndChild( decl );
+	doc.LinkEndChild( element );
+	doc.SaveFile( "madeByHand.xml" );
+}
+@endverbatim
+
+This can be loaded and displayed on the console with:
+
+@verbatim
+dump_to_stdout("madeByHand.xml"); // this func defined later in the tutorial
+@endverbatim
+
+and you'll see it is identical to Example 1:
+
+@verbatim
+madeByHand.xml:
+Document
++ Declaration
++ Element [Hello]
+  + Text: [World]
+@endverbatim
+
+This code produces exactly the same XML DOM but it shows a different ordering
+to node creation and linking:
+
+@verbatim
+void write_simple_doc2( )
+{
+	// same as write_simple_doc1 but add each node
+	// as early as possible into the tree.
+
+	TiXmlDocument doc;
+	TiXmlDeclaration * decl = new TiXmlDeclaration( "1.0", "", "" );
+	doc.LinkEndChild( decl );
+	
+	TiXmlElement * element = new TiXmlElement( "Hello" );
+	doc.LinkEndChild( element );
+	
+	TiXmlText * text = new TiXmlText( "World" );
+	element->LinkEndChild( text );
+	
+	doc.SaveFile( "madeByHand2.xml" );
+}
+@endverbatim
+
+Both of these produce the same XML, namely:
+
+@verbatim
+<?xml version="1.0" ?>
+<Hello>World</Hello>
+@endverbatim
+
+Or in structure form:
+
+@verbatim
+DOCUMENT
++ DECLARATION
++ ELEMENT Hello
+  + TEXT[World]
+@endverbatim
+
+
+<h2> Attributes </h2>
+
+Given an existing node, settings attributes is easy:
+
+@verbatim
+window = new TiXmlElement( "Demo" );  
+window->SetAttribute("name", "Circle");
+window->SetAttribute("x", 5);
+window->SetAttribute("y", 15);
+window->SetDoubleAttribute("radius", 3.14159);
+@endverbatim
+
+You can it also work with the TiXmlAttribute objects if you want.
+
+The following code shows one way (not the only way) to get all attributes of an 
+element, print the name and string value, and if the value can be converted
+to an integer or double, print that value too:
+
+@verbatim
+// print all attributes of pElement.
+// returns the number of attributes printed
+int dump_attribs_to_stdout(TiXmlElement* pElement, unsigned int indent)
+{
+	if ( !pElement ) return 0;
+
+	TiXmlAttribute* pAttrib=pElement->FirstAttribute();
+	int i=0;
+	int ival;
+	double dval;
+	const char* pIndent=getIndent(indent);
+	printf("\n");
+	while (pAttrib)
+	{
+		printf( "%s%s: value=[%s]", pIndent, pAttrib->Name(), pAttrib->Value());
+
+		if (pAttrib->QueryIntValue(&ival)==TIXML_SUCCESS)    printf( " int=%d", ival);
+		if (pAttrib->QueryDoubleValue(&dval)==TIXML_SUCCESS) printf( " d=%1.1f", dval);
+		printf( "\n" );
+		i++;
+		pAttrib=pAttrib->Next();
+	}
+	return i;
+}
+@endverbatim
+
+<h2> Writing a document to a file </h2>
+
+Writing a pre-built DOM to a file is trivial:
+
+@verbatim
+doc.SaveFile( saveFilename );  
+@endverbatim
+
+Recall, for example, example 4:
+
+@verbatim
+<?xml version="1.0" ?>
+<MyApp>
+    <!-- Settings for MyApp -->
+    <Messages>
+        <Welcome>Welcome to MyApp</Welcome>
+        <Farewell>Thank you for using MyApp</Farewell>
+    </Messages>
+    <Windows>
+        <Window name="MainFrame" x="5" y="15" w="400" h="250" />
+    </Windows>
+    <Connection ip="192.168.0.1" timeout="123.456000" />
+</MyApp>
+@endverbatim
+
+The following function builds this DOM and writes the file "appsettings.xml":
+
+@verbatim
+void write_app_settings_doc( )  
+{  
+	TiXmlDocument doc;  
+	TiXmlElement* msg;
+ 	TiXmlDeclaration* decl = new TiXmlDeclaration( "1.0", "", "" );  
+	doc.LinkEndChild( decl );  
+ 
+	TiXmlElement * root = new TiXmlElement( "MyApp" );  
+	doc.LinkEndChild( root );  
+
+	TiXmlComment * comment = new TiXmlComment();
+	comment->SetValue(" Settings for MyApp " );  
+	root->LinkEndChild( comment );  
+ 
+	TiXmlElement * msgs = new TiXmlElement( "Messages" );  
+	root->LinkEndChild( msgs );  
+ 
+	msg = new TiXmlElement( "Welcome" );  
+	msg->LinkEndChild( new TiXmlText( "Welcome to MyApp" ));  
+	msgs->LinkEndChild( msg );  
+ 
+	msg = new TiXmlElement( "Farewell" );  
+	msg->LinkEndChild( new TiXmlText( "Thank you for using MyApp" ));  
+	msgs->LinkEndChild( msg );  
+ 
+	TiXmlElement * windows = new TiXmlElement( "Windows" );  
+	root->LinkEndChild( windows );  
+
+	TiXmlElement * window;
+	window = new TiXmlElement( "Window" );  
+	windows->LinkEndChild( window );  
+	window->SetAttribute("name", "MainFrame");
+	window->SetAttribute("x", 5);
+	window->SetAttribute("y", 15);
+	window->SetAttribute("w", 400);
+	window->SetAttribute("h", 250);
+
+	TiXmlElement * cxn = new TiXmlElement( "Connection" );  
+	root->LinkEndChild( cxn );  
+	cxn->SetAttribute("ip", "192.168.0.1");
+	cxn->SetDoubleAttribute("timeout", 123.456); // floating point attrib
+	
+	dump_to_stdout( &doc );
+	doc.SaveFile( "appsettings.xml" );  
+} 
+@endverbatim
+
+The dump_to_stdout function will show this structure:
+
+@verbatim
+Document
++ Declaration
++ Element [MyApp]
+ (No attributes)
+  + Comment: [ Settings for MyApp ]
+  + Element [Messages]
+ (No attributes)
+    + Element [Welcome]
+ (No attributes)
+      + Text: [Welcome to MyApp]
+    + Element [Farewell]
+ (No attributes)
+      + Text: [Thank you for using MyApp]
+  + Element [Windows]
+ (No attributes)
+    + Element [Window]
+      + name: value=[MainFrame]
+      + x: value=[5] int=5 d=5.0
+      + y: value=[15] int=15 d=15.0
+      + w: value=[400] int=400 d=400.0
+      + h: value=[250] int=250 d=250.0
+      5 attributes
+  + Element [Connection]
+    + ip: value=[192.168.0.1] int=192 d=192.2
+    + timeout: value=[123.456000] int=123 d=123.5
+    2 attributes
+@endverbatim
+
+
+I was surprised that TinyXml, by default, writes the XML in what other
+APIs call a "pretty" format - it modifies the whitespace of text of elements 
+that contain other nodes so that writing the tree includes an indication of 
+nesting level.
+
+I haven't looked yet to see if there is a way to turn off indenting when 
+writing a file - its bound to be easy. 
+
+[Lee: It's easy in STL mode, just use cout << myDoc. Non-STL mode is 
+always in "pretty" format. Adding a switch would be a nice feature and
+has been requested.]
+
+
+<h1> XML to/from C++ objects </h1>
+
+<h2> Intro </h2>
+
+This example assumes you're loading and saving your app settings in an 
+XML file, e.g. something like example4.xml.
+
+There are a number of ways to do this. For example, look into the TinyBind
+project at http://sourceforge.net/projects/tinybind
+
+This section shows a plain-old approach to loading and saving a basic object
+structure using XML.
+
+<h2> Set up your object classes </h2>
+
+Start off with some basic classes like these:
+
+@verbatim
+#include <string>
+#include <map>
+using namespace std;
+
+typedef std::map<std::string,std::string> MessageMap;
+
+// a basic window abstraction - demo purposes only
+class WindowSettings
+{
+public:
+	int x,y,w,h;
+	string name;
+
+	WindowSettings()
+		: x(0), y(0), w(100), h(100), name("Untitled")
+	{
+	}
+
+	WindowSettings(int x, int y, int w, int h, const string& name)
+	{
+		this->x=x;
+		this->y=y;
+		this->w=w;
+		this->h=h;
+		this->name=name;
+	}
+};
+
+class ConnectionSettings
+{
+public:
+	string ip;
+	double timeout;
+};
+
+class AppSettings
+{
+public:
+	string m_name;
+	MessageMap m_messages;
+	list<WindowSettings> m_windows;
+	ConnectionSettings m_connection;
+
+	AppSettings() {}
+
+	void save(const char* pFilename);
+	void load(const char* pFilename);
+	
+	// just to show how to do it
+	void setDemoValues()
+	{
+		m_name="MyApp";
+		m_messages.clear();
+		m_messages["Welcome"]="Welcome to "+m_name;
+		m_messages["Farewell"]="Thank you for using "+m_name;
+		m_windows.clear();
+		m_windows.push_back(WindowSettings(15,15,400,250,"Main"));
+		m_connection.ip="Unknown";
+		m_connection.timeout=123.456;
+	}
+};
+@endverbatim
+
+This is a basic main() that shows how to create a default settings object tree,
+save it and load it again:
+
+@verbatim
+int main(void)
+{
+	AppSettings settings;
+	
+	settings.save("appsettings2.xml");
+	settings.load("appsettings2.xml");
+	return 0;
+}
+@endverbatim
+
+The following main() shows creation, modification, saving and then loading of a
+settings structure:
+
+@verbatim
+int main(void)
+{
+	// block: customise and save settings
+	{
+		AppSettings settings;
+		settings.m_name="HitchHikerApp";
+		settings.m_messages["Welcome"]="Don't Panic";
+		settings.m_messages["Farewell"]="Thanks for all the fish";
+		settings.m_windows.push_back(WindowSettings(15,25,300,250,"BookFrame"));
+		settings.m_connection.ip="192.168.0.77";
+		settings.m_connection.timeout=42.0;
+
+		settings.save("appsettings2.xml");
+	}
+	
+	// block: load settings
+	{
+		AppSettings settings;
+		settings.load("appsettings2.xml");
+		printf("%s: %s\n", settings.m_name.c_str(), 
+			settings.m_messages["Welcome"].c_str());
+		WindowSettings & w=settings.m_windows.front();
+		printf("%s: Show window '%s' at %d,%d (%d x %d)\n", 
+			settings.m_name.c_str(), w.name.c_str(), w.x, w.y, w.w, w.h);
+		printf("%s: %s\n", settings.m_name.c_str(), settings.m_messages["Farewell"].c_str());
+	}
+	return 0;
+}
+@endverbatim
+
+When the save() and load() are completed (see below), running this main() 
+displays on the console:
+
+@verbatim
+HitchHikerApp: Don't Panic
+HitchHikerApp: Show window 'BookFrame' at 15,25 (300 x 100)
+HitchHikerApp: Thanks for all the fish
+@endverbatim
+
+<h2> Encode C++ state as XML </h2>
+
+There are lots of different ways to approach saving this to a file.
+Here's one:
+
+@verbatim
+void AppSettings::save(const char* pFilename)
+{
+	TiXmlDocument doc;  
+	TiXmlElement* msg;
+	TiXmlComment * comment;
+	string s;
+ 	TiXmlDeclaration* decl = new TiXmlDeclaration( "1.0", "", "" );  
+	doc.LinkEndChild( decl ); 
+ 
+	TiXmlElement * root = new TiXmlElement(m_name.c_str());  
+	doc.LinkEndChild( root );  
+
+	comment = new TiXmlComment();
+	s=" Settings for "+m_name+" ";
+	comment->SetValue(s.c_str());  
+	root->LinkEndChild( comment );  
+
+	// block: messages
+	{
+		MessageMap::iterator iter;
+
+		TiXmlElement * msgs = new TiXmlElement( "Messages" );  
+		root->LinkEndChild( msgs );  
+ 
+		for (iter=m_messages.begin(); iter != m_messages.end(); iter++)
+		{
+			const string & key=(*iter).first;
+			const string & value=(*iter).second;
+			msg = new TiXmlElement(key.c_str());  
+			msg->LinkEndChild( new TiXmlText(value.c_str()));  
+			msgs->LinkEndChild( msg );  
+		}
+	}
+
+	// block: windows
+	{
+		TiXmlElement * windowsNode = new TiXmlElement( "Windows" );  
+		root->LinkEndChild( windowsNode );  
+
+		list<WindowSettings>::iterator iter;
+
+		for (iter=m_windows.begin(); iter != m_windows.end(); iter++)
+		{
+			const WindowSettings& w=*iter;
+
+			TiXmlElement * window;
+			window = new TiXmlElement( "Window" );  
+			windowsNode->LinkEndChild( window );  
+			window->SetAttribute("name", w.name.c_str());
+			window->SetAttribute("x", w.x);
+			window->SetAttribute("y", w.y);
+			window->SetAttribute("w", w.w);
+			window->SetAttribute("h", w.h);
+		}
+	}
+
+	// block: connection
+	{
+		TiXmlElement * cxn = new TiXmlElement( "Connection" );  
+		root->LinkEndChild( cxn );  
+		cxn->SetAttribute("ip", m_connection.ip.c_str());
+		cxn->SetDoubleAttribute("timeout", m_connection.timeout); 
+	}
+
+	doc.SaveFile(pFilename);  
+}
+@endverbatim
+
+Running this with the modified main produces this file:
+
+@verbatim
+<?xml version="1.0" ?>
+<HitchHikerApp>
+    <!-- Settings for HitchHikerApp -->
+    <Messages>
+        <Farewell>Thanks for all the fish</Farewell>
+        <Welcome>Don&apos;t Panic</Welcome>
+    </Messages>
+    <Windows>
+        <Window name="BookFrame" x="15" y="25" w="300" h="250" />
+    </Windows>
+    <Connection ip="192.168.0.77" timeout="42.000000" />
+</HitchHikerApp>
+@endverbatim
+
+
+<h2> Decoding state from XML </h2>
+
+As with encoding objects, there are a number of approaches to decoding XML
+into your own C++ object structure. The following approach uses TiXmlHandles.
+
+@verbatim
+void AppSettings::load(const char* pFilename)
+{
+	TiXmlDocument doc(pFilename);
+	if (!doc.LoadFile()) return;
+
+	TiXmlHandle hDoc(&doc);
+	TiXmlElement* pElem;
+	TiXmlHandle hRoot(0);
+
+	// block: name
+	{
+		pElem=hDoc.FirstChildElement().Element();
+		// should always have a valid root but handle gracefully if it does
+		if (!pElem) return;
+		m_name=pElem->Value();
+
+		// save this for later
+		hRoot=TiXmlHandle(pElem);
+	}
+
+	// block: string table
+	{
+		m_messages.clear(); // trash existing table
+
+		pElem=hRoot.FirstChild( "Messages" ).FirstChild().Element();
+		for( pElem; pElem; pElem=pElem->NextSiblingElement())
+		{
+			const char *pKey=pElem->Value();
+			const char *pText=pElem->GetText();
+			if (pKey && pText) 
+			{
+				m_messages[pKey]=pText;
+			}
+		}
+	}
+
+	// block: windows
+	{
+		m_windows.clear(); // trash existing list
+
+		TiXmlElement* pWindowNode=hRoot.FirstChild( "Windows" ).FirstChild().Element();
+		for( pWindowNode; pWindowNode; pWindowNode=pWindowNode->NextSiblingElement())
+		{
+			WindowSettings w;
+			const char *pName=pWindowNode->Attribute("name");
+			if (pName) w.name=pName;
+			
+			pWindowNode->QueryIntAttribute("x", &w.x); // If this fails, original value is left as-is
+			pWindowNode->QueryIntAttribute("y", &w.y);
+			pWindowNode->QueryIntAttribute("w", &w.w);
+			pWindowNode->QueryIntAttribute("hh", &w.h);
+
+			m_windows.push_back(w);
+		}
+	}
+
+	// block: connection
+	{
+		pElem=hRoot.FirstChild("Connection").Element();
+		if (pElem)
+		{
+			m_connection.ip=pElem->Attribute("ip");
+			pElem->QueryDoubleAttribute("timeout",&m_connection.timeout);
+		}
+	}
+}
+@endverbatim
+
+<h1> Full listing for dump_to_stdout </h1>
+
+Below is a copy-and-paste demo program for loading arbitrary XML files and
+dumping the structure to STDOUT using the recursive traversal listed above.
+
+@verbatim
+// tutorial demo program
+#include "stdafx.h"
+#include "tinyxml.h"
+
+// ----------------------------------------------------------------------
+// STDOUT dump and indenting utility functions
+// ----------------------------------------------------------------------
+const unsigned int NUM_INDENTS_PER_SPACE=2;
+
+const char * getIndent( unsigned int numIndents )
+{
+	static const char * pINDENT="                                      + ";
+	static const unsigned int LENGTH=strlen( pINDENT );
+	unsigned int n=numIndents*NUM_INDENTS_PER_SPACE;
+	if ( n > LENGTH ) n = LENGTH;
+
+	return &pINDENT[ LENGTH-n ];
+}
+
+// same as getIndent but no "+" at the end
+const char * getIndentAlt( unsigned int numIndents )
+{
+	static const char * pINDENT="                                        ";
+	static const unsigned int LENGTH=strlen( pINDENT );
+	unsigned int n=numIndents*NUM_INDENTS_PER_SPACE;
+	if ( n > LENGTH ) n = LENGTH;
+
+	return &pINDENT[ LENGTH-n ];
+}
+
+int dump_attribs_to_stdout(TiXmlElement* pElement, unsigned int indent)
+{
+	if ( !pElement ) return 0;
+
+	TiXmlAttribute* pAttrib=pElement->FirstAttribute();
+	int i=0;
+	int ival;
+	double dval;
+	const char* pIndent=getIndent(indent);
+	printf("\n");
+	while (pAttrib)
+	{
+		printf( "%s%s: value=[%s]", pIndent, pAttrib->Name(), pAttrib->Value());
+
+		if (pAttrib->QueryIntValue(&ival)==TIXML_SUCCESS)    printf( " int=%d", ival);
+		if (pAttrib->QueryDoubleValue(&dval)==TIXML_SUCCESS) printf( " d=%1.1f", dval);
+		printf( "\n" );
+		i++;
+		pAttrib=pAttrib->Next();
+	}
+	return i;	
+}
+
+void dump_to_stdout( TiXmlNode* pParent, unsigned int indent = 0 )
+{
+	if ( !pParent ) return;
+
+	TiXmlNode* pChild;
+	TiXmlText* pText;
+	int t = pParent->Type();
+	printf( "%s", getIndent(indent));
+	int num;
+
+	switch ( t )
+	{
+	case TiXmlNode::DOCUMENT:
+		printf( "Document" );
+		break;
+
+	case TiXmlNode::ELEMENT:
+		printf( "Element [%s]", pParent->Value() );
+		num=dump_attribs_to_stdout(pParent->ToElement(), indent+1);
+		switch(num)
+		{
+			case 0:  printf( " (No attributes)"); break;
+			case 1:  printf( "%s1 attribute", getIndentAlt(indent)); break;
+			default: printf( "%s%d attributes", getIndentAlt(indent), num); break;
+		}
+		break;
+
+	case TiXmlNode::COMMENT:
+		printf( "Comment: [%s]", pParent->Value());
+		break;
+
+	case TiXmlNode::UNKNOWN:
+		printf( "Unknown" );
+		break;
+
+	case TiXmlNode::TEXT:
+		pText = pParent->ToText();
+		printf( "Text: [%s]", pText->Value() );
+		break;
+
+	case TiXmlNode::DECLARATION:
+		printf( "Declaration" );
+		break;
+	default:
+		break;
+	}
+	printf( "\n" );
+	for ( pChild = pParent->FirstChild(); pChild != 0; pChild = pChild->NextSibling()) 
+	{
+		dump_to_stdout( pChild, indent+1 );
+	}
+}
+
+// load the named file and dump its structure to STDOUT
+void dump_to_stdout(const char* pFilename)
+{
+	TiXmlDocument doc(pFilename);
+	bool loadOkay = doc.LoadFile();
+	if (loadOkay)
+	{
+		printf("\n%s:\n", pFilename);
+		dump_to_stdout( &doc ); // defined later in the tutorial
+	}
+	else
+	{
+		printf("Failed to load file \"%s\"\n", pFilename);
+	}
+}
+
+// ----------------------------------------------------------------------
+// main() for printing files named on the command line
+// ----------------------------------------------------------------------
+int main(int argc, char* argv[])
+{
+	for (int i=1; i<argc; i++)
+	{
+		dump_to_stdout(argv[i]);
+	}
+	return 0;
+}
+@endverbatim
+
+Run this from the command line or a DOS window, e.g.:
+
+@verbatim
+C:\dev\tinyxml> Debug\tinyxml_1.exe example1.xml
+
+example1.xml:
+Document
++ Declaration
++ Element [Hello]
+ (No attributes)
+  + Text: [World]
+@endverbatim
+
+<i> Authors and Changes
+<ul>
+<li> Written by Ellers, April, May, June 2005 </li>
+<li> Minor edits and integration into doc system, Lee Thomason September 2005 </li>
+<li> Updated by Ellers, October 2005 </li>
+</ul>
+</i>
+
+*/
diff -Naur wxFormBuilder.orig/subprojects/ticpp/tutorial_ticpp.txt wxFormBuilder/subprojects/ticpp/tutorial_ticpp.txt
--- wxFormBuilder.orig/subprojects/ticpp/tutorial_ticpp.txt	1970-01-01 01:00:00.000000000 +0100
+++ wxFormBuilder/subprojects/ticpp/tutorial_ticpp.txt	2019-11-18 10:42:57.713406052 +0100
@@ -0,0 +1,220 @@
+/**
+@page ticppTutorial TinyXML++ Tutorial
+Take a look here @subpage ticpp
+
+This is a work in progress.
+
+
+@page ticpp TinyXML++
+<h2> General Concepts </h2>
+The TinyXML++ classes are all wrappers around the corresponding classes within TinyXML.
+
+There is no reason to create TinyXML++ objects on the heap, using @p new, because the memory is managed for you. If you choose
+to use @p new to create TinyXML++ objects, you will @b always need to use @p delete to clean up.
+
+Basically, TinyXML++ objects are just wrappers around TinyXML pointers.
+
+<h2> Goals </h2>
+- Simplify the use and interface of TinyXml, using C++ concepts.
+	- Use exceptions for error handling, so there are no return codes to check
+	- Use templates for automatic type conversion
+	- Use STL style iterators to move through nodes and attributes
+
+<h2> Details </h2>
+<h3> Use exceptions for error handling </h3>
+When using the original TinyXML, every function returns a value indicating
+success or failure. A programmer would have to check that value to ensure
+the function succeeded.
+
+Example:
+@code
+// Load a document
+TiXmlDocument doc( pFilename );
+if ( !doc.LoadFile() ) return;
+
+// Get a node
+TiXmlElement* pElem = doc.FirstChildElement();
+if ( !pElem ) return;
+
+// Get the node we want
+pElem = pElem->NextSibling();
+if ( !pElem ) return;
+
+// do something useful here
+@endcode
+
+An alternative was to use TiXmlHandle, which allows for function chaining by
+checking the intermediate function return values:
+
+Example:
+@code
+// Load a document
+TiXmlDocument doc(pFilename);
+if (!doc.LoadFile()) return;
+
+// Make a document handle
+TiXmlHandle hDoc(&doc);
+
+// Get an element by using the handle to chain calls
+// Note the conversion of the TiXmlHandle to the TiXmlElement* - .Element()
+TiXmlElement* pElem = hDoc.FirstChildElement().NextSibling().Element();
+if ( !pElem ) return;
+
+// do something useful here
+@endcode
+
+With TinyXML++, if there is an error during a function call, it throws an exception.
+This means that a programmer can assume that every function is successful, as
+long as the functions are enclosed in a try-catch block.
+
+Example:
+@code
+try
+{
+	// Load a document
+	ticpp::Document doc( pFilename );
+	doc.LoadFile();
+
+	// Get an element by chaining calls - no return values to check, no TiXmlHandle
+	ticpp::Element* pElem = doc.FirstChildElement()->NextSibling();
+
+	// do something useful here
+}
+catch( ticpp::Exception& ex )
+{
+	// If any function has an error, execution will enter here.
+	// Report the error
+	std::cout << ex.what();
+}
+@endcode
+
+
+<h3> Use templates for automatic type conversion </h3>
+When using TinyXML, a programmer either needs to convert values to and from
+strings, or choose from one of many overloads to get the value in the desired
+type.
+
+Example:
+@code
+// Load a document
+TiXmlDocument doc( pFilename );
+if ( !doc.LoadFile() ) return;
+
+// Get a node
+TiXmlElement* pElem = doc.FirstChildElement();
+if ( !pElem ) return;
+
+// Get the node we want
+pElem = pElem->NextSibling();
+if ( !pElem ) return;
+
+// Get the attribute as a string, convert to int
+const char* pszAttr = pElem->Attribute( "myAttribute" );
+int attr = atoi( pszAttr );
+
+// Get the attribute as an int
+int attr2;
+if ( TIXML_SUCCESS != pElem->QueryIntAttribute( "myAttribute", &attr2 ) )
+{
+	return;
+}
+
+// Get the attribute as a double
+double attr3;
+if ( TIXML_SUCCESS != pElem->QueryDoubleAttribute( "myAttribute", &attr3 ) )
+{
+	return;
+}
+
+// Get the attribute as a float
+float attr4;
+if ( TIXML_SUCCESS != pElem->QueryFloatAttribute( "myAttribute", &attr4 ) )
+{
+	return;
+}
+@endcode
+
+TinyXML++ uses templates for automatic type conversion.
+
+Example:
+@code
+try
+{
+	// Load a document
+	ticpp::Document doc( pFilename );
+	doc.LoadFile();
+
+	// Get an element by chaining calls - no return values to check, no TiXmlHandle
+	ticpp::Element* pElem = doc.FirstChildElement()->NextSibling();
+
+	// GetAttribute can determine the type of the pointer, and convert automatically
+
+	// Get the attribute as a string
+	std::string attr;
+	pElem->GetAttribute( "myAttribute", &attr );
+
+	// Get the attribute as an int
+	int attr2;
+	pElem->GetAttribute( "myAttribute", &attr2 );
+
+	// Get the attribute as an float
+	float attr3;
+	pElem->GetAttribute( "myAttribute", &attr3 );
+
+	// Get the attribute as an double
+	double attr4;
+	pElem->GetAttribute( "myAttribute", &attr4 );
+
+	// Get the attribute as an bool
+	bool attr5;
+	pElem->GetAttribute( "myAttribute", &attr5 );
+
+}
+catch( ticpp::Exception& ex )
+{
+	// If any function has an error, execution will enter here.
+	// Report the error
+	std::cout << ex.what();
+}
+@endcode
+<h3> Use STL style iterators to move through nodes and attributes </h3>
+TinyXML has two ways to iterate:
+
+First Method:
+@code
+	for( child = parent->FirstChild( false ); child; child = child->NextSibling( false ) )
+@endcode
+
+Second Method:
+@code
+	child = 0;
+	while( child = parent->IterateChildren( child ) )
+@endcode
+
+Although both methods work quite well, the syntax is not familiar.
+TinyXML++ introduces iterators:
+@code
+ticpp::Iterator< ticpp::Node > child;
+for ( child = child.begin( parent ); child != child.end(); child++ )
+@endcode
+
+Iterators have the added advantage of filtering by type:
+@code
+// Only iterates through Comment nodes
+ticpp::Iterator< ticpp::Comment > child;
+for ( child = child.begin( parent ); child != child.end(); child++ )
+@endcode
+
+@code
+// Only iterates through Element nodes with value "ElementValue"
+ticpp::Iterator< ticpp::Element > child( "ElementValue" );
+for ( child = child.begin( parent ); child != child.end(); child++ )
+@endcode
+
+Finally, Iterators also work with Attributes
+@code
+ticpp::Iterator< ticpp::Attribute > attribute;
+for ( attribute = attribute.begin( element ); attribute != attribute.end(); attribute++ )
+@endcode
+
+*/
