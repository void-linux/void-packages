--- a/runtime/phobos/std/complex.d
+++ b/runtime/phobos/std/complex.d
@@ -1140,9 +1140,11 @@ Complex!T sinh(T)(Complex!T z)  @safe pu
 @safe pure nothrow unittest
 {
     static import std.math;
+    import std.math.operations : isClose;
     assert(sinh(complex(0.0)) == 0.0);
     assert(sinh(complex(1.0L)) == std.math.sinh(1.0L));
-    assert(sinh(complex(1.0f)) == std.math.sinh(1.0f));
+    // i686: 1.1752+0i != 1.1752
+    assert(isClose(sinh(complex(1.0f)), std.math.sinh(1.0f)));
 }
 
 /// ditto
@@ -1506,7 +1508,8 @@ Complex!T exp(T)(Complex!T x) @trusted p
     assert(exp(complex(0.0, 0.0)) == complex(1.0, 0.0));
 
     auto a = complex(2.0, 1.0);
-    assert(exp(conj(a)) == conj(exp(a)));
+    // 3.99232-6.21768i != 3.99232-6.21768i
+    assert(isClose(exp(conj(a)), conj(exp(a))));
 
     auto b = exp(complex(0.0L, 1.0L) * PI);
     assert(isClose(b, -1.0L, 0.0, 1e-15));
@@ -1737,7 +1740,8 @@ Complex!T log10(T)(Complex!T x) @safe pu
     import std.math.operations : isClose;
 
     auto a = complex(2.0, 1.0);
-    assert(log10(a) == log(a) / log(complex(10.0)));
+    // i686: 0.349485+0.20136i != 0.349485+0.20136i
+    assert(isClose(log10(a), log(a) / log(complex(10.0))));
 
     auto b = log10(complex(0.0, 1.0)) * 2.0;
     auto c = log10(complex(sqrt(2.0) / 2, sqrt(2.0) / 2)) * 4.0;
--- a/runtime/phobos/std/math/algebraic.d
+++ b/runtime/phobos/std/math/algebraic.d
@@ -578,6 +578,7 @@ if (isFloatingPoint!T1 && isFloatingPoin
 
 @safe nothrow @nogc unittest
 {
+    import std.math.operations : isClose;
     double x = 3.1;
     static double[] pp = [56.1, 32.7, 6];
     double y = x;
@@ -585,7 +586,8 @@ if (isFloatingPoint!T1 && isFloatingPoin
     y += 32.7;
     y *= x;
     y += 56.1;
-    assert(poly(x, pp) == y);
+    // i686: 215.13 !=  215.13
+    assert(isClose(poly(x, pp), y));
 }
 
 @safe unittest
