--- a/media/filters/ffmpeg_demuxer.cc	2023-01-23 17:33:57.366213805 +0200
+++ b/media/filters/ffmpeg_demuxer.cc	2023-01-23 17:43:09.283436983 +0200
@@ -92,24 +92,12 @@
 
 static base::TimeDelta ExtractStartTime(AVStream* stream) {
   // The default start time is zero.
-  base::TimeDelta start_time;
+  base::TimeDelta start_time = kNoTimestamp;
 
   // First try to use  the |start_time| value as is.
-  if (stream->start_time != kNoFFmpegTimestamp)
+  if (stream->start_time != kNoFFmpegTimestamp) // AV_NOPTS_VALUE
     start_time = ConvertFromTimeBase(stream->time_base, stream->start_time);
 
-  // Next try to use the first DTS value, for codecs where we know PTS == DTS
-  // (excludes all H26x codecs). The start time must be returned in PTS.
-  if (av_stream_get_first_dts(stream) != kNoFFmpegTimestamp &&
-      stream->codecpar->codec_id != AV_CODEC_ID_HEVC &&
-      stream->codecpar->codec_id != AV_CODEC_ID_H264 &&
-      stream->codecpar->codec_id != AV_CODEC_ID_MPEG4) {
-    const base::TimeDelta first_pts =
-        ConvertFromTimeBase(stream->time_base, av_stream_get_first_dts(stream));
-    if (first_pts < start_time)
-      start_time = first_pts;
-  }
-
   return start_time;
 }
 
@@ -1597,7 +1585,7 @@
   for (const auto& stream : streams_) {
     if (!stream || stream->IsEnabled() != enabled)
       continue;
-    if (av_stream_get_first_dts(stream->av_stream()) == kInvalidPTSMarker)
+    if (stream->av_stream()->start_time == AV_NOPTS_VALUE)
       continue;
     if (!lowest_start_time_stream ||
         stream->start_time() < lowest_start_time_stream->start_time()) {
@@ -1618,7 +1606,7 @@
     if (stream->type() != DemuxerStream::VIDEO)
       continue;
 
-    if (av_stream_get_first_dts(stream->av_stream()) == kInvalidPTSMarker)
+    if (stream->av_stream()->start_time == AV_NOPTS_VALUE)
       continue;
 
     if (!stream->IsEnabled())
