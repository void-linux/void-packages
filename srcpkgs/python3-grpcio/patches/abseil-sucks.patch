An all-in-one patch that fixes several issues:

1) UnscaledCycleClock not fully implemented for ppc*-musl (disabled on musl)
2) powerpc stacktrace implementation only works on glibc (disabled on musl)
3) powerpc stacktrace implementation has ppc64 assumptions (fixed)
4) examine_stack.cpp makes glibc assumptions on powerpc (fixed)

--- third_party/abseil-cpp/absl/base/internal/unscaledcycleclock.cc
+++ third_party/abseil-cpp/absl/base/internal/unscaledcycleclock.cc
@@ -20,7 +20,7 @@
 #include <intrin.h>
 #endif
 
-#if defined(__powerpc__) || defined(__ppc__)
+#if (defined(__powerpc__) || defined(__ppc__)) && defined(__GLIBC__)
 #ifdef __GLIBC__
 #include <sys/platform/ppc.h>
 #elif defined(__FreeBSD__)
@@ -59,7 +59,7 @@
   return base_internal::NominalCPUFrequency();
 }
 
-#elif defined(__powerpc__) || defined(__ppc__)
+#elif (defined(__powerpc__) || defined(__ppc__)) && defined(__GLIBC__)
 
 int64_t UnscaledCycleClock::Now() {
 #ifdef __GLIBC__
--- third_party/abseil-cpp/absl/base/internal/unscaledcycleclock.h
+++ third_party/abseil-cpp/absl/base/internal/unscaledcycleclock.h
@@ -46,7 +46,7 @@
 
 // The following platforms have an implementation of a hardware counter.
 #if defined(__i386__) || defined(__x86_64__) || defined(__aarch64__) || \
-  defined(__powerpc__) || defined(__ppc__) || \
+  ((defined(__powerpc__) || defined(__ppc__)) && defined(__GLIBC__)) || \
   defined(_M_IX86) || defined(_M_X64)
 #define ABSL_HAVE_UNSCALED_CYCLECLOCK_IMPLEMENTATION 1
 #else
--- third_party/abseil-cpp/absl/debugging/internal/examine_stack.cc
+++ third_party/abseil-cpp/absl/debugging/internal/examine_stack.cc
@@ -27,6 +27,10 @@
 #include <csignal>
 #include <cstdio>
 
+#if defined(__powerpc__)
+#include <asm/ptrace.h>
+#endif
+
 #include "absl/base/attributes.h"
 #include "absl/base/internal/raw_logging.h"
 #include "absl/base/macros.h"
@@ -55,8 +59,10 @@
     return reinterpret_cast<void*>(context->uc_mcontext.pc);
 #elif defined(__powerpc64__)
     return reinterpret_cast<void*>(context->uc_mcontext.gp_regs[32]);
-#elif defined(__powerpc__)
+#elif defined(__powerpc__) && defined(__GLIBC__)
     return reinterpret_cast<void*>(context->uc_mcontext.regs->nip);
+#elif defined(__powerpc__)
+    return reinterpret_cast<void*>(((struct pt_regs *)context->uc_regs)->nip);
 #elif defined(__riscv)
     return reinterpret_cast<void*>(context->uc_mcontext.__gregs[REG_PC]);
 #elif defined(__s390__) && !defined(__s390x__)
--- third_party/abseil-cpp/absl/debugging/internal/stacktrace_config.h
+++ third_party/abseil-cpp/absl/debugging/internal/stacktrace_config.h
@@ -64,7 +64,7 @@
 #elif defined(__i386__) || defined(__x86_64__)
 #define ABSL_STACKTRACE_INL_HEADER \
   "absl/debugging/internal/stacktrace_x86-inl.inc"
-#elif defined(__ppc__) || defined(__PPC__)
+#elif (defined(__ppc__) || defined(__PPC__)) && defined(__GLIBC__)
 #define ABSL_STACKTRACE_INL_HEADER \
   "absl/debugging/internal/stacktrace_powerpc-inl.inc"
 #elif defined(__aarch64__)
--- third_party/abseil-cpp/absl/debugging/internal/stacktrace_powerpc-inl.inc
+++ third_party/abseil-cpp/absl/debugging/internal/stacktrace_powerpc-inl.inc
@@ -130,8 +130,13 @@
         StacktracePowerPCGetLR(new_sp) == kernel_sigtramp_rt64_address) {
       const ucontext_t* signal_context =
           reinterpret_cast<const ucontext_t*>(uc);
+#if defined(__powerpc64__)
       void **const sp_before_signal =
           reinterpret_cast<void**>(signal_context->uc_mcontext.gp_regs[PT_R1]);
+#else
+      void **const sp_before_signal =
+          reinterpret_cast<void**>(signal_context->uc_mcontext.uc_regs->gregs[PT_R1]);
+#endif
       // Check that alleged sp before signal is nonnull and is reasonably
       // aligned.
       if (sp_before_signal != nullptr &&
