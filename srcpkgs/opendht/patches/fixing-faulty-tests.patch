Tests may fail on CI due to time constraints and i686 memory limits. Increase
allowed time and limit memory allocation to satisfy these restrictions.

--- a/tests/dhtrunnertester.cpp
+++ b/tests/dhtrunnertester.cpp
@@ -59,7 +59,7 @@
     node1.shutdown(shutdown);
     node2.shutdown(shutdown);
     std::unique_lock<std::mutex> lk(cv_m);
-    CPPUNIT_ASSERT(cv.wait_for(lk, 30s, [&]{ return done == 2u; }));
+    CPPUNIT_ASSERT(cv.wait_for(lk, 60s, [&]{ return done == 2u; }));
     node1.join();
     node2.join();
 }
@@ -230,7 +230,7 @@
 
     {
         std::unique_lock<std::mutex> lk(mutex);
-        CPPUNIT_ASSERT(cv.wait_for(lk, 30s, [&]{ return putCount == N * 3u; }));
+        CPPUNIT_ASSERT(cv.wait_for(lk, 60s, [&]{ return putCount == N * 3u; }));
         CPPUNIT_ASSERT_EQUAL(N, putOkCount1);
         CPPUNIT_ASSERT_EQUAL(N, putOkCount2);
         CPPUNIT_ASSERT_EQUAL(N, putOkCount3);
@@ -289,7 +289,7 @@
 
     {
         std::unique_lock<std::mutex> lk(mutex);
-        CPPUNIT_ASSERT(cv.wait_for(lk, 20s, [&]{ return valueCount == 1; }));
+        CPPUNIT_ASSERT(cv.wait_for(lk, 60s, [&]{ return valueCount == 1; }));
     }
 
     node1.findCertificate(node2.getId(), [&](const std::shared_ptr<dht::crypto::Certificate>& crt){
@@ -301,7 +301,7 @@
 
     {
         std::unique_lock<std::mutex> lk(mutex);
-        CPPUNIT_ASSERT(cv.wait_for(lk, 20s, [&]{ return valueCount == 2; }));
+        CPPUNIT_ASSERT(cv.wait_for(lk, 60s, [&]{ return valueCount == 2; }));
     }
 
     dht::DhtRunner::Context context1;
@@ -367,8 +367,8 @@
 
     {
         std::unique_lock<std::mutex> lk(mutex);
-        CPPUNIT_ASSERT(cv.wait_for(lk, 20s, [&]{ return valueCount == 7; }));
-        CPPUNIT_ASSERT(cv.wait_for(lk, 20s, [&]{ return valueCountEdit == 2; }));
+        CPPUNIT_ASSERT(cv.wait_for(lk, 60s, [&]{ return valueCount == 7; }));
+        CPPUNIT_ASSERT(cv.wait_for(lk, 60s, [&]{ return valueCountEdit == 2; }));
     }
 
     // editValue->data = dht::packMsg("v2");
@@ -381,7 +381,7 @@
         cv.notify_all();
     });
     std::unique_lock<std::mutex> lk(mutex);
-    CPPUNIT_ASSERT(cv.wait_for(lk, 20s, [&]{ return valueCountEdit == 4; }));
+    CPPUNIT_ASSERT(cv.wait_for(lk, 60s, [&]{ return valueCountEdit == 4; }));
 }
 
 void
@@ -407,7 +407,7 @@
     }
     {
         std::unique_lock<std::mutex> lk(mutex);
-        CPPUNIT_ASSERT(cv.wait_for(lk, 30s, [&]{ return putCount == N; }));
+        CPPUNIT_ASSERT(cv.wait_for(lk, 60s, [&]{ return putCount == N; }));
     }
 
     dht::DhtRunner node3 {};
@@ -428,7 +428,7 @@
 
     {
         std::unique_lock<std::mutex> lk(mutex);
-        CPPUNIT_ASSERT(cv.wait_for(lk, 30s, [&]{ return valueCount == N; }));
+        CPPUNIT_ASSERT(cv.wait_for(lk, 60s, [&]{ return valueCount == N; }));
     }
 
     node3.cancelListen(foo, ftokenfoo.get());
@@ -463,7 +463,7 @@
         });
     }
     std::unique_lock<std::mutex> lk(mutex);
-    CPPUNIT_ASSERT(cv.wait_for(lk, 30s, [&]{ return putCount == 2*N; }));
+    CPPUNIT_ASSERT(cv.wait_for(lk, 60s, [&]{ return putCount == 2*N; }));
     CPPUNIT_ASSERT_EQUAL(2*N, putOkCount);
 
 }
+++ a/tests/cryptotester.cpp
--- b/tests/cryptotester.cpp
@@ -240,7 +240,8 @@
 }
 
 void CryptoTester::testAesEncryptionWithMultipleKeySizes() {
-    auto data = std::vector<uint8_t>(rand(), rand());
+	// incase size_t n is huge (that will cause i686 test to fail).
+    auto data = std::vector<uint8_t>(rand()%(1<<12), rand());
 
     // Valid key sizes
     for (auto key_length : {16, 24, 32}) {

