http://lists.gnu.org/archive/html/bug-make/2016-05/msg00041.html

diff --git remake.c remake.c
index df1a9e0..63ee648 100644
--- remake.c
+++ remake.c
@@ -320,7 +320,7 @@ update_file (struct file *file, unsigned int depth)
             && !f->dontcare && f->no_diag))
         {
           DBF (DB_VERBOSE, _("Pruning file '%s'.\n"));
-          return f->command_state == cs_finished ? f->update_status : us_success;
+          return f->command_state == cs_finished ? f->update_status : 0;
         }
     }
 
@@ -344,9 +344,12 @@ update_file (struct file *file, unsigned int depth)
 
       if (f->command_state == cs_running
           || f->command_state == cs_deps_running)
-        /* Don't run other :: rules for this target until
-           this rule is finished.  */
-        return us_success;
+        {
+          /* Don't run the other :: rules for this
+             file until this rule is finished.  */
+          status = us_success;
+          break;
+        }
 
       if (new > status)
         status = new;
@@ -1271,7 +1274,6 @@ FILE_TIMESTAMP
 f_mtime (struct file *file, int search)
 {
   FILE_TIMESTAMP mtime;
-  int propagate_timestamp;
 
   /* File's mtime is not known; must get it from the system.  */
 
@@ -1448,13 +1450,10 @@ f_mtime (struct file *file, int search)
         }
     }
 
-  /* Store the mtime into all the entries for this file for which it is safe
-     to do so: avoid propagating timestamps to double-colon rules that haven't
-     been examined so they're run or not based on the pre-update timestamp.  */
+  /* Store the mtime into all the entries for this file.  */
   if (file->double_colon)
     file = file->double_colon;
 
-  propagate_timestamp = file->updated;
   do
     {
       /* If this file is not implicit but it is intermediate then it was
@@ -1466,8 +1465,7 @@ f_mtime (struct file *file, int search)
           && !file->tried_implicit && file->intermediate)
         file->intermediate = 0;
 
-      if (file->updated == propagate_timestamp)
-        file->last_mtime = mtime;
+      file->last_mtime = mtime;
       file = file->prev;
     }
   while (file != 0);
diff --git tests/scripts/features/double_colon tests/scripts/features/double_colon
index 80ddb31..1097775 100644
--- tests/scripts/features/double_colon
+++ tests/scripts/features/double_colon
@@ -151,7 +151,8 @@ two');
 
 unlink('result','one','two');
 
-# TEST 10: SV 33399 : check for proper backslash handling
+# TEST 10: check for proper backslash handling
+#          Savannah bug #33399
 
 run_make_test('
 a\ xb :: ; @echo one
@@ -159,47 +160,5 @@ a\ xb :: ; @echo two
 ',
               '', "one\ntwo\n");
 
-# Test 11: SV 44742 : All double-colon rules should be run in parallel build.
-
-run_make_test('result :: 01
-	@echo update
-	@touch $@
-result :: 02
-	@echo update
-	@touch $@
-result :: 03
-	@echo update
-	@touch $@
-result :: 04
-	@echo update
-	@touch $@
-result :: 05
-	@echo update
-	@touch $@
-01 02 03 04 05:
-	@touch 01 02 03 04 05
-',
-              '-j10 result', "update\nupdate\nupdate\nupdate\nupdate\n");
-
-unlink('result', '01', '02', '03', '04', '05');
-
-# Test 12: SV 44742 : Double-colon rules with parallelism
-
-run_make_test('
-root: all
-	echo root
-all::
-	echo all_one
-all:: 3
-	echo all_two
-%:
-	sleep $*
-',
-              '-rs -j2 1 2 root', "all_one\nall_two\nroot\n");
-
 # This tells the test driver that the perl test script executed properly.
 1;
-
-### Local Variables:
-### eval: (setq whitespace-action (delq 'auto-cleanup whitespace-action))
-### End:
