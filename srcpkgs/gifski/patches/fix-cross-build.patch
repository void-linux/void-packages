Instead of using the host compiler to build and run
the "check" binary on the host, use the target compiler
and run it through qemu.
--- a/vendor/ffmpeg-sys-next-6.1.0/build.rs
+++ b/vendor/ffmpeg-sys-next-6.1.0/build.rs
@@ -500,7 +500,7 @@
 
     let executable = out_dir.join(if cfg!(windows) { "check.exe" } else { "check" });
     let mut compiler = cc::Build::new()
-        .target(&env::var("HOST").unwrap()) // don't cross-compile this
+        .target(&env::var("TARGET").unwrap()) // don't cross-compile this
         .get_compiler()
         .to_command();
 
@@ -520,10 +520,21 @@
         panic!("Compile failed");
     }
 
-    let check_output = Command::new(out_dir.join(&executable))
-        .current_dir(&out_dir)
-        .output()
-        .expect("Check failed");
+    let check_output = match env::var("XBPS_TARGET_QEMU_MACHINE") {
+        Ok(qemu_machine) => {
+            Command::new(format!("qemu-{}", qemu_machine))
+                .args([out_dir.join(&executable)])
+                .current_dir(&out_dir)
+                .output()
+                .expect("Check failed")
+        }
+        _ => {
+            Command::new(out_dir.join(&executable))
+                .current_dir(&out_dir)
+                .output()
+                .expect("Check failed")
+        }
+    };
     if !check_output.status.success() {
         panic!(
             "{} failed: {}\n{}",
